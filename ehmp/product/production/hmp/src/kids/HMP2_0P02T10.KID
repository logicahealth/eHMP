KIDS Distribution saved on Aug 26, 2016@11:03:21
EHMP PATCH VERSION 10
**KIDS**:HMP*2.0*2^

**INSTALL NAME**
HMP*2.0*2
"BLD",9670,0)
HMP*2.0*2^HEALTH MANAGEMENT PLATFORM^0^3160826^y
"BLD",9670,4,0)
^9.64PA^800003^2
"BLD",9670,4,800000,0)
800000
"BLD",9670,4,800000,222)
y^y^f^^^^n
"BLD",9670,4,800003,0)
800003
"BLD",9670,4,800003,222)
y^y^f^^^^n
"BLD",9670,4,"B",800000,800000)

"BLD",9670,4,"B",800003,800003)

"BLD",9670,6.3)
24
"BLD",9670,"ABPKG")
n
"BLD",9670,"KRN",0)
^9.67PA^779.2^20
"BLD",9670,"KRN",.4,0)
.4
"BLD",9670,"KRN",.401,0)
.401
"BLD",9670,"KRN",.402,0)
.402
"BLD",9670,"KRN",.403,0)
.403
"BLD",9670,"KRN",.5,0)
.5
"BLD",9670,"KRN",.84,0)
.84
"BLD",9670,"KRN",3.6,0)
3.6
"BLD",9670,"KRN",3.8,0)
3.8
"BLD",9670,"KRN",9.2,0)
9.2
"BLD",9670,"KRN",9.8,0)
9.8
"BLD",9670,"KRN",9.8,"NM",0)
^9.68A^73^73
"BLD",9670,"KRN",9.8,"NM",1,0)
HMPCRPC^^0^B13274810
"BLD",9670,"KRN",9.8,"NM",2,0)
HMPDJ^^0^B36566294
"BLD",9670,"KRN",9.8,"NM",3,0)
HMPDJ0^^0^B123520924
"BLD",9670,"KRN",9.8,"NM",4,0)
HMPDJ00^^0^B165368982
"BLD",9670,"KRN",9.8,"NM",5,0)
HMPDJ01^^0^B96911634
"BLD",9670,"KRN",9.8,"NM",6,0)
HMPDJ02^^0^B212781835
"BLD",9670,"KRN",9.8,"NM",7,0)
HMPSTMP^^0^B101713428
"BLD",9670,"KRN",9.8,"NM",8,0)
HMPEVNT^^0^B181881949
"BLD",9670,"KRN",9.8,"NM",9,0)
HMPDJ04^^0^B91911154
"BLD",9670,"KRN",9.8,"NM",10,0)
HMPDJ04A^^0^B59768993
"BLD",9670,"KRN",9.8,"NM",11,0)
HMPDJ04E^^0^B17743110
"BLD",9670,"KRN",9.8,"NM",12,0)
HMPDJ05^^0^B94650196
"BLD",9670,"KRN",9.8,"NM",13,0)
HMPDJ07^^0^B31184394
"BLD",9670,"KRN",9.8,"NM",14,0)
HMPDJ08^^0^B80070149
"BLD",9670,"KRN",9.8,"NM",15,0)
HMPDMC^^0^B58301952
"BLD",9670,"KRN",9.8,"NM",16,0)
HMPDJFSD^^0^B6635230
"BLD",9670,"KRN",9.8,"NM",17,0)
HMPDJFSG^^0^B239094228
"BLD",9670,"KRN",9.8,"NM",18,0)
HMPDJFSM^^0^B83803111
"BLD",9670,"KRN",9.8,"NM",19,0)
HMPDJFSP^^0^B224332595
"BLD",9670,"KRN",9.8,"NM",20,0)
HMPDPSOR^^0^B2353345
"BLD",9670,"KRN",9.8,"NM",21,0)
HMPEF^^0^B86301720
"BLD",9670,"KRN",9.8,"NM",22,0)
HMPEF1^^0^B41995874
"BLD",9670,"KRN",9.8,"NM",23,0)
HMPFPTC^^0^B13917826
"BLD",9670,"KRN",9.8,"NM",24,0)
HMPLOG^^0^B18006538
"BLD",9670,"KRN",9.8,"NM",25,0)
HMPMETA^^0^B193059254
"BLD",9670,"KRN",9.8,"NM",26,0)
HMPMON^^0^B33479508
"BLD",9670,"KRN",9.8,"NM",27,0)
HMPMONC^^0^B19385564
"BLD",9670,"KRN",9.8,"NM",28,0)
HMPMOND^^0^B73551310
"BLD",9670,"KRN",9.8,"NM",29,0)
HMPMONDH^^0^B9552546
"BLD",9670,"KRN",9.8,"NM",30,0)
HMPMONE^^0^B15446586
"BLD",9670,"KRN",9.8,"NM",31,0)
HMPMONEH^^0^B7976382
"BLD",9670,"KRN",9.8,"NM",32,0)
HMPMONH^^0^B3366095
"BLD",9670,"KRN",9.8,"NM",33,0)
HMPMONHH^^0^B6882140
"BLD",9670,"KRN",9.8,"NM",34,0)
HMPMONJ^^0^B21225316
"BLD",9670,"KRN",9.8,"NM",35,0)
HMPMONL^^0^B48690614
"BLD",9670,"KRN",9.8,"NM",36,0)
HMPMONM^^0^B24792706
"BLD",9670,"KRN",9.8,"NM",37,0)
HMPMONS^^0^B5634204
"BLD",9670,"KRN",9.8,"NM",38,0)
HMPMONSH^^0^B8092582
"BLD",9670,"KRN",9.8,"NM",39,0)
HMPMONV^^0^B42629686
"BLD",9670,"KRN",9.8,"NM",40,0)
HMPMONX^^0^B51029601
"BLD",9670,"KRN",9.8,"NM",41,0)
HMPOR^^0^B51019081
"BLD",9670,"KRN",9.8,"NM",42,0)
HMPUTILS^^0^B55237151
"BLD",9670,"KRN",9.8,"NM",43,0)
HMPUPD^^0^B25103187
"BLD",9670,"KRN",9.8,"NM",44,0)
HMPWB^^0^B1427046
"BLD",9670,"KRN",9.8,"NM",45,0)
HMPWB1^^0^B43200310
"BLD",9670,"KRN",9.8,"NM",46,0)
HMPWB2^^0^B43784847
"BLD",9670,"KRN",9.8,"NM",47,0)
HMPWB5^^0^B28193400
"BLD",9670,"KRN",9.8,"NM",48,0)
HMPWB5A^^0^B30522775
"BLD",9670,"KRN",9.8,"NM",49,0)
HMPWBIM1^^0^B55295368
"BLD",9670,"KRN",9.8,"NM",50,0)
HMPWBM1^^0^B2139238
"BLD",9670,"KRN",9.8,"NM",51,0)
HMPWBM2^^0^B8891114
"BLD",9670,"KRN",9.8,"NM",52,0)
HMPWBPL^^0^B2694501
"BLD",9670,"KRN",9.8,"NM",53,0)
HMPWBSO^^0^B3162958
"BLD",9670,"KRN",9.8,"NM",54,0)
HMPXGDPT^^0^B2019789
"BLD",9670,"KRN",9.8,"NM",55,0)
HMPXGLAB^^0^B1064430
"BLD",9670,"KRN",9.8,"NM",56,0)
HMPXGNP^^0^B1299808
"BLD",9670,"KRN",9.8,"NM",57,0)
HMPXGORD^^0^B2568884
"BLD",9670,"KRN",9.8,"NM",58,0)
HMPXGSD^^0^B2602100
"BLD",9670,"KRN",9.8,"NM",59,0)
HMPDJ03^^0^B113601878
"BLD",9670,"KRN",9.8,"NM",60,0)
HMPTOOLS^^0^B13771837
"BLD",9670,"KRN",9.8,"NM",61,0)
HMPUTIL2^^0^B22837890
"BLD",9670,"KRN",9.8,"NM",62,0)
HMPMONA^^0^B32852666
"BLD",9670,"KRN",9.8,"NM",63,0)
HMPDJFSQ^^0^B141457837
"BLD",9670,"KRN",9.8,"NM",64,0)
HMPORRPC^^0^B2194584
"BLD",9670,"KRN",9.8,"NM",65,0)
HMPDJ06^^0^B65685348
"BLD",9670,"KRN",9.8,"NM",66,0)
HMPDJ1^^0^B18436618
"BLD",9670,"KRN",9.8,"NM",67,0)
HMPDJ09^^0^B140504631
"BLD",9670,"KRN",9.8,"NM",68,0)
HMPDJ2^^0^B21343271
"BLD",9670,"KRN",9.8,"NM",69,0)
HMPDJFS^^0^B75039687
"BLD",9670,"KRN",9.8,"NM",70,0)
HMPPTRPC^^0^B11913363
"BLD",9670,"KRN",9.8,"NM",71,0)
HMPTFU2^^0^B40570794
"BLD",9670,"KRN",9.8,"NM",72,0)
HMPMONR^^0^B2756
"BLD",9670,"KRN",9.8,"NM",73,0)
HMPTIUL^^0^B4400616
"BLD",9670,"KRN",9.8,"NM","B","HMPCRPC",1)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ",2)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ0",3)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ00",4)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ01",5)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ02",6)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ03",59)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ04",9)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ04A",10)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ04E",11)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ05",12)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ06",65)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ07",13)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ08",14)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ09",67)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ1",66)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJ2",68)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJFS",69)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJFSD",16)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJFSG",17)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJFSM",18)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJFSP",19)

"BLD",9670,"KRN",9.8,"NM","B","HMPDJFSQ",63)

"BLD",9670,"KRN",9.8,"NM","B","HMPDMC",15)

"BLD",9670,"KRN",9.8,"NM","B","HMPDPSOR",20)

"BLD",9670,"KRN",9.8,"NM","B","HMPEF",21)

"BLD",9670,"KRN",9.8,"NM","B","HMPEF1",22)

"BLD",9670,"KRN",9.8,"NM","B","HMPEVNT",8)

"BLD",9670,"KRN",9.8,"NM","B","HMPFPTC",23)

"BLD",9670,"KRN",9.8,"NM","B","HMPLOG",24)

"BLD",9670,"KRN",9.8,"NM","B","HMPMETA",25)

"BLD",9670,"KRN",9.8,"NM","B","HMPMON",26)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONA",62)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONC",27)

"BLD",9670,"KRN",9.8,"NM","B","HMPMOND",28)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONDH",29)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONE",30)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONEH",31)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONH",32)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONHH",33)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONJ",34)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONL",35)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONM",36)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONR",72)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONS",37)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONSH",38)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONV",39)

"BLD",9670,"KRN",9.8,"NM","B","HMPMONX",40)

"BLD",9670,"KRN",9.8,"NM","B","HMPOR",41)

"BLD",9670,"KRN",9.8,"NM","B","HMPORRPC",64)

"BLD",9670,"KRN",9.8,"NM","B","HMPPTRPC",70)

"BLD",9670,"KRN",9.8,"NM","B","HMPSTMP",7)

"BLD",9670,"KRN",9.8,"NM","B","HMPTFU2",71)

"BLD",9670,"KRN",9.8,"NM","B","HMPTIUL",73)

"BLD",9670,"KRN",9.8,"NM","B","HMPTOOLS",60)

"BLD",9670,"KRN",9.8,"NM","B","HMPUPD",43)

"BLD",9670,"KRN",9.8,"NM","B","HMPUTIL2",61)

"BLD",9670,"KRN",9.8,"NM","B","HMPUTILS",42)

"BLD",9670,"KRN",9.8,"NM","B","HMPWB",44)

"BLD",9670,"KRN",9.8,"NM","B","HMPWB1",45)

"BLD",9670,"KRN",9.8,"NM","B","HMPWB2",46)

"BLD",9670,"KRN",9.8,"NM","B","HMPWB5",47)

"BLD",9670,"KRN",9.8,"NM","B","HMPWB5A",48)

"BLD",9670,"KRN",9.8,"NM","B","HMPWBIM1",49)

"BLD",9670,"KRN",9.8,"NM","B","HMPWBM1",50)

"BLD",9670,"KRN",9.8,"NM","B","HMPWBM2",51)

"BLD",9670,"KRN",9.8,"NM","B","HMPWBPL",52)

"BLD",9670,"KRN",9.8,"NM","B","HMPWBSO",53)

"BLD",9670,"KRN",9.8,"NM","B","HMPXGDPT",54)

"BLD",9670,"KRN",9.8,"NM","B","HMPXGLAB",55)

"BLD",9670,"KRN",9.8,"NM","B","HMPXGNP",56)

"BLD",9670,"KRN",9.8,"NM","B","HMPXGORD",57)

"BLD",9670,"KRN",9.8,"NM","B","HMPXGSD",58)

"BLD",9670,"KRN",19,0)
19
"BLD",9670,"KRN",19,"NM",0)
^9.68A^13^11
"BLD",9670,"KRN",19,"NM",1,0)
HMP EVENT PURGE^^0
"BLD",9670,"KRN",19,"NM",2,0)
HMP SYNCHRONIZATION CONTEXT^^0
"BLD",9670,"KRN",19,"NM",3,0)
HMP UI CONTEXT^^0
"BLD",9670,"KRN",19,"NM",4,0)
HMPMGR^^0
"BLD",9670,"KRN",19,"NM",5,0)
HMPMON DASHBOARD^^0
"BLD",9670,"KRN",19,"NM",6,0)
HMPMON SET PKG DASHBOARD RATE^^0
"BLD",9670,"KRN",19,"NM",7,0)
HMPMON SET SYS DASHBOARD RATE^^0
"BLD",9670,"KRN",19,"NM",8,0)
HMPM ADD HMP PATIENT^^0
"BLD",9670,"KRN",19,"NM",9,0)
HMPM EMERGENCY STOP^^0
"BLD",9670,"KRN",19,"NM",10,0)
HMPM RESTART FRESHNESS^^0
"BLD",9670,"KRN",19,"NM",13,0)
HMP PATIENT DATA MONITOR^^0
"BLD",9670,"KRN",19,"NM","B","HMP EVENT PURGE",1)

"BLD",9670,"KRN",19,"NM","B","HMP PATIENT DATA MONITOR",13)

"BLD",9670,"KRN",19,"NM","B","HMP SYNCHRONIZATION CONTEXT",2)

"BLD",9670,"KRN",19,"NM","B","HMP UI CONTEXT",3)

"BLD",9670,"KRN",19,"NM","B","HMPM ADD HMP PATIENT",8)

"BLD",9670,"KRN",19,"NM","B","HMPM EMERGENCY STOP",9)

"BLD",9670,"KRN",19,"NM","B","HMPM RESTART FRESHNESS",10)

"BLD",9670,"KRN",19,"NM","B","HMPMGR",4)

"BLD",9670,"KRN",19,"NM","B","HMPMON DASHBOARD",5)

"BLD",9670,"KRN",19,"NM","B","HMPMON SET PKG DASHBOARD RATE",6)

"BLD",9670,"KRN",19,"NM","B","HMPMON SET SYS DASHBOARD RATE",7)

"BLD",9670,"KRN",19.1,0)
19.1
"BLD",9670,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",9670,"KRN",101,0)
101
"BLD",9670,"KRN",101,"NM",0)
^9.68A^1^1
"BLD",9670,"KRN",101,"NM",1,0)
HMP DGPF ASSIGN FLAG^^0
"BLD",9670,"KRN",101,"NM","B","HMP DGPF ASSIGN FLAG",1)

"BLD",9670,"KRN",409.61,0)
409.61
"BLD",9670,"KRN",771,0)
771
"BLD",9670,"KRN",779.2,0)
779.2
"BLD",9670,"KRN",870,0)
870
"BLD",9670,"KRN",8989.51,0)
8989.51
"BLD",9670,"KRN",8989.51,"NM",0)
^9.68A^1^1
"BLD",9670,"KRN",8989.51,"NM",1,0)
HMPMON DASHBOARD UPDATE^^0
"BLD",9670,"KRN",8989.51,"NM","B","HMPMON DASHBOARD UPDATE",1)

"BLD",9670,"KRN",8989.52,0)
8989.52
"BLD",9670,"KRN",8989.52,"NM",0)
^9.68A^3^3
"BLD",9670,"KRN",8989.52,"NM",1,0)
HMPMON DASHBOARD PKG^^0
"BLD",9670,"KRN",8989.52,"NM",2,0)
HMPMON DASHBOARD SYS^^0
"BLD",9670,"KRN",8989.52,"NM",3,0)
HMPMON DASHBOARD USR^^0
"BLD",9670,"KRN",8989.52,"NM","B","HMPMON DASHBOARD PKG",1)

"BLD",9670,"KRN",8989.52,"NM","B","HMPMON DASHBOARD SYS",2)

"BLD",9670,"KRN",8989.52,"NM","B","HMPMON DASHBOARD USR",3)

"BLD",9670,"KRN",8994,0)
8994
"BLD",9670,"KRN",8994,"NM",0)
^9.68A^16^16
"BLD",9670,"KRN",8994,"NM",1,0)
HMP CHKXTMP^^0
"BLD",9670,"KRN",8994,"NM",2,0)
HMP GET RELATED ORDERS^^0
"BLD",9670,"KRN",8994,"NM",3,0)
HMP GLOBAL SIZE^^0
"BLD",9670,"KRN",8994,"NM",4,0)
HMP WRITEBACK ALLERGY^^0
"BLD",9670,"KRN",8994,"NM",5,0)
HMP WRITEBACK ALLERGY EIE^^0
"BLD",9670,"KRN",8994,"NM",6,0)
HMP WRITEBACK SIGN ORDERS^^0
"BLD",9670,"KRN",8994,"NM",7,0)
HMP WRITEBACK VITAL^^0
"BLD",9670,"KRN",8994,"NM",8,0)
HMP WRITEBACK VITAL EIE^^0
"BLD",9670,"KRN",8994,"NM",9,0)
HMP LOCAL GETCORRESPONDINGIDS^^1^
"BLD",9670,"KRN",8994,"NM",10,0)
TIU LONG LIST OF TITLES^^0
"BLD",9670,"KRN",8994,"NM",11,0)
HMP SAVE NOTE STUB^^0
"BLD",9670,"KRN",8994,"NM",12,0)
HMP MED ORDER CHECKS^^0
"BLD",9670,"KRN",8994,"NM",13,0)
HMP WRITEBACK ENCOUNTERS^^0
"BLD",9670,"KRN",8994,"NM",14,0)
HMP DELETE TIU NOTE^^0
"BLD",9670,"KRN",8994,"NM",15,0)
HMP TIU LONG LIST OF TITLES^^0
"BLD",9670,"KRN",8994,"NM",16,0)
HMP SUBSCRIPTION STATUS^^0
"BLD",9670,"KRN",8994,"NM","B","HMP CHKXTMP",1)

"BLD",9670,"KRN",8994,"NM","B","HMP DELETE TIU NOTE",14)

"BLD",9670,"KRN",8994,"NM","B","HMP GET RELATED ORDERS",2)

"BLD",9670,"KRN",8994,"NM","B","HMP GLOBAL SIZE",3)

"BLD",9670,"KRN",8994,"NM","B","HMP LOCAL GETCORRESPONDINGIDS",9)

"BLD",9670,"KRN",8994,"NM","B","HMP MED ORDER CHECKS",12)

"BLD",9670,"KRN",8994,"NM","B","HMP SAVE NOTE STUB",11)

"BLD",9670,"KRN",8994,"NM","B","HMP SUBSCRIPTION STATUS",16)

"BLD",9670,"KRN",8994,"NM","B","HMP TIU LONG LIST OF TITLES",15)

"BLD",9670,"KRN",8994,"NM","B","HMP WRITEBACK ALLERGY",4)

"BLD",9670,"KRN",8994,"NM","B","HMP WRITEBACK ALLERGY EIE",5)

"BLD",9670,"KRN",8994,"NM","B","HMP WRITEBACK ENCOUNTERS",13)

"BLD",9670,"KRN",8994,"NM","B","HMP WRITEBACK SIGN ORDERS",6)

"BLD",9670,"KRN",8994,"NM","B","HMP WRITEBACK VITAL",7)

"BLD",9670,"KRN",8994,"NM","B","HMP WRITEBACK VITAL EIE",8)

"BLD",9670,"KRN",8994,"NM","B","TIU LONG LIST OF TITLES",10)

"BLD",9670,"KRN","B",.4,.4)

"BLD",9670,"KRN","B",.401,.401)

"BLD",9670,"KRN","B",.402,.402)

"BLD",9670,"KRN","B",.403,.403)

"BLD",9670,"KRN","B",.5,.5)

"BLD",9670,"KRN","B",.84,.84)

"BLD",9670,"KRN","B",3.6,3.6)

"BLD",9670,"KRN","B",3.8,3.8)

"BLD",9670,"KRN","B",9.2,9.2)

"BLD",9670,"KRN","B",9.8,9.8)

"BLD",9670,"KRN","B",19,19)

"BLD",9670,"KRN","B",19.1,19.1)

"BLD",9670,"KRN","B",101,101)

"BLD",9670,"KRN","B",409.61,409.61)

"BLD",9670,"KRN","B",771,771)

"BLD",9670,"KRN","B",779.2,779.2)

"BLD",9670,"KRN","B",870,870)

"BLD",9670,"KRN","B",8989.51,8989.51)

"BLD",9670,"KRN","B",8989.52,8989.52)

"BLD",9670,"KRN","B",8994,8994)

"BLD",9670,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",9670,"QUES",0)
^9.62^^
"BLD",9670,"REQB",0)
^9.611^6^6
"BLD",9670,"REQB",1,0)
PSS*1.0*197^2
"BLD",9670,"REQB",2,0)
DG*5.3*921^2
"BLD",9670,"REQB",3,0)
GMRV*5.0*32^2
"BLD",9670,"REQB",4,0)
OR*3.0*421^2
"BLD",9670,"REQB",5,0)
PSB*3.0*95^2
"BLD",9670,"REQB",6,0)
MD*1.0*46^2
"BLD",9670,"REQB","B","DG*5.3*921",2)

"BLD",9670,"REQB","B","GMRV*5.0*32",3)

"BLD",9670,"REQB","B","MD*1.0*46",6)

"BLD",9670,"REQB","B","OR*3.0*421",4)

"BLD",9670,"REQB","B","PSB*3.0*95",5)

"BLD",9670,"REQB","B","PSS*1.0*197",1)

"FIA",800000)
HMP SUBSCRIPTION
"FIA",800000,0)
^HMP(800000,
"FIA",800000,0,0)
800000
"FIA",800000,0,1)
y^y^f^^^^n
"FIA",800000,0,10)

"FIA",800000,0,11)

"FIA",800000,0,"RLRO")

"FIA",800000,0,"VR")
2.0^HMP
"FIA",800000,800000)
0
"FIA",800000,800000.01)
0
"FIA",800000,800000.02)
0
"FIA",800000,800000.14)
0
"FIA",800000,800000.142)
0
"FIA",800003)
HMP EVENT
"FIA",800003,0)
^HMPLOG(800003,
"FIA",800003,0,0)
800003I
"FIA",800003,0,1)
y^y^f^^^^n
"FIA",800003,0,10)

"FIA",800003,0,11)

"FIA",800003,0,"RLRO")

"FIA",800003,0,"VR")
2.0^HMP
"FIA",800003,800003)
0
"FIA",800003,800003.01)
0
"IX",800000,800000,"AD",0)
800000^AD^Index of operational data by server.^R^^F^IR^I^800000^^^^^S
"IX",800000,800000,"AD",.1,0)
^^1^1^3160720^
"IX",800000,800000,"AD",.1,1,0)
This index is used to find operational data for each eHMP server.
"IX",800000,800000,"AD",1)
S ^HMP(800000,"AD",X,DA)=""
"IX",800000,800000,"AD",1.4)
S X=X(1)
"IX",800000,800000,"AD",2)
K ^HMP(800000,"AD",X,DA)
"IX",800000,800000,"AD",2.4)
S X=X(1)
"IX",800000,800000,"AD",2.5)
K ^HMP(800000,"AD")
"IX",800000,800000,"AD",11.1,0)
^.114IA^1^1
"IX",800000,800000,"AD",11.1,1,0)
1^F^800000^.07^^1^F
"IX",800000,800000,"ADFN",0)
800000^ADFN^Patients to track in the Data Monitor^MU^^R^IR^W^800000.01^^^^^S
"IX",800000,800000,"ADFN",.1,0)
^^1^1^3160720^
"IX",800000,800000,"ADFN",.1,1,0)
This index will place the entry in the data monitor for this patient.
"IX",800000,800000,"ADFN",1)
D HMPSET^HMPDJFS(.DA,.X)
"IX",800000,800000,"ADFN",1.4)
S X=0 I +X(1)>0 S X=1
"IX",800000,800000,"ADFN",2)
D HMPKILL^HMPDJFS(.DA,.X)
"IX",800000,800000,"ADFN",2.4)
S X=0 I X(1)'="" S X=1
"IX",800000,800000,"ADFN",2.5)
K ^HMP(800000,"AITEM")
"IX",800000,800000,"ADFN",11.1,0)
^.114IA^2^2
"IX",800000,800000,"ADFN",11.1,1,0)
1^F^800000.01^.01^^1^F
"IX",800000,800000,"ADFN",11.1,2,0)
2^F^800000.01^2^^^F
"IX",800000,800000,"AITEM",0)
800000^AITEM^AITEM TEST^MU^^F^IR^I^800000^^^^^A
"IX",800000,800000,"AITEM",.1,0)
^^1^1^3160726^
"IX",800000,800000,"AITEM",.1,1,0)
This index will place the entry in the data monitor for this patient.
"IX",800000,800000,"AITEM",1)
D HMPOSET^HMPDJFS(DA,X)
"IX",800000,800000,"AITEM",1.4)
I X(1)'=""
"IX",800000,800000,"AITEM",2)
D HMPOKILL^HMPDJFS(DA)
"IX",800000,800000,"AITEM",2.4)
I X(1)'=""
"IX",800000,800000,"AITEM",2.5)
K ^HMP(800000,"AITEM")
"IX",800000,800000,"AITEM",11.1,0)
^.114IA^1^1
"IX",800000,800000,"AITEM",11.1,1,0)
1^F^800000^.03^^^F
"IX",800000,800000,"AROS",0)
800000^AROS^Rosters to track in the Data Monitor^MU^^R^IR^W^800000.02^^^^^S
"IX",800000,800000,"AROS",.1,0)
^^1^1^3160720^
"IX",800000,800000,"AROS",.1,1,0)
A cross-reference of rosters for groups of patients on wards.
"IX",800000,800000,"AROS",1)
S:X2(2) ^HMP(800000,"AROS",X,DA(1))=""
"IX",800000,800000,"AROS",2)
K:X1(2) ^HMP(800000,"AROS",X,DA(1))
"IX",800000,800000,"AROS",2.5)
K ^HMP(800000,"AROS")
"IX",800000,800000,"AROS",11.1,0)
^.114IA^2^2
"IX",800000,800000,"AROS",11.1,1,0)
1^F^800000.02^.01^^1^F
"IX",800000,800000,"AROS",11.1,2,0)
2^F^800000.02^2^^2^
"IX",800000,800000.01,"AP",0)
800000.01^AP^Subscribed patients by server not yet initialized.^R^^R^IR^I^800000.01^^^^^S
"IX",800000,800000.01,"AP",.1,0)
^^6^6^3140521^
"IX",800000,800000.01,"AP",.1,1,0)
This index lists the patients who are not yet initialized:
"IX",800000,800000.01,"AP",.1,2,0)
 
"IX",800000,800000.01,"AP",.1,3,0)
  SERVER_IEN, "AP", STATUS, STATUS TIME, DFN
"IX",800000,800000.01,"AP",.1,4,0)
 
"IX",800000,800000.01,"AP",.1,5,0)
Patients with an initialized status (STATUS = 2) do not appear in this 
"IX",800000,800000.01,"AP",.1,6,0)
index.
"IX",800000,800000.01,"AP",1)
S ^HMP(800000,DA(1),1,"AP",X(1),X(2),DA)=""
"IX",800000,800000.01,"AP",1.4)
S X=(+X2(1)<2)
"IX",800000,800000.01,"AP",2)
K ^HMP(800000,DA(1),1,"AP",X(1),X(2),DA)
"IX",800000,800000.01,"AP",2.5)
K ^HMP(800000,DA(1),1,"AP")
"IX",800000,800000.01,"AP",11.1,0)
^.114IA^2^2
"IX",800000,800000.01,"AP",11.1,1,0)
1^F^800000.01^2^^1^F
"IX",800000,800000.01,"AP",11.1,2,0)
2^F^800000.01^3^^2^F
"KRN",19,14321,-1)
0^3
"KRN",19,14321,0)
HMP UI CONTEXT^HMP UI CONTEXT version 20160108-01.US12195^^B^^^^^^^^
"KRN",19,14321,1,0)
^19.06^1^1^3160726^^^^
"KRN",19,14321,1,1,0)
This option allows the HMP UI access to the VistA system.
"KRN",19,14321,99.1)
62990,29647
"KRN",19,14321,"RPC",0)
^19.05P^137^136
"KRN",19,14321,"RPC",1,0)
HMPCORD RPC
"KRN",19,14321,"RPC",2,0)
HMPCPAT RPC
"KRN",19,14321,"RPC",3,0)
HMPFPTC CHKS
"KRN",19,14321,"RPC",4,0)
HMPFPTC LOG
"KRN",19,14321,"RPC",5,0)
HMP APPOINTMENTS
"KRN",19,14321,"RPC",6,0)
HMP DATA VERSION
"KRN",19,14321,"RPC",7,0)
HMP DELETE ROSTER
"KRN",19,14321,"RPC",8,0)
HMP GET PATIENT DATA
"KRN",19,14321,"RPC",9,0)
HMP GET SOURCE
"KRN",19,14321,"RPC",10,0)
HMP INPATIENTS
"KRN",19,14321,"RPC",11,0)
HMP PREVIEW ROSTER
"KRN",19,14321,"RPC",12,0)
HMP ROSTER PATIENTS
"KRN",19,14321,"RPC",13,0)
HMP ROSTERS
"KRN",19,14321,"RPC",14,0)
HMP SUBSCRIBE
"KRN",19,14321,"RPC",15,0)
HMP UPDATE ROSTER
"KRN",19,14321,"RPC",16,0)
HMPCRPC RPC
"KRN",19,14321,"RPC",17,0)
XHD GET PARAMETER DEF LIST
"KRN",19,14321,"RPC",18,0)
HMP PUT PATIENT DATA
"KRN",19,14321,"RPC",19,0)
HMP PUT OBJECT
"KRN",19,14321,"RPC",20,0)
HMP DELETE OBJECT
"KRN",19,14321,"RPC",21,0)
HMP GET OBJECT
"KRN",19,14321,"RPC",22,0)
HMP GET ROSTER LIST
"KRN",19,14321,"RPC",23,0)
HMPCPRS RPC
"KRN",19,14321,"RPC",24,0)
ORQPT WARDS
"KRN",19,14321,"RPC",25,0)
ORQPT WARD PATIENTS
"KRN",19,14321,"RPC",26,0)
ORQPT SPECIALTIES
"KRN",19,14321,"RPC",27,0)
ORQPT SPECIALTY PATIENTS
"KRN",19,14321,"RPC",28,0)
ORWU CLINLOC
"KRN",19,14321,"RPC",29,0)
ORQPT CLINIC PATIENTS
"KRN",19,14321,"RPC",30,0)
ORWU NEWPERS
"KRN",19,14321,"RPC",31,0)
ORQPT PROVIDER PATIENTS
"KRN",19,14321,"RPC",32,0)
ORWRP COLUMN HEADERS
"KRN",19,14321,"RPC",33,0)
ORWLR CUMULATIVE REPORT
"KRN",19,14321,"RPC",34,0)
ORWLRR INTERIM
"KRN",19,14321,"RPC",35,0)
ORWRP REPORT TEXT
"KRN",19,14321,"RPC",36,0)
ORWRP3 EXPAND COLUMNS
"KRN",19,14321,"RPC",37,0)
HMP PUT DEMOGRAPHICS
"KRN",19,14321,"RPC",38,0)
HMPCRPC RPCCHAIN
"KRN",19,14321,"RPC",39,0)
ORQPT DEFAULT PATIENT LIST
"KRN",19,14321,"RPC",40,0)
ORWU USERINFO
"KRN",19,14321,"RPC",41,0)
YTQ ALLKEYS
"KRN",19,14321,"RPC",42,0)
ORWPT BYWARD
"KRN",19,14321,"RPC",43,0)
ORQQPX REMINDERS LIST
"KRN",19,14321,"RPC",44,0)
ORQQPX REMINDER DETAIL
"KRN",19,14321,"RPC",45,0)
ORQQPL4 LEX
"KRN",19,14321,"RPC",46,0)
ORWRP REPORT LISTS
"KRN",19,14321,"RPC",47,0)
HMP PATIENT ADMIT SYNC
"KRN",19,14321,"RPC",48,0)
HMP PATIENT SCHED SYNC
"KRN",19,14321,"RPC",49,0)
ORWPT LIST ALL
"KRN",19,14321,"RPC",50,0)
ORWPT APPTLST
"KRN",19,14321,"RPC",51,0)
PX SAVE DATA
"KRN",19,14321,"RPC",52,0)
GMV ADD VM
"KRN",19,14321,"RPC",53,0)
GMV VITALS/CAT/QUAL
"KRN",19,14321,"RPC",54,0)
GMV MARK ERROR
"KRN",19,14321,"RPC",55,0)
ORWDAL32 SAVE ALLERGY
"KRN",19,14321,"RPC",56,0)
ORWDAL32 CLINUSER
"KRN",19,14321,"RPC",57,0)
ORWDAL32 ALLERGY MATCH
"KRN",19,14321,"RPC",58,0)
ORWDAL32 SYMPTOMS
"KRN",19,14321,"RPC",59,0)
HMP CHKXTMP
"KRN",19,14321,"RPC",60,0)
HMP GLOBAL SIZE
"KRN",19,14321,"RPC",61,0)
ORQQPL ADD SAVE
"KRN",19,14321,"RPC",62,0)
ORQQPL DELETE
"KRN",19,14321,"RPC",63,0)
ORQQPL EDIT SAVE
"KRN",19,14321,"RPC",64,0)
ORQQVI NOTEVIT
"KRN",19,14321,"RPC",65,0)
ORWPCE HASVISIT
"KRN",19,14321,"RPC",66,0)
ORWPCE NOTEVSTR
"KRN",19,14321,"RPC",67,0)
ORWU DT
"KRN",19,14321,"RPC",68,0)
ORWU EXTNAME
"KRN",19,14321,"RPC",69,0)
TIU AUTHORIZATION
"KRN",19,14321,"RPC",70,0)
TIU CREATE ADDENDUM RECORD
"KRN",19,14321,"RPC",71,0)
TIU CREATE RECORD
"KRN",19,14321,"RPC",72,0)
TIU DOCUMENTS BY CONTEXT
"KRN",19,14321,"RPC",73,0)
TIU GET DOCUMENT TITLE
"KRN",19,14321,"RPC",74,0)
TIU GET RECORD TEXT
"KRN",19,14321,"RPC",75,0)
TIU GET REQUEST
"KRN",19,14321,"RPC",76,0)
TIU IS THIS A CONSULT?
"KRN",19,14321,"RPC",77,0)
TIU IS THIS A SURGERY?
"KRN",19,14321,"RPC",78,0)
TIU ISPRF
"KRN",19,14321,"RPC",79,0)
TIU LOCK RECORD
"KRN",19,14321,"RPC",80,0)
TIU LONG LIST OF TITLES
"KRN",19,14321,"RPC",81,0)
TIU REQUIRES COSIGNATURE
"KRN",19,14321,"RPC",82,0)
TIU SET DOCUMENT TEXT
"KRN",19,14321,"RPC",83,0)
TIU SIGN RECORD
"KRN",19,14321,"RPC",84,0)
TIU UNLOCK RECORD
"KRN",19,14321,"RPC",85,0)
TIU UPDATE RECORD
"KRN",19,14321,"RPC",86,0)
ORCNOTE GET TOTAL
"KRN",19,14321,"RPC",87,0)
HMP SAVE NOTE STUB
"KRN",19,14321,"RPC",88,0)
ORWPCE LEX
"KRN",19,14321,"RPC",89,0)
ORWPCE SAVE
"KRN",19,14321,"RPC",90,0)
ORQQPL USER PROB LIST
"KRN",19,14321,"RPC",91,0)
TIU DELETE RECORD
"KRN",19,14321,"RPC",92,0)
HMP WRITEBACK VITAL
"KRN",19,14321,"RPC",93,0)
HMP MED ORDER CHECKS
"KRN",19,14321,"RPC",95,0)
HMP WRITEBACK ENCOUNTERS
"KRN",19,14321,"RPC",99,0)
ORWPCE SCSEL
"KRN",19,14321,"RPC",100,0)
HMP PUT OPERATIONAL DATA
"KRN",19,14321,"RPC",101,0)
HMP WRITEBACK VITAL EIE
"KRN",19,14321,"RPC",103,0)
HMP WRITEBACK ALLERGY EIE
"KRN",19,14321,"RPC",104,0)
HMP WRITEBACK ALLERGY
"KRN",19,14321,"RPC",106,0)
HMP DELETE TIU NOTE
"KRN",19,14321,"RPC",107,0)
HMP WRITEBACK SIGN ORDERS
"KRN",19,14321,"RPC",108,0)
ORQOR DETAIL
"KRN",19,14321,"RPC",110,0)
HMP DEFAULT PATIENT LIST
"KRN",19,14321,"RPC",119,0)
HMP GET PATIENT DATA JSON
"KRN",19,14321,"RPC",120,0)
GMV GET CURRENT TIME
"KRN",19,14321,"RPC",121,0)
ORWU VALIDSIG
"KRN",19,14321,"RPC",122,0)
VAFC LOCAL GETCORRESPONDINGIDS
"KRN",19,14321,"RPC",123,0)
HMP PATIENT SELECT
"KRN",19,14321,"RPC",124,0)
ORWPCE GETSVC
"KRN",19,14321,"RPC",125,0)
ORWPCE PCE4NOTE
"KRN",19,14321,"RPC",126,0)
ORWLEX GETFREQ
"KRN",19,14321,"RPC",127,0)
ORWLEX GETI10DX
"KRN",19,14321,"RPC",128,0)
ORWCV VST
"KRN",19,14321,"RPC",130,0)
HMP TIU LONG LIST OF TITLES
"KRN",19,14321,"RPC",131,0)
ORWPT ADMITLST
"KRN",19,14321,"RPC",132,0)
HMP GET RELATED ORDERS
"KRN",19,14321,"RPC",133,0)
ORWPCE LEXCODE
"KRN",19,14321,"RPC",134,0)
ORWDRA32 RAORDITM
"KRN",19,14321,"RPC",135,0)
ORQQPL EDIT LOAD
"KRN",19,14321,"RPC",137,0)
ORWU1 NEWLOC
"KRN",19,14321,"U")
HMP UI CONTEXT VERSION 2016010
"KRN",19,14373,-1)
0^2
"KRN",19,14373,0)
HMP SYNCHRONIZATION CONTEXT^Synchronize the HMP^^B^^^^^^^^
"KRN",19,14373,1,0)
^^2^2^3150923^
"KRN",19,14373,1,1,0)
This option manages access to RPCs responsible for synchronization of eHMP
"KRN",19,14373,1,2,0)
data with VistA.
"KRN",19,14373,99.1)
63613,33836
"KRN",19,14373,"RPC",0)
^19.05P^28^28
"KRN",19,14373,"RPC",2,0)
HMP DATA VERSION
"KRN",19,14373,"RPC",4,0)
HMP SUBSCRIBE
"KRN",19,14373,"RPC",5,0)
HMP GET PATIENT DATA JSON
"KRN",19,14373,"RPC",7,0)
HMP GET OBJECT
"KRN",19,14373,"RPC",8,0)
HMP GET OPERATIONAL DATA
"KRN",19,14373,"RPC",10,0)
HMP PUT OBJECT
"KRN",19,14373,"RPC",19,0)
HMPDJFS API
"KRN",19,14373,"RPC",20,0)
HMPDJFS DELSUB
"KRN",19,14373,"RPC",21,0)
HMP GET CHECKSUM
"KRN",19,14373,"RPC",22,0)
HMP PATIENT ACTIVITY
"KRN",19,14373,"RPC",24,0)
ORWU USERINFO
"KRN",19,14373,"RPC",25,0)
HMP SUBSCRIPTION STATUS
"KRN",19,14373,"RPC",26,0)
VAFC LOCAL GETCORRESPONDINGIDS
"KRN",19,14373,"RPC",27,0)
HMP DEFAULT PATIENT LIST
"KRN",19,14373,"RPC",28,0)
HMP PATIENT ADMIT SYNC
"KRN",19,14373,"U")
SYNCHRONIZE THE HMP
"KRN",19,14406,-1)
0^13
"KRN",19,14406,0)
HMP PATIENT DATA MONITOR^HMP Patient Data Monitor^^A^^^^^^^^^^1
"KRN",19,14406,1,0)
^19.06^4^4^3160726^^^
"KRN",19,14406,1,1,0)
This option manages the HMP Patient Data Monitor background job.  It first
"KRN",19,14406,1,2,0)
checks to see if the job is running, and will prompt the user to start it
"KRN",19,14406,1,3,0)
if it's stopped. It may also be used to stop the job, but the eHMP client
"KRN",19,14406,1,4,0)
may not display up-to-date data until it is started again.
"KRN",19,14406,20)
D EN^HMPHTTP
"KRN",19,14406,"U")
HMP PATIENT DATA MONITOR
"KRN",19,14410,-1)
0^9
"KRN",19,14410,0)
HMPM EMERGENCY STOP^Emergency Stop HMP Freshness Updates^^A^^^^^^^^^^1
"KRN",19,14410,1,0)
^^5^5^3140403^
"KRN",19,14410,1,1,0)
This option should be used with caution.  It will stop the freshness 
"KRN",19,14410,1,2,0)
events for the ENTERPRISE HEALTH MANAGEMENT PLATFORM (HMP) from being called.  Once the 
"KRN",19,14410,1,3,0)
freshness events are stopped, patient data must be re-synchronized with
"KRN",19,14410,1,4,0)
the HMP to ensure completeness.  Only stop freshness updates if there is a
"KRN",19,14410,1,5,0)
problem with system operation.
"KRN",19,14410,20)
D EMERSTOP^HMPDJFSM
"KRN",19,14410,"U")
EMERGENCY STOP HMP FRESHNESS U
"KRN",19,14411,-1)
0^8
"KRN",19,14411,0)
HMPM ADD HMP PATIENT^Manually Add Patient to HMP^^A^^^^^^^^^^1
"KRN",19,14411,1,0)
^19.06^2^2^3160726^^
"KRN",19,14411,1,1,0)
Use this option to manually add a patient for synchronization with the 
"KRN",19,14411,1,2,0)
Enterprise Health Management Platform (eHMP).
"KRN",19,14411,20)
D ADDPT^HMPDJFSM
"KRN",19,14411,"U")
MANUALLY ADD PATIENT TO HMP
"KRN",19,14412,-1)
0^4
"KRN",19,14412,0)
HMPMGR^HMP Technical Management^^M^^^^^^^^
"KRN",19,14412,1,0)
^19.06^1^1^3160726^^^^
"KRN",19,14412,1,1,0)
This menu contains various options to help with the management of HMP.
"KRN",19,14412,10,0)
^19.01IP^13^13
"KRN",19,14412,10,5,0)
14445^^1
"KRN",19,14412,10,5,"^")
HMPMON DASHBOARD
"KRN",19,14412,10,7,0)
14411^^40
"KRN",19,14412,10,7,"^")
HMPM ADD HMP PATIENT
"KRN",19,14412,10,11,0)
14410^^10
"KRN",19,14412,10,11,"^")
HMPM EMERGENCY STOP
"KRN",19,14412,10,12,0)
14413^^20
"KRN",19,14412,10,12,"^")
HMPM RESTART FRESHNESS
"KRN",19,14412,10,13,0)
14406^^50
"KRN",19,14412,10,13,"^")
HMP PATIENT DATA MONITOR
"KRN",19,14412,99)
64155,59554
"KRN",19,14412,"U")
HMP TECHNICAL MANAGEMENT
"KRN",19,14413,-1)
0^10
"KRN",19,14413,0)
HMPM RESTART FRESHNESS^Resume Freshness Updates That Have Been Stopped^^A^^^^^^^^^^1
"KRN",19,14413,1,0)
^19.06^4^4^3151208^^^
"KRN",19,14413,1,1,0)
This option will remove the flags that cause freshness updates to be 
"KRN",19,14413,1,2,0)
stopped.  It will likely be necessary to re-synchronized patients after 
"KRN",19,14413,1,3,0)
freshness has been stopped, since updates will be missing from the time 
"KRN",19,14413,1,4,0)
that freshness updates were not being received.
"KRN",19,14413,20)
D RSTRTFR^HMPDJFSM
"KRN",19,14413,"U")
RESUME FRESHNESS UPDATES THAT 
"KRN",19,14442,-1)
0^1
"KRN",19,14442,0)
HMP EVENT PURGE^HMP Purge HMP EVENT file (#800003)^^R^^^^^^^^
"KRN",19,14442,1,0)
^^4^4^3160613^
"KRN",19,14442,1,1,0)
This option will delete entries in the HMP EVENT file (#800003)
"KRN",19,14442,1,2,0)
that are older than 2 months (61 days).
"KRN",19,14442,1,3,0)
 
"KRN",19,14442,1,4,0)
It is recommended that this option be scheduled to run daily.
"KRN",19,14442,25)
PRGLOG^HMPLOG
"KRN",19,14442,"U")
HMP PURGE HMP EVENT FILE (#800
"KRN",19,14443,-1)
0^7
"KRN",19,14443,0)
HMPMON SET SYS DASHBOARD RATE^Set System's Dashboard Auto-update Rate^^R^^HMP ADMIN^^^^^^
"KRN",19,14443,1,0)
^^5^5^3160329^
"KRN",19,14443,1,1,0)
Option HMPMON SET SYS DASHBOARD RATE lets the eHMP coordinator for this 
"KRN",19,14443,1,2,0)
Vista system set a system-level value for parameter HMPMON DASHBOARD 
"KRN",19,14443,1,3,0)
UPDATE to override the package-level default set by the eHMP primary 
"KRN",19,14443,1,4,0)
developers. This parameter controls the auto-update rate of the screens 
"KRN",19,14443,1,5,0)
in the eHMP Dashboard [HMPMON DASHBOARD].
"KRN",19,14443,25)
SETSYS^HMPMONC
"KRN",19,14443,"U")
SET SYSTEM'S DASHBOARD AUTO-UP
"KRN",19,14444,-1)
0^6
"KRN",19,14444,0)
HMPMON SET PKG DASHBOARD RATE^Set Package's Dashboard Auto-update Rate^^R^^HMP ADMIN^^^^^^
"KRN",19,14444,1,0)
^^8^8^3160329^
"KRN",19,14444,1,1,0)
Option HMPMON SET PKG DASHBOARD RATE lets the eHMP primary developers
"KRN",19,14444,1,2,0)
set a package-level value for parameter HMPMON DASHBOARD UPDATE that
"KRN",19,14444,1,3,0)
ships with the eHMP software. This parameter controls the auto-update rate
"KRN",19,14444,1,4,0)
of the screens in the eHMP Dashboard [HMPMON DASHBOARD]. It can be 
"KRN",19,14444,1,5,0)
overridden by the eHMP coordinator for a Vista system or by individual 
"KRN",19,14444,1,6,0)
Dashboard users using the system-level or user-level parameters, but the 
"KRN",19,14444,1,7,0)
package-level parameter should not be changed outside the development 
"KRN",19,14444,1,8,0)
environments of the eHMP primary developers.
"KRN",19,14444,25)
SETPKG^HMPMONC
"KRN",19,14444,"U")
SET PACKAGE'S DASHBOARD AUTO-U
"KRN",19,14445,-1)
0^5
"KRN",19,14445,0)
HMPMON DASHBOARD^HMP Dashboard^^R^^^^^^^^
"KRN",19,14445,1,0)
^^5^5^3160413^
"KRN",19,14445,1,1,0)
Option HMPMON DASHBOARD is a high-level system-management and 
"KRN",19,14445,1,2,0)
troubleshooting dashboard for monitoring the health of the Vista-side 
"KRN",19,14445,1,3,0)
eHMP software, including polling jobs, batch extracts, progress of 
"KRN",19,14445,1,4,0)
patients through the synchronization queue, errors generated by eHMP, and 
"KRN",19,14445,1,5,0)
usage of the ^XTMP and ^TMP globals.
"KRN",19,14445,25)
OPTION^HMPMON
"KRN",19,14445,"U")
HMP DASHBOARD
"KRN",101,6193,-1)
0^1
"KRN",101,6193,0)
HMP DGPF ASSIGN FLAG^^^A^^^^^^^^HEALTH MANAGEMENT PLATFORM
"KRN",101,6193,1,0)
^101.06^2^2^3160203^^^
"KRN",101,6193,1,1,0)
Used to trigger a JDS update when the DGPF ASSIGN FLAG action protocol is used.
"KRN",101,6193,1,2,0)
A patient must have been selected and the DFN value is in DGDFN.
"KRN",101,6193,20)
I $G(DGDFN),$L($T(POST^HMPEVNT)) D POST^HMPEVNT(DGDFN,"patient",DGDFN)
"KRN",8989.51,872,-1)
0^1
"KRN",8989.51,872,0)
HMPMON DASHBOARD UPDATE^HMP Dashboard Update Rate
"KRN",8989.51,872,1)
N^3:300^Enter a number between 3 and 300 seconds inclusively.
"KRN",8989.51,872,20,0)
^^26^26^3160316^
"KRN",8989.51,872,20,1,0)
This parameter controls the behavior of option eHMP Dashboard [HMPMON
"KRN",8989.51,872,20,2,0)
DASHBOARD]. Most of this option's prompts time out normally, but its 
"KRN",8989.51,872,20,3,0)
Action Prompts control monitoring screens that auto-update the screen when
"KRN",8989.51,872,20,4,0)
they time out, to provide dashboard functionality for monitoring the 
"KRN",8989.51,872,20,5,0)
Vista-side eHMP software.
"KRN",8989.51,872,20,6,0)
 
"KRN",8989.51,872,20,7,0)
This parameter ships with three settings:
"KRN",8989.51,872,20,8,0)
 
"KRN",8989.51,872,20,9,0)
1) a package default setting, defined by the eHMP development team using
"KRN",8989.51,872,20,10,0)
parameter template HMPMON DASHBOARD PKG, accessed through menu option Set 
"KRN",8989.51,872,20,11,0)
Package's Dashboard Auto-update Rate [HMPMON SET PKG DASHBOARD RATE], 
"KRN",8989.51,872,20,12,0)
which should not be changed at local sites;
"KRN",8989.51,872,20,13,0)
 
"KRN",8989.51,872,20,14,0)
2) a system setting that will override the package setting; it can be 
"KRN",8989.51,872,20,15,0)
defined by the local system manager using parameter template HMPMON 
"KRN",8989.51,872,20,16,0)
DASHBOARD SYS, accessed hrough menu option Set System's Dashboard 
"KRN",8989.51,872,20,17,0)
Auto-update Rate [HMPMON SET SYS DASHBOARD RATE];
"KRN",8989.51,872,20,18,0)
 
"KRN",8989.51,872,20,19,0)
3) a user setting that overrides the other two; it is defined by the 
"KRN",8989.51,872,20,20,0)
current user using parameter HMPMON DASHBOARD USR, accessed by the 
"KRN",8989.51,872,20,21,0)
dashboard action Change Auto-update Rate action within option eHMP
"KRN",8989.51,872,20,22,0)
Dashboard [HMPMON DASHBOARD].
"KRN",8989.51,872,20,23,0)
 
"KRN",8989.51,872,20,24,0)
It is usually set to 3 to 30 seconds, but can be set as high as 300 
"KRN",8989.51,872,20,25,0)
seconds to support demonstration or teaching situations. If it is wholly 
"KRN",8989.51,872,20,26,0)
absent, the user's default Vista time-out rate is used.
"KRN",8989.51,872,30,0)
^8989.513I^3^3
"KRN",8989.51,872,30,1,0)
1^200
"KRN",8989.51,872,30,2,0)
2^4.2
"KRN",8989.51,872,30,3,0)
3^9.4
"KRN",8989.52,123,-1)
0^1
"KRN",8989.52,123,0)
HMPMON DASHBOARD PKG^Dashboard Auto-update Rate^9.4
"KRN",8989.52,123,10,0)
^8989.521IA^1^1
"KRN",8989.52,123,10,1,0)
1^HMPMON DASHBOARD UPDATE
"KRN",8989.52,124,-1)
0^3
"KRN",8989.52,124,0)
HMPMON DASHBOARD USR^Dashboard Auto-update Rate^200
"KRN",8989.52,124,10,0)
^8989.521IA^1^1
"KRN",8989.52,124,10,1,0)
1^HMPMON DASHBOARD UPDATE
"KRN",8989.52,125,-1)
0^2
"KRN",8989.52,125,0)
HMPMON DASHBOARD SYS^Dashboard Auto-update Rate^4.2^
"KRN",8989.52,125,10,0)
^8989.521IA^1^1
"KRN",8989.52,125,10,1,0)
1^HMPMON DASHBOARD UPDATE
"KRN",8994,135,-1)
0^10
"KRN",8994,135,0)
TIU LONG LIST OF TITLES^LONGLIST^TIUSRVD^2^S^^^^^^1
"KRN",8994,135,1,0)
^^3^3^2971021^^
"KRN",8994,135,1,1,0)
This RPC serves data to a longlist of selectable TITLES by CLASS.  e.g.,
"KRN",8994,135,1,2,0)
passing the class PROGRESS NOTES will return active Progress Notes titles
"KRN",8994,135,1,3,0)
which the current user is authorized to enter notes under.
"KRN",8994,135,2,0)
^8994.02A^3^3
"KRN",8994,135,2,1,0)
CLASS^1^^1^1
"KRN",8994,135,2,1,1,0)
^^2^2^2971021^^
"KRN",8994,135,2,1,1,1,0)
This is a pointer to the CLASS in the Document Definition File (#8925.1)
"KRN",8994,135,2,1,1,2,0)
from which the application intends to allow selection of TITLES.
"KRN",8994,135,2,2,0)
FROM^1^^1^2
"KRN",8994,135,2,2,1,0)
^^1^1^2971021^
"KRN",8994,135,2,2,1,1,0)
This is the reference title from which the longlist is scrolling.
"KRN",8994,135,2,3,0)
DIR^1^^^3
"KRN",8994,135,2,3,1,0)
^^2^2^2971021^
"KRN",8994,135,2,3,1,1,0)
This is the direction in which the longlist is scrolling from the
"KRN",8994,135,2,3,1,2,0)
reference title.
"KRN",8994,135,2,"B","CLASS",1)

"KRN",8994,135,2,"B","DIR",3)

"KRN",8994,135,2,"B","FROM",2)

"KRN",8994,135,2,"PARAMSEQ",1,1)

"KRN",8994,135,2,"PARAMSEQ",2,2)

"KRN",8994,135,2,"PARAMSEQ",3,3)

"KRN",8994,135,3,0)
^^2^2^2971021^^
"KRN",8994,135,3,1,0)
This is an array of the 44 nearest titles to that indicate by the user in
"KRN",8994,135,3,2,0)
the direction passed by the longlist component.
"KRN",8994,3551,-1)
0^1
"KRN",8994,3551,0)
HMP CHKXTMP^CHKXTMP^HMPMONX^2^S
"KRN",8994,3551,1,0)
^^4^4^3160328^
"KRN",8994,3551,1,1,0)
Remote procedure HMP CHKXTMP returns the status of the eHMP entries in
"KRN",8994,3551,1,2,0)
^XTMP (complete, staging).
"KRN",8994,3551,1,3,0)
 
"KRN",8994,3551,1,4,0)
It takes no input parameters.
"KRN",8994,3551,3,0)
^^6^6^3160328^
"KRN",8994,3551,3,1,0)
It returns an array consisting only of a single array entry, result(1),
"KRN",8994,3551,3,2,0)
which equals a string like:
"KRN",8994,3551,3,3,0)
 
"KRN",8994,3551,3,4,0)
"There are a total of xxx patients in queue.  yyy Complete  zzz Staging",
"KRN",8994,3551,3,5,0)
where xxx,yyy, and zzz are zero or greater. If xxx is zero, the sentence
"KRN",8994,3551,3,6,0)
after "queue." will not be displayed.
"KRN",8994,3552,-1)
0^3
"KRN",8994,3552,0)
HMP GLOBAL SIZE^SIZE^HMPMONX^2^S
"KRN",8994,3552,1,0)
^^2^2^3160330^
"KRN",8994,3552,1,1,0)
Remote procedure HMP GLOBAL SIZE takes no input parameters; it returns 
"KRN",8994,3552,1,2,0)
the size of eHMP's current usage of the ^XTMP global.
"KRN",8994,3552,3,0)
^^2^2^3160330^
"KRN",8994,3552,3,1,0)
result(1) = a single number, the kilobytes of storage in ^XTMP that eHMP 
"KRN",8994,3552,3,2,0)
is responsible for.
"KRN",8994,3762,-1)
0^11
"KRN",8994,3762,0)
HMP SAVE NOTE STUB^STUB^HMPTIU^4^^^^0
"KRN",8994,3762,1,0)
^^1^1^3150626^
"KRN",8994,3762,1,1,0)
 Saves a note stub with minimal info
"KRN",8994,3762,2,0)
^8994.02A^1^1
"KRN",8994,3762,2,1,0)
DATA^2^255^1^1
"KRN",8994,3762,2,1,1,0)
^^5^5^3150629^
"KRN",8994,3762,2,1,1,1,0)
Array containing note information in the "data" subscript and note text in the "text" subscript
"KRN",8994,3762,2,1,1,2,0)
as such:
"KRN",8994,3762,2,1,1,3,0)
DATA("data")=Patient IEN^Document Type^Visit/episode date^Hospital location^Visit IEN^
"KRN",8994,3762,2,1,1,4,0)
             author/dictator^Reference date^Subject^Visit string(format: location;date;service category)
"KRN",8994,3762,2,1,1,5,0)
DATA("text",n)=The nth line of text of the note (free text)
"KRN",8994,3762,2,"B","DATA",1)

"KRN",8994,3762,2,"PARAMSEQ",1,1)

"KRN",8994,3762,3,0)
^^1^1^3150629^
"KRN",8994,3762,3,1,0)
Note IEN or a message indicating why the note was NOT created
"KRN",8994,3763,-1)
0^16
"KRN",8994,3763,0)
HMP SUBSCRIPTION STATUS^SUBSTA^HMPTOOLS^2^S^^^1^1^^1
"KRN",8994,3763,1,0)
^8994.01^2^2^3150708^^^^
"KRN",8994,3763,1,1,0)
This RPC checks the subscription status for a single patient and returns.
"KRN",8994,3763,1,2,0)
the result as a JSON containing code and text values.
"KRN",8994,3763,2,0)
^8994.02A^1^1
"KRN",8994,3763,2,1,0)
ARGS^1^^1^1
"KRN",8994,3763,2,1,1,0)
^8994.021^3^3^3150708^^^^
"KRN",8994,3763,2,1,1,1,0)
The input array should contain:
"KRN",8994,3763,2,1,1,2,0)
   'localId' = Patient identifier (Patient IEN)
"KRN",8994,3763,2,1,1,3,0)
   'server' = Server name (e.g. hmp-development-sever)
"KRN",8994,3763,2,"B","ARGS",1)

"KRN",8994,3763,2,"PARAMSEQ",1,1)

"KRN",8994,3763,3,0)
^8994.03^13^13^3150708^^^^
"KRN",8994,3763,3,1,0)
Text formatted as JSON including 'code' and 'text'
"KRN",8994,3763,3,2,0)
 
"KRN",8994,3763,3,3,0)
    0 = 'Subscription not found'
"KRN",8994,3763,3,4,0)
    1 = 'Subscription received - staging not started'
"KRN",8994,3763,3,5,0)
    2 = 'Subscription received - staging in progress'
"KRN",8994,3763,3,6,0)
    3 = 'Subscription received - staging in progress - paused by throttle for XXX seconds'
"KRN",8994,3763,3,7,0)
    4 = 'Subscription complete - staged data not completely sent'
"KRN",8994,3763,3,8,0)
    5 = 'Subscription complete - staged data already sent'
"KRN",8994,3763,3,9,0)
 
"KRN",8994,3763,3,10,0)
    90 = 'Error: server not specified'
"KRN",8994,3763,3,11,0)
    91 = 'Error: server '_HMPFRSP_" not found"
"KRN",8994,3763,3,12,0)
    92 = 'Error: patient ien not specified'
"KRN",8994,3763,3,13,0)
    93 = 'Error: patient ien not present on this system'
"KRN",8994,3764,-1)
0^12
"KRN",8994,3764,0)
HMP MED ORDER CHECKS^ORCHECK^HMPWBM1^4^^^^1^1
"KRN",8994,3764,1,0)
^8994.01^4^4^3150625^^
"KRN",8994,3764,1,1,0)
This RPC wraps the broker calls for both ORWDXC ACCEPT and ORCHECK 
"KRN",8994,3764,1,2,0)
GETXTRA into a single call.  It will use the same inputs as the ORWDXC 
"KRN",8994,3764,1,3,0)
ACCEPT RPC; but will combine the outputs from both broker calls into a 
"KRN",8994,3764,1,4,0)
single return.
"KRN",8994,3764,2,0)
^8994.02A^7^7
"KRN",8994,3764,2,1,0)
DFN^1^30^1^1
"KRN",8994,3764,2,1,1,0)
^^1^1^3150625^
"KRN",8994,3764,2,1,1,1,0)
Patient IEN found in the PATIENT FILE (#2)
"KRN",8994,3764,2,2,0)
FID^1^20^1^2
"KRN",8994,3764,2,2,1,0)
^^2^2^3150625^
"KRN",8994,3764,2,2,1,1,0)
FILLER ID, aka namespace.  Acquired by passing the selected 
"KRN",8994,3764,2,2,1,2,0)
orderDialogIen from the ORWDX WRLST RPC output to the ORWDXC FILLID RPC.
"KRN",8994,3764,2,3,0)
STRT^1^30^^3
"KRN",8994,3764,2,3,1,0)
^^2^2^3150625^
"KRN",8994,3764,2,3,1,1,0)
Desired date in Mmm DD,YYYY@HH:SS format  (Does not apply to pharmacy 
"KRN",8994,3764,2,3,1,2,0)
orders)
"KRN",8994,3764,2,4,0)
ORL^1^20^1^4
"KRN",8994,3764,2,4,1,0)
^^1^1^3150625^
"KRN",8994,3764,2,4,1,1,0)
Ordering Location (locationIen from the Visit)
"KRN",8994,3764,2,5,0)
OIL^4^256^1^5
"KRN",8994,3764,2,5,1,0)
^^4^4^3150625^
"KRN",8994,3764,2,5,1,1,0)
An ordered list (array) of orderable items for Radiology, Lab, Pharmacy, 
"KRN",8994,3764,2,5,1,2,0)
etc.  Note:  Pharmacy orders contains orderable items + package 
"KRN",8994,3764,2,5,1,3,0)
information (inpatient, infusion, non-VA, and outpatient medication 
"KRN",8994,3764,2,5,1,4,0)
orders) as appropriate.
"KRN",8994,3764,2,6,0)
ORIFN^1^30^^6
"KRN",8994,3764,2,6,1,0)
^^3^3^3150625^
"KRN",8994,3764,2,6,1,1,0)
This is only available and required for existing orders that are being
"KRN",8994,3764,2,6,1,2,0)
copied, changed, or renewed.  New orders do not have an orderIen until
"KRN",8994,3764,2,6,1,3,0)
they are saved.
"KRN",8994,3764,2,7,0)
ORREN^1^1^^7
"KRN",8994,3764,2,7,1,0)
^^2^2^3150625^
"KRN",8994,3764,2,7,1,1,0)
Is the order being renewed.  Input is a boolean 1 or 0
"KRN",8994,3764,2,7,1,2,0)
The ORIFN is required if ORREN is set to 1.
"KRN",8994,3764,2,"B","DFN",1)

"KRN",8994,3764,2,"B","FID",2)

"KRN",8994,3764,2,"B","OIL",5)

"KRN",8994,3764,2,"B","ORIFN",6)

"KRN",8994,3764,2,"B","ORL",4)

"KRN",8994,3764,2,"B","ORREN",7)

"KRN",8994,3764,2,"B","STRT",3)

"KRN",8994,3764,2,"PARAMSEQ",1,1)

"KRN",8994,3764,2,"PARAMSEQ",2,2)

"KRN",8994,3764,2,"PARAMSEQ",3,3)

"KRN",8994,3764,2,"PARAMSEQ",4,4)

"KRN",8994,3764,2,"PARAMSEQ",5,5)

"KRN",8994,3764,2,"PARAMSEQ",6,6)

"KRN",8994,3764,2,"PARAMSEQ",7,7)

"KRN",8994,3764,3,0)
^^14^14^3150625^
"KRN",8994,3764,3,1,0)
orderIen^orderCheckIen^CDL^message
"KRN",8994,3764,3,2,0)
    orderIen = NEW for new orders.
"KRN",8994,3764,3,3,0)
    CDL = Clinic Danger Level.  If CDL = 1, an override comment will be
"KRN",8994,3764,3,4,0)
required during processing order checks during the signing process.
"KRN",8994,3764,3,5,0)
 
"KRN",8994,3764,3,6,0)
Each order check returned will be evaluated for extra lines:
"KRN",8994,3764,3,7,0)
 
"KRN",8994,3764,3,8,0)
    Example:  NEW^25^2^||63679,54957,NEW&These checks could not be
"KRN",8994,3764,3,9,0)
completed for this patient:
"KRN",8994,3764,3,10,0)
      Note:  An order check that is returned with the double pipe (||) as 
"KRN",8994,3764,3,11,0)
noted above is the indication that this RPC needs to be run.
"KRN",8994,3764,3,12,0)
 
"KRN",8994,3764,3,13,0)
Final output may contain a mix of order checks with and without extra 
"KRN",8994,3764,3,14,0)
lines.
"KRN",8994,3765,-1)
0^2
"KRN",8994,3765,0)
HMP GET RELATED ORDERS^RELATED^HMPORRPC^2
"KRN",8994,3765,1,0)
^^2^2^3151221^
"KRN",8994,3765,1,1,0)
Returns the parent, children, and/or siblings (orders that share the same parent) of an order from the ORDER (#100)
"KRN",8994,3765,1,2,0)
FILE in JSON format.
"KRN",8994,3765,2,0)
^8994.02A^1^1
"KRN",8994,3765,2,1,0)
ORDER IEN^1^30^1^1
"KRN",8994,3765,2,1,1,0)
^^1^1^3151221^
"KRN",8994,3765,2,1,1,1,0)
IEN to the ORDER (#100) file, indicates which order from which to draw related orders.
"KRN",8994,3765,2,"B","ORDER IEN",1)

"KRN",8994,3765,2,"PARAMSEQ",1,1)

"KRN",8994,3765,3,0)
^^21^21^3151221^
"KRN",8994,3765,3,1,0)
Returns a JSON message containing an IEN for "parent," a list of IENS for "children," and/or a list of IENs for "siblings",
"KRN",8994,3765,3,2,0)
depending on which fields are applicable to an order (i.e., an order with no parent will not have a "parent" value). If an error
"KRN",8994,3765,3,3,0)
is returned, it will be in the "error" field.
"KRN",8994,3765,3,4,0)
{
"KRN",8994,3765,3,5,0)
|TAB|"parent": 7282.1,
"KRN",8994,3765,3,6,0)
|TAB|"siblings": [7283.1, 7284.1, 7285.1, 7286.1, 7287.1, 7288.1, 7289.1, 72
"KRN",8994,3765,3,7,0)
|TAB||TAB|90.1, 7291.1, 7292.1, 7293.1, 7294.1, 7295.1, 7296.1, 7297.1, 7298.1, 7299.1, 7300.1, 7301.
"KRN",8994,3765,3,8,0)
|TAB||TAB|1, 7302.1, 7303.1, 7304.1, 7305.1, 7306.1, 7307.1
"KRN",8994,3765,3,9,0)
|TAB|]
"KRN",8994,3765,3,10,0)
}
"KRN",8994,3765,3,11,0)
or
"KRN",8994,3765,3,12,0)
{
"KRN",8994,3765,3,13,0)
|TAB|"children": [
"KRN",8994,3765,3,14,0)
|TAB|  7283.1, 7284.1, 7285.1, 7286.1, 7287.1, 7288.1, 7289.1, 7290.1, 7291.1, 7292.1, 7293.1, 7294.1, 7295.1, 7296.1, 7297.1,
"KRN",8994,3765,3,15,0)
|TAB|  7298.1, 7299.1, 7300.1, 7301.1, 7302.1, 7303.1, 7304.1, 7305.1, 7306.1, 7307.1
"KRN",8994,3765,3,16,0)
|TAB|]
"KRN",8994,3765,3,17,0)
}
"KRN",8994,3765,3,18,0)
or
"KRN",8994,3765,3,19,0)
{
"KRN",8994,3765,3,20,0)
|TAB|"error": "order not found"
"KRN",8994,3765,3,21,0)
}
"KRN",8994,3766,-1)
0^7
"KRN",8994,3766,0)
HMP WRITEBACK VITAL^VMADD^HMPWB2^4^S^^^0^^^1
"KRN",8994,3766,1,0)
^8994.01^1^1^3150903^^^^
"KRN",8994,3766,1,1,0)
This RPC accepts writeback data from JDS and returns a JSON formatted acknowledgement message. 
"KRN",8994,3766,2,0)
^8994.02A^3^3
"KRN",8994,3766,2,1,0)
IEN^1^^1^1
"KRN",8994,3766,2,2,0)
DFN^1^^1^2
"KRN",8994,3766,2,3,0)
DATA^1^^1^3
"KRN",8994,3766,2,"B","DATA",3)

"KRN",8994,3766,2,"B","DFN",2)

"KRN",8994,3766,2,"B","IEN",1)

"KRN",8994,3766,2,"PARAMSEQ",1,1)

"KRN",8994,3766,2,"PARAMSEQ",2,2)

"KRN",8994,3766,2,"PARAMSEQ",3,3)

"KRN",8994,3767,-1)
0^8
"KRN",8994,3767,0)
HMP WRITEBACK VITAL EIE^VMERR^HMPWB2^4^^^^0
"KRN",8994,3767,2,0)
^8994.02A^1^1
"KRN",8994,3767,2,1,0)
DATA^1^^^1
"KRN",8994,3767,2,"B","DATA",1)

"KRN",8994,3767,2,"PARAMSEQ",1,1)

"KRN",8994,3768,-1)
0^13
"KRN",8994,3768,0)
HMP WRITEBACK ENCOUNTERS^ENC^HMPWB5^4^^^^0
"KRN",8994,3769,-1)
0^4
"KRN",8994,3769,0)
HMP WRITEBACK ALLERGY^ALLERGY^HMPWB1^4^^^^0
"KRN",8994,3769,2,0)
^8994.02A^3^3
"KRN",8994,3769,2,1,0)
IEN^1^^^1
"KRN",8994,3769,2,2,0)
DFN^1^^^2
"KRN",8994,3769,2,3,0)
DATA^2^^^3
"KRN",8994,3769,2,"B","DATA",3)

"KRN",8994,3769,2,"B","DFN",2)

"KRN",8994,3769,2,"B","IEN",1)

"KRN",8994,3769,2,"PARAMSEQ",1,1)

"KRN",8994,3769,2,"PARAMSEQ",2,2)

"KRN",8994,3769,2,"PARAMSEQ",3,3)

"KRN",8994,3770,-1)
0^5
"KRN",8994,3770,0)
HMP WRITEBACK ALLERGY EIE^ALLEIE^HMPWB1^4^^^^0
"KRN",8994,3770,2,0)
^8994.02A^1^1
"KRN",8994,3770,2,1,0)
DATA^1^^^1
"KRN",8994,3770,2,"B","DATA",1)

"KRN",8994,3770,2,"PARAMSEQ",1,1)

"KRN",8994,3771,-1)
0^14
"KRN",8994,3771,0)
HMP DELETE TIU NOTE^DELETE^HMPTIU^1^^^^0
"KRN",8994,3771,2,0)
^8994.02A^2^2
"KRN",8994,3771,2,1,0)
IEN^1^255^1^1
"KRN",8994,3771,2,2,0)
RSN^1^255^0^2
"KRN",8994,3771,2,"B","IEN",1)

"KRN",8994,3771,2,"B","RSN",2)

"KRN",8994,3771,2,"PARAMSEQ",1,1)

"KRN",8994,3771,2,"PARAMSEQ",2,2)

"KRN",8994,3772,-1)
0^6
"KRN",8994,3772,0)
HMP WRITEBACK SIGN ORDERS^SIGN^HMPWBSO^2^^^^1
"KRN",8994,3772,2,0)
^8994.02A^5^5
"KRN",8994,3772,2,1,0)
DFN^1^^1^1
"KRN",8994,3772,2,2,0)
ORNP^1^^1^2
"KRN",8994,3772,2,3,0)
ORL^1^^1^3
"KRN",8994,3772,2,4,0)
ES ^1^^1^4
"KRN",8994,3772,2,5,0)
DATA^2^^1^5
"KRN",8994,3772,2,"B","DATA",5)

"KRN",8994,3772,2,"B","DFN",1)

"KRN",8994,3772,2,"B","ES ",4)

"KRN",8994,3772,2,"B","ORL",3)

"KRN",8994,3772,2,"B","ORNP",2)

"KRN",8994,3772,2,"PARAMSEQ",1,1)

"KRN",8994,3772,2,"PARAMSEQ",2,2)

"KRN",8994,3772,2,"PARAMSEQ",3,3)

"KRN",8994,3772,2,"PARAMSEQ",4,4)

"KRN",8994,3772,2,"PARAMSEQ",5,5)

"KRN",8994,3773,-1)
0^15
"KRN",8994,3773,0)
HMP TIU LONG LIST OF TITLES^LONGLIST^HMPTIUL^2
"KRN",8994,3773,1,0)
^8994.01^1^1^3151211^^^
"KRN",8994,3773,1,1,0)
HMP TIU LONG LIST OF NOTE TITLES
"KRN",8994,3775,-1)
1^9
"KRN",8994,3775,0)
HMP LOCAL GETCORRESPONDINGIDS
"MBREQ")
0
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"ORD",20,8989.51)
8989.51;20;;;PAR1E1^XPDTA2;PAR1F1^XPDIA3;PAR1E1^XPDIA3;PAR1F2^XPDIA3;;PAR1DEL^XPDIA3(%)
"ORD",20,8989.51,0)
PARAMETER DEFINITION
"ORD",21,8989.52)
8989.52;21;1;;PAR2E1^XPDTA2;PAR2F1^XPDIA3;PAR2E1^XPDIA3;PAR2F2^XPDIA3;;PAR2DEL^XPDIA3(%)
"ORD",21,8989.52,0)
PARAMETER TEMPLATE
"PKG",578,-1)
1^1
"PKG",578,0)
HEALTH MANAGEMENT PLATFORM^HMP^Access patient medical records from all VistA's
"PKG",578,20,0)
^9.402P^^
"PKG",578,22,0)
^9.49I^1^1
"PKG",578,22,1,0)
2.0^3160223^3160825^1
"PKG",578,22,1,"PAH",1,0)
2^3160826^1
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
73
"RTN","HMPCRPC")
0^1^B13274810
"RTN","HMPCRPC",1,0)
HMPCRPC ;SLC/AGP,ASMR/RRB - Generic RPC controller for HMP;11/7/12 5:42pm
"RTN","HMPCRPC",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPCRPC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPCRPC",4,0)
 ;
"RTN","HMPCRPC",5,0)
 Q
"RTN","HMPCRPC",6,0)
 ;
"RTN","HMPCRPC",7,0)
CHAINRPC(HMPRES,PARAMS) ; Chain multiple rpcs into one call
"RTN","HMPCRPC",8,0)
 N CITER,RSP,PID
"RTN","HMPCRPC",9,0)
 S CITER="" F  S CITER=$O(PARAMS("commandList",CITER)) Q:CITER=""  D
"RTN","HMPCRPC",10,0)
 . N SUBCMD,SUBRSP,X
"RTN","HMPCRPC",11,0)
 . S X=""
"RTN","HMPCRPC",12,0)
 . F  S X=$O(PARAMS("commandList",CITER,X)) Q:X=""  M SUBCMD(X)=PARAMS("commandList",CITER,X)
"RTN","HMPCRPC",13,0)
 . D CHAINCMD(.SUBCMD,.SUBRSP)
"RTN","HMPCRPC",14,0)
 . I $D(SUBRSP) D DECODE^HMPJSON("SUBRSP","RSP(SUBCMD(""command""))","^JMCERR") I 1
"RTN","HMPCRPC",15,0)
 . I '$TEST S RSP(SUBCMD("command"))=""
"RTN","HMPCRPC",16,0)
 D ENCODE^HMPJSON("RSP","HMPRES","^JMCERR")
"RTN","HMPCRPC",17,0)
 Q
"RTN","HMPCRPC",18,0)
RPC(HMPRES,PARAMS) ; Process request via RPC instead of CSP
"RTN","HMPCRPC",19,0)
 N X,REQ,HMPVAL,HMPCNT,HMPSITE,HMPUSER,HMPDBUG,HMPSTA
"RTN","HMPCRPC",20,0)
 ;S HMPXML=$NA(^TMP($J,"HMP RESULTS")) K @HMPXML
"RTN","HMPCRPC",21,0)
 S HMPCNT=0
"RTN","HMPCRPC",22,0)
 ;S HMPUSER=DUZ,HMPSITE=DUZ(2),HMPSTA=$$STA^XUAF4(DUZ(2))
"RTN","HMPCRPC",23,0)
 S X="" F  S X=$O(PARAMS(X)) Q:X=""  I X'="value" S REQ(X,1)=PARAMS(X)
"RTN","HMPCRPC",24,0)
 I $D(PARAMS("value")) M HMPVAL=PARAMS("value")
"RTN","HMPCRPC",25,0)
 ;
"RTN","HMPCRPC",26,0)
COMMON ; Come here for both CSP and RPC Mode
"RTN","HMPCRPC",27,0)
 ; 
"RTN","HMPCRPC",28,0)
 N CMD
"RTN","HMPCRPC",29,0)
 S CMD=$G(REQ("command",1))
"RTN","HMPCRPC",30,0)
 ;
"RTN","HMPCRPC",31,0)
 I CMD="saveParam" D  G OUT
"RTN","HMPCRPC",32,0)
 . D PUTPARAM^HMPPARAM(.HMPRES,.HMPVAL,"")
"RTN","HMPCRPC",33,0)
 ;
"RTN","HMPCRPC",34,0)
 I CMD="saveParamByUid" D  G OUT
"RTN","HMPCRPC",35,0)
 . D PUTBYUID^HMPPARAM(.HMPRES,$$VAL("uid"),.HMPVAL)
"RTN","HMPCRPC",36,0)
 ;
"RTN","HMPCRPC",37,0)
 I CMD="getParam" D  G OUT
"RTN","HMPCRPC",38,0)
 . D GETBYUID^HMPPARAM(.HMPRES,$$VAL("uid"))
"RTN","HMPCRPC",39,0)
 ;
"RTN","HMPCRPC",40,0)
 I CMD="clearParam" D  G OUT
"RTN","HMPCRPC",41,0)
 . D DELPARAM^HMPPARAM(.HMPRES,$$VAL("uid"))
"RTN","HMPCRPC",42,0)
 ;
"RTN","HMPCRPC",43,0)
 I CMD="getAllParam" D  G OUT
"RTN","HMPCRPC",44,0)
 .D GETALPAR^HMPPARAM(.HMPRES,$$VAL("entity"),$$VAL("entityId"),$$VAL("getValues"))
"RTN","HMPCRPC",45,0)
 ;
"RTN","HMPCRPC",46,0)
 I CMD="getUserInfo" D  G OUT
"RTN","HMPCRPC",47,0)
 .D GETUSERI^HMPCRPC1(.HMPRES,$$VAL("userId"))
"RTN","HMPCRPC",48,0)
 ;
"RTN","HMPCRPC",49,0)
 I CMD="getPatientInfo" D  G OUT
"RTN","HMPCRPC",50,0)
 .D GETPATI^HMPCRPC1(.HMPRES,$$VAL("patientId"))
"RTN","HMPCRPC",51,0)
 ;
"RTN","HMPCRPC",52,0)
 I CMD="getPatientChecks" D  G OUT
"RTN","HMPCRPC",53,0)
 .D CHKS^HMPFPTC(.HMPRES,$$VAL("patientId"))
"RTN","HMPCRPC",54,0)
 ;
"RTN","HMPCRPC",55,0)
 I CMD="logPatientAccess" D  G OUT
"RTN","HMPCRPC",56,0)
 .D LOG^HMPFPTC(.HMPRES,$$VAL("patientId"))
"RTN","HMPCRPC",57,0)
 ;
"RTN","HMPCRPC",58,0)
 I CMD="addTask" D  G OUT
"RTN","HMPCRPC",59,0)
 .D PUT^HMPDJ1(.HMPRES,$$VAL("patientId"),$$VAL("type"),.HMPVAL)
"RTN","HMPCRPC",60,0)
 ;
"RTN","HMPCRPC",61,0)
 I CMD="getReminderList" D  G OUT
"RTN","HMPCRPC",62,0)
 .D REMLIST^HMPPXRM(.HMPRES,$$VAL("user"),$$VAL("location"))
"RTN","HMPCRPC",63,0)
 ;
"RTN","HMPCRPC",64,0)
 I CMD="evaluateReminder" D  G OUT
"RTN","HMPCRPC",65,0)
 .D EVALREM^HMPPXRM(.HMPRES,$$VAL("patientId"),$$VAL("uid"))
"RTN","HMPCRPC",66,0)
 ;
"RTN","HMPCRPC",67,0)
 I CMD="getDefaultPatientList" D  G OUT
"RTN","HMPCRPC",68,0)
 .D GETDLIST^HMPROS8(.HMPRES,$$VAL("server"))
"RTN","HMPCRPC",69,0)
 ;
"RTN","HMPCRPC",70,0)
 I CMD="getWardList" D  G OUT
"RTN","HMPCRPC",71,0)
 .D GETWLIST^HMPROS8(.HMPRES,$$VAL("server"),$$VAL("id"))
"RTN","HMPCRPC",72,0)
 ;
"RTN","HMPCRPC",73,0)
 I CMD="getClinicList" D  G OUT
"RTN","HMPCRPC",74,0)
 .D GETCLIST^HMPROS8(.HMPRES,$$VAL("server"),$$VAL("id"),$$VAL("start"),$$VAL("end"))
"RTN","HMPCRPC",75,0)
 ;
"RTN","HMPCRPC",76,0)
OUT ; output the XML
"RTN","HMPCRPC",77,0)
 ;S HMPRES=$G(RESULT)
"RTN","HMPCRPC",78,0)
 I '$D(HMPRES) S HMPRES="{}"
"RTN","HMPCRPC",79,0)
END Q
"RTN","HMPCRPC",80,0)
 ;
"RTN","HMPCRPC",81,0)
VAL(X) ; return value from request
"RTN","HMPCRPC",82,0)
 Q $G(REQ(X,1))
"RTN","HMPCRPC",83,0)
 ;
"RTN","HMPCRPC",84,0)
CHAINCMD(HMPCMD,HMPRSP) ; Do one command in chain
"RTN","HMPCRPC",85,0)
 ; 
"RTN","HMPCRPC",86,0)
 N CMD
"RTN","HMPCRPC",87,0)
 S CMD=$G(HMPCMD("command"))
"RTN","HMPCRPC",88,0)
 I CMD="getParam" D GETBYUID^HMPPARAM(.HMPRSP,$G(HMPCMD("uid")))
"RTN","HMPCRPC",89,0)
 I CMD="getPatientInfo" D GETPATI^HMPCRPC1(.HMPRSP,$G(HMPCMD("patientId")))
"RTN","HMPCRPC",90,0)
 I CMD="getPatientChecks" D CHKS^HMPFPTC(.HMPRSP,$G(HMPCMD("patientId")))
"RTN","HMPCRPC",91,0)
 I CMD="saveParam" D PUTPARAM^HMPPARAM(.HMPRSP,$G(HMPCMD("value")),"")
"RTN","HMPCRPC",92,0)
 I CMD="saveParamByUid" D PUTBYUID^HMPPARAM(.HMPRSP,$G(HMPCMD("uid")),$G(HMPCMD("value")))
"RTN","HMPCRPC",93,0)
 Q
"RTN","HMPDJ")
0^2^B36566294
"RTN","HMPDJ",1,0)
HMPDJ ;SLC/MKB,ASMR/RRB,CK -- Serve VistA data as JSON via RPC;Jun 22, 2016 17:23:52
"RTN","HMPDJ",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPDJ",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ",4,0)
 ;
"RTN","HMPDJ",5,0)
 ; External References          DBIA#
"RTN","HMPDJ",6,0)
 ; -------------------          -----
"RTN","HMPDJ",7,0)
 ; ^DPT                         10035
"RTN","HMPDJ",8,0)
 ; MPIF001                       2701
"RTN","HMPDJ",9,0)
 ; XLFDT                        10103
"RTN","HMPDJ",10,0)
 ; XLFSTR                       10104
"RTN","HMPDJ",11,0)
 ; XUPARAM                       2541
"RTN","HMPDJ",12,0)
 ;
"RTN","HMPDJ",13,0)
 ; DE2818/RRB - SQA findings 1st 3 lines of code.
"RTN","HMPDJ",14,0)
 ;
"RTN","HMPDJ",15,0)
 Q
"RTN","HMPDJ",16,0)
 ;
"RTN","HMPDJ",17,0)
GET(HMP,FILTER) ; -- Return search results as JSON in @HMP@(n)
"RTN","HMPDJ",18,0)
 ; RPC = HMP GET PATIENT DATA JSON
"RTN","HMPDJ",19,0)
 ; where FILTER("patientId") = DFN or DFN;ICN
"RTN","HMPDJ",20,0)
 ;       FILTER("domain")    = name of desired data type  (see HMPDJ0)
"RTN","HMPDJ",21,0)
 ;       FILTER("text")      = boolean, to include document text [opt]
"RTN","HMPDJ",22,0)
 ;       FILTER("start")     = start date.time of search         [opt]
"RTN","HMPDJ",23,0)
 ;       FILTER("stop")      = stop date.time of search          [opt]
"RTN","HMPDJ",24,0)
 ;       FILTER("max")       = maximum number of items to return [opt]
"RTN","HMPDJ",25,0)
 ;       FILTER("id")        = single item id to return          [opt]
"RTN","HMPDJ",26,0)
 ;       FILTER("uid")       = single record uid to return       [opt]
"RTN","HMPDJ",27,0)
 ;       FILTER("noHead")    = flag, to omit header and commas   [opt]
"RTN","HMPDJ",28,0)
 ;
"RTN","HMPDJ",29,0)
 N ICN,DFN,HMPI,HMPSYS,HMPTYPE,HMPSTART,HMPSTOP,HMPMAX,HMPID,HMPTEXT,HMPP,TYPE,HMPTN,HMPERR
"RTN","HMPDJ",30,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPDJ",31,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJ",32,0)
 S DT=$$DT^XLFDT             ;for crossing midnight boundary
"RTN","HMPDJ",33,0)
 ;
"RTN","HMPDJ",34,0)
 ; parse & validate input parameters
"RTN","HMPDJ",35,0)
 I $G(FILTER("uid"))'="" D SEPUID(.FILTER)
"RTN","HMPDJ",36,0)
 ;
"RTN","HMPDJ",37,0)
 S DFN=$G(FILTER("patientId"))
"RTN","HMPDJ",38,0)
 ;
"RTN","HMPDJ",39,0)
 S ICN=+$P($G(DFN),";",2),DFN=+$G(DFN)
"RTN","HMPDJ",40,0)
 I DFN<1,ICN S DFN=+$$GETDFN^MPIF001(ICN)
"RTN","HMPDJ",41,0)
 ;
"RTN","HMPDJ",42,0)
 S HMPTYPE=$G(FILTER("domain")) S:HMPTYPE="" HMPTYPE=$$ALL
"RTN","HMPDJ",43,0)
 I $D(ZTQUEUED) S HMP=$NA(^XTMP(HMPBATCH,HMPFZTSK,HMPTYPE)) K @HMP
"RTN","HMPDJ",44,0)
 I HMPTYPE'="new",DFN<1!'$D(^DPT(DFN)) S HMPERR=$$ERR(1,DFN) G GTQ ;ICR 10035 DE2818 ASF 11/2/15
"RTN","HMPDJ",45,0)
 ;
"RTN","HMPDJ",46,0)
 ; -- initialize chunking if from DOMPT^HMPDJFSP ; i.e. HMPCHNK defined *S68-JCH*
"RTN","HMPDJ",47,0)
 D CHNKINIT^HMPDJFSP(.HMP,.HMPI) ; *S68-JCH*
"RTN","HMPDJ",48,0)
 ;
"RTN","HMPDJ",49,0)
 S HMPSTART=+$G(FILTER("start"),1410102)
"RTN","HMPDJ",50,0)
 S HMPSTOP=+$G(FILTER("stop"),4141015)
"RTN","HMPDJ",51,0)
 S HMPMAX=+$G(FILTER("max"),999999)
"RTN","HMPDJ",52,0)
 I HMPSTART,HMPSTOP,HMPSTOP<HMPSTART D
"RTN","HMPDJ",53,0)
 . N X S X=HMPSTART,HMPSTART=HMPSTOP,HMPSTOP=X
"RTN","HMPDJ",54,0)
 I HMPSTOP,$L(HMPSTOP,".")<2 S HMPSTOP=HMPSTOP_".24"
"RTN","HMPDJ",55,0)
 ;
"RTN","HMPDJ",56,0)
 S HMPID=$G(FILTER("id"))
"RTN","HMPDJ",57,0)
 S HMPTEXT=+$G(FILTER("text"),1) ;default = true/text
"RTN","HMPDJ",58,0)
 ;
"RTN","HMPDJ",59,0)
 ;set error trap
"RTN","HMPDJ",60,0)
 K ^TMP($J,"HMP ERROR")
"RTN","HMPDJ",61,0)
 ;
"RTN","HMPDJ",62,0)
 ; extract data
"RTN","HMPDJ",63,0)
 I HMPTYPE="new",$L($T(EN^HMPDJX)),'$G(^XTMP("HMP-off","GET")) D EN^HMPDJX(HMPID,HMPMAX) Q  ;data updates
"RTN","HMPDJ",64,0)
 F HMPP=1:1:$L(HMPTYPE,";") S TYPE=$P(HMPTYPE,";",HMPP) I $L(TYPE) D
"RTN","HMPDJ",65,0)
 . S HMPTN=$$TAG(TYPE)_"^HMPDJ0" Q:'$L($T(@HMPTN))  ;D ERR(2) Q
"RTN","HMPDJ",66,0)
 . N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ",67,0)
 . S $ET="D ERRHDLR^HMPDERRH",ERRMSG="A problem occurred when trying to load patient data from an API."
"RTN","HMPDJ",68,0)
 . D @HMPTN
"RTN","HMPDJ",69,0)
 ;
"RTN","HMPDJ",70,0)
GTQ ; add item count and terminating characters
"RTN","HMPDJ",71,0)
 N ERROR I $D(^TMP($J,"HMP ERROR"))>0 D BUILDERR(.ERROR)
"RTN","HMPDJ",72,0)
 I +$G(FILTER("noHead"))=1 D  Q
"RTN","HMPDJ",73,0)
 .S @HMP@("total")=+$G(HMPI)
"RTN","HMPDJ",74,0)
 .I $L($G(ERROR(1)))>1 S @HMP@("error")=ERROR(1)
"RTN","HMPDJ",75,0)
 S @HMP@(.5)="{""apiVersion"":""1.01"",""params"":{"_$$SYS_"},"
"RTN","HMPDJ",76,0)
 I $D(HMPERR) S @HMP@(1)="""error"":{""message"":"""_HMPERR_"""}}" Q
"RTN","HMPDJ",77,0)
 I '$D(@HMP)!'$G(HMPI) D  Q
"RTN","HMPDJ",78,0)
 . I '$D(ERROR) S @HMP@(1)="""data"":{""totalItems"":0,""items"":[]}}" Q
"RTN","HMPDJ",79,0)
 . S @HMP@(1)="""data"":{""totalItems"":0,""items"":[]},"
"RTN","HMPDJ",80,0)
 . S @HMP@(2,1)=ERROR(1)_"}"
"RTN","HMPDJ",81,0)
 ;
"RTN","HMPDJ",82,0)
 S @HMP@(.6)="""data"":{""updated"":"""_$$HL7NOW_""",""totalItems"":"_HMPI_",""items"":["
"RTN","HMPDJ",83,0)
 S HMPI=HMPI+1,@HMP@(HMPI)=$S($D(ERROR):"]}",1:"]}}")
"RTN","HMPDJ",84,0)
 I $D(ERROR)>0 S HMPI=HMPI+1,@HMP@(HMPI,.3)=",",@HMP@(HMPI,1)=ERROR(1)_"}"
"RTN","HMPDJ",85,0)
 K ^TMP($J,"HMP ERROR"),^TMP("HMPTEXT",$J)
"RTN","HMPDJ",86,0)
 Q
"RTN","HMPDJ",87,0)
 ;
"RTN","HMPDJ",88,0)
SEPUID(FILTER) ; -- separate uid into FILTER pieces
"RTN","HMPDJ",89,0)
 N UID
"RTN","HMPDJ",90,0)
 S UID=$G(FILTER("uid")) K FILTER("uid") Q:UID=""
"RTN","HMPDJ",91,0)
 I $P(UID,":",4)'=HMPSYS Q
"RTN","HMPDJ",92,0)
 S FILTER("patientId")=$P(UID,":",5)
"RTN","HMPDJ",93,0)
 S FILTER("domain")=$P(UID,":",3)
"RTN","HMPDJ",94,0)
 S FILTER("id")=$P(UID,":",6)
"RTN","HMPDJ",95,0)
 Q
"RTN","HMPDJ",96,0)
 ;
"RTN","HMPDJ",97,0)
SYS() ; -- return system info for JSON header
"RTN","HMPDJ",98,0)
 Q """domain"":"""_$$KSP^XUPARAM("WHERE")_""",""systemId"":"""_HMPSYS_""""
"RTN","HMPDJ",99,0)
 ;
"RTN","HMPDJ",100,0)
BUILDERR(RESULT,DFN) ; -- build error array
"RTN","HMPDJ",101,0)
 N COUNT,MESSAGE,MSGCNT
"RTN","HMPDJ",102,0)
 S COUNT=$G(^TMP($J,"HMP ERROR","# of Errors"))
"RTN","HMPDJ",103,0)
 S MESSAGE="A mumps error occurred when extracting patient data. A total of "_COUNT_" occurred.\n\r"
"RTN","HMPDJ",104,0)
 S MSGCNT=0 F  S MSGCNT=$O(^TMP($J,"HMP ERROR","ERROR MESSAGE",MSGCNT)) Q:MSGCNT'>0  D
"RTN","HMPDJ",105,0)
 . S MESSAGE=MESSAGE_$G(^TMP($J,"HMP ERROR","ERROR MESSAGE",MSGCNT))_"\n\r"
"RTN","HMPDJ",106,0)
 S RESULT(1)="""error"":{""message"":"""_MESSAGE_"""}"
"RTN","HMPDJ",107,0)
 Q
"RTN","HMPDJ",108,0)
 ;
"RTN","HMPDJ",109,0)
TAG(X) ; -- Return linetag in HMPDJ0 routine for clinical domain X
"RTN","HMPDJ",110,0)
 N Y S X=$G(X,"Z")
"RTN","HMPDJ",111,0)
 S Y=$E($$UP^XLFSTR(X),1,8)
"RTN","HMPDJ",112,0)
 S:'$L($T(@(Y_"^HMPDJ0"))) Y="HMP"
"RTN","HMPDJ",113,0)
 Q Y
"RTN","HMPDJ",114,0)
 ;
"RTN","HMPDJ",115,0)
ALL() ; -- return string for all types of data
"RTN","HMPDJ",116,0)
 Q "patient;problem;allergy;consult;vital;lab;procedure;obs;order;treatment;med;ptf;factor;immunization;exam;cpt;education;pov;skin;image;appointment;surgery;document;visit;mh"
"RTN","HMPDJ",117,0)
 ;
"RTN","HMPDJ",118,0)
ERR(X,VAL) ; -- return error message
"RTN","HMPDJ",119,0)
 N MSG  S MSG="Error"
"RTN","HMPDJ",120,0)
 I X=1  S MSG="Patient with dfn '"_$G(VAL)_"' not found"
"RTN","HMPDJ",121,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPDJ",122,0)
 I X=3  S MSG="UID '"_$G(VAL)_"' not found"
"RTN","HMPDJ",123,0)
 I X=4  S MSG="Unable to create new object"
"RTN","HMPDJ",124,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPDJ",125,0)
 Q MSG
"RTN","HMPDJ",126,0)
 ;
"RTN","HMPDJ",127,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPDJ",128,0)
 Q $$FMTHL7^HMPSTMP($$NOW^XLFDT)  ; DE5016
"RTN","HMPDJ",129,0)
 ;
"RTN","HMPDJ",130,0)
ADD(ITEM,COLL) ; -- add ITEM to results
"RTN","HMPDJ",131,0)
 I $D(HMPCRC),$D(COLL) D ONE^HMPDCRC(ITEM,COLL) Q  ;checksum
"RTN","HMPDJ",132,0)
 ; -- add ITEM to @HMP@(HMPI) to return JSON
"RTN","HMPDJ",133,0)
 N HMPY,HMPERR
"RTN","HMPDJ",134,0)
 D ENCODE^HMPJSON(ITEM,"HMPY","HMPERR")
"RTN","HMPDJ",135,0)
 I $D(HMPERR) D  ;return ERRor instead of ITEM
"RTN","HMPDJ",136,0)
 . N HMPTMP,HMPTXT,HMPITM
"RTN","HMPDJ",137,0)
 . M HMPITM=@ITEM K HMPY
"RTN","HMPDJ",138,0)
 . S HMPTXT(1)="Problem encoding json output."
"RTN","HMPDJ",139,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.HMPITM)
"RTN","HMPDJ",140,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","HMPY","HMPERR")
"RTN","HMPDJ",141,0)
 I $D(HMPY) D
"RTN","HMPDJ",142,0)
 . S HMPI=HMPI+1
"RTN","HMPDJ",143,0)
 . I HMPI>1 S @HMP@(HMPI,.3)=","
"RTN","HMPDJ",144,0)
 . M @HMP@(HMPI)=HMPY
"RTN","HMPDJ",145,0)
 . ;
"RTN","HMPDJ",146,0)
 . ; -- chunk data if from DOMPT^HMPDJFSP ; i.e. HMPCHNK defined ; *S68-JCH*
"RTN","HMPDJ",147,0)
 . D CHNKCHK^HMPDJFSP(.HMP,.HMPI) ; *S68-JCH*
"RTN","HMPDJ",148,0)
 Q
"RTN","HMPDJ",149,0)
 ;
"RTN","HMPDJ",150,0)
TEST(DFN,TYPE,ID,TEXT,IN) ; -- test GET, write results to screen
"RTN","HMPDJ",151,0)
 N OUT,IDX S U="^"
"RTN","HMPDJ",152,0)
 S:'$D(IN("systemID")) IN("systemID")=$$SYS^HMPUTILS
"RTN","HMPDJ",153,0)
 S IN("patientId")=+$G(DFN)
"RTN","HMPDJ",154,0)
 S IN("domain")=$G(TYPE)
"RTN","HMPDJ",155,0)
 S:$D(ID) IN("id")=ID
"RTN","HMPDJ",156,0)
 S:$D(TEXT) IN("text")=TEXT
"RTN","HMPDJ",157,0)
 D GET(.OUT,.IN)
"RTN","HMPDJ",158,0)
 ;
"RTN","HMPDJ",159,0)
 S IDX=OUT
"RTN","HMPDJ",160,0)
 F  S IDX=$Q(@IDX) Q:IDX'?1"^TMP(""HMP"","1.N.E  Q:+$P(IDX,",",2)'=$J  W !,@IDX
"RTN","HMPDJ",161,0)
 Q
"RTN","HMPDJ",162,0)
 ;
"RTN","HMPDJ0")
0^3^B123520924
"RTN","HMPDJ0",1,0)
HMPDJ0 ;SLC/MKB,ASMR/JD,PB,CPC -- Serve VistA data as JSON cont ; 07/13/16 04:45pm
"RTN","HMPDJ0",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ0",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ0",4,0)
 ;
"RTN","HMPDJ0",5,0)
 ; External References          DBIA#
"RTN","HMPDJ0",6,0)
 ; -------------------          -----
"RTN","HMPDJ0",7,0)
 ; ^DPT                         10035  <see HMPDJ0* for others>
"RTN","HMPDJ0",8,0)
 ; EN^ORQ1                      3154
"RTN","HMPDJ0",9,0)
 ; SDAMA301                     4433
"RTN","HMPDJ0",10,0)
 ;
"RTN","HMPDJ0",11,0)
 ; All tags expect DFN, HMPSTART, HMPSTOP, HMPMAX, HMPID, HMPTEXT
"RTN","HMPDJ0",12,0)
 Q
"RTN","HMPDJ0",13,0)
 ;
"RTN","HMPDJ0",14,0)
PATIENT ; -- Patient Registration
"RTN","HMPDJ0",15,0)
 D DPT1^HMPDJ00
"RTN","HMPDJ0",16,0)
 Q
"RTN","HMPDJ0",17,0)
 ;
"RTN","HMPDJ0",18,0)
PROBLEM ; -- Problem List
"RTN","HMPDJ0",19,0)
 I $G(HMPID) D GMPL1^HMPDJ02(HMPID) Q
"RTN","HMPDJ0",20,0)
 N ID,HMPSTS,HMPPROB,HMPN,X,POVLST
"RTN","HMPDJ0",21,0)
 S HMPSTS=$G(FILTER("status")) ;default = all problems
"RTN","HMPDJ0",22,0)
 D LIST^GMPLUTL2(.HMPPROB,DFN,HMPSTS)
"RTN","HMPDJ0",23,0)
 D DIAGLIST^HMPDJ02(.POVLST,DFN)
"RTN","HMPDJ0",24,0)
 S HMPN=0 F  S HMPN=$O(HMPPROB(HMPN)) Q:(HMPN<1)!(HMPI'<HMPMAX)  D
"RTN","HMPDJ0",25,0)
 . S X=$P(HMPPROB(HMPN),U,6) I X,(X<HMPSTART)!(X>HMPSTOP) Q  ;last updated
"RTN","HMPDJ0",26,0)
 . S ID=+HMPPROB(HMPN) D GMPL1^HMPDJ02(ID,.POVLST)
"RTN","HMPDJ0",27,0)
 Q
"RTN","HMPDJ0",28,0)
 ;
"RTN","HMPDJ0",29,0)
ALLERGY ; -- Allergies/Adverse Reactions
"RTN","HMPDJ0",30,0)
 N GMRAL,ID D EN1^GMRADPT
"RTN","HMPDJ0",31,0)
 ; This IF statement was disabled to prevent getting "deletes" in the
"RTN","HMPDJ0",32,0)
 ; JSON during a fetch if ALL allergies for a given patient have been marked
"RTN","HMPDJ0",33,0)
 ; as "entered in error". US6021
"RTN","HMPDJ0",34,0)
 ;I 'GMRAL Q  ;D NKA^HMPDJ02 Q
"RTN","HMPDJ0",35,0)
 I $G(HMPID) D GMRA1^HMPDJ02(HMPID) Q
"RTN","HMPDJ0",36,0)
 S ID=0 F  S ID=+$O(GMRAL(ID)) Q:ID<1  D GMRA1^HMPDJ02(ID) Q:HMPI'<HMPMAX
"RTN","HMPDJ0",37,0)
 Q
"RTN","HMPDJ0",38,0)
 ;
"RTN","HMPDJ0",39,0)
CONSULT ; -- Consult/Request Tracking
"RTN","HMPDJ0",40,0)
 N HMPN,HMPX,ID
"RTN","HMPDJ0",41,0)
 D OER^GMRCSLM1(DFN,"",HMPSTART,HMPSTOP,"")
"RTN","HMPDJ0",42,0)
 S HMPN=0 F  S HMPN=$O(^TMP("GMRCR",$J,"CS",HMPN)) Q:HMPN<1!(HMPN>HMPMAX)  S HMPX=$G(^(HMPN,0)) Q:$E(HMPX)="<"  D
"RTN","HMPDJ0",43,0)
 . I $G(HMPID),HMPID'=+HMPX Q
"RTN","HMPDJ0",44,0)
 . D GMRC1^HMPDJ03(+HMPX)
"RTN","HMPDJ0",45,0)
 K ^TMP("GMRCR",$J,"CS")
"RTN","HMPDJ0",46,0)
 Q
"RTN","HMPDJ0",47,0)
 ;
"RTN","HMPDJ0",48,0)
VITAL ; -- GMR Vital Measurements
"RTN","HMPDJ0",49,0)
 I $L($G(HMPID)) D GMV1^HMPDJ02(HMPID) Q
"RTN","HMPDJ0",50,0)
 N GMRVSTR,HMPIDT,HMPTYP,ID
"RTN","HMPDJ0",51,0)
 S GMRVSTR="BP;T;R;P;HT;WT;CVP;CG;PO2;PN"
"RTN","HMPDJ0",52,0)
 S GMRVSTR(0)=HMPSTART_U_HMPSTOP_U_HMPMAX_"^1"
"RTN","HMPDJ0",53,0)
 D EN1^GMRVUT0
"RTN","HMPDJ0",54,0)
 S HMPIDT=0 F  S HMPIDT=$O(^UTILITY($J,"GMRVD",HMPIDT)) Q:HMPIDT<1  D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",55,0)
 . S HMPTYP="" F  S HMPTYP=$O(^UTILITY($J,"GMRVD",HMPIDT,HMPTYP)) Q:HMPTYP=""  D
"RTN","HMPDJ0",56,0)
 .. S ID=$O(^UTILITY($J,"GMRVD",HMPIDT,HMPTYP,0)) D GMV1^HMPDJ02(ID)
"RTN","HMPDJ0",57,0)
 K ^UTILITY($J,"GMRVD")
"RTN","HMPDJ0",58,0)
 Q
"RTN","HMPDJ0",59,0)
 ;
"RTN","HMPDJ0",60,0)
LAB ; -- Lab Results
"RTN","HMPDJ0",61,0)
 N LRDFN,LRID,HMPSUB,HMPIDT,HMPN,HMPP,HMPACC,BEG,END,SUB,ORPK,ID,X
"RTN","HMPDJ0",62,0)
 S LRDFN=$$LRDFN^HMPXGLAB(DFN),HMPSUB=$G(FILTER("category"))  ;DE2818, (#63) LABORATORY REFERENCE
"RTN","HMPDJ0",63,0)
 S BEG=HMPSTART,END=HMPSTOP,LRID=$G(HMPID),ORPK=""
"RTN","HMPDJ0",64,0)
 I $L(LRID) D  ;reset for LR7OR1
"RTN","HMPDJ0",65,0)
 . I LRID S ORPK=LRID,LRID=$P(LRID,";",4,99) Q:LRID=""  ;order
"RTN","HMPDJ0",66,0)
 . S HMPSUB=$P(LRID,";"),HMPIDT=+$P(LRID,";",2)
"RTN","HMPDJ0",67,0)
 . S:HMPIDT (BEG,END)=9999999-HMPIDT
"RTN","HMPDJ0",68,0)
 S SUB=HMPSUB I $L(SUB),"CH^MI"'[SUB S SUB="AP"
"RTN","HMPDJ0",69,0)
 D RR^LR7OR1(DFN,ORPK,BEG,END,SUB,,,HMPMAX)  ; ICR 2503, DE2818
"RTN","HMPDJ0",70,0)
 S HMPSUB="" F  S HMPSUB=$O(^TMP("LRRR",$J,DFN,HMPSUB)) Q:HMPSUB=""  D
"RTN","HMPDJ0",71,0)
 . S HMPIDT=0 F  S HMPIDT=$O(^TMP("LRRR",$J,DFN,HMPSUB,HMPIDT)) Q:HMPIDT<1  I $O(^(HMPIDT,0)) D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",72,0)
 .. I HMPSUB="MI"  S ID=HMPSUB_";"_HMPIDT D MI^HMPDJ06 Q
"RTN","HMPDJ0",73,0)
 .. I HMPSUB'="CH" S ID=HMPSUB_";"_HMPIDT D AP^HMPDJ06 Q
"RTN","HMPDJ0",74,0)
 .. D ACC^HMPDJ06 ;get chem accession data
"RTN","HMPDJ0",75,0)
 .. S HMPP=0 F  S HMPP=$O(^TMP("LRRR",$J,DFN,HMPSUB,HMPIDT,HMPP)) Q:HMPP<1  S X=+$G(^(HMPP)) D
"RTN","HMPDJ0",76,0)
 ... S HMPN=$$LRDN^LRPXAPIU(X) I $L(LRID,";")>2,HMPN'=$P(LRID,";",3) Q
"RTN","HMPDJ0",77,0)
 ... S ID=HMPSUB_";"_HMPIDT_";"_HMPN D CH1^HMPDJ06
"RTN","HMPDJ0",78,0)
 K ^TMP("LRRR",$J),^TMP("LRX",$J)
"RTN","HMPDJ0",79,0)
 Q
"RTN","HMPDJ0",80,0)
 ;
"RTN","HMPDJ0",81,0)
PROCEDUR ; -- Clinical Procedures
"RTN","HMPDJ0",82,0)
 N HMPN,HMPX,BEG,END,ID
"RTN","HMPDJ0",83,0)
 S BEG=HMPSTART,END=HMPSTOP
"RTN","HMPDJ0",84,0)
 I $G(HMPID) D  ;reset dates for HMPID only
"RTN","HMPDJ0",85,0)
 . N HMPMC,IEN,FILE,X
"RTN","HMPDJ0",86,0)
 . S IEN=+HMPID,FILE=+$P(HMPID,"(",2)  Q:FILE=702  Q:'FILE
"RTN","HMPDJ0",87,0)
 . D MEDLKUP^MCARUTL3(.HMPMC,FILE,IEN)
"RTN","HMPDJ0",88,0)
 . S X=$P(HMPMC,U,6) S:X (BEG,END)=X
"RTN","HMPDJ0",89,0)
 D MDPS1^HMPDJ03(DFN,BEG,END,HMPMAX)    ;gets ^TMP("MDHSP",$J)
"RTN","HMPDJ0",90,0)
 S HMPN=0 F  S HMPN=$O(^TMP("MDHSP",$J,HMPN)) Q:HMPN<1  S HMPX=$G(^(HMPN)) D
"RTN","HMPDJ0",91,0)
 . I $G(HMPID),+HMPID'=+$P(HMPX,U,2) Q  ;update 1 procedure
"RTN","HMPDJ0",92,0)
 . D MC1^HMPDJ03($G(HMPID))             ;uses HMPX
"RTN","HMPDJ0",93,0)
 K ^TMP("MDHSP",$J)
"RTN","HMPDJ0",94,0)
 Q
"RTN","HMPDJ0",95,0)
 ;
"RTN","HMPDJ0",96,0)
OBS ; -- Clinical Observations (CLiO)
"RTN","HMPDJ0",97,0)
 N HMPCLIO,HMPN,ID,X
"RTN","HMPDJ0",98,0)
 I $L($G(HMPID)) D MDC1^HMPDJ03(HMPID) Q
"RTN","HMPDJ0",99,0)
 D QRYPT^HMPDMDC("HMPCLIO",DFN,HMPSTART,HMPSTOP) ;all [verified] observations
"RTN","HMPDJ0",100,0)
 S HMPN=0 F  S HMPN=$O(HMPCLIO(HMPN)) Q:(HMPN<1)!(HMPI'<HMPMAX)  D
"RTN","HMPDJ0",101,0)
 . S ID=$G(HMPCLIO(HMPN)) ;GUID
"RTN","HMPDJ0",102,0)
 . D MDC1^HMPDJ03(ID)
"RTN","HMPDJ0",103,0)
 Q
"RTN","HMPDJ0",104,0)
 ;
"RTN","HMPDJ0",105,0)
ORDER ; -- Order Entry
"RTN","HMPDJ0",106,0)
 N DAD,HMPN,HMPORDR,ID,ORLIST,X  ; DE2818, added HMPORDR, removed X3,X4
"RTN","HMPDJ0",107,0)
 I $G(HMPID) S ORLIST=$H D OR1^HMPDJ01(HMPID) G ORQ
"RTN","HMPDJ0",108,0)
 ; changed FLG to 1 to get all orders including pending.  JD - 1/20/16 - US11951
"RTN","HMPDJ0",109,0)
 D EN^ORQ1(DFN_";DPT(",,1,,HMPSTART,HMPSTOP,,,,1) ; DBIA 3154
"RTN","HMPDJ0",110,0)
 S HMPN=0 F  S HMPN=$O(^TMP("ORR",$J,ORLIST,HMPN)) Q:HMPN<1  S ID=$G(^(HMPN)),ID=+ID D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",111,0)
 . ;DE2818, begin logic change
"RTN","HMPDJ0",112,0)
 . K HMPORDR D ORDINFO(.HMPORDR,ID)  ; kill it for each iteration
"RTN","HMPDJ0",113,0)
 . ; (#33) PACKAGE REFERENCE
"RTN","HMPDJ0",114,0)
 . ; (# 5) STATUS: 13=CANCELLED, 12=DISCONTINUED/EDIT, 1=DISCONTINUED
"RTN","HMPDJ0",115,0)
 . Q:$G(HMPORDR(100,ID,5,"I"))=13  I $G(HMPORDR(100,ID,33,"I"))["P",($G(HMPORDR(100,ID,5,"I"))=12)!($G(HMPORDR(100,ID,5,"I"))=1) Q
"RTN","HMPDJ0",116,0)
 . ; Get Parent order if we don't already have it
"RTN","HMPDJ0",117,0)
 . ; Also, add the child order to the returned list
"RTN","HMPDJ0",118,0)
 . S DAD=$G(HMPORDR(100,ID,36,"I"))  ;(#36) PARENT 
"RTN","HMPDJ0",119,0)
 . I DAD D:'$D(^TMP("ORGOTIT",$J,DAD)) OR1^HMPDJ01(DAD)
"RTN","HMPDJ0",120,0)
 . ;DE2818, end logic change
"RTN","HMPDJ0",121,0)
 . D OR1^HMPDJ01(ID)
"RTN","HMPDJ0",122,0)
ORQ ; end
"RTN","HMPDJ0",123,0)
 K ^TMP("ORR",$J),^TMP("ORGOTIT",$J)
"RTN","HMPDJ0",124,0)
 Q
"RTN","HMPDJ0",125,0)
 ;
"RTN","HMPDJ0",126,0)
TREATMEN ; -- Nursing Treatments (orders)
"RTN","HMPDJ0",127,0)
 N HMPN,HMPORDR,ID,ORDG,ORLIST,X  ;DE2818, added HMPORDR, removed X3,X4
"RTN","HMPDJ0",128,0)
 I $G(HMPID) S ORLIST=$H D NTX1^HMPDJ01(HMPID) G TXQ
"RTN","HMPDJ0",129,0)
 ;DE2818, ***replacement for ^ORD reference needed below***
"RTN","HMPDJ0",130,0)
 S ORDG=+$O(^ORD(100.98,"B","NTX",0))
"RTN","HMPDJ0",131,0)
 D EN^ORQ1(DFN_";DPT(",ORDG,6,,HMPSTART,HMPSTOP,,,,1)
"RTN","HMPDJ0",132,0)
 S HMPN=0 F  S HMPN=$O(^TMP("ORR",$J,ORLIST,HMPN)) Q:HMPN<1  S ID=$G(^(HMPN)) D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",133,0)
 . Q:$D(^TMP("ORGOTIT",$J,+ID))  Q:$P(ID,";",2)>1  S ID=+ID  ;actions
"RTN","HMPDJ0",134,0)
 . ;DE2818, begin logic change
"RTN","HMPDJ0",135,0)
 . K HMPORDR D ORDINFO(.HMPORDR,ID)  ; kill it for each iteration
"RTN","HMPDJ0",136,0)
 . ;(#33) PACKAGE REFERENCE,(#5) STATUS: 13=CANCELLED, 12=DISCONTINUED/EDIT, 1=DISCONTINUED
"RTN","HMPDJ0",137,0)
 . Q:$G(HMPORDR(100,ID,5,"I"))=13  I $G(HMPORDR(100,ID,33,"I"))["P",($G(HMPORDR(100,ID,5,"I"))=12)!($G(HMPORDR(100,ID,5,"I"))=1) Q
"RTN","HMPDJ0",138,0)
 . ;DE2818, end logic change
"RTN","HMPDJ0",139,0)
 . D NTX1^HMPDJ01(ID)
"RTN","HMPDJ0",140,0)
TXQ ; end
"RTN","HMPDJ0",141,0)
 K ^TMP("ORR",$J),^TMP("ORGOTIT",$J)
"RTN","HMPDJ0",142,0)
 Q
"RTN","HMPDJ0",143,0)
 ;
"RTN","HMPDJ0",144,0)
MED ; -- Pharmacy
"RTN","HMPDJ0",145,0)
 ;DE2818, removed reference to ^OR(100,HMPID) below
"RTN","HMPDJ0",146,0)
 N ORDIALOG I $G(HMPID),$$GET1^DIQ(100,HMPID_",",.01)]"" D PS1^HMPDJ05(HMPID) Q  ;get 1 order
"RTN","HMPDJ0",147,0)
 N DAD,HMPN,HMPORDR,ID,ORDG,ORLIST,ORVP,TYPE  ;DE2818, added HMPORDR, removed extra ORLIST and X3,X4
"RTN","HMPDJ0",148,0)
 S TYPE=$G(FILTER("vaType")) S:$L(TYPE) TYPE=$S(TYPE="N":"NV",TYPE="V":"IV",1:TYPE)_" "
"RTN","HMPDJ0",149,0)
 ;DE2818, ***replacement for ^ORD reference needed below***
"RTN","HMPDJ0",150,0)
 S ORDG=$O(^ORD(100.98,"B",TYPE_"RX",0)),ORVP=DFN_";DPT(" ;CPC removed + 10/30/15 DE2434
"RTN","HMPDJ0",151,0)
 ;If RX group not found, and not overridden by specific type then try PHARMACY CPC 10/30/15 DE2434
"RTN","HMPDJ0",152,0)
 I ORDG="" S ORDG=0 I TYPE="" S ORDG=+$O(^ORD(100.98,"B","PHARMACY",0)) ;CPC 10/30/15 DE2434
"RTN","HMPDJ0",153,0)
 D EN^ORQ1(ORVP,ORDG,6,,HMPSTART,HMPSTOP)
"RTN","HMPDJ0",154,0)
 K ^TMP("HMPOR",$J) S HMPN=0
"RTN","HMPDJ0",155,0)
 F  S HMPN=$O(^TMP("ORR",$J,ORLIST,HMPN)) Q:HMPN<1  S ID=$G(^(HMPN)),ID=+ID D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",156,0)
 . ;DE2818, begin logic change
"RTN","HMPDJ0",157,0)
 . K HMPORDR D ORDINFO(.HMPORDR,ID)  ; kill it for each iteration
"RTN","HMPDJ0",158,0)
 . ;(#33) PACKAGE REFERENCE,(#5) STATUS: 13=CANCELLED, 12=DISCONTINUED/EDIT, 1=DISCONTINUED
"RTN","HMPDJ0",159,0)
 . Q:$G(HMPORDR(100,ID,5,"I"))=13  I $G(HMPORDR(100,ID,33,"I"))["P",($G(HMPORDR(100,ID,5,"I"))=12)!($G(HMPORDR(100,ID,5,"I"))=1) Q
"RTN","HMPDJ0",160,0)
 . S DAD=$G(HMPORDR(100,ID,36,"I"))  ;(#36) PARENT
"RTN","HMPDJ0",161,0)
 . I DAD D:'$D(^TMP("HMPOR",$J,DAD)) PS1^HMPDJ05(DAD)
"RTN","HMPDJ0",162,0)
 . ;DE2818, end logic change
"RTN","HMPDJ0",163,0)
 . D PS1^HMPDJ05(ID) ;DE5156 ensure parent added as well as children
"RTN","HMPDJ0",164,0)
 K ^TMP("HMPOR",$J),^TMP("ORR",$J),^TMP("ORGOTIT",$J),^TMP($J,"PSOI")
"RTN","HMPDJ0",165,0)
 Q
"RTN","HMPDJ0",166,0)
 ;
"RTN","HMPDJ0",167,0)
PTF ; -- Patient Treatment File
"RTN","HMPDJ0",168,0)
 ;Purpose - Main Patient Treatment File (PTF) RPC
"RTN","HMPDJ0",169,0)
 ;
"RTN","HMPDJ0",170,0)
 ;Called by - PTF RPC
"RTN","HMPDJ0",171,0)
 ;
"RTN","HMPDJ0",172,0)
 ;Assumptions - Expects variables DFN, HMPSTART, HMPSTOP, HMPMAX
"RTN","HMPDJ0",173,0)
 ;
"RTN","HMPDJ0",174,0)
 ;Modification History -
"RTN","HMPDJ0",175,0)
 ;US5630 (TW) - Namespaced variables and enhanced newing
"RTN","HMPDJ0",176,0)
 ;
"RTN","HMPDJ0",177,0)
 N HMPRDT,HMPX,HMPAPI,HMPLID
"RTN","HMPDJ0",178,0)
 K ^TMP("HMPPX",$J)
"RTN","HMPDJ0",179,0)
 ;
"RTN","HMPDJ0",180,0)
 I $G(HMPID),HMPID'=+HMPID D PTFA^HMPDJ04A(HMPID) Q  ; If HMPID and dx type, process and quit
"RTN","HMPDJ0",181,0)
 ;
"RTN","HMPDJ0",182,0)
 I $G(HMPID) D  Q:'$D(^TMP("HMPPX",$J))  ; If HMPID only, set one ^TMP("HMPPX") entry
"RTN","HMPDJ0",183,0)
 . S HMPRDT=9999999
"RTN","HMPDJ0",184,0)
 . D RPC^DGPTFAPI(.HMPAPI,HMPID)
"RTN","HMPDJ0",185,0)
 . S HMPX=$P($G(HMPAPI(1)),U,3)
"RTN","HMPDJ0",186,0)
 . I $L(HMPX) S ^TMP("HMPPX",$J,HMPRDT,HMPID_";70;DXLS")=HMPX_U
"RTN","HMPDJ0",187,0)
 . F HMPAPI=1:1:9 S HMPX=$P($G(HMPY(2)),U,HMPAPI) I $L(HMPX) S ^TMP("HMPPX",$J,HMPRDT,HMPID_";70;D SD"_HMPAPI)=HMPX_U_$G(DISDAT)
"RTN","HMPDJ0",188,0)
 ;
"RTN","HMPDJ0",189,0)
 I '$G(HMPID) D PTF^HMPDJ09  ; If no HMPID, set up ^TMP("HMPPX") for all dx
"RTN","HMPDJ0",190,0)
 ;
"RTN","HMPDJ0",191,0)
 ;Loop through ^TMP("HMPPX",$J) and do PTF1^HMPDJ04A to set PTF array, ^TMP
"RTN","HMPDJ0",192,0)
 S HMPRDT="" F  S HMPRDT=$O(^TMP("HMPPX",$J,HMPRDT)) Q:HMPRDT=""  D
"RTN","HMPDJ0",193,0)
 . S HMPLID="" F  S HMPLID=$O(^TMP("HMPPX",$J,HMPRDT,HMPLID)) Q:HMPLID=""!(HMPI'<HMPMAX)  D
"RTN","HMPDJ0",194,0)
 .. D PTF1^HMPDJ04A
"RTN","HMPDJ0",195,0)
 K ^TMP("HMPPX",$J)
"RTN","HMPDJ0",196,0)
 Q
"RTN","HMPDJ0",197,0)
 ;
"RTN","HMPDJ0",198,0)
FACTOR   D PX^HMPDJ09(9000010.23) Q   ; -- PCE Health Factors
"RTN","HMPDJ0",199,0)
IMMUNIZA D PX^HMPDJ09(9000010.11) Q   ; -- PCE Immunizations
"RTN","HMPDJ0",200,0)
EXAM     D PX^HMPDJ09(9000010.13) Q   ; -- PCE Exams
"RTN","HMPDJ0",201,0)
CPT      D PX^HMPDJ09(9000010.18) Q   ; -- PCE CPT
"RTN","HMPDJ0",202,0)
EDUCATIO D PX^HMPDJ09(9000010.16) Q   ; -- PCE Patient Education
"RTN","HMPDJ0",203,0)
POV      D PX^HMPDJ09(9000010.07) Q   ; -- PCE Purpose of Visit (POV)
"RTN","HMPDJ0",204,0)
SKIN     D PX^HMPDJ09(9000010.12) Q   ; -- PCE Skin Tests
"RTN","HMPDJ0",205,0)
 ;
"RTN","HMPDJ0",206,0)
IMAGE ; -- Radiology/Nuclear Medicine
"RTN","HMPDJ0",207,0)
 D EN1^RAO7PC1(DFN,HMPSTART,HMPSTOP,HMPMAX_"P")
"RTN","HMPDJ0",208,0)
 I $G(HMPID) D RA1^HMPDJ07(HMPID) G IMQ
"RTN","HMPDJ0",209,0)
 N ID S ID=""
"RTN","HMPDJ0",210,0)
 F  S ID=$O(^TMP($J,"RAE1",DFN,ID)) Q:ID=""  D RA1^HMPDJ07(ID)  Q:HMPI'<+HMPMAX
"RTN","HMPDJ0",211,0)
IMQ ; end
"RTN","HMPDJ0",212,0)
 K ^TMP($J,"RAE1")
"RTN","HMPDJ0",213,0)
 Q
"RTN","HMPDJ0",214,0)
 ;
"RTN","HMPDJ0",215,0)
APPOINTM ; -- Scheduling/Appointment Mgt
"RTN","HMPDJ0",216,0)
 N HMPX,HMPNUM,HMPDT,X,HMPA,ID
"RTN","HMPDJ0",217,0)
 S HMPX(1)=HMPSTART_";"_HMPSTOP,HMPX(4)=DFN,ID=$G(HMPID)
"RTN","HMPDJ0",218,0)
 S HMPX("FLDS")="1;2;3;6;9;10;11;13;22",HMPX("SORT")="P"  ;DE4469 - PB - Apr 26, 2016 added field 22 to the list of fields to be pulled.
"RTN","HMPDJ0",219,0)
 I $L(ID) G:$E(ID)="H" DGS^HMPDJ04 D  Q
"RTN","HMPDJ0",220,0)
 . S HMPDT=$P(ID,";",2),HMPX(1)=$P(ID,";",2)_";"_$P(ID,";",2)
"RTN","HMPDJ0",221,0)
 . S HMPX(2)=$P(ID,";",3)
"RTN","HMPDJ0",222,0)
 . S HMPNUM=$$SDAPI^SDAMA301(.HMPX)
"RTN","HMPDJ0",223,0)
 . D:HMPNUM>0 SDAM1^HMPDJ04
"RTN","HMPDJ0",224,0)
 . K ^TMP($J,"SDAMA301",DFN)
"RTN","HMPDJ0",225,0)
 ; appointments
"RTN","HMPDJ0",226,0)
 S HMPX(3)="R;I;NS;NSR;NT" ;no cancelled appt's
"RTN","HMPDJ0",227,0)
 S HMPNUM=$$SDAPI^SDAMA301(.HMPX),HMPDT=0
"RTN","HMPDJ0",228,0)
 F  S HMPDT=$O(^TMP($J,"SDAMA301",DFN,HMPDT)) Q:HMPDT<1  D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",229,0)
 . S X=$P($G(^TMP($J,"SDAMA301",DFN,HMPDT)),U,3)
"RTN","HMPDJ0",230,0)
 . ;I HMPDT<DT,$P(X,";")'["NS" Q   ;no prior kept appt's
"RTN","HMPDJ0",231,0)
 . D SDAM1^HMPDJ04
"RTN","HMPDJ0",232,0)
 K ^TMP($J,"SDAMA301",DFN)
"RTN","HMPDJ0",233,0)
 Q
"RTN","HMPDJ0",234,0)
 ;
"RTN","HMPDJ0",235,0)
SURGERY ; -- Surgery
"RTN","HMPDJ0",236,0)
 I $G(HMPID) D SR1^HMPDJ07(HMPID) Q
"RTN","HMPDJ0",237,0)
 Q:'$L($T(LIST^SROESTV))
"RTN","HMPDJ0",238,0)
 N SHOWADD S SHOWADD=1 ;to omit leading '+' with note titles
"RTN","HMPDJ0",239,0)
 N HMPN,HMPY,ID D LIST^SROESTV(.HMPY,DFN,HMPSTART,HMPSTOP,HMPMAX,1)
"RTN","HMPDJ0",240,0)
 S HMPN=0 F  S HMPN=$O(@HMPY@(HMPN)) Q:HMPN<1  D
"RTN","HMPDJ0",241,0)
 . S ID=+$G(@HMPY@(HMPN)) D:ID SR1^HMPDJ07(ID)
"RTN","HMPDJ0",242,0)
 K @HMPY
"RTN","HMPDJ0",243,0)
 Q
"RTN","HMPDJ0",244,0)
 ;
"RTN","HMPDJ0",245,0)
DOCUMENT ; -- Text Integration Utilities
"RTN","HMPDJ0",246,0)
 N HMPC,CLS,HMPS,CTXT,HMPY,HMPN,HMPX,ID
"RTN","HMPDJ0",247,0)
 I $L($G(HMPID)) D TIU1^HMPDJ08(HMPID) Q
"RTN","HMPDJ0",248,0)
 N CLASS,SUBCLASS,STATUS
"RTN","HMPDJ0",249,0)
 D SETUP^HMPDJ08 ;define search criteria
"RTN","HMPDJ0",250,0)
 F HMPC=1:1:$L(CLASS,U) S CLS=$P(CLASS,U,HMPC) D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",251,0)
 . I CLS="CP" D CP^HMPDJ08A(DFN,HMPSTART,HMPSTOP,HMPMAX) Q
"RTN","HMPDJ0",252,0)
 . I CLS="RA" D RA^HMPDJ08A(DFN,HMPSTART,HMPSTOP,HMPMAX) Q
"RTN","HMPDJ0",253,0)
 . I CLS="LR" D LR^HMPDJ08A(DFN,HMPSTART,HMPSTOP,HMPMAX) Q
"RTN","HMPDJ0",254,0)
 . ; TIU document classes, by sig status
"RTN","HMPDJ0",255,0)
 . F HMPS=1:1:$L(STATUS,U) S CTXT=$P(STATUS,U,HMPS) D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",256,0)
 .. ;I $L($G(HMPBATCH)) D GET^TIUHMP(.HMPY,DFN,CLS,HMPSTART,HMPSTOP) I 1 ; <<<< 12.3
"RTN","HMPDJ0",257,0)
 .. I $L($G(HMPBATCH)) D GET^TIUVPR(.HMPY,DFN,CLS,HMPSTART,HMPSTOP) I 1 ;  <<<< 12.3
"RTN","HMPDJ0",258,0)
 .. E  D CONTEXT^TIUSRVLO(.HMPY,CLS,CTXT,DFN,HMPSTART,HMPSTOP,,HMPMAX,,1)
"RTN","HMPDJ0",259,0)
 .. S HMPN=0 F  S HMPN=$O(@HMPY@(HMPN)) Q:HMPN<1  D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",260,0)
 ... S HMPX=$G(@HMPY@(HMPN)) ;Q:'$$MATCH^HMPDJ08(HMPX,CTXT)
"RTN","HMPDJ0",261,0)
 ... Q:$D(^TMP("HMPD",$J,+HMPX))  ;already included
"RTN","HMPDJ0",262,0)
 ... D EN1^HMPDJ08(HMPX,CLS)
"RTN","HMPDJ0",263,0)
 .. K @HMPY
"RTN","HMPDJ0",264,0)
 Q
"RTN","HMPDJ0",265,0)
 ;
"RTN","HMPDJ0",266,0)
VISIT ; -- Visits
"RTN","HMPDJ0",267,0)
 I $L($G(HMPID)) D VSIT1^HMPDJ04(HMPID) Q
"RTN","HMPDJ0",268,0)
 N BEG,END,HMPADMIT,HMPDEMOG,HMPIDT,ID  ;DE2818, added HMPDEMOG
"RTN","HMPDJ0",269,0)
 D TOP^HMPXGDPT("HMPDEMOG",DFN,.105,"I")  ;DE2818, (.105) CURRENT ADMISSION
"RTN","HMPDJ0",270,0)
 S HMPADMIT=+$G(HMPDEMOG(2,DFN,.105,"I")) ;DE2818
"RTN","HMPDJ0",271,0)
 S BEG=HMPSTART,END=HMPSTOP D IDT^HMPDVSIT ;invert dates
"RTN","HMPDJ0",272,0)
 ;DE2818 ***ICR 2028 needed for ^AUPNVSIT references below***
"RTN","HMPDJ0",273,0)
 S HMPIDT=BEG F  S HMPIDT=$O(^AUPNVSIT("AA",DFN,HMPIDT)) Q:HMPIDT<1!(HMPIDT>END)  D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",274,0)
 . S ID=0 F  S ID=$O(^AUPNVSIT("AA",DFN,HMPIDT,ID)) Q:ID<1  D VSIT1^HMPDJ04(ID)
"RTN","HMPDJ0",275,0)
 ; kill HMPADMIT in VSIT1 if adm is included, but add unless filtered
"RTN","HMPDJ0",276,0)
 I $G(HMPADMIT),HMPMAX'<9999,HMPSTART'>1410102 D VSIT1^HMPDJ04("H"_HMPADMIT)
"RTN","HMPDJ0",277,0)
 Q
"RTN","HMPDJ0",278,0)
 ;I HMPSTOP,HMPSTOP'["." S END=HMPSTOP_".24" ;assume end of day
"RTN","HMPDJ0",279,0)
 ;S HMPDT=END F  S HMPDT=$O(^AUPNVSIT("AET",DFN,HMPDT),-1)  Q:HMPDT<HMPSTART  D  Q:HMPI'<HMPMAX
"RTN","HMPDJ0",280,0)
 ;. S HMPLOC=0 F  S HMPLOC=$O(^AUPNVSIT("AET",DFN,HMPDT,HMPLOC)) Q:HMPLOC<1  D
"RTN","HMPDJ0",281,0)
 ;.. S ID=0 F  S ID=$O(^AUPNVSIT("AET",DFN,HMPDT,HMPLOC,"P",ID)) Q:ID<1  D VSIT1^HMPDJ04(ID)
"RTN","HMPDJ0",282,0)
 ;
"RTN","HMPDJ0",283,0)
HMP ; -- HMP Patient Objects
"RTN","HMPDJ0",284,0)
 D HMP^HMPDJ02($G(TYPE))
"RTN","HMPDJ0",285,0)
 Q
"RTN","HMPDJ0",286,0)
 ;
"RTN","HMPDJ0",287,0)
MH ; -- Mental Health
"RTN","HMPDJ0",288,0)
 I $L($T(MH^HMPDJ09M)) D MH^HMPDJ09M
"RTN","HMPDJ0",289,0)
 Q
"RTN","HMPDJ0",290,0)
 ;
"RTN","HMPDJ0",291,0)
ERRQ ; -- Quit for error handling
"RTN","HMPDJ0",292,0)
 Q
"RTN","HMPDJ0",293,0)
 ;
"RTN","HMPDJ0",294,0)
 ;new subroutine for DE2818
"RTN","HMPDJ0",295,0)
ORDINFO(ORRSLT,ORIEN) ; ORDER file (#100), ORRSLT passed by reference
"RTN","HMPDJ0",296,0)
 ; all data returned in internal format
"RTN","HMPDJ0",297,0)
 ;
"RTN","HMPDJ0",298,0)
 ;   fields on ^OR(100,D0,0)
"RTN","HMPDJ0",299,0)
 ;(#.01) ORDER #
"RTN","HMPDJ0",300,0)
 ;(#.02) OBJECT OF ORDER
"RTN","HMPDJ0",301,0)
 ;
"RTN","HMPDJ0",302,0)
 ;   fields on ^OR(100,D0,3)
"RTN","HMPDJ0",303,0)
 ;(#5) STATUS
"RTN","HMPDJ0",304,0)
 ;(#7) ITEM ORDERED
"RTN","HMPDJ0",305,0)
 ;(#8) VEILED
"RTN","HMPDJ0",306,0)
 ;(#8.1) TYPE
"RTN","HMPDJ0",307,0)
 ;(#9) REPLACED ORDER
"RTN","HMPDJ0",308,0)
 ;(#9.1) REPLACEMENT ORDER
"RTN","HMPDJ0",309,0)
 ;(#30) CURRENT ACTION
"RTN","HMPDJ0",310,0)
 ;(#31) DATE OF LAST ACTIVITY
"RTN","HMPDJ0",311,0)
 ;(#32) GRACE DAYS BEFORE PURGE
"RTN","HMPDJ0",312,0)
 ;(#36) PARENT
"RTN","HMPDJ0",313,0)
 ;(#35) ALERT ON RESULTS
"RTN","HMPDJ0",314,0)
 ;
"RTN","HMPDJ0",315,0)
 ;   field on ^OR(100,D0,4)
"RTN","HMPDJ0",316,0)
 ;(#33) PACKAGE REFERENCE
"RTN","HMPDJ0",317,0)
 ;
"RTN","HMPDJ0",318,0)
 Q:'($G(ORIEN)>0)  ; IEN required
"RTN","HMPDJ0",319,0)
 D TOP^HMPXGORD("ORRSLT",ORIEN,".01;.02;5;7;8;8.1;9;9.1;30;31;32;33;35;36","I")
"RTN","HMPDJ0",320,0)
 ;
"RTN","HMPDJ0",321,0)
 Q
"RTN","HMPDJ0",322,0)
 ;end DE2818
"RTN","HMPDJ0",323,0)
 ;
"RTN","HMPDJ00")
0^4^B165368982
"RTN","HMPDJ00",1,0)
HMPDJ00 ;SLC/MKB,ASMR/RRB - Patient demographics;Jul 08, 2016 18:17:48
"RTN","HMPDJ00",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ00",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ00",4,0)
 ;
"RTN","HMPDJ00",5,0)
 ; External References          DBIA#
"RTN","HMPDJ00",6,0)
 ; -------------------          -----
"RTN","HMPDJ00",7,0)
 ; ^AUPNVSIT                     2028
"RTN","HMPDJ00",8,0)
 ; ^DPT                         10035
"RTN","HMPDJ00",9,0)
 ; DGACT                         2248
"RTN","HMPDJ00",10,0)
 ; DGCV                          4156
"RTN","HMPDJ00",11,0)
 ; DGMSTAPI                      2716
"RTN","HMPDJ00",12,0)
 ; DGNTAPI                       3457
"RTN","HMPDJ00",13,0)
 ; DGPFAPI                       3860
"RTN","HMPDJ00",14,0)
 ; DGRPDB                        4807
"RTN","HMPDJ00",15,0)
 ; DIQ                           2056
"RTN","HMPDJ00",16,0)
 ; IBBAPI                        4419
"RTN","HMPDJ00",17,0)
 ; MPIF001                       2701
"RTN","HMPDJ00",18,0)
 ; SDUTL3                        1252
"RTN","HMPDJ00",19,0)
 ; VADPT                        10061
"RTN","HMPDJ00",20,0)
 ; VAFCTFU1                      2990
"RTN","HMPDJ00",21,0)
 ; VASITE                       10112
"RTN","HMPDJ00",22,0)
 ; XUAF4                         2171
"RTN","HMPDJ00",23,0)
 ; SECURITY/SENSITIVE RECORD ACC 3027
"RTN","HMPDJ00",24,0)
 ;
"RTN","HMPDJ00",25,0)
 ; All tags expect DFN
"RTN","HMPDJ00",26,0)
 ; [HMPID, HMPSTART, HMPSTOP, HMPMAX, HMPTEXT not currently used here]
"RTN","HMPDJ00",27,0)
 Q
"RTN","HMPDJ00",28,0)
 ;
"RTN","HMPDJ00",29,0)
DPT1 ; -- Demographics
"RTN","HMPDJ00",30,0)
 N PAT D DPT1OD(.PAT)
"RTN","HMPDJ00",31,0)
 I $D(PAT)>9 D ADD^HMPDJ("PAT")
"RTN","HMPDJ00",32,0)
 Q
"RTN","HMPDJ00",33,0)
 ;
"RTN","HMPDJ00",34,0)
DPT1OD(PAT) ; -- Demographics (data array only)
"RTN","HMPDJ00",35,0)
 N SYS S SYS=$$SITE^VASITE
"RTN","HMPDJ00",36,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ00",37,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ00",38,0)
 S ERRMSG="A problem occurred building the patient "_DFN_" demographic extract."
"RTN","HMPDJ00",39,0)
 D DEM,SVC,PRF,ATC,SUPP,ALIAS,FAC,PC,INPT,INS
"RTN","HMPDJ00",40,0)
 D KVAR^VADPT
"RTN","HMPDJ00",41,0)
 S PAT("stampTime")=$S($G(HMPSTMP)]"":HMPSTMP,1:$$EN^HMPSTMP("NOW")) ;US6734
"RTN","HMPDJ00",42,0)
 S PAT("lastUpdateTime")=PAT("stampTime")
"RTN","HMPDJ00",43,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ00",44,0)
 I $G(HMPMETA) D ADD^HMPMETA("patient",PAT("uid"),PAT("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ00",45,0)
 Q
"RTN","HMPDJ00",46,0)
 ;
"RTN","HMPDJ00",47,0)
LKUP ; patient lookup data
"RTN","HMPDJ00",48,0)
 ; expects HMPSYS,DFN
"RTN","HMPDJ00",49,0)
 N X,X0
"RTN","HMPDJ00",50,0)
 S X0=$G(^DPT(DFN,0)),X=$P(X0,U) Q:X=""  ; invalid DFN passed in DE4983
"RTN","HMPDJ00",51,0)
 S PAT("fullName")=X
"RTN","HMPDJ00",52,0)
 S PAT("familyName")=$P(X,",")
"RTN","HMPDJ00",53,0)
 S PAT("givenNames")=$P(X,",",2,99)
"RTN","HMPDJ00",54,0)
 S X=$P(X0,U,2)
"RTN","HMPDJ00",55,0)
 S PAT("genderCode")="urn:va:pat-gender:"_X
"RTN","HMPDJ00",56,0)
 S PAT("genderName")=$$NAME(X,"gender")
"RTN","HMPDJ00",57,0)
 S PAT("localId")=DFN
"RTN","HMPDJ00",58,0)
 S PAT("pid")=HMPSYS_";"_DFN
"RTN","HMPDJ00",59,0)
 S PAT("uid")=$$SETUID^HMPUTILS("pt-select",DFN,DFN)
"RTN","HMPDJ00",60,0)
 S X=$$GETICN^MPIF001(DFN)
"RTN","HMPDJ00",61,0)
 S:X>0 PAT("icn")=X
"RTN","HMPDJ00",62,0)
 S PAT("ssn")=$P(X0,U,9)
"RTN","HMPDJ00",63,0)
 S PAT("birthDate")=$$JSONDT^HMPUTILS($P(X0,U,3))
"RTN","HMPDJ00",64,0)
 S X=$P($G(^DPT(DFN,.35)),U)
"RTN","HMPDJ00",65,0)
 S:X PAT("deceased")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ00",66,0)
 D PTSEC^DGSEC4(.LST,DFN)  ; DBIA 3027 DE2818 - PB 30 Oct 2015 changed to use a global reference covered by an active ICR
"RTN","HMPDJ00",67,0)
 S PAT("sensitive")=$$BOOL(LST(1))
"RTN","HMPDJ00",68,0)
 ;US6734 - pre-compile metastamp for OPD
"RTN","HMPDJ00",69,0)
 I $G(HMPMETA),$P($G(HMPFADOM),"#")="pt-select" D ADD^HMPMETA("pt-select",PAT("uid"),$G(HMPSTMP)) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ00",70,0)
 I $G(HMPSTMP)]"" S PAT("stampTime")=HMPSTMP ; US6734 - set stamptime as time of subscription
"RTN","HMPDJ00",71,0)
 E  S PAT("stampTime")=$$EN^HMPSTMP("NOW") ; DE2616 - must add stampTime to receive OPD freshness update from ADHOC^HMPUTIL1
"RTN","HMPDJ00",72,0)
 I $D(PAT)>9 D ADD^HMPDJ("PAT")
"RTN","HMPDJ00",73,0)
 Q
"RTN","HMPDJ00",74,0)
 ;
"RTN","HMPDJ00",75,0)
DEM ;-demographic data
"RTN","HMPDJ00",76,0)
 N VADM,VA,VAERR,X,I
"RTN","HMPDJ00",77,0)
 S PAT("pid")=$$PID^HMPDJFS(DFN)
"RTN","HMPDJ00",78,0)
 S X=$$GETICN^MPIF001(DFN) S:X>1 PAT("icn")=X
"RTN","HMPDJ00",79,0)
 D DEM^VADPT S X=VADM(1),PAT("fullName")=X
"RTN","HMPDJ00",80,0)
 S PAT("familyName")=$P(X,","),PAT("givenNames")=$P(X,",",2,99)
"RTN","HMPDJ00",81,0)
 S PAT("ssn")=$P(VADM(2),U),PAT("localId")=DFN
"RTN","HMPDJ00",82,0)
 S PAT("uid")=$$SETUID^HMPUTILS("patient",DFN,DFN)
"RTN","HMPDJ00",83,0)
 S:$D(VA("BID")) PAT("briefId")=$E(X)_VA("BID")
"RTN","HMPDJ00",84,0)
 S X=+$P($P(VADM(3),U),"."),PAT("birthDate")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ00",85,0)
 S X=$P(VADM(5),U) S:X="" X="UNK"
"RTN","HMPDJ00",86,0)
 S PAT("genderCode")="urn:va:pat-gender:"_X,PAT("genderName")=$$NAME(X,"gender")
"RTN","HMPDJ00",87,0)
 S X=+$P($P(VADM(6),U),".") S:X PAT("deceased")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ00",88,0)
 D PTSEC^DGSEC4(.LST,DFN)  ; DBIA 3027 DE2818 - PB 30 Oct 2015 changed to use a global reference covered by an active ICR
"RTN","HMPDJ00",89,0)
 S PAT("sensitive")=$$BOOL(LST(1))
"RTN","HMPDJ00",90,0)
 S X=+VADM(9) S:X PAT("religionCode")="urn:va:pat-religion:"_X,PAT("religionName")=$$NAME(X,"religion")
"RTN","HMPDJ00",91,0)
 S X=$P(VADM(10),U,2) I $L(X) D
"RTN","HMPDJ00",92,0)
 . S X=$E(X),X=$S(X="S":"L",X="N":"S",1:X)
"RTN","HMPDJ00",93,0)
 . S PAT("maritalStatusCode")="urn:va:pat-maritalStatus:"_X
"RTN","HMPDJ00",94,0)
 . S PAT("maritalStatusName")=$$NAME(X,"maritalStatus")
"RTN","HMPDJ00",95,0)
 I VADM(11) S I=0 F  S I=$O(VADM(11,I)) Q:I<1  D
"RTN","HMPDJ00",96,0)
 . S X=+VADM(11,I)
"RTN","HMPDJ00",97,0)
 . S PAT("ethnicity",X,"code")=$$GET1^DIQ(2.06,X_","_DFN_",",".01:3")
"RTN","HMPDJ00",98,0)
 I VADM(12) S I=0 F  S I=$O(VADM(12,I)) Q:I<1  D
"RTN","HMPDJ00",99,0)
 . S X=+VADM(12,I)
"RTN","HMPDJ00",100,0)
 . S PAT("race",X,"code")=$$GET1^DIQ(2.02,X_","_DFN_",",".01:3")
"RTN","HMPDJ00",101,0)
 Q
"RTN","HMPDJ00",102,0)
 ;
"RTN","HMPDJ00",103,0)
SVC ;-service data
"RTN","HMPDJ00",104,0)
 N VAEL,VASV,VAERR,X,Y,I,P,AO,IR,PGF,HNC,MST,CV,HMPSC
"RTN","HMPDJ00",105,0)
 D 7^VADPT
"RTN","HMPDJ00",106,0)
 S PAT("veteran")=$$BOOL(VAEL(4))
"RTN","HMPDJ00",107,0)
 S PAT("serviceConnected")=$$BOOL(+VAEL(3)) I VAEL(3) D
"RTN","HMPDJ00",108,0)
 . S PAT("scPercent")=+$P(VAEL(3),U,2)
"RTN","HMPDJ00",109,0)
 . D GETS^DIQ(2,DFN_",",".3731*",,"HMPSC")
"RTN","HMPDJ00",110,0)
 . S I="" F  S I=$O(HMPSC(2.05,I)) Q:I=""  D
"RTN","HMPDJ00",111,0)
 .. S PAT("scCondition",+I,"name")=HMPSC(2.05,I,.01)
"RTN","HMPDJ00",112,0)
 .. S PAT("scCondition",+I,"scPercent")=HMPSC(2.05,I,.02)
"RTN","HMPDJ00",113,0)
 S X=+$G(^DPT(DFN,"LR")) S:X PAT("lrdfn")=X
"RTN","HMPDJ00",114,0)
 I VAEL(9)]"" S PAT("meanStatus")=$P(VAEL(9),U,2)
"RTN","HMPDJ00",115,0)
 ;
"RTN","HMPDJ00",116,0)
 ; exposures
"RTN","HMPDJ00",117,0)
 ;Agent Orange
"RTN","HMPDJ00",118,0)
 S EXPVAL=$S(VASV(2):"Yes",VASV(2)=0:"No",1:"Unknown"),PAT("exposure",1,"uid")="urn:va:agent-orange:"_$E(EXPVAL),PAT("exposure",1,"name")=EXPVAL
"RTN","HMPDJ00",119,0)
 ;Ionizing Radiation
"RTN","HMPDJ00",120,0)
 S EXPVAL=$S(VASV(3):"Yes",VASV(3)=0:"No",1:"Unknown"),PAT("exposure",2,"uid")="urn:va:ionizing-radiation:"_$E(EXPVAL),PAT("exposure",2,"name")=EXPVAL
"RTN","HMPDJ00",121,0)
 ;SW Asia/Persian Gulf
"RTN","HMPDJ00",122,0)
 ;DE3917 - CPRS does not use the OIF/OEF fields to determine PGF/SW Asia exposure, but, instead, per VADPT^GMPLX1
"RTN","HMPDJ00",123,0)
 ;(called by ORQQPL INIT PT), directly gets the data from the #.32201 (PERSIAN GULF SERVICE?) field in the PATIENT file.
"RTN","HMPDJ00",124,0)
 S EXPVAL=$$GET1^DIQ(2,DFN_",",".32201","E") S:EXPVAL="" EXPVAL="Unknown"
"RTN","HMPDJ00",125,0)
 S PAT("exposure",3,"uid")="urn:va:sw-asia:"_$E(EXPVAL),PAT("exposure",3,"name")=EXPVAL
"RTN","HMPDJ00",126,0)
 ;Head-Neck Cancer
"RTN","HMPDJ00",127,0)
 S X=$$GETCUR^DGNTAPI(DFN,"HNC"),X=+($G(HNC("STAT"))),X=$S(X=4:1,X=5:1,X=1:0,X=6:0,1:"")
"RTN","HMPDJ00",128,0)
 S EXPVAL=$S(X:"Yes",X=0:"No",1:"Unknown"),PAT("exposure",4,"uid")="urn:va:head-neck-cancer:"_$E(EXPVAL),PAT("exposure",4,"name")=EXPVAL
"RTN","HMPDJ00",129,0)
 ;Military Sexual Trauma
"RTN","HMPDJ00",130,0)
 S X=$P($$GETSTAT^DGMSTAPI(DFN),U,2),EXPVAL=$S(X="Y":"Yes",X="N":"No",1:"Unknown")
"RTN","HMPDJ00",131,0)
 S PAT("exposure",5,"uid")="urn:va:mst:"_$E(EXPVAL),PAT("exposure",5,"name")=EXPVAL
"RTN","HMPDJ00",132,0)
 ;Combat Vet
"RTN","HMPDJ00",133,0)
 S X=$$CVEDT^DGCV(DFN),X=$S(+X<0:"",+X=0:0,$P(X,U,3):1,1:0)
"RTN","HMPDJ00",134,0)
 S EXPVAL=$S(X:"Yes",X=0:"No",1:"Unknown"),PAT("exposure",6,"uid")="urn:va:combat-vet:"_$E(EXPVAL),PAT("exposure",6,"name")=EXPVAL
"RTN","HMPDJ00",135,0)
 ;Shipboard Hazard And Defense
"RTN","HMPDJ00",136,0)
 S EXPVAL=$S(VASV(14):"Yes",VASV(14)=0:"No",1:"Unknown"),PAT("exposure",7,"uid")="urn:va:shipboard-hazard:"_$E(EXPVAL),PAT("exposure",7,"name")=EXPVAL
"RTN","HMPDJ00",137,0)
 ;
"RTN","HMPDJ00",138,0)
 ; rated disabilities [DGRPDB]
"RTN","HMPDJ00",139,0)
 N HMPDIS,DIS,NM,DX
"RTN","HMPDJ00",140,0)
 D RDIS^DGRPDB(DFN,.HMPDIS)
"RTN","HMPDJ00",141,0)
 S I=0 F  S I=$O(HMPDIS(I)) Q:I<1  D
"RTN","HMPDJ00",142,0)
 . S DIS=HMPDIS(I)
"RTN","HMPDJ00",143,0)
 . S NM=$$GET1^DIQ(31,+DIS_",",.01),DX=$$GET1^DIQ(31,+DIS_",",2)
"RTN","HMPDJ00",144,0)
 . S PAT("disability",+DX,"name")=NM
"RTN","HMPDJ00",145,0)
 . S PAT("disability",+DX,"disPercent")=$P(DIS,U,2)
"RTN","HMPDJ00",146,0)
 . S PAT("disability",+DX,"serviceConnected")=$$BOOL($P(DIS,U,3))
"RTN","HMPDJ00",147,0)
 Q
"RTN","HMPDJ00",148,0)
 ;
"RTN","HMPDJ00",149,0)
PRF ;-patient record flags
"RTN","HMPDJ00",150,0)
 N HMPF,I,N,X
"RTN","HMPDJ00",151,0)
 S X=$$GETACT^DGPFAPI(DFN,"HMPF")
"RTN","HMPDJ00",152,0)
 S I=0 F  S I=$O(HMPF(I)) Q:I<1  D
"RTN","HMPDJ00",153,0)
 . S PAT("patientRecordFlag",I,"assignmentStatus")="Active"
"RTN","HMPDJ00",154,0)
 . S PAT("patientRecordFlag",I,"assignTS")=$$JSONDT^HMPUTILS($P($G(HMPF(I,"ASSIGNDT")),U))
"RTN","HMPDJ00",155,0)
 . S PAT("patientRecordFlag",I,"approved")=$P($G(HMPF(I,"APPRVBY")),U,2)
"RTN","HMPDJ00",156,0)
 . S PAT("patientRecordFlag",I,"nextReviewDT")=$$JSONDT^HMPUTILS($P($G(HMPF(I,"REVIEWDT")),U))
"RTN","HMPDJ00",157,0)
 . S PAT("patientRecordFlag",I,"name")=$P($G(HMPF(I,"FLAG")),U,2)
"RTN","HMPDJ00",158,0)
 . S PAT("patientRecordFlag",I,"type")=$P($G(HMPF(I,"FLAGTYPE")),U,2)
"RTN","HMPDJ00",159,0)
 . S PAT("patientRecordFlag",I,"category")=$P($G(HMPF(I,"CATEGORY")),U,2)
"RTN","HMPDJ00",160,0)
 . S PAT("patientRecordFlag",I,"ownerSite")=$P($G(HMPF(I,"OWNER")),U,2)
"RTN","HMPDJ00",161,0)
 . S PAT("patientRecordFlag",I,"originatingSite")=$P($G(HMPF(I,"ORIGSITE")),U,2)
"RTN","HMPDJ00",162,0)
 . S N=1,X=$G(HMPF(I,"NARR",1,0))
"RTN","HMPDJ00",163,0)
 . F  S N=$O(HMPF(I,"NARR",N)) Q:N<1  S X=X_$C(13,10)_$G(HMPF(I,"NARR",N,0))
"RTN","HMPDJ00",164,0)
 . S PAT("patientRecordFlag",I,"text")=X
"RTN","HMPDJ00",165,0)
 S X=$$CWAD^ORQPT2(DFN)
"RTN","HMPDJ00",166,0)
 I X]"" S PAT("cwadf")=X
"RTN","HMPDJ00",167,0)
 I $D(PAT("patientRecordFlag")) S PAT("cwadf")=$G(PAT("cwadf"))_"F"
"RTN","HMPDJ00",168,0)
 Q
"RTN","HMPDJ00",169,0)
 ;
"RTN","HMPDJ00",170,0)
ATC ;-address & telecom
"RTN","HMPDJ00",171,0)
 N VAPA,CNT,X,I,P,NM
"RTN","HMPDJ00",172,0)
 ; VAPA("P")="" ;permanent address
"RTN","HMPDJ00",173,0)
 D ADD^VADPT S CNT=0 I $$VAPA(1,5) D
"RTN","HMPDJ00",174,0)
 . S CNT=CNT+1
"RTN","HMPDJ00",175,0)
 . D ADD(1,2,3,4,5,11,9,10)
"RTN","HMPDJ00",176,0)
 . S PAT("address",CNT,"use")=$S($L(VAPA(9)):"TMP",1:"H")
"RTN","HMPDJ00",177,0)
 I VAPA(12) D   ;confidential address
"RTN","HMPDJ00",178,0)
 . S CNT=CNT+1
"RTN","HMPDJ00",179,0)
 . D ADD(13,14,15,16,17,18,20,21)
"RTN","HMPDJ00",180,0)
 . S PAT("address",CNT,"use")="CONF"
"RTN","HMPDJ00",181,0)
 . S I=0 F  S I=$O(VAPA(22,I)) Q:I=""  S X=VAPA(22,I) D
"RTN","HMPDJ00",182,0)
 .. S PAT("address",CNT,"category",I,"name")=$P(X,U,2)
"RTN","HMPDJ00",183,0)
 .. S PAT("address",CNT,"category",I,"status")=$$BOOL($P(X,U,3))
"RTN","HMPDJ00",184,0)
 ; 
"RTN","HMPDJ00",185,0)
 ; X=home^cell^work phones
"RTN","HMPDJ00",186,0)
 S X=$$FORMAT(VAPA(8))_U_$$FORMAT($$GET1^DIQ(2,DFN_",",.134))_U_$$FORMAT($$GET1^DIQ(2,DFN_",",.132))
"RTN","HMPDJ00",187,0)
 S NM="H^MC^WP" F P=1:1:3 I $L($P(X,U,P)) D
"RTN","HMPDJ00",188,0)
 . S I=$P(NM,U,P),PAT("telecom",P,"use")=I
"RTN","HMPDJ00",189,0)
 . S PAT("telecom",P,"value")=$P(X,U,P)
"RTN","HMPDJ00",190,0)
 S X=$P($G(^DPT(DFN,.13)),U,3) S:X'="" PAT("email")=X
"RTN","HMPDJ00",191,0)
 I +$P($G(^DPT(DFN,.11)),U,16)>0 S PAT("badAddress")=$$GET1^DIQ(2,DFN_",",.121)
"RTN","HMPDJ00",192,0)
 Q
"RTN","HMPDJ00",193,0)
 ;
"RTN","HMPDJ00",194,0)
ADD(LINE1,LINE2,LINE3,CITY,STATE,ZIP,START,STOP) ; -- address set
"RTN","HMPDJ00",195,0)
 S:$L(VAPA(LINE1)) PAT("address",CNT,"line1")=VAPA(LINE1)
"RTN","HMPDJ00",196,0)
 S:$L(VAPA(LINE2)) PAT("address",CNT,"line2")=VAPA(LINE2)
"RTN","HMPDJ00",197,0)
 S:$L(VAPA(LINE3)) PAT("address",CNT,"line3")=VAPA(LINE3)
"RTN","HMPDJ00",198,0)
 S:$L(VAPA(CITY)) PAT("address",CNT,"city")=VAPA(CITY)
"RTN","HMPDJ00",199,0)
 S X=$P(VAPA(STATE),U) S:X PAT("address",CNT,"state")=$$GET1^DIQ(5,+X_",",1)
"RTN","HMPDJ00",200,0)
 S X=$P(VAPA(ZIP),U,2) S:$L(X) PAT("address",CNT,"zip")=X
"RTN","HMPDJ00",201,0)
 S X=+VAPA(START) S:X PAT("address",CNT,"start")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ00",202,0)
 S X=+VAPA(STOP) S:X PAT("address",CNT,"end")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ00",203,0)
 Q
"RTN","HMPDJ00",204,0)
 ;
"RTN","HMPDJ00",205,0)
VAPA(BEG,END) ; -- VAPA nodes have data?
"RTN","HMPDJ00",206,0)
 N I,Y S Y=0
"RTN","HMPDJ00",207,0)
 F I=BEG:1:END I $L($G(VAPA(I))) S Y=1 Q
"RTN","HMPDJ00",208,0)
 Q Y
"RTN","HMPDJ00",209,0)
 ;
"RTN","HMPDJ00",210,0)
SUPP ;-support contacts
"RTN","HMPDJ00",211,0)
 N VAOA,A,I,X,TYPE,S
"RTN","HMPDJ00",212,0)
 S S=0 F A="",1 K VAOA D
"RTN","HMPDJ00",213,0)
 . S:A VAOA("A")=A D OAD^VADPT Q:'$L($G(VAOA(9)))
"RTN","HMPDJ00",214,0)
 . S S=S+1,TYPE=$S(A=1:"ECON^Emergency Contact",1:"NOK^Next of Kin")
"RTN","HMPDJ00",215,0)
 . S PAT("contact",S,"typeCode")="urn:va:pat-contact:"_$P(TYPE,U)
"RTN","HMPDJ00",216,0)
 . S PAT("contact",S,"typeName")=$P(TYPE,U,2)
"RTN","HMPDJ00",217,0)
 . S:$L(VAOA(9)) PAT("contact",S,"name")=VAOA(9)
"RTN","HMPDJ00",218,0)
 . S:$L(VAOA(10)) PAT("contact",S,"relationship")=VAOA(10)
"RTN","HMPDJ00",219,0)
 . S:$L(VAOA(1)) PAT("contact",S,"address",1,"line1")=VAOA(1)
"RTN","HMPDJ00",220,0)
 . S:$L(VAOA(2)) PAT("contact",S,"address",1,"line2")=VAOA(2)
"RTN","HMPDJ00",221,0)
 . S:$L(VAOA(3)) PAT("contact",S,"address",1,"line3")=VAOA(3)
"RTN","HMPDJ00",222,0)
 . S:$L(VAOA(4)) PAT("contact",S,"address",1,"city")=VAOA(4)
"RTN","HMPDJ00",223,0)
 . S X=$P(VAOA(5),U) S:X PAT("contact",S,"address",1,"state")=$$GET1^DIQ(5,+X_",",1)
"RTN","HMPDJ00",224,0)
 . S X=$P(VAOA(11),U,2) S:$L(X) PAT("contact",S,"address",1,"zip")=X
"RTN","HMPDJ00",225,0)
 . S I=$S(A=1:.33011,1:.21011),X=$$FORMAT(VAOA(8))_U_U_$$FORMAT($$GET1^DIQ(2,DFN_",",I))
"RTN","HMPDJ00",226,0)
 . ; X=home^cell^work phones
"RTN","HMPDJ00",227,0)
 . S NM="H^MC^WP" F P=1:1:3 I $L($P(X,U,P)) D
"RTN","HMPDJ00",228,0)
 .. S I=$P(NM,U,P),PAT("contact",S,"telecom",P,"use")=I
"RTN","HMPDJ00",229,0)
 .. S PAT("contact",S,"telecom",P,"value")=$P(X,U,P)
"RTN","HMPDJ00",230,0)
 Q
"RTN","HMPDJ00",231,0)
 ;
"RTN","HMPDJ00",232,0)
ALIAS ;-other names used
"RTN","HMPDJ00",233,0)
 N I,X
"RTN","HMPDJ00",234,0)
 S I=0 F  S I=$O(^DPT(DFN,.01,I)) Q:I<1  S X=$G(^(I,0)) D
"RTN","HMPDJ00",235,0)
 . S PAT("alias",I,"fullName")=$P(X,U)
"RTN","HMPDJ00",236,0)
 Q
"RTN","HMPDJ00",237,0)
 ;
"RTN","HMPDJ00",238,0)
FAC ;-treating facilities [see FACLIST^ORWCIRN]
"RTN","HMPDJ00",239,0)
 N IFN S DFN=+$G(DFN) Q:DFN<1
"RTN","HMPDJ00",240,0)
 N HMPY,HOME,LAST,I,X,IEN,VASITE
"RTN","HMPDJ00",241,0)
 S X=$$ALL^VASITE ;VASITE(stn#)=stn# for all local
"RTN","HMPDJ00",242,0)
 I $L($T(TFL^VAFCTFU1)) D TFL^VAFCTFU1(.HMPY,DFN)
"RTN","HMPDJ00",243,0)
 S HOME=+$P($G(^DPT(DFN,"MPI")),U,3) ;home facility
"RTN","HMPDJ00",244,0)
 I $P($G(HMPY(1)),U)<0 D  ;not setup
"RTN","HMPDJ00",245,0)
 . S X=$O(^AUPNVSIT("AA",DFN,0)),LAST=$S(X:9999999-$P(X,"."),1:"")
"RTN","HMPDJ00",246,0)
 . S X=$$SITE^VASITE
"RTN","HMPDJ00",247,0)
 . S HMPY(1)=$P(X,U,3)_U_$P(X,U,2)_U_LAST_U_$$GET1^DIQ(4,+X_",",60)
"RTN","HMPDJ00",248,0)
 S I=0 F  S I=$O(HMPY(I)) Q:I<1  D
"RTN","HMPDJ00",249,0)
 . S X=HMPY(I) Q:$P(X,U)=""  ;unknown
"RTN","HMPDJ00",250,0)
 . S IEN=+$$IEN^XUAF4($P(X,U))
"RTN","HMPDJ00",251,0)
 . I +X=776!(+X=200) S $P(X,U,2)="DEPT. OF DEFENSE"
"RTN","HMPDJ00",252,0)
 . S PAT("facility",I,"code")=$P(X,U)    ;stn#
"RTN","HMPDJ00",253,0)
 . S PAT("facility",I,"name")=$P(X,U,2)  ;name
"RTN","HMPDJ00",254,0)
 . S:IEN=HOME PAT("facility",I,"homeSite")="true"
"RTN","HMPDJ00",255,0)
 . S:$L($P(X,U,3)) PAT("facility",I,"latestDate")=$$JSONDT^HMPUTILS($P($P(X,U,3),"."))
"RTN","HMPDJ00",256,0)
 . I $D(VASITE(+X)) D
"RTN","HMPDJ00",257,0)
 .. S PAT("facility",I,"localPatientId")=DFN
"RTN","HMPDJ00",258,0)
 .. S PAT("facility",I,"systemId")=HMPSYS
"RTN","HMPDJ00",259,0)
 Q
"RTN","HMPDJ00",260,0)
 ;
"RTN","HMPDJ00",261,0)
PC ;-primary care assignments
"RTN","HMPDJ00",262,0)
 D GETPATTM^HMPCRPC1(.PAT,DFN)
"RTN","HMPDJ00",263,0)
 Q
"RTN","HMPDJ00",264,0)
 N X S X=$$OUTPTPR^SDUTL3(DFN) I X D
"RTN","HMPDJ00",265,0)
 . S PAT("pcProviderUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ00",266,0)
 . S PAT("pcProviderName")=$P(X,U,2)
"RTN","HMPDJ00",267,0)
 S X=$$OUTPTTM^SDUTL3(DFN) I X D
"RTN","HMPDJ00",268,0)
 . S PAT("pcTeamUid")=$$SETUID^HMPUTILS("team",,+X)
"RTN","HMPDJ00",269,0)
 . S PAT("pcTeamName")=$P(X,U,2)
"RTN","HMPDJ00",270,0)
 Q
"RTN","HMPDJ00",271,0)
 ;
"RTN","HMPDJ00",272,0)
INPT ;-inpatient information
"RTN","HMPDJ00",273,0)
 N ADM,X,Y,Z,I,HL,TS
"RTN","HMPDJ00",274,0)
 S ADM=+$G(^DPT(DFN,.105)) Q:ADM<1  ;current admission mvt
"RTN","HMPDJ00",275,0)
 S PAT("admissionUid")=$$SETUID^HMPUTILS("visit",DFN,"H"_ADM)
"RTN","HMPDJ00",276,0)
 S X=$P($G(^DPT(DFN,.101)),U) S:X]"" PAT("roomBed")=X
"RTN","HMPDJ00",277,0)
 S X=$P($G(^DPT(DFN,.1)),U) I X]"" D
"RTN","HMPDJ00",278,0)
 . S PAT("inpatientLocation")=X
"RTN","HMPDJ00",279,0)
 . S I=+$O(^DIC(42,"B",X,0)),HL=+$G(^DIC(42,I,44)) Q:HL<1
"RTN","HMPDJ00",280,0)
 . S X=$P($G(^SC(HL,0)),U,2) S:X]"" PAT("shortInpatientLocation")=X
"RTN","HMPDJ00",281,0)
 ;
"RTN","HMPDJ00",282,0)
 S TS=$G(^DPT(DFN,.103)) I TS D  ;treating specialty
"RTN","HMPDJ00",283,0)
 . S X=$$TSDATA^DGACT(45.7,+TS,.Y) Q:X<1
"RTN","HMPDJ00",284,0)
 . S PAT("specialty")=$G(Y(1)),X=""
"RTN","HMPDJ00",285,0)
 . I +$G(Y(2))>0 S X=$$TSDATA^DGACT(42.4,+Y(2),.Z)
"RTN","HMPDJ00",286,0)
 . I X>0,$G(Z(3))]"" S PAT("specialtyService")=$P(Z(3),U)
"RTN","HMPDJ00",287,0)
 Q
"RTN","HMPDJ00",288,0)
 ;
"RTN","HMPDJ00",289,0)
INS ;-insurance information
"RTN","HMPDJ00",290,0)
 N X,I,HMPX,HMPINS
"RTN","HMPDJ00",291,0)
 S X=$$INSUR^IBBAPI(DFN,,,.HMPX,"*") Q:X<1
"RTN","HMPDJ00",292,0)
 S I=0 F  S I=$O(HMPX("IBBAPI","INSUR",I)) Q:I<1  D
"RTN","HMPDJ00",293,0)
 . K HMPINS M HMPINS=HMPX("IBBAPI","INSUR",I)
"RTN","HMPDJ00",294,0)
 . S PAT("insurance",I,"id")=DFN_";"_+$G(HMPINS(1))_";"_+$G(HMPINS(8))
"RTN","HMPDJ00",295,0)
 . ; = DFN;COMPANY;POLICY
"RTN","HMPDJ00",296,0)
 . S PAT("insurance",I,"companyName")=$P(HMPINS(1),U,2)
"RTN","HMPDJ00",297,0)
 . ;DE942 - Convert effective and expiration dates to JSON format - TW
"RTN","HMPDJ00",298,0)
 . S:$G(HMPINS(10))]"" PAT("insurance",I,"effectiveDate")=$$JSONDT^HMPUTILS(HMPINS(10))
"RTN","HMPDJ00",299,0)
 . S:$G(HMPINS(11))]"" PAT("insurance",I,"expirationDate")=$$JSONDT^HMPUTILS(HMPINS(11))
"RTN","HMPDJ00",300,0)
 . S:$G(HMPINS(18))]"" PAT("insurance",I,"groupNumber")=HMPINS(18)
"RTN","HMPDJ00",301,0)
 . S:$G(HMPINS(21))]"" PAT("insurance",I,"policyType")=$P(HMPINS(21),U,2)
"RTN","HMPDJ00",302,0)
 . S X=$P($G(HMPINS(12)),U,2) S:X="PATIENT" X="SELF"
"RTN","HMPDJ00",303,0)
 . S:X]"" PAT("insurance",I,"policyHolder")=X
"RTN","HMPDJ00",304,0)
 Q
"RTN","HMPDJ00",305,0)
 ;
"RTN","HMPDJ00",306,0)
FORMAT(X) ; -- enforce (xxx)xxx-xxxx phone format
"RTN","HMPDJ00",307,0)
 S X=$G(X) I X?1"("3N1")"3N1"-"4N.E Q X
"RTN","HMPDJ00",308,0)
 N P,N,I,Y S P=""
"RTN","HMPDJ00",309,0)
 F I=1:1:$L(X) S N=$E(X,I) I N=+N S P=P_N
"RTN","HMPDJ00",310,0)
 S:$L(P)<10 P=$E("0000000000",1,10-$L(P))_P
"RTN","HMPDJ00",311,0)
 S Y=$S(P:"("_$E(P,1,3)_")"_$E(P,4,6)_"-"_$E(P,7,10),1:"")
"RTN","HMPDJ00",312,0)
 Q Y
"RTN","HMPDJ00",313,0)
 ;
"RTN","HMPDJ00",314,0)
NAME(CODE,SET) ; -- Return expanded name for code set
"RTN","HMPDJ00",315,0)
 N Y S Y="",CODE=$G(CODE)
"RTN","HMPDJ00",316,0)
 I $G(SET)="gender" S Y=$S(CODE="F":"Female",CODE="M":"Male",1:"Unknown")
"RTN","HMPDJ00",317,0)
 I $G(SET)="maritalStatus" S Y=$S(CODE="D":"Divorced",CODE="M":"Married",CODE="W":"Widowed",CODE="L":"Legally Separated",CODE="S":"Never Married",1:"Unknown")
"RTN","HMPDJ00",318,0)
 I $G(SET)="religion" S Y=$$GET1^DIQ(13,CODE_",",.01)
"RTN","HMPDJ00",319,0)
 Q Y
"RTN","HMPDJ00",320,0)
 ;
"RTN","HMPDJ00",321,0)
BOOL(X) ;
"RTN","HMPDJ00",322,0)
 I X>0 Q "true"
"RTN","HMPDJ00",323,0)
 S X=$E(X) I X="Y"!(X="y") Q "true"
"RTN","HMPDJ00",324,0)
 Q "false"
"RTN","HMPDJ01")
0^5^B96911634
"RTN","HMPDJ01",1,0)
HMPDJ01 ;SLC/MKB,ASMR/MBS -- Orders ;Apr 15, 2016 09:18:55
"RTN","HMPDJ01",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ01",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ01",4,0)
 ;
"RTN","HMPDJ01",5,0)
 ; External References          ICR
"RTN","HMPDJ01",6,0)
 ; -------------------          -----
"RTN","HMPDJ01",7,0)
 ; ^DPT                         10035
"RTN","HMPDJ01",8,0)
 ; ^OR(100                       5771
"RTN","HMPDJ01",9,0)
 ; ^ORA(102.4                    5769
"RTN","HMPDJ01",10,0)
 ; ^ORD(100.98                    873
"RTN","HMPDJ01",11,0)
 ; ^PXRMINDX                     4290
"RTN","HMPDJ01",12,0)
 ; ^RADPT                        2480
"RTN","HMPDJ01",13,0)
 ; ^SC                          10040
"RTN","HMPDJ01",14,0)
 ; ^VA(200                      10060
"RTN","HMPDJ01",15,0)
 ; DIC                           2051
"RTN","HMPDJ01",16,0)
 ; DIQ                           2056
"RTN","HMPDJ01",17,0)
 ; GMRCGUIB                      2980
"RTN","HMPDJ01",18,0)
 ; LR7OU1                        2955
"RTN","HMPDJ01",19,0)
 ; ORQ1,^TMP("ORR"               3154
"RTN","HMPDJ01",20,0)
 ; ORQ12,^TMP("ORR"              5704
"RTN","HMPDJ01",21,0)
 ; ORX8                          2467
"RTN","HMPDJ01",22,0)
 ; PSS51P1                       4546
"RTN","HMPDJ01",23,0)
 ;
"RTN","HMPDJ01",24,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ01",25,0)
 Q
"RTN","HMPDJ01",26,0)
 ;
"RTN","HMPDJ01",27,0)
OR1(ID) ; -- order ID >> ^TMP("ORR",$J,ORLIST,HMPN)
"RTN","HMPDJ01",28,0)
 N ORDER,CHILD,HMPC
"RTN","HMPDJ01",29,0)
 D ORX(ID,.ORDER)
"RTN","HMPDJ01",30,0)
 ;DE2818, ^OR(100) - ICR 5771
"RTN","HMPDJ01",31,0)
 S HMPC=0 F  S HMPC=$O(^OR(100,ID,2,HMPC)) Q:HMPC<1  D
"RTN","HMPDJ01",32,0)
 . K CHILD D ORX(HMPC,.CHILD)
"RTN","HMPDJ01",33,0)
 . M ORDER("children",HMPC)=CHILD
"RTN","HMPDJ01",34,0)
 S ORDER("lastUpdateTime")=$$EN^HMPSTMP("order") ;RHL 20141231
"RTN","HMPDJ01",35,0)
 S ORDER("stampTime")=ORDER("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ01",36,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ01",37,0)
 I $G(HMPMETA) D ADD^HMPMETA("order",ORDER("uid"),ORDER("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ01",38,0)
 D ADD^HMPDJ("ORDER","order")
"RTN","HMPDJ01",39,0)
 Q
"RTN","HMPDJ01",40,0)
ORX(IFN,ORD) ; -- extract order IFN into ORD("attribute")
"RTN","HMPDJ01",41,0)
 N DA,HDFN,I,LOC,ORDSTAT,ORLIST,ORLST,X,X0,X8
"RTN","HMPDJ01",42,0)
 S ORLST=$S(+$G(HMPN):HMPN-1,1:0) S:'$D(ORLIST) ORLIST=$H
"RTN","HMPDJ01",43,0)
 D GET^ORQ12(IFN,ORLIST,1)  ; this modifies ^TMP("ORR",$J)
"RTN","HMPDJ01",44,0)
 S X0=$G(^TMP("ORR",$J,ORLIST,ORLST))
"RTN","HMPDJ01",45,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ01",46,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ01",47,0)
 S ERRMSG="A problem occurred converting record "_IFN_" for the orders domain"
"RTN","HMPDJ01",48,0)
 ;
"RTN","HMPDJ01",49,0)
 S ORD("localId")=IFN,ORD("uid")=$$SETUID^HMPUTILS("order",DFN,IFN)
"RTN","HMPDJ01",50,0)
 S X=$$OI^ORX8(+X0) I $L(X) D
"RTN","HMPDJ01",51,0)
 . N ARRAY,NAME
"RTN","HMPDJ01",52,0)
 . S ARRAY("Code")=1_U_"oi",ARRAY("Name")=2,ARRAY("PackageRef")=3
"RTN","HMPDJ01",53,0)
 . D SPLITVAL^HMPUTILS(X,.ARRAY) S ORD("name")=ARRAY("Name")
"RTN","HMPDJ01",54,0)
 . S NAME="" F  S NAME=$O(ARRAY(NAME)) Q:NAME=""  S ORD("oi"_NAME)=$G(ARRAY(NAME))
"RTN","HMPDJ01",55,0)
 S ORD("displayGroup")=$P(X0,U,2)
"RTN","HMPDJ01",56,0)
 S ORD("entered")=$$JSONDT^HMPUTILS($P(X0,U,3))
"RTN","HMPDJ01",57,0)
 S ORD("start")=$$JSONDT^HMPUTILS($P(X0,U,4)),ORD("stop")=$$JSONDT^HMPUTILS($P(X0,U,5))  ;US10045, DE3054
"RTN","HMPDJ01",58,0)
 S ORD("statusCode")="urn:va:order-status:"_$P(X0,U,7)
"RTN","HMPDJ01",59,0)
 S ORD("statusName")=$P(X0,U,6)
"RTN","HMPDJ01",60,0)
 S ORD("statusVuid")="urn:va:vuid:"_$$STS^HMPDOR($P(X0,U,7))
"RTN","HMPDJ01",61,0)
 D SETTEXT^HMPUTILS($NA(^TMP("ORR",$J,ORLIST,ORLST,"TX")),$NA(^TMP("HMPTEXT",$J,IFN)))
"RTN","HMPDJ01",62,0)
 M ORD("content","\")=^TMP("HMPTEXT",$J,IFN)
"RTN","HMPDJ01",63,0)
 ; DE3504 - Jan 18, 2016, added the code for US10045 below
"RTN","HMPDJ01",64,0)
 ; US10045 - PB Dec 7, 2015 if ORDER is saved, signed, discontinued, then ORDER is unsigned
"RTN","HMPDJ01",65,0)
 S HDFN=+$P($G(^OR(100,+IFN,0)),U,2)
"RTN","HMPDJ01",66,0)
 S ORDSTAT=$$ORDACT(HDFN,+IFN) I ORDSTAT="DC" D
"RTN","HMPDJ01",67,0)
 . ; DE3777 - March 15, 2016 - Modified the statusName to "UNRELEASED" for the  order to match the status
"RTN","HMPDJ01",68,0)
 . ;  that appears in CPRS if the ORDER was DISCONTINUED and is UNSIGNED
"RTN","HMPDJ01",69,0)
 . N HDC,HDCRSN,HMPORACT,HPTR,HSIGN
"RTN","HMPDJ01",70,0)
 . S HDC=$O(^OR(100,IFN,8,"C","DC","")),HSIGN="" Q:'(HDC>0)
"RTN","HMPDJ01",71,0)
 . S HMPORACT=$G(^OR(100,IFN,8,HDC,0))
"RTN","HMPDJ01",72,0)
 . ; The 15th piece of HMPORACT is the RELEASE STATUS - '11' FOR unreleased
"RTN","HMPDJ01",73,0)
 . I $P(HMPORACT,U,15)=11 S ORD("statusName")="UNRELEASED",ORD("statusCode")="urn:va:order-status:unr"
"RTN","HMPDJ01",74,0)
 . S:$P($G(HMPORACT),U,4)=2 HSIGN="*UNSIGNED*"
"RTN","HMPDJ01",75,0)
 . S HPTR=+$P($G(^OR(100,IFN,6)),U,4),HDCRSN=$P($G(^ORD(100.03,HPTR,0)),U)  ;Combined fixes Mar 16, 2016 DE3777 CK - PB - DE4027
"RTN","HMPDJ01",76,0)
 . I $L(HDCRSN) S ORD("content","\",2)=" <"_$G(HDCRSN)_"> "_HSIGN  ; add DC order not signed in JSON object
"RTN","HMPDJ01",77,0)
 . ; DE3777 - end of changes
"RTN","HMPDJ01",78,0)
 ;
"RTN","HMPDJ01",79,0)
 S X=$$GET1^DIQ(100,IFN_",",1,"I") I X D
"RTN","HMPDJ01",80,0)
 . S ORD("providerUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ01",81,0)
 . S ORD("providerName")=$$GET1^DIQ(200,X_",",.01)  ;DE2818, ICR 10060
"RTN","HMPDJ01",82,0)
 S LOC=+$$GET1^DIQ(100,IFN_",",6,"I"),FAC=$$FAC^HMPD(LOC) I LOC D
"RTN","HMPDJ01",83,0)
 . S ORD("locationName")=$$GET1^DIQ(44,LOC_",",.01)  ;DE2818, ICR 10040
"RTN","HMPDJ01",84,0)
 . S ORD("locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ01",85,0)
 D FACILITY^HMPUTILS(FAC,"ORD")
"RTN","HMPDJ01",86,0)
 S ORD("service")=$$GET1^DIQ(100,IFN_",","12:1")
"RTN","HMPDJ01",87,0)
 S X=$$GET1^DIQ(100,IFN_",",9,"I") S:X ORD("predecessor")=$$SETUID^HMPUTILS("order",DFN,+X)
"RTN","HMPDJ01",88,0)
 S X=$$GET1^DIQ(100,IFN_",",9.1,"I") S:X ORD("successor")=$$SETUID^HMPUTILS("order",DFN,+X)
"RTN","HMPDJ01",89,0)
 D RESULTS
"RTN","HMPDJ01",90,0)
 ; US11945 - Get parent and child orders for order
"RTN","HMPDJ01",91,0)
 D KIN
"RTN","HMPDJ01",92,0)
 ; sign/verify
"RTN","HMPDJ01",93,0)
 ;US10045 modifications to get signed, verified and reviewed datetime stamp from HMP(800000
"RTN","HMPDJ01",94,0)
 N C,HMUSR,HMORIN,HMPFND,HMPUF,HMSRVR,HPROV,HX8,ORFLG,ORIFN,ORIN ; US11894 Dec 18, 2015 - added variables used by Order Flag and Unflag
"RTN","HMPDJ01",95,0)
 D  ; US11894 Dec 18, 2015 - Order flagged and unflagged added to JSON
"RTN","HMPDJ01",96,0)
 . S C=0,HMORIN=0  ; C = count for JSON object, HMORIN = IEN in sub-file
"RTN","HMPDJ01",97,0)
 . S HMSRVR=$$SRVRNO^HMPOR(HDFN) Q:'HMSRVR  ; if 'HMSRVR then not subscribed
"RTN","HMPDJ01",98,0)
 . ; DE3584 Feb 1, 2016 - begin
"RTN","HMPDJ01",99,0)
 . I '$D(^HMP(800000,HMSRVR,1,HDFN,1,IFN)) D  ; orders not in HMP(800000) add them
"RTN","HMPDJ01",100,0)
 ..  N HMVALS,RSLT  ; HMVALS = fields to update in 800000.14
"RTN","HMPDJ01",101,0)
 ..  D ORDRVALS^HMPOR(.HMVALS,IFN)  ; get fields from ORDER file and map to HMP fields
"RTN","HMPDJ01",102,0)
 ..  Q:'$O(HMVALS(0))  ; error setting up fields, HMVALS("ERR") will be defined
"RTN","HMPDJ01",103,0)
 ..  S HMVALS(1.01)=$$NOW^XLFDT  ; (#1.01) TRACKING START
"RTN","HMPDJ01",104,0)
 ..  D ADDORDR^HMPOR(.RSLT,.HMVALS,IFN,HDFN)  ; may want to log error if RSLT<0
"RTN","HMPDJ01",105,0)
 . ; DE3584 Feb 1, 2016 - end
"RTN","HMPDJ01",106,0)
 . F  S HMORIN=$O(^HMP(800000,HMSRVR,1,HDFN,1,IFN,2,HMORIN)) Q:'HMORIN  D
"RTN","HMPDJ01",107,0)
 ..  S C=C+1,HMPFND=$G(^HMP(800000,HMSRVR,1,HDFN,1,IFN,2,HMORIN,0))
"RTN","HMPDJ01",108,0)
 ..  S HMPUF=$P(HMPFND,U,2),HMPUF=$S(HMPUF="U":"Unflagged",1:"Flagged")
"RTN","HMPDJ01",109,0)
 ..  S ORD("orderFlags",C,"order"_HMPUF_"DateTime")=$$JSONDT^HMPUTILS($P(HMPFND,U))
"RTN","HMPDJ01",110,0)
 ..  S HMUSR=$P(HMPFND,U,3)
"RTN","HMPDJ01",111,0)
 ..  S ORD("orderFlags",C,"order"_HMPUF_"By")=$$GET1^DIQ(200,HMUSR_",",.01,"E")
"RTN","HMPDJ01",112,0)
 ..  S ORD("orderFlags",C,"order"_HMPUF_"Reason")=$P(HMPFND,U,4)
"RTN","HMPDJ01",113,0)
 ;
"RTN","HMPDJ01",114,0)
 I $D(^HMP(800000,HMSRVR,1,HDFN,1,IFN)) D  Q  ; check for existence of order in ^HMP(800000)
"RTN","HMPDJ01",115,0)
 . S I=0,HX8=$G(^HMP(800000,HMSRVR,1,HDFN,1,IFN,0)),HPROV=$P(HX8,U,3)
"RTN","HMPDJ01",116,0)
 . I HPROV'="" D USER(.I,"S",HPROV,$P(HX8,U,4))  ; get signed date/time
"RTN","HMPDJ01",117,0)
 . I $P(HX8,U,6) D USER(.I,"N",$P(HX8,U,5),$P(HX8,U,6))  ; order verified by a nurse get the timestamp
"RTN","HMPDJ01",118,0)
 . I $P(HX8,U,8) D USER(.I,"C",$P(HX8,U,7),$P(HX8,U,8))  ; order was verified by a clerk get the timestamp
"RTN","HMPDJ01",119,0)
 . I $P(HX8,U,10) D USER(.I,"R",$P(HX8,U,9),$P(HX8,U,10))  ;order was reviewed get the timestamp
"RTN","HMPDJ01",120,0)
 ;
"RTN","HMPDJ01",121,0)
 ; DE3504 - Jan 18, 2016, go to ORDER file to get data
"RTN","HMPDJ01",122,0)
 N ORACTION
"RTN","HMPDJ01",123,0)
 S (ORACTION,I)=0
"RTN","HMPDJ01",124,0)
 F  S ORACTION=$O(^OR(100,IFN,8,ORACTION)) Q:'ORACTION  D
"RTN","HMPDJ01",125,0)
 . S HX8=$G(^OR(100,IFN,8,ORACTION,0)) I $P(HX8,U,6) D  ; only if order is signed
"RTN","HMPDJ01",126,0)
 .. S HPROV=$P(HX8,U,5) S:HPROV<1 HPROV=$P(HX8,U,3)  ; signed by or provider
"RTN","HMPDJ01",127,0)
 .. D USER(.I,"S",HPROV,$P(HX8,U,6))  ; date/time signed
"RTN","HMPDJ01",128,0)
 .. I $P(HX8,U,9)  D USER(.I,"N",$P(HX8,U,8),$P(HX8,U,9))   ; verifying nurse and date/time
"RTN","HMPDJ01",129,0)
 .. I $P(HX8,U,11) D USER(.I,"C",$P(HX8,U,10),$P(HX8,U,11)) ; verifying clerk and date/time
"RTN","HMPDJ01",130,0)
 .. I $P(HX8,U,19) D USER(.I,"R",$P(HX8,U,18),$P(HX8,U,19)) ; chart reviewed by and date/time
"RTN","HMPDJ01",131,0)
 ;
"RTN","HMPDJ01",132,0)
 Q
"RTN","HMPDJ01",133,0)
 ;
"RTN","HMPDJ01",134,0)
KIN ; US11945 - Add parents/children (kin) to order
"RTN","HMPDJ01",135,0)
 N HMPNOJS,HMPORKIN,I
"RTN","HMPDJ01",136,0)
 S HMPNOJS=1 D RELATED^HMPORRPC(.HMPORKIN,IFN)
"RTN","HMPDJ01",137,0)
 S:$D(@HMPORKIN@("parent")) ORD("parentOrderUid")=$$SETUID^HMPUTILS("order",DFN,+@HMPORKIN@("parent"))
"RTN","HMPDJ01",138,0)
 S I="" F  S I=$O(@HMPORKIN@("children",I)) Q:I=""  D
"RTN","HMPDJ01",139,0)
 . S ORD("childrenOrderUids",I)=$$SETUID^HMPUTILS("order",DFN,+@HMPORKIN@("children",I))
"RTN","HMPDJ01",140,0)
 Q
"RTN","HMPDJ01",141,0)
RESULTS ; -- add ORD("results",n,"uid") list
"RTN","HMPDJ01",142,0)
 N ORPK,ORPKG,ORDG
"RTN","HMPDJ01",143,0)
 S ORPK=$G(^OR(100,IFN,4)),ORPKG=ORD("service"),ORDG=ORD("displayGroup")
"RTN","HMPDJ01",144,0)
 I ORPKG="GMRC" D  Q
"RTN","HMPDJ01",145,0)
 . N HMPD,I,N,X D DOCLIST^GMRCGUIB(.HMPD,+ORPK)  ; HMPD contains global references
"RTN","HMPDJ01",146,0)
 . S N=1,ORD("results",N,"uid")=$$SETUID^HMPUTILS("consult",DFN,+ORPK)
"RTN","HMPDJ01",147,0)
 . S I=0 F  S I=$O(HMPD(50,I)) Q:I<1  S X=$G(HMPD(50,I)) D
"RTN","HMPDJ01",148,0)
 .. Q:'$D(@(U_$P(X,";",2)_+X_")"))  ;text deleted
"RTN","HMPDJ01",149,0)
 .. S N=N+1,ORD("results",N,"uid")=$$SETUID^HMPUTILS("document",DFN,+X)
"RTN","HMPDJ01",150,0)
 . Q:ORDG'="PROC"
"RTN","HMPDJ01",151,0)
 . N HMPC D FIND^DIC(702,,"@","Q",+ORPK,,"ACON",,,"HMPC") ;CP
"RTN","HMPDJ01",152,0)
 . S I=0 F  S I=$O(HMPC("DILIST",2,I)) Q:I<1  D
"RTN","HMPDJ01",153,0)
 .. S X=+$G(HMPC("DILIST",2,I))_";MDD(702,"
"RTN","HMPDJ01",154,0)
 .. S N=N+1,ORD("results",N,"uid")=$$SETUID^HMPUTILS("procedure",DFN,X)
"RTN","HMPDJ01",155,0)
 I ORPKG="LR" D  Q
"RTN","HMPDJ01",156,0)
 . Q:$L(ORPK,";")'>3  ;no results yet, or parent order
"RTN","HMPDJ01",157,0)
 . N SUB,IDT,CDT,ITM,HMPT,ID,T,N,LRDFN,IDX
"RTN","HMPDJ01",158,0)
 . S SUB=$P(ORPK,";",4),IDT=$P(ORPK,";",5),CDT=9999999-IDT
"RTN","HMPDJ01",159,0)
 . I SUB="CH" D  Q
"RTN","HMPDJ01",160,0)
 .. S ITM=+$G(ORD("oiPackageRef")) D EXPAND^LR7OU1(ITM,.HMPT)
"RTN","HMPDJ01",161,0)
 .. S (T,N)=0 F  S T=$O(HMPT(T)) Q:T<1  S ID=$O(^PXRMINDX(63,"PI",DFN,T,CDT,"")) I $L(ID) S N=N+1,ORD("results",N,"uid")=$$SETUID^HMPUTILS("lab",DFN,$P(ID,";",2,9))
"RTN","HMPDJ01",162,0)
 . I SUB="MI" D  Q
"RTN","HMPDJ01",163,0)
 .. S ITM="M;A;",N=0,LRDFN=$$LRDFN^HMPXGLAB(DFN)  ;DE2818
"RTN","HMPDJ01",164,0)
 .. F  S ITM=$O(^PXRMINDX(63,"PI",DFN,ITM)) Q:$E(ITM,1,4)'="M;A;"  I $D(^(ITM,CDT)) D
"RTN","HMPDJ01",165,0)
 ... S IDX=LRDFN_";MI;"_IDT
"RTN","HMPDJ01",166,0)
 ... F  S IDX=$O(^PXRMINDX(63,"PI",DFN,ITM,CDT,IDX)) Q:IDX=""  S ID=$P(IDX,";",2,99),N=N+1,ORD("results",N,"uid")=$$SETUID^HMPUTILS("lab",DFN,ID)
"RTN","HMPDJ01",167,0)
 .. S N=N+1,ORD("results",N,"uid")=$$SETUID^HMPUTILS("document",DFN,SUB_";"_IDT)
"RTN","HMPDJ01",168,0)
 . ; SUB:"AP" [AU,CY,EM,SP]
"RTN","HMPDJ01",169,0)
 . S ORD("results",1,"uid")=$$SETUID^HMPUTILS("lab",DFN,SUB_";"_IDT)
"RTN","HMPDJ01",170,0)
 . S ORD("results",2,"uid")=$$SETUID^HMPUTILS("document",DFN,SUB_";"_IDT)
"RTN","HMPDJ01",171,0)
 I ORPKG["PS" D  Q
"RTN","HMPDJ01",172,0)
 . S:ORPK ORD("results",1,"uid")=$$SETUID^HMPUTILS("med",DFN,IFN)
"RTN","HMPDJ01",173,0)
 I ORPKG="RA" D  Q
"RTN","HMPDJ01",174,0)
 . N IDT,CN S IDT=+$O(^RADPT("AO",+ORPK,DFN,0)) Q:'IDT
"RTN","HMPDJ01",175,0)
 . S CN=0 F  S CN=$O(^RADPT("AO",+ORPK,DFN,IDT,CN)) Q:CN<1  S ORD("results",CN,"uid")=$$SETUID^HMPUTILS("image",DFN,IDT_"-"_CN)
"RTN","HMPDJ01",176,0)
 ; rest should be generic (OR) orders
"RTN","HMPDJ01",177,0)
 I ORDG="NTX" S ORD("results",1,"uid")=$$SETUID^HMPUTILS("treatment",DFN,IFN) Q
"RTN","HMPDJ01",178,0)
 I ORDG="V/M" Q  ;no link
"RTN","HMPDJ01",179,0)
 Q
"RTN","HMPDJ01",180,0)
 ;
"RTN","HMPDJ01",181,0)
NTX1(IFN) ; -- extract nursing treatment order IFN into NTX("attribute")
"RTN","HMPDJ01",182,0)
 N NTX,X
"RTN","HMPDJ01",183,0)
 D ORX(IFN,.NTX) ;get basic order info
"RTN","HMPDJ01",184,0)
 S NTX("orderUid")=NTX("uid")
"RTN","HMPDJ01",185,0)
 S NTX("uid")=$$SETUID^HMPUTILS("treatment",DFN,IFN)
"RTN","HMPDJ01",186,0)
 S X=$$VALUE^ORX8(IFN,"COMMENT") S:$L(X) NTX("instructions")=X
"RTN","HMPDJ01",187,0)
 S X=$$VALUE^ORX8(IFN,"SCHEDULE") I X D
"RTN","HMPDJ01",188,0)
 . D ZERO^PSS51P1(X,,,,"HMPS")
"RTN","HMPDJ01",189,0)
 . S NTX("scheduleName")=$G(^TMP($J,"HMPS",X,.01))
"RTN","HMPDJ01",190,0)
 . S NTX("adminTimes")=$G(^TMP($J,"HMPS",X,1))
"RTN","HMPDJ01",191,0)
 . K ^TMP($J,"HMPS")
"RTN","HMPDJ01",192,0)
 S NTX("lastUpdateTime")=$$EN^HMPSTMP("treatment") ;RHL 20141231
"RTN","HMPDJ01",193,0)
 S NTX("stampTime")=NTX("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ01",194,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ01",195,0)
 I $G(HMPMETA) D ADD^HMPMETA("treatment",NTX("uid"),NTX("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ01",196,0)
 D ADD^HMPDJ("NTX","treatment")
"RTN","HMPDJ01",197,0)
 Q
"RTN","HMPDJ01",198,0)
 ;
"RTN","HMPDJ01",199,0)
USER(N,ROLE,IEN,DATE) ; -- add signature/verification data
"RTN","HMPDJ01",200,0)
 S N=+$G(N)+1
"RTN","HMPDJ01",201,0)
 S ORD("clinicians",N,"signedDateTime")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ01",202,0)
 S ORD("clinicians",N,"role")=$G(ROLE)
"RTN","HMPDJ01",203,0)
 Q:+$G(IEN)<1
"RTN","HMPDJ01",204,0)
 S ORD("clinicians",N,"uid")=$$SETUID^HMPUTILS("user",,IEN)
"RTN","HMPDJ01",205,0)
 S ORD("clinicians",N,"name")=$$GET1^DIQ(200,IEN_",",.01)  ;DE2818, ICR 10060
"RTN","HMPDJ01",206,0)
 Q
"RTN","HMPDJ01",207,0)
 ;
"RTN","HMPDJ01",208,0)
ORDACT(HMPDFN,ORDRNUM) ; function, if patient and order are in HMP(800000) return status code, Jan 10, 2016 US10045, US11894
"RTN","HMPDJ01",209,0)
 N SRV S SRV=$$SRVRNO^HMPOR(HMPDFN)  ; server number for patient
"RTN","HMPDJ01",210,0)
 Q:'(SRV>0) ""  ; not found, return null
"RTN","HMPDJ01",211,0)
 Q $P($G(^HMP(800000,SRV,1,HMPDFN,1,ORDRNUM,0)),U,14)  ; ORDER ACTION returned
"RTN","HMPDJ01",212,0)
 ;
"RTN","HMPDJ01",213,0)
TM(X) ; -- strip seconds off a FM time
"RTN","HMPDJ01",214,0)
 N D,T,Y S D=$P(X,"."),T=$P(X,".",2)
"RTN","HMPDJ01",215,0)
 S Y=D_$S(T:"."_$E(T,1,4),1:"")
"RTN","HMPDJ01",216,0)
 S Y=$$JSONDT^HMPUTILS(Y)
"RTN","HMPDJ01",217,0)
 Q Y
"RTN","HMPDJ01",218,0)
 ;
"RTN","HMPDJ02")
0^6^B212781835
"RTN","HMPDJ02",1,0)
HMPDJ02 ;ASMR/MKB/JD,CK - Problems,Allergies,Vitals ;July 1, 2016 09:56:26
"RTN","HMPDJ02",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;Sep 01, 2011;Build 24
"RTN","HMPDJ02",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ02",4,0)
 ;
"RTN","HMPDJ02",5,0)
 ; External References          DBIA#
"RTN","HMPDJ02",6,0)
 ; -------------------          -----
"RTN","HMPDJ02",7,0)
 ; ^PXRMINDX                     4290
"RTN","HMPDJ02",8,0)
 ; ^SC                          10040
"RTN","HMPDJ02",9,0)
 ; DIC                           2051
"RTN","HMPDJ02",10,0)
 ; DIQ                           2056
"RTN","HMPDJ02",11,0)
 ; GMPLUTL2                      2741
"RTN","HMPDJ02",12,0)
 ; GMRADPT                      10099
"RTN","HMPDJ02",13,0)
 ; GMRAOR2                       2422
"RTN","HMPDJ02",14,0)
 ; GMRVUT0,^UTILITY($J           1446
"RTN","HMPDJ02",15,0)
 ; GMVGETQL                      5048
"RTN","HMPDJ02",16,0)
 ; GMVGETVT                      5047
"RTN","HMPDJ02",17,0)
 ; GMVUTL                        5046
"RTN","HMPDJ02",18,0)
 ; ICDCODE                       3990
"RTN","HMPDJ02",19,0)
 ; XLFSTR                       10104
"RTN","HMPDJ02",20,0)
 ; XUAF4                         2171
"RTN","HMPDJ02",21,0)
 ;
"RTN","HMPDJ02",22,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ02",23,0)
 ;
"RTN","HMPDJ02",24,0)
 Q
"RTN","HMPDJ02",25,0)
 ;
"RTN","HMPDJ02",26,0)
GMPL1(ID,POVLST) ; -- problem
"RTN","HMPDJ02",27,0)
 N HMPL,PROB,X,I,DATE,USER,FAC,LEXS
"RTN","HMPDJ02",28,0)
 D DETAIL^GMPLUTL2(ID,.HMPL) Q:'$D(HMPL)  ;doesn't exist
"RTN","HMPDJ02",29,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ02",30,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ02",31,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the problem domain"
"RTN","HMPDJ02",32,0)
 ;
"RTN","HMPDJ02",33,0)
 S PROB("uid")=$$SETUID^HMPUTILS("problem",DFN,ID),PROB("localId")=ID
"RTN","HMPDJ02",34,0)
 S PROB("problemText")=$G(HMPL("NARRATIVE"))
"RTN","HMPDJ02",35,0)
 S DATE=$P($G(HMPL("ENTERED")),U)
"RTN","HMPDJ02",36,0)
 S:$L(DATE) DATE=$$DATE^HMPDGMPL(DATE),PROB("entered")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ02",37,0)
 S X=$G(HMPL("DIAGNOSIS")) I $L(X) D
"RTN","HMPDJ02",38,0)
 . N ICD9ZN,DIAG,SCTCODE
"RTN","HMPDJ02",39,0)
 . I DATE'>0 S DATE=DT
"RTN","HMPDJ02",40,0)
 . S ICD9ZN=$$ICDDX^ICDCODE(X,DATE),DIAG=$S($P($G(ICD9ZN),U,4)'="":$P(ICD9ZN,U,4),1:X)
"RTN","HMPDJ02",41,0)
 . ; BEGIN MOD ASF 09/8/15 US 9239 DE 2082
"RTN","HMPDJ02",42,0)
 . ; Only set icdCode and icdName if it is ICD9 (ICD10 is only available in codes array)
"RTN","HMPDJ02",43,0)
 . I HMPL("CSYS")="ICD" S PROB("icdCode")=$$SETNCS^HMPUTILS("icd",HMPL("DIAGNOSIS")),PROB("icdName")=DIAG
"RTN","HMPDJ02",44,0)
 . ; Create codes array for both ICD9 or ICD10
"RTN","HMPDJ02",45,0)
 . S PROB("codes",1,"code")=HMPL("DIAGNOSIS")
"RTN","HMPDJ02",46,0)
 . S PROB("codes",1,"display")=$S(HMPL("CSYS")="ICD":DIAG,HMPL("CSYS")="10D":HMPL("ICDD"))
"RTN","HMPDJ02",47,0)
 . S PROB("codes",1,"system")=$S(HMPL("CSYS")="ICD":"urn:oid:2.16.840.1.113883.6.42",HMPL("CSYS")="10D":"urn:oid:2.16.840.1.113883.6.3",1:"codesystem error")
"RTN","HMPDJ02",48,0)
 . ;SNOMED CT codes
"RTN","HMPDJ02",49,0)
 . S SCTCODE=$$GET1^DIQ(9000011,ID_",",80001) ;9000011,80001 SNOMED CT CONCEPT CODE
"RTN","HMPDJ02",50,0)
 . D:SCTCODE EN^LEXCODE(SCTCODE) ; ICR 1614
"RTN","HMPDJ02",51,0)
 . I $D(LEXS("SCT",1)) D
"RTN","HMPDJ02",52,0)
 . . S PROB("codes",2,"code")=SCTCODE
"RTN","HMPDJ02",53,0)
 . . S PROB("codes",2,"code","\s")="" ; Ensure code is sent as a string
"RTN","HMPDJ02",54,0)
 . . S PROB("codes",2,"display")=$P(LEXS("SCT",1),U,2)
"RTN","HMPDJ02",55,0)
 . . S PROB("codes",2,"system")="http://snomed.info/sct"
"RTN","HMPDJ02",56,0)
 . ; END MOD ASF US 9239 DE 2082
"RTN","HMPDJ02",57,0)
 ;Get the internal date from ^AUPNPROB so the imprecise date can be converted properly
"RTN","HMPDJ02",58,0)
 ;JD - 2/1/16 - DE3548
"RTN","HMPDJ02",59,0)
 S X=$$GET1^DIQ(9000011,ID_",",.01,"I") S:$L(X) PROB("lexiconCode")=X  ; DE4680 May 11, 2016 - added lexiconCode to JDS
"RTN","HMPDJ02",60,0)
 S X=$$GET1^DIQ(9000011,ID_",",.13,"I") S:$L(X) PROB("onset")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",61,0)
 S X=$G(HMPL("MODIFIED")) S:$L(X) X=$$DATE^HMPDGMPL(X),PROB("updated")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",62,0)
 S X=$G(HMPL("STATUS")) I $L(X) D
"RTN","HMPDJ02",63,0)
 . S PROB("statusName")=X,X=$E(X)
"RTN","HMPDJ02",64,0)
 . S X=$S(X="A":55561003,X="I":73425007,1:"")
"RTN","HMPDJ02",65,0)
 . S PROB("statusCode")=$$SETNCS^HMPUTILS("sct",X)
"RTN","HMPDJ02",66,0)
 ;S X=$G(HMPL("PRIORITY")) I X]"" D
"RTN","HMPDJ02",67,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.14,"I") I X]"" D  ;DE3988 take directly from the file regardless of status
"RTN","HMPDJ02",68,0)
 . S X=$S(X="C":"chronic",X="A":"acute",1:"")
"RTN","HMPDJ02",69,0)
 . I X'="" S PROB("acuityName")=X,PROB("acuityCode")=$$SETVURN^HMPUTILS("prob-acuity",$E(X))
"RTN","HMPDJ02",70,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.07,"I") S:X PROB("resolved")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",71,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.03,"E") S:$L(X) PROB("enteredBy")=X  ; DE5096 June 24, 2016 - add addt'l problem fields to JDS
"RTN","HMPDJ02",72,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.04,"E") S:$L(X) PROB("recordedBy")=X  ; DE5096 June 24, 2016
"RTN","HMPDJ02",73,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.09,"I") S:$L(X) PROB("recordedOn")=$$JSONDT^HMPUTILS(X)  ; DE5096 July 1, 2016 
"RTN","HMPDJ02",74,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.02,"I")
"RTN","HMPDJ02",75,0)
 S:X="P" PROB("unverified")="false",PROB("removed")="false"
"RTN","HMPDJ02",76,0)
 S:X="T" PROB("unverified")="true",PROB("removed")="false"
"RTN","HMPDJ02",77,0)
 S:X="H" PROB("unverified")="false",PROB("removed")="true"
"RTN","HMPDJ02",78,0)
 S X=$G(HMPL("SC")),X=$S(X="YES":"true",X="NO":"false",1:"")  ; DE3918, Mar 2, 2016
"RTN","HMPDJ02",79,0)
 S:$L(X) PROB("serviceConnected")=X
"RTN","HMPDJ02",80,0)
 S X=$G(HMPL("PROVIDER")) I $L(X) D
"RTN","HMPDJ02",81,0)
 . S PROB("providerName")=X,X=$$GET1^DIQ(9000011,ID_",",1.05,"I")
"RTN","HMPDJ02",82,0)
 . S PROB("providerUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ02",83,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.06) S:$L(X) PROB("service")=X
"RTN","HMPDJ02",84,0)
 S X=$G(HMPL("CLINIC")) I $L(X) D
"RTN","HMPDJ02",85,0)
 . S PROB("locationName")=X
"RTN","HMPDJ02",86,0)
 . N LOC S LOC=+$$FIND1^DIC(44,,"QX",X)
"RTN","HMPDJ02",87,0)
 . S:LOC PROB("locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ02",88,0)
 S X=+$$GET1^DIQ(9000011,ID_",",.06,"I")
"RTN","HMPDJ02",89,0)
 S:X FAC=$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U)
"RTN","HMPDJ02",90,0)
 I 'X S FAC=$$FAC^HMPD ;local stn#^name
"RTN","HMPDJ02",91,0)
 D FACILITY^HMPUTILS(FAC,"PROB")
"RTN","HMPDJ02",92,0)
 S I=0 F  S I=$O(HMPL("COMMENT",I)) Q:I<1  D
"RTN","HMPDJ02",93,0)
 . S X=$G(HMPL("COMMENT",I))
"RTN","HMPDJ02",94,0)
 . S USER=$$VA200^HMPDGMPL($P(X,U,2)),DATE=$$DATE^HMPDGMPL($P(X,U))
"RTN","HMPDJ02",95,0)
 . S PROB("comments",I,"noteCounter")=I  ; Feb 24, 2016 - US12724
"RTN","HMPDJ02",96,0)
 . S PROB("comments",I,"enteredByCode")=$$SETUID^HMPUTILS("user",,+USER)
"RTN","HMPDJ02",97,0)
 . S PROB("comments",I,"enteredByName")=$P(X,U,2)
"RTN","HMPDJ02",98,0)
 . S PROB("comments",I,"entered")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ02",99,0)
 . S PROB("comments",I,"comment")=$P(X,U,3)
"RTN","HMPDJ02",100,0)
 I $D(POVLST) D GMPLVST(ID,"PROB",.POVLST)  ;JL;add encounter information.
"RTN","HMPDJ02",101,0)
 ;== Treatment attributes - Added on 1/4/16 - JD - US12358
"RTN","HMPDJ02",102,0)
 ;Modified 1/8/16 - JD - US12358
"RTN","HMPDJ02",103,0)
 ;Guarding against direct sets into ^AUPNPROB in RPC: "ORQQPL ADD SAVE" by checking for "Y" and "N".
"RTN","HMPDJ02",104,0)
 S X=$$UP^XLFSTR($$GET1^DIQ(9000011,ID_",",1.11,"I"))
"RTN","HMPDJ02",105,0)
 S:$L(X) PROB("agentOrangeExposure")=$S(X=1:"YES",$E(X)="Y":"YES",X=0:"NO",$E(X)="N":"NO",1:X)
"RTN","HMPDJ02",106,0)
 S X=$$UP^XLFSTR($$GET1^DIQ(9000011,ID_",",1.12,"I"))
"RTN","HMPDJ02",107,0)
 S:$L(X) PROB("radiationExposure")=$S(X=1:"YES",$E(X)="Y":"YES",X=0:"NO",$E(X)="N":"NO",1:X)
"RTN","HMPDJ02",108,0)
 S X=$$UP^XLFSTR($$GET1^DIQ(9000011,ID_",",1.13,"I"))
"RTN","HMPDJ02",109,0)
 S:$L(X) PROB("persianGulfExposure")=$S(X=1:"YES",$E(X)="Y":"YES",X=0:"NO",$E(X)="N":"NO",1:X)
"RTN","HMPDJ02",110,0)
 S X=$$UP^XLFSTR($$GET1^DIQ(9000011,ID_",",1.15,"I"))
"RTN","HMPDJ02",111,0)
 S:$L(X) PROB("headNeckCancer")=$S(X=1:"YES",$E(X)="Y":"YES",X=0:"NO",$E(X)="N":"NO",1:X)
"RTN","HMPDJ02",112,0)
 S X=$$UP^XLFSTR($$GET1^DIQ(9000011,ID_",",1.16,"I"))
"RTN","HMPDJ02",113,0)
 S:$L(X) PROB("militarySexualTrauma")=$S(X=1:"YES",$E(X)="Y":"YES",X=0:"NO",$E(X)="N":"NO",1:X)
"RTN","HMPDJ02",114,0)
 S X=$$UP^XLFSTR($$GET1^DIQ(9000011,ID_",",1.17,"I"))
"RTN","HMPDJ02",115,0)
 S:$L(X) PROB("combatVeteran")=$S(X=1:"YES",$E(X)="Y":"YES",X=0:"NO",$E(X)="N":"NO",1:X)
"RTN","HMPDJ02",116,0)
 S X=$$UP^XLFSTR($$GET1^DIQ(9000011,ID_",",1.18,"I"))
"RTN","HMPDJ02",117,0)
 S:$L(X) PROB("shipboardHazard")=$S(X=1:"YES",$E(X)="Y":"YES",X=0:"NO",$E(X)="N":"NO",1:X)
"RTN","HMPDJ02",118,0)
 ;==
"RTN","HMPDJ02",119,0)
 S PROB("lastUpdateTime")=$$EN^HMPSTMP("problem")
"RTN","HMPDJ02",120,0)
 S PROB("stampTime")=PROB("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ02",121,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ02",122,0)
 I $G(HMPMETA) D ADD^HMPMETA("problem",PROB("uid"),PROB("stampTime")) Q:HMPMETA=1  ;US11019/US6734
"RTN","HMPDJ02",123,0)
 D ADD^HMPDJ("PROB","problem")
"RTN","HMPDJ02",124,0)
 Q
"RTN","HMPDJ02",125,0)
 ;
"RTN","HMPDJ02",126,0)
GMPLVST(ID,Y,POVLST)  ; --- JL;associate problem with visit and notes
"RTN","HMPDJ02",127,0)
 Q:'$G(ID)!'$G(^AUPNPROB(ID,0))!'$D(POVLST)  ;invalid id or no data
"RTN","HMPDJ02",128,0)
 N ICDCODE
"RTN","HMPDJ02",129,0)
 S ICDCODE=$$CODEC^ICDCODE($P(^AUPNPROB(ID,0),U,1)) Q:ICDCODE=-1  ;invalid icdcode
"RTN","HMPDJ02",130,0)
 Q:$D(POVLST(ICDCODE))=0
"RTN","HMPDJ02",131,0)
 N IDX,VCNT,NCNT,DIEN,VIEN,FAC,STCODE
"RTN","HMPDJ02",132,0)
 S IDX="",VCNT=0,NCNT=0 F  S IDX=$O(POVLST(ICDCODE,IDX)) Q:IDX=""  D
"RTN","HMPDJ02",133,0)
 . S VCNT=VCNT+1
"RTN","HMPDJ02",134,0)
 . S VIEN=+$G(POVLST(ICDCODE,IDX)),FAC=$$FAC^HMPDJ04(VIEN),STCODE=$$STCODE^HMPDJ04(VIEN)
"RTN","HMPDJ02",135,0)
 . I FAC D FACILITY^HMPUTILS(FAC,Y_"(""encounters"","_VCNT_")")  ; facility info
"RTN","HMPDJ02",136,0)
 . I STCODE D STOPCODE^HMPDJ04(STCODE,Y_"(""encounters"","_VCNT_")") ; stop code
"RTN","HMPDJ02",137,0)
 . S @Y@("encounters",VCNT,"dateTime")=$$JSONDT^HMPUTILS($$DATE^HMPDGMPL(+IDX))
"RTN","HMPDJ02",138,0)
 . S @Y@("encounters",VCNT,"visitUid")=$$SETUID^HMPUTILS("visit",DFN,VIEN)
"RTN","HMPDJ02",139,0)
 . N ENINFO S ENINFO=$G(POVLST(ICDCODE,IDX))
"RTN","HMPDJ02",140,0)
 . S DIEN=+$P(ENINFO,U,2)
"RTN","HMPDJ02",141,0)
 . ;W "DIEN is "_DIEN,!
"RTN","HMPDJ02",142,0)
 . I DIEN D
"RTN","HMPDJ02",143,0)
 . . S NCNT=NCNT+1
"RTN","HMPDJ02",144,0)
 . . ; extract the extra data from the document
"RTN","HMPDJ02",145,0)
 . . N DOCINFO S DOCINFO=$E(ENINFO,$F($G(ENINFO),U),$L(ENINFO))
"RTN","HMPDJ02",146,0)
 . . N OUTPUT S OUTPUT="" D EN1^HMPDJ08(DOCINFO,3,.OUTPUT)
"RTN","HMPDJ02",147,0)
 . . N NAME F NAME="documentTypeName","entered","summary","facilityName","authorDisplayName" D
"RTN","HMPDJ02",148,0)
 . . . S:$D(OUTPUT(NAME)) @Y@("documents",NCNT,NAME)=$G(OUTPUT(NAME))
"RTN","HMPDJ02",149,0)
 . . S @Y@("documents",NCNT,"documentUid")=$$SETUID^HMPUTILS("document",DFN,DIEN)
"RTN","HMPDJ02",150,0)
 Q
"RTN","HMPDJ02",151,0)
 ;
"RTN","HMPDJ02",152,0)
GMPLPOV(DFNN,POVLST,DONTKILL) ; -- JL;All problem of visit related to the patient from V POV file
"RTN","HMPDJ02",153,0)
 ;INPUT: Patient's DFN
"RTN","HMPDJ02",154,0)
 ;OUTPUT: Patient's VISIT list in the format of
"RTN","HMPDJ02",155,0)
 ;        OUTPUT(DIAGNOSIS,DATATIME)="VISITIEN"
"RTN","HMPDJ02",156,0)
 ;
"RTN","HMPDJ02",157,0)
 Q:'$G(DFNN)
"RTN","HMPDJ02",158,0)
 N INVVST
"RTN","HMPDJ02",159,0)
 K:'DONTKILL POVLST ; clear the output
"RTN","HMPDJ02",160,0)
 ; Query V POV(^AUPNVPOV() by using "AA" Cross Reference.
"RTN","HMPDJ02",161,0)
 S INVVST="",CURVST="" F  S INVVST=$O(^AUPNVPOV("AA",DFNN,INVVST)) Q:INVVST=""  D
"RTN","HMPDJ02",162,0)
 . N CURVST,DIEN
"RTN","HMPDJ02",163,0)
 . S CURVST=INVVST,DIEN="" F  S DIEN=$O(^AUPNVPOV("AA",DFNN,CURVST,DIEN)) Q:DIEN=""  D
"RTN","HMPDJ02",164,0)
 . . N ICDIEN,PVISIT
"RTN","HMPDJ02",165,0)
 . . S ICDIEN=+$P(^AUPNVPOV(DIEN,0),U,1),PVISIT=$P(^AUPNVPOV(DIEN,0),U,3)
"RTN","HMPDJ02",166,0)
 . . N VISITDT
"RTN","HMPDJ02",167,0)
 . . S VISITDT=+$G(^AUPNVSIT(PVISIT,0)) Q:'$L(VISITDT)  ;quit if no visit is found, bad data entry.
"RTN","HMPDJ02",168,0)
 . . N ICDCODE,VIEN
"RTN","HMPDJ02",169,0)
 . . S ICDCODE=$$CODEC^ICDCODE(ICDIEN) Q:ICDCODE=-1  ;convert to ICD code, quit if not valid
"RTN","HMPDJ02",170,0)
 . . I $D(POVLST(ICDCODE,VISITDT))'=0 D  Q
"RTN","HMPDJ02",171,0)
 . . . S VIEN=$$GETVIEN(DFNN,VISITDT)
"RTN","HMPDJ02",172,0)
 . . . ; W:VIEN=-1 "Can not find VISIT IEN for "_VISITDT,!
"RTN","HMPDJ02",173,0)
 . . . S:VIEN'=-1 POVLST(ICDCODE,VISITDT)=VIEN
"RTN","HMPDJ02",174,0)
 Q
"RTN","HMPDJ02",175,0)
 ;
"RTN","HMPDJ02",176,0)
GETVIEN(DFNN,VISITDT)  ;JL; get the Visit IEN from VISIT file based on patient ID and Datetime
"RTN","HMPDJ02",177,0)
 Q:'+$G(DFNN)!'$L(VISITDT) -1  ;return -1 if bad parameter
"RTN","HMPDJ02",178,0)
 N REVDT,VISITIEN
"RTN","HMPDJ02",179,0)
 S REVDT=9999999-$P(VISITDT,".",1)_$S($P(VISITDT,".",2)'="":"."_$P(VISITDT,".",2),1:"")
"RTN","HMPDJ02",180,0)
 S VISITIEN=$O(^AUPNVSIT("AA",DFNN,REVDT,""))  ; using "AA" cross-reference
"RTN","HMPDJ02",181,0)
 Q:VISITIEN="" -1
"RTN","HMPDJ02",182,0)
 Q VISITIEN
"RTN","HMPDJ02",183,0)
 ;
"RTN","HMPDJ02",184,0)
DIAGLIST(DIAGS,DFN,ORDATE,ORPRCNT) ;BL,JL; get list diagnosis on past notes
"RTN","HMPDJ02",185,0)
 S:'+$G(ORDATE) ORDATE=DT
"RTN","HMPDJ02",186,0)
 S:'+$G(ORPRCNT) ORPRCNT=1
"RTN","HMPDJ02",187,0)
 ;Use TIU DOCUMENTS BY CONTEXT to retrieve all notes associated with patient (CONTEXT^TIUSRVLO)
"RTN","HMPDJ02",188,0)
 K ENC,DIAGCODE,CNT,DIAG,DIAGNUM,DIAGLINE,ENCNUM,LINE,IEN,CLASS,CONTEXT,EARLY,LATE,PERSON,OCCLIM,SEQUENCE,SHOWADD,INCUND,LSTNUM,NOTEINFO
"RTN","HMPDJ02",189,0)
 K NEWCNT,OLDLST,DIAGCNT
"RTN","HMPDJ02",190,0)
 S CLASS=3,CONTEXT=1,EARLY=-1,LATE=-1,PERSON=0,OCCLIM=0,SEQUENCE="D",SHOWADD=0,INCUND=0,OLDLST=""
"RTN","HMPDJ02",191,0)
 ;TAKE EXISTING LIST FROM ENCOUNTER CALL AND PRESERVE TO BE APPENDED AFTERWARD
"RTN","HMPDJ02",192,0)
 K DIAGS S DIAGS=""
"RTN","HMPDJ02",193,0)
 D CONTEXT^TIUSRVLO(.DIAGS,CLASS,CONTEXT,DFN,EARLY,LATE,PERSON,OCCLIM,SEQUENCE,SHOWADD,INCUND)
"RTN","HMPDJ02",194,0)
 M DIAGS=^TMP("TIUR",$J)
"RTN","HMPDJ02",195,0)
 ;Go through notes list and use ORWPCE PCE4NOTE to extract diagnosis associated with each encounter to previous problem list (PCE4NOTE^ORWPCE3)
"RTN","HMPDJ02",196,0)
 S LSTNUM=""
"RTN","HMPDJ02",197,0)
 ;THIS CALL WILL EXTRACT ALL THE VISIT INFORMATION TO ^TMP(PXKENC,$J,VISIT)
"RTN","HMPDJ02",198,0)
 N VIEN
"RTN","HMPDJ02",199,0)
 F  S LSTNUM=$O(DIAGS(LSTNUM)) Q:LSTNUM=""  D
"RTN","HMPDJ02",200,0)
 . S NOTEINFO=""
"RTN","HMPDJ02",201,0)
 . S IEN=$P(DIAGS(LSTNUM),"^",1)
"RTN","HMPDJ02",202,0)
 . D PCE4NOTE^ORWPCE3(.NOTEINFO,IEN,DFN)
"RTN","HMPDJ02",203,0)
 . S CNT=0,DIAGCNT=0
"RTN","HMPDJ02",204,0)
 . F  S CNT=$O(NOTEINFO(CNT)) Q:CNT=""  D
"RTN","HMPDJ02",205,0)
 . . Q:$P(NOTEINFO(CNT),"^",1)'["POV"
"RTN","HMPDJ02",206,0)
 . . S DIAGCNT=DIAGCNT+1
"RTN","HMPDJ02",207,0)
 . . S VISITDT=$P($G(NOTEINFO(2)),U,3)  ; get the visit datetime
"RTN","HMPDJ02",208,0)
 . . S ICDCODE=$P(NOTEINFO(CNT),U,2)  ; get the diagnosis code
"RTN","HMPDJ02",209,0)
 . . I $D(ENC(ICDCODE,VISITDT))=0 D
"RTN","HMPDJ02",210,0)
 . . . S VIEN=$$GETVIEN(DFN,VISITDT)
"RTN","HMPDJ02",211,0)
 . . . ;W:VIEN=-1 "Can not find Visit ID for "_NOTEINFO(CNT),!
"RTN","HMPDJ02",212,0)
 . . . S:VIEN'=-1 ENC(ICDCODE,VISITDT)=VIEN_U_$G(DIAGS(LSTNUM)) ;  add to list only if visit ien is valid
"RTN","HMPDJ02",213,0)
 ; KILL DIAGS BECAUSE IT NOW CONTAINS NOTE INFO
"RTN","HMPDJ02",214,0)
 K DIAGS
"RTN","HMPDJ02",215,0)
 M DIAGS=ENC
"RTN","HMPDJ02",216,0)
 ;CLEAN UP ARRAYS
"RTN","HMPDJ02",217,0)
 K NOTEINFO,ENC,DIAG,^TMP("TIUR",$J)
"RTN","HMPDJ02",218,0)
 D GMPLPOV(DFN,.DIAGS,1)  ; Also loop thru V POV file to find extra encounter
"RTN","HMPDJ02",219,0)
 Q
"RTN","HMPDJ02",220,0)
 ;
"RTN","HMPDJ02",221,0)
GMRA1(ID) ; -- allergy/reaction GMRAL(ID)
"RTN","HMPDJ02",222,0)
 N GMRA,HMPY,REAC,X,Y,I,USER,CMMT
"RTN","HMPDJ02",223,0)
 S GMRA=$G(GMRAL(ID)) D EN1^GMRAOR2(ID,"HMPY")
"RTN","HMPDJ02",224,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ02",225,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ02",226,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the allergy domain"
"RTN","HMPDJ02",227,0)
 ;
"RTN","HMPDJ02",228,0)
 S X=$P(HMPY,U,10) I $L(X) S X=$$DATE^HMPDGMRA(X) Q:X<HMPSTART  Q:X>HMPSTOP  S REAC("entered")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",229,0)
 S X=$$FAC^HMPD D FACILITY^HMPUTILS(X,"REAC")
"RTN","HMPDJ02",230,0)
 S REAC("kind")="Allergy / Adverse Reaction"
"RTN","HMPDJ02",231,0)
 S REAC("localId")=ID,REAC("uid")=$$SETUID^HMPUTILS("allergy",DFN,ID)
"RTN","HMPDJ02",232,0)
 S (REAC("summary"),REAC("products",1,"name"))=$P(HMPY,U) I $P(GMRA,U,9) D
"RTN","HMPDJ02",233,0)
 . S X=$P(GMRA,U,9),REAC("reference")=X
"RTN","HMPDJ02",234,0)
 . S Y=+$P(X,"(",2) I 'Y,X["PSDRUG" S Y=50
"RTN","HMPDJ02",235,0)
 . S I=$$VUID^HMPD(+X,Y),REAC("products",1,"vuid")=$$SETVURN^HMPUTILS("vuid",I)
"RTN","HMPDJ02",236,0)
 S X=$P(HMPY,U,2) S:$L(X) REAC("originatorName")=X
"RTN","HMPDJ02",237,0)
 S REAC("historical")=$S($E($P(HMPY,U,5))="H":"true",1:"false")
"RTN","HMPDJ02",238,0)
 S X=$P(HMPY,U,6) S:$L(X) REAC("mechanism")=X
"RTN","HMPDJ02",239,0)
 S X=$P(HMPY,U,7) S:$L(X) REAC("typeName")=X
"RTN","HMPDJ02",240,0)
 ; REAC("adverseEventTypeName")=$P(HMPY,U,7)_" "_$P(HMPY,U,6) ;TYPE_MECH
"RTN","HMPDJ02",241,0)
 I $P(HMPY,U,4)="VERIFIED",$P(HMPY,U,9) D
"RTN","HMPDJ02",242,0)
 . S REAC("verified")=$$JSONDT^HMPUTILS($P(HMPY,U,9))
"RTN","HMPDJ02",243,0)
 . S REAC("verifierName")=$P(HMPY,U,8)
"RTN","HMPDJ02",244,0)
 ; severity
"RTN","HMPDJ02",245,0)
 S I=0 F  S I=$O(HMPY("O",I)) Q:I<1  D
"RTN","HMPDJ02",246,0)
 . S X=$G(HMPY("O",I))
"RTN","HMPDJ02",247,0)
 . S REAC("observations",I,"date")=$$JSONDT^HMPUTILS(+X)
"RTN","HMPDJ02",248,0)
 . S REAC("observations",I,"severity")=$P(X,U,2)
"RTN","HMPDJ02",249,0)
 ; reactions
"RTN","HMPDJ02",250,0)
 S I=0 F  S I=$O(GMRAL(ID,"S",I)) Q:I<1  D
"RTN","HMPDJ02",251,0)
 . S X=$G(GMRAL(ID,"S",I))
"RTN","HMPDJ02",252,0)
 . S REAC("reactions",I,"name")=$P(X,";")
"RTN","HMPDJ02",253,0)
 . S Y=$$VUID^HMPD(+$P(X,";",2),120.83)
"RTN","HMPDJ02",254,0)
 . S REAC("reactions",I,"vuid")=$$SETVURN^HMPUTILS("vuid",Y)
"RTN","HMPDJ02",255,0)
 ; drug classes
"RTN","HMPDJ02",256,0)
 S I=0 F  S I=$O(HMPY("V",I)) Q:I<1  D
"RTN","HMPDJ02",257,0)
 . S X=$G(HMPY("V",I))
"RTN","HMPDJ02",258,0)
 . S REAC("drugClasses",I,"code")=$P(X,U)
"RTN","HMPDJ02",259,0)
 . S REAC("drugClasses",I,"name")=$P(X,U,2)
"RTN","HMPDJ02",260,0)
 S I=0 F  S I=$O(HMPY("C",I)) Q:I<1  D
"RTN","HMPDJ02",261,0)
 . S X=$G(HMPY("C",I)),USER=$$VA200^HMPDGMPL($P(X,U,3))
"RTN","HMPDJ02",262,0)
 . S REAC("comments",I,"enteredByUid")=$$SETUID^HMPUTILS("user",,+USER)
"RTN","HMPDJ02",263,0)
 . S REAC("comments",I,"enteredByName")=$P(X,U,3)
"RTN","HMPDJ02",264,0)
 . S REAC("comments",I,"entered")=$$JSONDT^HMPUTILS(+X)
"RTN","HMPDJ02",265,0)
 . K CMMT M CMMT=HMPY("C",I)
"RTN","HMPDJ02",266,0)
 . S REAC("comments",I,"comment")=$$STRING^HMPD(.CMMT)
"RTN","HMPDJ02",267,0)
 I GMRA="" S REAC("removed")="true" ;entered in error
"RTN","HMPDJ02",268,0)
 ; next
"RTN","HMPDJ02",269,0)
 S REAC("lastUpdateTime")=$$EN^HMPSTMP("allergy")
"RTN","HMPDJ02",270,0)
 S REAC("stampTime")=REAC("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ02",271,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ02",272,0)
 I $G(HMPMETA) D ADD^HMPMETA("allergy",REAC("uid"),REAC("stampTime")) Q:HMPMETA=1  ;US11019/US6734
"RTN","HMPDJ02",273,0)
 D ADD^HMPDJ("REAC","allergy")
"RTN","HMPDJ02",274,0)
 Q
"RTN","HMPDJ02",275,0)
 ;
"RTN","HMPDJ02",276,0)
NKA ; -- no assessment or NKA [GMRAL=0 or ""]
"RTN","HMPDJ02",277,0)
 N REAC,X
"RTN","HMPDJ02",278,0)
 S X=$G(^GMR(120.86,DFN,0)) Q:GMRAL=""!'$P(X,U,2)
"RTN","HMPDJ02",279,0)
 S REAC("uid")=$$SETUID^HMPUTILS("obs",DFN,"120.86;"_DFN)
"RTN","HMPDJ02",280,0)
 S REAC("typeCode")="urn:sct:160244002"
"RTN","HMPDJ02",281,0)
 S REAC("typeName")="No known allergies"
"RTN","HMPDJ02",282,0)
 S X=$$FAC^HMPD D FACILITY^HMPUTILS(X,"REAC")
"RTN","HMPDJ02",283,0)
 D ADD^HMPDJ("REAC","allergy")
"RTN","HMPDJ02",284,0)
 Q
"RTN","HMPDJ02",285,0)
 ;
"RTN","HMPDJ02",286,0)
GMV1(ID) ; -- vital/measurement ^UTILITY($J,"GMRVD",HMPIDT,HMPTYP,ID)
"RTN","HMPDJ02",287,0)
 N VIT,HMPY,X0,TYPE,LOC,FAC,X,Y,MRES,MUNT,HIGH,LOW,I
"RTN","HMPDJ02",288,0)
 D GETREC^GMVUTL(.HMPY,ID,1) S X0=$G(HMPY(0))
"RTN","HMPDJ02",289,0)
 ; GMRVUT0 returns CLiO data with a pseudo-ID >> get real ID
"RTN","HMPDJ02",290,0)
 I X0="",$G(HMPIDT),$D(HMPTYP) D  ;[from HMPDJ0]
"RTN","HMPDJ02",291,0)
 . N GMRVD S GMRVD=$G(^UTILITY($J,"GMRVD",HMPIDT,HMPTYP,ID))
"RTN","HMPDJ02",292,0)
 . S ID=$O(^PXRMINDX(120.5,"PI",DFN,$P(GMRVD,U,3),+GMRVD,""))
"RTN","HMPDJ02",293,0)
 . I $L(ID) D GETREC^GMVUTL(.HMPY,ID,1) S X0=$G(HMPY(0))
"RTN","HMPDJ02",294,0)
 Q:X0=""
"RTN","HMPDJ02",295,0)
 ;
"RTN","HMPDJ02",296,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ02",297,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ02",298,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the vitals domain"
"RTN","HMPDJ02",299,0)
 S VIT("localId")=ID,VIT("kind")="Vital Sign"
"RTN","HMPDJ02",300,0)
 S VIT("uid")=$$SETUID^HMPUTILS("vital",DFN,ID)
"RTN","HMPDJ02",301,0)
 S VIT("observed")=$$JSONDT^HMPUTILS(+X0)
"RTN","HMPDJ02",302,0)
 S VIT("resulted")=$$JSONDT^HMPUTILS(+$P(X0,U,4))
"RTN","HMPDJ02",303,0)
 S TYPE=$$FIELD^GMVGETVT(+$P(X0,U,3),2)
"RTN","HMPDJ02",304,0)
 S VIT("displayName")=TYPE
"RTN","HMPDJ02",305,0)
 S VIT("typeName")=$$FIELD^GMVGETVT($P(X0,U,3),1)
"RTN","HMPDJ02",306,0)
 S VIT("typeCode")="urn:va:vuid:"_$$FIELD^GMVGETVT($P(X0,U,3),4)
"RTN","HMPDJ02",307,0)
 S X=$P(X0,U,8),VIT("result")=X
"RTN","HMPDJ02",308,0)
 S VIT("units")=$$UNIT^HMPDGMV(TYPE),(MRES,MUNT)=""
"RTN","HMPDJ02",309,0)
 I TYPE="T"  S MUNT="C",MRES=$J(X-32*5/9,0,1) ;EN1^GMRVUTL
"RTN","HMPDJ02",310,0)
 I TYPE="HT" S MUNT="cm",MRES=$J(2.54*X,0,2)  ;EN2^GMRVUTL
"RTN","HMPDJ02",311,0)
 I TYPE="WT" S MUNT="kg",MRES=$J(X/2.2,0,2)   ;EN3^GMRVUTL
"RTN","HMPDJ02",312,0)
 I TYPE="CG" S MUNT="cm",MRES=$J(2.54*X,0,2)
"RTN","HMPDJ02",313,0)
 S:MRES VIT("metricResult")=MRES,VIT("metricUnits")=MUNT
"RTN","HMPDJ02",314,0)
 S X=$$RANGE^HMPDGMV(TYPE) I $L(X) S VIT("high")=$P(X,U),VIT("low")=$P(X,U,2)
"RTN","HMPDJ02",315,0)
 S VIT("summary")=VIT("typeName")_" "_VIT("result")_" "_VIT("units")
"RTN","HMPDJ02",316,0)
 F I=1:1:$L(HMPY(5),U) S X=$P(HMPY(5),U,I) I X D
"RTN","HMPDJ02",317,0)
 . S VIT("qualifiers",I,"name")=$$FIELD^GMVGETQL(X,1)
"RTN","HMPDJ02",318,0)
 . S VIT("qualifiers",I,"vuid")=$$FIELD^GMVGETQL(X,3)
"RTN","HMPDJ02",319,0)
 ;US4338 - add pulse ox qualifier if it exists. name component is required. vuid is not per Thomas Loth
"RTN","HMPDJ02",320,0)
 I $P(X0,U,10) S VIT("qualifiers",I+1,"name")=$P(X0,U,10)
"RTN","HMPDJ02",321,0)
 I $G(HMPY(2)) D
"RTN","HMPDJ02",322,0)
 . S VIT("removed")="true"        ;entered in error
"RTN","HMPDJ02",323,0)
 . S X=$$GET1^DIQ(120.506,"1,"_ID_",",.01,"E") S:X VIT("reasonEnteredInError")=X
"RTN","HMPDJ02",324,0)
 . S X=$$GET1^DIQ(120.506,"1,"_ID_",",.02,"I") S:X VIT("dateEnteredInError")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",325,0)
 S LOC=+$P(X0,U,5),FAC=$$FAC^HMPD(LOC)
"RTN","HMPDJ02",326,0)
 S VIT("locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ02",327,0)
 S VIT("locationName")=$S(LOC:$P($G(^SC(LOC,0)),U),1:"unknown")
"RTN","HMPDJ02",328,0)
 N USERID S USERID=$P(HMPY(0),U,6)
"RTN","HMPDJ02",329,0)
 I $G(USERID) D
"RTN","HMPDJ02",330,0)
 . S VIT("enteredByUid")=$$SETUID^HMPUTILS("user",,USERID)
"RTN","HMPDJ02",331,0)
 . S VIT("enteredByName")=$P($G(^VA(200,USERID,0)),U,1)
"RTN","HMPDJ02",332,0)
 D FACILITY^HMPUTILS(FAC,"VIT")
"RTN","HMPDJ02",333,0)
 S VIT("lastUpdateTime")=$$EN^HMPSTMP("vital")
"RTN","HMPDJ02",334,0)
 S VIT("stampTime")=VIT("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ02",335,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ02",336,0)
 I $G(HMPMETA) D ADD^HMPMETA("vital",VIT("uid"),VIT("stampTime")) Q:HMPMETA=1  ;US11019/US6734
"RTN","HMPDJ02",337,0)
 D ADD^HMPDJ("VIT","vital")
"RTN","HMPDJ02",338,0)
 Q
"RTN","HMPDJ02",339,0)
 ;
"RTN","HMPDJ02",340,0)
HMP(COLL) ; -- HMP Patient Objects
"RTN","HMPDJ02",341,0)
 N ID I $L($G(HMPID)) D  Q
"RTN","HMPDJ02",342,0)
 . S ID=+HMPID I 'ID S ID=+$O(^HMP(800000.1,"B",HMPID,0)) ;IEN or UID
"RTN","HMPDJ02",343,0)
 . D:ID HMP1(800000.1,ID)
"RTN","HMPDJ02",344,0)
 Q:$G(COLL)=""  ;error
"RTN","HMPDJ02",345,0)
 S ID=0 F  S ID=$O(^HMP(800000.1,"C",DFN,COLL,ID)) Q:ID<1  D HMP1(800000.1,ID)
"RTN","HMPDJ02",346,0)
 Q
"RTN","HMPDJ02",347,0)
HMP1(FNUM,ID) ; -- [patient] object
"RTN","HMPDJ02",348,0)
 N I,X,HMPY
"RTN","HMPDJ02",349,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ02",350,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=$G(DFN)
"RTN","HMPDJ02",351,0)
 S ERRMSG="A problem occurred retreiving record "_ID_" for the HMP domain"
"RTN","HMPDJ02",352,0)
 S I=0 F  S I=$O(^HMP(FNUM,ID,1,I)) Q:I<1  S X=$G(^(I,0)),HMPY(I)=X
"RTN","HMPDJ02",353,0)
 I $D(HMPY) D  ;already encoded JSON
"RTN","HMPDJ02",354,0)
 . S HMPI=HMPI+1 S:HMPI>1 @HMP@(HMPI,.3)=","
"RTN","HMPDJ02",355,0)
 . M @HMP@(HMPI)=HMPY
"RTN","HMPDJ02",356,0)
 . ; -- chunk data if from DQINIT^HMPDJFSP ; i.e. HMPCHNK defined ;*S68-JCH*
"RTN","HMPDJ02",357,0)
 . D CHNKCHK^HMPDJFSP(.HMP,.HMPI) ;*S68-JCH*
"RTN","HMPDJ02",358,0)
 Q
"RTN","HMPDJ03")
0^59^B113601878
"RTN","HMPDJ03",1,0)
HMPDJ03 ;SLC/MKB,ASMR/RRB,JD - Consults,ClinProcedures,CLiO ;4/4/16  15:33
"RTN","HMPDJ03",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPDJ03",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ03",4,0)
 ;
"RTN","HMPDJ03",5,0)
 ; DE4173 - JD - 3/30/16: Send consult notes for "activities" and "results".
"RTN","HMPDJ03",6,0)
 ;
"RTN","HMPDJ03",7,0)
 ; External References          DBIA#
"RTN","HMPDJ03",8,0)
 ; -------------------          -----
"RTN","HMPDJ03",9,0)
 ; ^SC(                         10040
"RTN","HMPDJ03",10,0)
 ; ^TIU(8925.1                   5677
"RTN","HMPDJ03",11,0)
 ; ^VA(200                      10060
"RTN","HMPDJ03",12,0)
 ; %DT                          10003
"RTN","HMPDJ03",13,0)
 ; DILFD                         2055
"RTN","HMPDJ03",14,0)
 ; DIQ                           2056
"RTN","HMPDJ03",15,0)
 ; GMRCAPI                       6082
"RTN","HMPDJ03",16,0)
 ; GMRCGUIB                      2980
"RTN","HMPDJ03",17,0)
 ; GMRCSLM1,^TMP("GMRCR"         2740
"RTN","HMPDJ03",18,0)
 ; MCARUTL3                      3280
"RTN","HMPDJ03",19,0)
 ; MDPS1,^TMP("MDHSP"            4230
"RTN","HMPDJ03",20,0)
 ; ORX8                          2467
"RTN","HMPDJ03",21,0)
 ; TIULQ                         2693
"RTN","HMPDJ03",22,0)
 ; TIUSRVLO                      2834
"RTN","HMPDJ03",23,0)
 ; XLFSTR                       10104
"RTN","HMPDJ03",24,0)
 ; XUAF4                         2171
"RTN","HMPDJ03",25,0)
 ;
"RTN","HMPDJ03",26,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ03",27,0)
 Q
"RTN","HMPDJ03",28,0)
 ;
"RTN","HMPDJ03",29,0)
GMRC1(ID) ; -- consult/request HMPX=^TMP("GMRCR",$J,"CS",HMPN,0)
"RTN","HMPDJ03",30,0)
 N CONS,ORDER,HMPD,X0,X,HMPA,DA,ACT0,ACT2,ACT3,ACT,HMPEASON,HMPJ,HMPTIU
"RTN","HMPDJ03",31,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ03",32,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ03",33,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the consults domain"
"RTN","HMPDJ03",34,0)
 ;
"RTN","HMPDJ03",35,0)
 S CONS("localId")=+HMPX,CONS("uid")=$$SETUID^HMPUTILS("consult",DFN,+HMPX)
"RTN","HMPDJ03",36,0)
 S CONS("dateTime")=$$JSONDT^HMPUTILS($P(HMPX,U,2))
"RTN","HMPDJ03",37,0)
 S CONS("statusName")=$P(HMPX,U,3),CONS("service")=$P(HMPX,U,4)
"RTN","HMPDJ03",38,0)
 S CONS("consultProcedure")=$P(HMPX,U,5)
"RTN","HMPDJ03",39,0)
 I $P(HMPX,U,6)="*" S CONS("interpretation")="SIGNIFICANT FINDINGS"
"RTN","HMPDJ03",40,0)
 S CONS("typeName")=$P(HMPX,U,7),CONS("category")=$P(HMPX,U,9)
"RTN","HMPDJ03",41,0)
 S ORDER=+$P(HMPX,U,8),CONS("orderName")=$P($$OI^ORX8(ORDER),U,2)
"RTN","HMPDJ03",42,0)
 S CONS("orderUid")=$$SETUID^HMPUTILS("order",DFN,ORDER)
"RTN","HMPDJ03",43,0)
 D GET^GMRCAPI(.HMPD,+HMPX) S X0=$G(HMPD(0)) ;=^GMR(123,ID,0)
"RTN","HMPDJ03",44,0)
 S X=$P(X0,U,6) S:X CONS("fromService")=$$GET1^DIQ(44,X_",",.01)  ;DE2818
"RTN","HMPDJ03",45,0)
 S X=$P(X0,U,9) S:X]"" CONS("urgency")=X
"RTN","HMPDJ03",46,0)
 S X=$P(X0,U,10) S:X]"" CONS("place")=X
"RTN","HMPDJ03",47,0)
 S X=$P(X0,U,11) S:X CONS("attention")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",48,0)
 S X=$P(X0,U,13) S:X]"" CONS("lastAction")=X
"RTN","HMPDJ03",49,0)
 S X=$P(X0,U,14) I X D  ;ordering provider
"RTN","HMPDJ03",50,0)
 . S CONS("providerUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ03",51,0)
 . S CONS("providerName")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",52,0)
 S X=$P(X0,U,18) I $L(X) D
"RTN","HMPDJ03",53,0)
 . S CONS("patientClassCode")="urn:va:patient-class:"_$S(X="I":"IMP",1:"AMB")
"RTN","HMPDJ03",54,0)
 . S CONS("patientClassName")=$S(X="I":"Inpatient",1:"Ambulatory")
"RTN","HMPDJ03",55,0)
 S X=+$P(X0,U,24) S:X CONS("earliestDate")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",56,0)
 I $P(HMPX,U,9)="M" S CONS("clinicalProcedure")=$G(HMPD(1))
"RTN","HMPDJ03",57,0)
 I $D(HMPD(20)) M HMPEASON=HMPD(20) S CONS("reason")=$$STRING^HMPD(.HMPEASON)
"RTN","HMPDJ03",58,0)
 S X=$G(HMPD(30)) S:$L(X) CONS("provisionalDx")=X
"RTN","HMPDJ03",59,0)
 ; 
"RTN","HMPDJ03",60,0)
 I $P(X0,U,23) D  ;inter-facility
"RTN","HMPDJ03",61,0)
 . N IFC S X=$$NS^XUAF4($P(X0,U,23))
"RTN","HMPDJ03",62,0)
 . S CONS("remote","facilityCode")=$P(X,U,2),CONS("remote","facilityName")=$P(X,U)
"RTN","HMPDJ03",63,0)
 . S:$P(X0,U,22) CONS("remote","id")=$P(X0,U,22)
"RTN","HMPDJ03",64,0)
 . S IFC=$$IFC^GMRCAPI(ID)
"RTN","HMPDJ03",65,0)
 . S X=$P(IFC,U) S:$L(X) CONS("remote","service")=X
"RTN","HMPDJ03",66,0)
 . S X=$P(IFC,U,5) S:$L(X) CONS("remote","role")=$S(X="P":"Requesting facility",1:"Consulting facility")
"RTN","HMPDJ03",67,0)
 . S CONS("remote","providerName")=$P(IFC,U,6)
"RTN","HMPDJ03",68,0)
 . S X=$P(IFC,U,2) S:$L(X) CONS("remote","providerphone")=X
"RTN","HMPDJ03",69,0)
 . S X=$P(IFC,U,3) S:$L(X) CONS("remote","providerpager")=X
"RTN","HMPDJ03",70,0)
 ;
"RTN","HMPDJ03",71,0)
 D ACT^GMRCAPI(.HMPA,ID)
"RTN","HMPDJ03",72,0)
 S DA=0 F  S DA=$O(HMPA(DA)) Q:DA<1  D
"RTN","HMPDJ03",73,0)
 . S ACT0=$G(HMPA(DA,0)),ACT2=$G(HMPA(DA,2)),ACT3=$G(HMPA(DA,3)) K ACT
"RTN","HMPDJ03",74,0)
 . I $L(ACT2),$P(X0,U,23) S X=$$NS^XUAF4($P(X0,U,23)),ACT("facilityCode")=$P(X,U,2),ACT("facilityName")=$P(X,U)
"RTN","HMPDJ03",75,0)
 . S ACT("name")=$P(ACT0,U,2)
"RTN","HMPDJ03",76,0)
 . S ACT("entered")=$$JSONDT^HMPUTILS($P(ACT0,U))
"RTN","HMPDJ03",77,0)
 . S ACT("dateTime")=$$JSONDT^HMPUTILS($P(ACT0,U,3))
"RTN","HMPDJ03",78,0)
 . S:$L($P(ACT2,U,3)) ACT("timeZone")=$P(ACT2,U,3)
"RTN","HMPDJ03",79,0)
 . I $L(ACT2) S ACT("enteredBy")=$P(ACT2,U),ACT("responsible")=$P(ACT2,U,2)
"RTN","HMPDJ03",80,0)
 . E  D  ;remote vs. local users
"RTN","HMPDJ03",81,0)
 .. S X=+$P(ACT0,U,4) S:X ACT("responsible")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",82,0)
 .. S X=+$P(ACT0,U,5) S:X ACT("enteredBy")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",83,0)
 . S X=$S($L(ACT3):ACT3,1:$P(ACT0,U,6)) S:$L(X) ACT("forwardedFrom")=X
"RTN","HMPDJ03",84,0)
 . S X=$P(ACT0,U,7) S:X ACT("previousAttention")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",85,0)
 . S X=$P(ACT0,U,8) S:X ACT("device")=$$GET1^DIQ(3.5,X_",",.01)
"RTN","HMPDJ03",86,0)
 . S X=$P(ACT0,U,9) I X,X["TIU" D
"RTN","HMPDJ03",87,0)
 .. S ACT("resultUid")=$$SETUID^HMPUTILS("document",DFN,+X)
"RTN","HMPDJ03",88,0)
 .. ;=== Start DE4173 for "activity" attribute
"RTN","HMPDJ03",89,0)
 .. N HMP92,HMPNI
"RTN","HMPDJ03",90,0)
 .. S HMPNI=$P($P(ACT0,U,9),";")  ;Note (document) IEN --> ^TIU(8925,HMPNI
"RTN","HMPDJ03",91,0)
 .. I HMPNI'>0 Q
"RTN","HMPDJ03",92,0)
 .. D SETTEXT^HMPUTILS($NA(^TIU(8925,HMPNI,"TEXT")),"HMP92")  ;Format a word processing field
"RTN","HMPDJ03",93,0)
 .. M ACT("note","\")=HMP92
"RTN","HMPDJ03",94,0)
 .. ;=== End DE4173 for "activity" attribute
"RTN","HMPDJ03",95,0)
 . I $D(HMPA(DA,1)) M HMPEASON=HMPA(DA,1) S ACT("comment")=$$STRING^HMPD(.HMPEASON)
"RTN","HMPDJ03",96,0)
 . M CONS("activity",DA)=ACT
"RTN","HMPDJ03",97,0)
 ;
"RTN","HMPDJ03",98,0)
 S HMPJ=0 F  S HMPJ=$O(HMPD(50,HMPJ)) Q:HMPJ<1  S X=$G(HMPD(50,HMPJ)) D
"RTN","HMPDJ03",99,0)
 . Q:'$D(@(U_$P(X,";",2)_+X_")"))  ;text deleted
"RTN","HMPDJ03",100,0)
 . ;=== Start DE4173 for "results" attribute
"RTN","HMPDJ03",101,0)
 . N HMP92,HMPNI
"RTN","HMPDJ03",102,0)
 . S HMPNI=$P(X,";")  ;Note (document) IEN --> ^TIU(8925,HMPNI
"RTN","HMPDJ03",103,0)
 . I HMPNI>0 D
"RTN","HMPDJ03",104,0)
 .. D SETTEXT^HMPUTILS($NA(^TIU(8925,HMPNI,"TEXT")),"HMP92")  ;Format a word processing field
"RTN","HMPDJ03",105,0)
 .. M CONS("results",HMPJ,"note","\")=HMP92
"RTN","HMPDJ03",106,0)
 . ;=== End DE4173 for "results" attribute
"RTN","HMPDJ03",107,0)
 . S CONS("results",HMPJ,"uid")=$$SETUID^HMPUTILS("document",DFN,+X)
"RTN","HMPDJ03",108,0)
 . D EXTRACT^TIULQ(+X,"HMPTIU",,.01)
"RTN","HMPDJ03",109,0)
 . S CONS("results",HMPJ,"localTitle")=$G(HMPTIU(+X,.01,"E"))
"RTN","HMPDJ03",110,0)
 S X=$P(X0,U,21),X=$S(X:$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U),1:$$FAC^HMPD)
"RTN","HMPDJ03",111,0)
 D FACILITY^HMPUTILS(X,"CONS")
"RTN","HMPDJ03",112,0)
 S CONS("lastUpdateTime")=$$EN^HMPSTMP("consult")
"RTN","HMPDJ03",113,0)
 S CONS("stampTime")=CONS("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ03",114,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ03",115,0)
 I $G(HMPMETA) D ADD^HMPMETA("consult",CONS("uid"),CONS("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ03",116,0)
 D ADD^HMPDJ("CONS","consult")
"RTN","HMPDJ03",117,0)
 Q
"RTN","HMPDJ03",118,0)
 ;
"RTN","HMPDJ03",119,0)
MDPS1(DFN,BEG,END,MAX) ; -- perform CP search (scope variables)
"RTN","HMPDJ03",120,0)
 N MCARCODE,MCARDT,MCARPROC,MCESKEY,MCESSEC,MCFILE,MDC,MDIMG,RES
"RTN","HMPDJ03",121,0)
 S BEG=$G(BEG,1410101),END=$G(END,4141015),MAX=$G(MAX,9999)
"RTN","HMPDJ03",122,0)
 K ^TMP("MDHSP",$J) S RES=""
"RTN","HMPDJ03",123,0)
 D EN1^MDPS1(.RES,DFN,BEG,END,MAX,"",0) ;RES=^TMP("MDHSP",$J)
"RTN","HMPDJ03",124,0)
 Q
"RTN","HMPDJ03",125,0)
 ;
"RTN","HMPDJ03",126,0)
MC1(ID) ; -- clinical procedure HMPX=^TMP("MDHSP",$J,HMPN)
"RTN","HMPDJ03",127,0)
 N X,Y,%DT,DATE,RTN,GBL,CONS,TIUN,HMPD,X0,PROC,HMPT,LOC,FAC
"RTN","HMPDJ03",128,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ03",129,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ03",130,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the clinical procedure domain"
"RTN","HMPDJ03",131,0)
 ;
"RTN","HMPDJ03",132,0)
 S RTN=$P(HMPX,U,3,4) Q:RTN="PRPRO^MDPS4"  ;skip non-CP items
"RTN","HMPDJ03",133,0)
 S X=$P(HMPX,U,6),%DT="TXS" D ^%DT Q:Y'>0  S DATE=Y
"RTN","HMPDJ03",134,0)
 S GBL=+$P(HMPX,U,2)_";"_$S(RTN="PR702^MDPS1":"MDD(702,",1:$$ROOT^HMPDMC(DFN,$P(HMPX,U,11),DATE))
"RTN","HMPDJ03",135,0)
 Q:'GBL  I $G(ID),ID'=GBL Q                ;unknown, or not requested
"RTN","HMPDJ03",136,0)
 ;
"RTN","HMPDJ03",137,0)
 S CONS=+$P(HMPX,U,13) D:CONS DOCLIST^GMRCGUIB(.HMPD,CONS) S X0=$G(HMPD(0)) ;=^GMR(123,ID,0)
"RTN","HMPDJ03",138,0)
 S TIUN=+$P(HMPX,U,14) S:TIUN TIUN=TIUN_U_$$RESOLVE^TIUSRVLO(TIUN)
"RTN","HMPDJ03",139,0)
 S PROC("localId")=GBL,PROC("category")="CP"
"RTN","HMPDJ03",140,0)
 S PROC("uid")=$$SETUID^HMPUTILS("procedure",DFN,GBL)
"RTN","HMPDJ03",141,0)
 S PROC("name")=$P(HMPX,U),PROC("dateTime")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ03",142,0)
 S X=$P(HMPX,U,7) S:$L(X) PROC("interpretation")=X
"RTN","HMPDJ03",143,0)
 S PROC("kind")="Procedure"
"RTN","HMPDJ03",144,0)
 I CONS,X0 D
"RTN","HMPDJ03",145,0)
 . N HMPJ S PROC("requested")=$$JSONDT^HMPUTILS(+X0)
"RTN","HMPDJ03",146,0)
 . S PROC("consultUid")=$$SETUID^HMPUTILS("consult",DFN,CONS)
"RTN","HMPDJ03",147,0)
 . S PROC("orderUid")=$$SETUID^HMPUTILS("order",DFN,+$P(X0,U,3))
"RTN","HMPDJ03",148,0)
 . S PROC("statusName")=$$EXTERNAL^DILFD(123,8,,$P(X0,U,12))
"RTN","HMPDJ03",149,0)
 . S HMPJ=0 F  S HMPJ=$O(HMPD(50,HMPJ)) Q:HMPJ<1  S X=+$G(HMPD(50,HMPJ)) D
"RTN","HMPDJ03",150,0)
 .. D NOTE(X)
"RTN","HMPDJ03",151,0)
 .. S:'TIUN TIUN=X_U_$$RESOLVE^TIUSRVLO(X)
"RTN","HMPDJ03",152,0)
 I TIUN D
"RTN","HMPDJ03",153,0)
 . S X=$P(TIUN,U,5) I X D
"RTN","HMPDJ03",154,0)
 .. S PROC("providers",1,"providerUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ03",155,0)
 .. S PROC("providers",1,"providerName")=$P(X,";",3)
"RTN","HMPDJ03",156,0)
 . S:$P(TIUN,U,11) PROC("hasImages")="true"
"RTN","HMPDJ03",157,0)
 . K HMPT D EXTRACT^TIULQ(+TIUN,"HMPT",,".03;.05;1211",,,"I")
"RTN","HMPDJ03",158,0)
 . S X=+$G(HMPT(+TIUN,.03,"I")),PROC("encounterUid")=$$SETUID^HMPUTILS("visit",DFN,X)
"RTN","HMPDJ03",159,0)
 . S LOC=+$G(HMPT(+TIUN,1211,"I")) I LOC S LOC=LOC_U_$$GET1^DIQ(44,LOC_",",.01)  ;DE2818
"RTN","HMPDJ03",160,0)
 . E  S X=$P(TIUN,U,6) S:$L(X) LOC=+$O(^SC("B",X,0))_U_X  ; DE2818, ICR 10040
"RTN","HMPDJ03",161,0)
 . S:LOC PROC("locationUid")=$$SETUID^HMPUTILS("location",,+LOC),PROC("locationName")=$P(LOC,U,2),FAC=$$FAC^HMPD(+LOC)
"RTN","HMPDJ03",162,0)
 . I '$D(PROC("statusName")) S X=+$G(HMPT(+TIUN,.05,"I")),PROC("statusName")=$S(X<6:"PARTIAL RESULTS",1:"COMPLETE")
"RTN","HMPDJ03",163,0)
 . I '$G(PROC("results",+TIUN)) D NOTE(+TIUN)
"RTN","HMPDJ03",164,0)
 ; if no consult or note/visit ...
"RTN","HMPDJ03",165,0)
 I 'CONS,'TIUN,RTN'="PR702^MDPS1" S PROC("results",1,"uid")=$$SETUID^HMPUTILS("document",DFN,GBL) ;DE1977 add link to report document
"RTN","HMPDJ03",166,0)
 S:'$D(PROC("statusName")) PROC("statusName")="COMPLETE"
"RTN","HMPDJ03",167,0)
 I '$D(FAC) S X=$P(X0,U,21),FAC=$S(X:$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U),1:$$FAC^HMPD)
"RTN","HMPDJ03",168,0)
 D FACILITY^HMPUTILS(FAC,"PROC")
"RTN","HMPDJ03",169,0)
 S PROC("lastUpdateTime")=$$EN^HMPSTMP("procedure")
"RTN","HMPDJ03",170,0)
 S PROC("stampTime")=PROC("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ03",171,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ03",172,0)
 I $G(HMPMETA) D ADD^HMPMETA("procedure",PROC("uid"),PROC("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ03",173,0)
 D ADD^HMPDJ("PROC","procedure")
"RTN","HMPDJ03",174,0)
 Q
"RTN","HMPDJ03",175,0)
 ;
"RTN","HMPDJ03",176,0)
NOTE(DA) ; -- add TIU note info
"RTN","HMPDJ03",177,0)
 N HMPT,TEXT
"RTN","HMPDJ03",178,0)
 D EXTRACT^TIULQ(DA,"HMPT",,.01)
"RTN","HMPDJ03",179,0)
 S PROC("results",DA,"uid")=$$SETUID^HMPUTILS("document",+$G(DFN),DA)
"RTN","HMPDJ03",180,0)
 S PROC("results",DA,"localTitle")=$G(HMPT(DA,.01,"E"))
"RTN","HMPDJ03",181,0)
 Q
"RTN","HMPDJ03",182,0)
 ;
"RTN","HMPDJ03",183,0)
MDC1(ID) ; -- clinical observation
"RTN","HMPDJ03",184,0)
 N GUID,CLIO,HMPC,HMPT,LOC,FAC,I,X,Y
"RTN","HMPDJ03",185,0)
 S GUID=$G(ID) Q:GUID=""  ;invalid GUID
"RTN","HMPDJ03",186,0)
 D QRYOBS^HMPDMDC("HMPC",GUID) Q:'$D(HMPC)  ;doesn't exist
"RTN","HMPDJ03",187,0)
 Q:$L($G(HMPC("PARENT_ID","E")))            ;PARENT also in list
"RTN","HMPDJ03",188,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ03",189,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ03",190,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the clinical observation domain"
"RTN","HMPDJ03",191,0)
 ;
"RTN","HMPDJ03",192,0)
 S CLIO("localId")=GUID,CLIO("uid")=$$SETUID^HMPUTILS("obs",DFN,GUID)
"RTN","HMPDJ03",193,0)
 S X=$G(HMPC("TERM_ID","I")) S:X CLIO("typeVuid")="urn:va:vuid:"_X
"RTN","HMPDJ03",194,0)
 S CLIO("typeCode")="urn:va:clioterminology:"_$G(HMPC("TERM_ID","GUID"))
"RTN","HMPDJ03",195,0)
 S CLIO("typeName")=$G(HMPC("TERM_ID","E"))
"RTN","HMPDJ03",196,0)
 S CLIO("result")=$G(HMPC("SVALUE","E"))
"RTN","HMPDJ03",197,0)
 S X=$G(HMPC("UNIT_ID","ABBV")) S:$L(X) CLIO("units")=X
"RTN","HMPDJ03",198,0)
 S X=$G(HMPC("ENTERED_DATE_TIME","I")),CLIO("entered")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",199,0)
 S X=$G(HMPC("OBSERVED_DATE_TIME","I")),CLIO("observed")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",200,0)
 D QRYTYPES^HMPDMDC("HMPT")
"RTN","HMPDJ03",201,0)
 F I=3,5 S X=$G(HMPT(I,"XML")) I $L($G(HMPC(X,"E"))) D
"RTN","HMPDJ03",202,0)
 . S Y=HMPT(I,"NAME"),Y=$S(Y="LOCATION":"bodySite",1:$$LOW^XLFSTR(Y))
"RTN","HMPDJ03",203,0)
 . S CLIO(Y_"Code")=HMPC(X,"I"),CLIO(Y_"Name")=HMPC(X,"E")
"RTN","HMPDJ03",204,0)
 F I=4,6,7 S X=$G(HMPT(I,"XML")) I $L($G(HMPC(X,"E"))) D
"RTN","HMPDJ03",205,0)
 . S CLIO("qualifiers",I,"type")=$$LOW^XLFSTR(HMPT(I,"NAME"))
"RTN","HMPDJ03",206,0)
 . S CLIO("qualifiers",I,"code")=HMPC(X,"I")
"RTN","HMPDJ03",207,0)
 . S CLIO("qualifiers",I,"name")=HMPC(X,"E")
"RTN","HMPDJ03",208,0)
 S X=$G(HMPC("RANGE","E")) I $L(X) D
"RTN","HMPDJ03",209,0)
 . S Y=$S(X="Out of Bounds Low":"<",X="Out of Bounds High":">",1:$E(X))
"RTN","HMPDJ03",210,0)
 . S CLIO("interpretationCode")="urn:hl7:observation-interpretation:"_Y
"RTN","HMPDJ03",211,0)
 . S CLIO("interpretationName")=$S(X="<":"Low off scale",X=">":"High off scale",1:X)
"RTN","HMPDJ03",212,0)
 ; X=$G(HMPC("STATUS","E")) S:$L(X) CLIO("resultStatus")=$S(X="unverified":"active",1:"complete")
"RTN","HMPDJ03",213,0)
 I $D(HMPC("SUPP_PAGE")) D  ;add set info
"RTN","HMPDJ03",214,0)
 . S CLIO("setID")=$G(HMPC("SUPP_PAGE","GUID"))
"RTN","HMPDJ03",215,0)
 . S CLIO("setName")=$G(HMPC("SUPP_PAGE","DISPLAY_NAME"))
"RTN","HMPDJ03",216,0)
 . S X=$G(HMPC("SUPP_PAGE","TYPE")) S:$L(X) CLIO("setType")=X
"RTN","HMPDJ03",217,0)
 . S X=$G(HMPC("SUPP_PAGE","ACTIVATED_DATE_TIME")) S:X CLIO("setStart")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",218,0)
 . S X=$G(HMPC("SUPP_PAGE","DEACTIVATED_DATE_TIME")) S:X CLIO("setStop")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",219,0)
 S CLIO("statusCode")="urn:va:observation-status:complete",CLIO("statusName")="complete"
"RTN","HMPDJ03",220,0)
 S LOC=$G(HMPC("HOSPITAL_LOCATION_ID","I")),FAC=$$FAC^HMPD(LOC)
"RTN","HMPDJ03",221,0)
 S CLIO("locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ03",222,0)
 S CLIO("locationName")=$G(HMPC("HOSPITAL_LOCATION_ID","E"))
"RTN","HMPDJ03",223,0)
 D FACILITY^HMPUTILS(FAC,"CLIO")
"RTN","HMPDJ03",224,0)
 S X=$G(HMPC("COMMENT","E")) S:$L(X) CLIO("comment")=X
"RTN","HMPDJ03",225,0)
 S CLIO("lastUpdateTime")=$$EN^HMPSTMP("obs") ; RHL 20141231
"RTN","HMPDJ03",226,0)
 S CLIO("stampTime")=CLIO("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ03",227,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ03",228,0)
 I $G(HMPMETA) D ADD^HMPMETA("obs",CLIO("uid"),CLIO("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ03",229,0)
 D ADD^HMPDJ("CLIO","obs")
"RTN","HMPDJ03",230,0)
 Q
"RTN","HMPDJ04")
0^9^B91911154
"RTN","HMPDJ04",1,0)
HMPDJ04 ;SLC/MKB,ASMR/RRB,ASF,PB - Appointments,Visits;May 24, 2016 15:21:17
"RTN","HMPDJ04",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ04",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ04",4,0)
 ;
"RTN","HMPDJ04",5,0)
 ; External References          DBIA#
"RTN","HMPDJ04",6,0)
 ; -------------------          -----
"RTN","HMPDJ04",7,0)
 ; ^AUPNVSIT                     2028
"RTN","HMPDJ04",8,0)
 ; ^DGS(41.1                     3796
"RTN","HMPDJ04",9,0)
 ; ^DIC(42                      10039
"RTN","HMPDJ04",10,0)
 ; ^SC                          10040
"RTN","HMPDJ04",11,0)
 ; ^VA(200                      10060
"RTN","HMPDJ04",12,0)
 ; DIQ                           2056
"RTN","HMPDJ04",13,0)
 ; ICPTCOD                       1995
"RTN","HMPDJ04",14,0)
 ; PXAPI,^TMP("PXKENC"           1894
"RTN","HMPDJ04",15,0)
 ; SDAMA301                      4433
"RTN","HMPDJ04",16,0)
 ; XLFDT                        10103
"RTN","HMPDJ04",17,0)
 ; XUAF4                         2171
"RTN","HMPDJ04",18,0)
 ; EDP(230                       6275
"RTN","HMPDJ04",19,0)
 ; SC(                             93
"RTN","HMPDJ04",20,0)
 ;
"RTN","HMPDJ04",21,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ04",22,0)
 Q
"RTN","HMPDJ04",23,0)
 ;
"RTN","HMPDJ04",24,0)
SDAM1 ; -- appointment ^TMP($J,"SDAMA301",DFN,HMPDT)
"RTN","HMPDJ04",25,0)
 N NODE,HLOC,APPT,X,STS,CLS,FAC,SV,PRV
"RTN","HMPDJ04",26,0)
 S NODE=$G(^TMP($J,"SDAMA301",DFN,HMPDT))
"RTN","HMPDJ04",27,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ04",28,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ04",29,0)
 S ERRMSG="A problem occurred converting a record for the appointment domain"
"RTN","HMPDJ04",30,0)
 ;
"RTN","HMPDJ04",31,0)
 S HLOC=$P(NODE,U,2),X="A;"_HMPDT_";"_+HLOC
"RTN","HMPDJ04",32,0)
 I $L($G(ID)),$P(ID,";",1,3)'=X Q
"RTN","HMPDJ04",33,0)
 S APPT("localId")=X,APPT("uid")=$$SETUID^HMPUTILS("appointment",DFN,X)
"RTN","HMPDJ04",34,0)
 S X=$P(NODE,U,10),APPT("typeCode")=$P(X,";"),APPT("typeName")=$P(X,";",2)
"RTN","HMPDJ04",35,0)
 S STS=$P(NODE,U,3),CLS=$S($E(STS)="I":"I",1:"O")
"RTN","HMPDJ04",36,0)
 S STS=$P($P(NODE,U,22),";",1,2)  ;DE4469 - PB - APR 26, 2016 changed from using the SDAMA308 API to using the SDAMA301 Supported API to get appointment status ICR 4433
"RTN","HMPDJ04",37,0)
 S APPT("dateTime")=$$JSONDT^HMPUTILS(HMPDT)
"RTN","HMPDJ04",38,0)
 S:$L($P(NODE,U,6)) APPT("comment")=$P(NODE,U,6)
"RTN","HMPDJ04",39,0)
 S:$P(NODE,U,9) APPT("checkIn")=$$JSONDT^HMPUTILS($P(NODE,U,9))
"RTN","HMPDJ04",40,0)
 S:$P(NODE,U,11) APPT("checkOut")=$$JSONDT^HMPUTILS($P(NODE,U,11))
"RTN","HMPDJ04",41,0)
 I $L(ID,";")>3 S APPT("reasonName")=$P(ID,";",4),PRV=+$P(ID,";",5) ;from SDAM event
"RTN","HMPDJ04",42,0)
 S FAC=$$FAC^HMPD(+HLOC) D FACILITY^HMPUTILS(FAC,"APPT") I HLOC D
"RTN","HMPDJ04",43,0)
 . S APPT("locationName")=$P(HLOC,";",2)
"RTN","HMPDJ04",44,0)
 . S APPT("locationUid")=$$SETUID^HMPUTILS("location",,+HLOC)
"RTN","HMPDJ04",45,0)
 . S X=$$GET1^DIQ(44,(+HLOC)_",",1) S:X]"" APPT("shortLocationName")=X  ;DE2818, (#1) ABBREVIATION
"RTN","HMPDJ04",46,0)
 . S X=$$AMIS^HMPDVSIT(+$P(NODE,U,13))
"RTN","HMPDJ04",47,0)
 . S:$L(X) APPT("stopCodeUid")="urn:va:stop-code:"_$P(X,U),APPT("stopCodeName")=$P(X,U,2)
"RTN","HMPDJ04",48,0)
 . S SV=$$GET1^DIQ(44,+HLOC_",",9.5,"I")
"RTN","HMPDJ04",49,0)
 . I SV S APPT("service")=$$SERV^HMPDSDAM(SV)
"RTN","HMPDJ04",50,0)
 . ;find default provider
"RTN","HMPDJ04",51,0)
 . S:'$G(PRV) PRV=+$$GET1^DIQ(44,+HLOC_",",16,"I") I 'PRV D
"RTN","HMPDJ04",52,0)
 .. N HMPP,I,FIRST
"RTN","HMPDJ04",53,0)
 .. D GETS^DIQ(44,+HLOC_",","2600*","I","HMPP")
"RTN","HMPDJ04",54,0)
 .. S FIRST=$O(HMPP(44.1,"")),I=""
"RTN","HMPDJ04",55,0)
 .. F  S I=$O(HMPP(44.1,I)) Q:I=""  I $G(HMPP(44.1,I,.02,"I")) S PRV=$G(HMPP(44.1,I,.01,"I")) Q
"RTN","HMPDJ04",56,0)
 .. I 'PRV,FIRST S PRV=$G(HMPP(44.1,FIRST,.01,"I"))
"RTN","HMPDJ04",57,0)
 I $G(PRV) S APPT("providers",1,"providerUid")=$$SETUID^HMPUTILS("user",,PRV),APPT("providers",1,"providerName")=$$GET1^DIQ(200,PRV_",",.01)  ;DE2818
"RTN","HMPDJ04",58,0)
 S APPT("patientClassCode")="urn:va:patient-class:"_$S(CLS="I":"IMP",1:"AMB")
"RTN","HMPDJ04",59,0)
 S APPT("patientClassName")=$S(CLS="I":"Inpatient",1:"Ambulatory")
"RTN","HMPDJ04",60,0)
 S APPT("categoryCode")="urn:va:encounter-category:OV",APPT("categoryName")="Outpatient Visit"
"RTN","HMPDJ04",61,0)
 S APPT("appointmentStatus")=$P(STS,";",2)
"RTN","HMPDJ04",62,0)
 S APPT("lastUpdateTime")=$$EN^HMPSTMP("appointment") ;RHL 20150102
"RTN","HMPDJ04",63,0)
 S APPT("stampTime")=APPT("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ04",64,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ04",65,0)
 I $G(HMPMETA) D ADD^HMPMETA("appointment",APPT("uid"),APPT("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ04",66,0)
 D ADD^HMPDJ("APPT","appointment")
"RTN","HMPDJ04",67,0)
 Q
"RTN","HMPDJ04",68,0)
 ;
"RTN","HMPDJ04",69,0)
DGS ; scheduled admissions [from APPOINTM^HMPDJ0]
"RTN","HMPDJ04",70,0)
 ;DE2818, ^DGS(41.1) references ICR 3796
"RTN","HMPDJ04",71,0)
 S HMPA=0 F  S HMPA=$O(^DGS(41.1,"B",DFN,HMPA)) Q:HMPA<1  D  Q:HMPI'<HMPMAX
"RTN","HMPDJ04",72,0)
 . S HMPX=$G(^DGS(41.1,HMPA,0))
"RTN","HMPDJ04",73,0)
 . I $L($G(ID)),+$P(ID,";",2)=+$P(HMPX,U,2) D DGS1(HMPA) Q
"RTN","HMPDJ04",74,0)
 . Q:$P(HMPX,U,13)  Q:$P(HMPX,U,17)  ;cancelled or admitted
"RTN","HMPDJ04",75,0)
 . S X=$P(HMPX,U,2) Q:X<HMPSTART!(X>HMPSTOP)  ;out of date range
"RTN","HMPDJ04",76,0)
 . D DGS1(HMPA)
"RTN","HMPDJ04",77,0)
 Q
"RTN","HMPDJ04",78,0)
 ;
"RTN","HMPDJ04",79,0)
DGS1(IFN) ; -- scheduled admission
"RTN","HMPDJ04",80,0)
 N ADM,X0,DATE,HLOC,FAC,SV,X
"RTN","HMPDJ04",81,0)
 S X0=$G(^DGS(41.1,+$G(IFN),0)) Q:X0=""  ;deleted (DE2818, ICR 3796)
"RTN","HMPDJ04",82,0)
 ;
"RTN","HMPDJ04",83,0)
 S DATE=+$P(X0,U,2),HLOC=+$$GET1^DIQ(42,+$P(X0,U,8)_",",.01)  ;DE2818, ICR 10039
"RTN","HMPDJ04",84,0)
 S X="H;"_DATE,ADM("localId")=X,ADM("uid")=$$SETUID^HMPUTILS("appointment",DFN,X)
"RTN","HMPDJ04",85,0)
 S ADM("dateTime")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ04",86,0)
 S FAC=$$FAC^HMPD(+HLOC) D FACILITY^HMPUTILS(FAC,"ADM") I HLOC D
"RTN","HMPDJ04",87,0)
 . S HLOC=$$GET1^DIQ(44,(+HLOC)_",",.01)  ;DE2818, (#.01) NAME
"RTN","HMPDJ04",88,0)
 . S ADM("uid")=ADM("uid")_";"_+HLOC
"RTN","HMPDJ04",89,0)
 . S ADM("locationName")=$P(HLOC,";",2)
"RTN","HMPDJ04",90,0)
 . S X=$$GET1^DIQ(44,(+HLOC)_",",1)  S:X]"" ADM("shortLocationName")=X  ;DE2818, (#1) ABBREVIATION
"RTN","HMPDJ04",91,0)
 . S ADM("locationUid")=$$SETUID^HMPUTILS("location",,+HLOC)
"RTN","HMPDJ04",92,0)
 . S X=$$GET1^DIQ(44,+HLOC_",",8,"I"),X=$$AMIS^HMPDVSIT(X)
"RTN","HMPDJ04",93,0)
 . S:$L(X) ADM("stopCodeUid")="urn:va:stop-code:"_$P(X,U),ADM("stopCodeName")=$P(X,U,2)
"RTN","HMPDJ04",94,0)
 . S SV=$$GET1^DIQ(44,+HLOC_",",9.5,"I")
"RTN","HMPDJ04",95,0)
 . I SV S ADM("service")=$$SERV^HMPDSDAM(SV)
"RTN","HMPDJ04",96,0)
 S X=+$P(X0,U,5) I X D
"RTN","HMPDJ04",97,0)
 . S ADM("providers",1,"providerUid")=$$SETUID^HMPUTILS("user",,X)
"RTN","HMPDJ04",98,0)
 . S ADM("providers",1,"providerName")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ04",99,0)
 S ADM("patientClassCode")="urn:va:patient-class:IMP",ADM("patientClassName")="Inpatient"
"RTN","HMPDJ04",100,0)
 S ADM("categoryCode")="urn:va:encounter-category:AD",ADM("categoryName")="Admission"
"RTN","HMPDJ04",101,0)
 S ADM("appointmentStatus")=$S($P(X0,U,17):"ADMITTED",$P(X0,U,13):"CANCELLED",1:"SCHEDULED")
"RTN","HMPDJ04",102,0)
 S ADM("lastUpdateTime")=$$EN^HMPSTMP("adm") ;RHL 20150102
"RTN","HMPDJ04",103,0)
 S ADM("stampTime")=ADM("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ04",104,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ04",105,0)
 I $G(HMPMETA) D ADD^HMPMETA("appointment",ADM("uid"),ADM("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ04",106,0)
 D ADD^HMPDJ("ADM","appointment")
"RTN","HMPDJ04",107,0)
 Q
"RTN","HMPDJ04",108,0)
 ;
"RTN","HMPDJ04",109,0)
VSIT1(ID) ; -- visit
"RTN","HMPDJ04",110,0)
 N VST,X0,X15,X,FAC,LOC,CATG,AMIS,INPT,DA,PS
"RTN","HMPDJ04",111,0)
 I $G(ID)?1"H"1.N D ADM^HMPDJ04A(ID) Q
"RTN","HMPDJ04",112,0)
 ;DE2818, ICR 6275
"RTN","HMPDJ04",113,0)
 I $D(^EDP(230,"V",ID)),$L($T(EDP1^HMPDJ04E)) D EDP1^HMPDJ04E(ID) Q
"RTN","HMPDJ04",114,0)
 ; ENCEVENT^PXAPI(ID)
"RTN","HMPDJ04",115,0)
 ;
"RTN","HMPDJ04",116,0)
 ; DE2818, ^AUPNVSIT - ICR 2028
"RTN","HMPDJ04",117,0)
 S X0=$G(^AUPNVSIT(ID,0)),X15=$G(^(150)) Q:X0=""  ;pjh - quit if visit already deleted
"RTN","HMPDJ04",118,0)
 ; X0=$G(^TMP("PXKENC",$J,ID,"VST",ID,0)),X15=$G(^(150))
"RTN","HMPDJ04",119,0)
 ;Q:$P(X15,U,3)'="P"  Q:$P(X0,U,7)="E"  Q:$P(X0,U,12)  ;primary, not historical or child
"RTN","HMPDJ04",120,0)
 I $P(X0,U,7)="H" D ADM^HMPDJ04A(ID,+X0) Q
"RTN","HMPDJ04",121,0)
 S VST("localId")=ID,VST("uid")=$$SETUID^HMPUTILS("visit",DFN,ID)
"RTN","HMPDJ04",122,0)
 S VST("dateTime")=$$JSONDT^HMPUTILS(+X0)  ;(#.01) VISIT/ADMIT DATE&TIME
"RTN","HMPDJ04",123,0)
 S:$P(X0,U,18) VST("checkOut")=$$JSONDT^HMPUTILS($P(X0,U,18))  ;(#.18) CHECK OUT DATE&TIME
"RTN","HMPDJ04",124,0)
 S:$P(X0,U,12) VST("parentUid")=$$SETUID^HMPUTILS("visit",DFN,$P(X0,U,12))  ;(#.12) PARENT VISIT LINK
"RTN","HMPDJ04",125,0)
 ;(#.06) LOC. OF ENCOUNTER, (#.07) SERVICE CATEGORY, (#.22) HOSPITAL LOCATION
"RTN","HMPDJ04",126,0)
 S FAC=+$P(X0,U,6),CATG=$P(X0,U,7),LOC=+$P(X0,U,22)
"RTN","HMPDJ04",127,0)
 S:FAC X=$$STA^XUAF4(FAC)_U_$P($$NS^XUAF4(FAC),U)
"RTN","HMPDJ04",128,0)
 S:'FAC X=$$FAC^HMPD(LOC) D FACILITY^HMPUTILS(X,"VST")
"RTN","HMPDJ04",129,0)
 S X=$S(CATG="H":"AD",CATG="C":"CR",CATG="T":"TC",CATG="N":"U",CATG="R":"NH","D^X"[CATG:"O",1:"OV")
"RTN","HMPDJ04",130,0)
 S VST("categoryCode")="urn:va:encounter-category:"_X
"RTN","HMPDJ04",131,0)
 S VST("categoryName")=$S(X="AD":"Admission",X="CR":"Chart Review",X="TC":"Phone Contact",X="U":"Unknown",X="NH":"Nursing Home",X="O":"Other",1:"Outpatient Visit")
"RTN","HMPDJ04",132,0)
 S INPT=$P(X15,U,2) S:INPT="" INPT=$S("H^I^R^D"[CATG:1,1:0)  ;(#15002) PATIENT STATUS IN/OUT
"RTN","HMPDJ04",133,0)
 S X=$P(X15,U,3) S:$L(X) VST("encounterType")=X  ;(#15003) ENCOUNTER TYPE
"RTN","HMPDJ04",134,0)
 S X=$$CPT(ID) S:X VST("typeName")=$P($$CPT^ICPTCOD(X),U,3)
"RTN","HMPDJ04",135,0)
 I 'X S VST("typeName")=$S('INPT&LOC:$$GET1^DIQ(44,LOC_",",.01)_" VISIT",1:$$CATG^HMPDVSIT(CATG))  ;DE2818
"RTN","HMPDJ04",136,0)
 S VST("patientClassCode")="urn:va:patient-class:"_$S(INPT:"IMP",1:"AMB")
"RTN","HMPDJ04",137,0)
 S VST("patientClassName")=$S(INPT:"Inpatient",1:"Ambulatory")
"RTN","HMPDJ04",138,0)
 ; US12589 - add createdByName field to extract
"RTN","HMPDJ04",139,0)
 S X=$$GET1^DIQ(200,$P(X0,U,23)_",",".01") S:$G(X)="" X="UNKNOWN"
"RTN","HMPDJ04",140,0)
 S VST("createdByName")=X
"RTN","HMPDJ04",141,0)
 ;(#.08) DSS ID
"RTN","HMPDJ04",142,0)
 S X=$P(X0,U,8) S:X AMIS=$$AMIS^HMPDVSIT(X) I LOC D
"RTN","HMPDJ04",143,0)
 . I 'X N AMISARR D GETS^DIQ(44,LOC_",",8,"I","AMISARR","ERR") I $G(AMISARR(44,LOC_",",8,"I"))'="" S X=$G(AMISARR(44,LOC_",",8,"I")),AMIS=$$AMIS^HMPDVSIT(X)  ;DE5300 - PB - Jun 30 2015 changed call to get stop code name and number
"RTN","HMPDJ04",144,0)
 . S VST("locationUid")=$$SETUID^HMPUTILS("location",,+LOC)
"RTN","HMPDJ04",145,0)
 . S X=$$GET1^DIQ(44,LOC_",",1) S:X]"" VST("shortLocationName")=X  ;DE2818, (#1) ABBREVIATION
"RTN","HMPDJ04",146,0)
 . S VST("locationName")=$$GET1^DIQ(44,LOC_",",.01)  ;DE2818, (#.01) NAME
"RTN","HMPDJ04",147,0)
 . S VST("locationOos")=$S($$GET1^DIQ(44,LOC_",",50.01,"I"):"true",1:"false")  ;DE2818, (#50.01) OCCASION OF SERVICE CLINIC?
"RTN","HMPDJ04",148,0)
 . S X=$$SERV^HMPDVSIT($$GET1^DIQ(44,LOC_",",9.5,"I")) S:$L(X) VST("service")=X  ;DE2818, (#9.5) TREATING SPECIALTY
"RTN","HMPDJ04",149,0)
 S:$D(AMIS) VST("stopCodeUid")="urn:va:stop-code:"_$P(AMIS,U),VST("stopCodeName")=$P(AMIS,U,2)
"RTN","HMPDJ04",150,0)
 S X=$$POV(ID) S:$L(X) VST("reasonUid")=$$SETNCS^HMPUTILS("icd",$P(X,U)),VST("reasonName")=$P(X,U,2)
"RTN","HMPDJ04",151,0)
 ; provider(s), DE2818 - ^AUPNVPRV references - ICR 2316
"RTN","HMPDJ04",152,0)
 S DA=0 F  S DA=$O(^AUPNVPRV("AD",ID,DA)) Q:DA<1  D
"RTN","HMPDJ04",153,0)
 . S X0=$G(^AUPNVPRV(DA,0))
"RTN","HMPDJ04",154,0)
 . I $P(X0,U,4)="P" D PROV("VST",DA,+X0,"P",1) Q  ;primary
"RTN","HMPDJ04",155,0)
 . D:'$D(PS(+X0)) PROV("VST",DA,+X0,"S")          ;secondary
"RTN","HMPDJ04",156,0)
 . S PS(+X0)=""                                   ; (no duplicates)
"RTN","HMPDJ04",157,0)
 K ^TMP("PXKENC",$J,ID)
"RTN","HMPDJ04",158,0)
 S VST("lastUpdateTime")=$$EN^HMPSTMP("visit") ;RHL 20150103
"RTN","HMPDJ04",159,0)
 S VST("stampTime")=VST("lastUpdateTime") ; RHL 20150103
"RTN","HMPDJ04",160,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ04",161,0)
 I $G(HMPMETA) D ADD^HMPMETA("visit",VST("uid"),VST("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ04",162,0)
 D ADD^HMPDJ("VST","visit")
"RTN","HMPDJ04",163,0)
 Q
"RTN","HMPDJ04",164,0)
 ;
"RTN","HMPDJ04",165,0)
CPT(VISIT) ; -- Return CPT code of encounter type
"RTN","HMPDJ04",166,0)
 ;DE2818 - Change to use API and not directly access the global
"RTN","HMPDJ04",167,0)
 N DA,Y S Y=""
"RTN","HMPDJ04",168,0)
 ;DE2818, ICR 2048 for ^AUPNVCPT references
"RTN","HMPDJ04",169,0)
 S DA=0 F  S DA=$O(^AUPNVCPT("AD",VISIT,DA)) Q:DA<1  D  Q:$L(Y)
"RTN","HMPDJ04",170,0)
 . D ENCEVENT^PXAPI(VISIT,1)
"RTN","HMPDJ04",171,0)
 . I +$G(^TMP("PXKENC",$J,VISIT,"CPT",DA,0))?1"992"2N S Y=+$G(^TMP("PXKENC",$J,VISIT,"CPT",DA,0))
"RTN","HMPDJ04",172,0)
 Q Y
"RTN","HMPDJ04",173,0)
 ;
"RTN","HMPDJ04",174,0)
POV(VISIT) ; -- return the primary Purpose of Visit as ICD^ProviderNarrative
"RTN","HMPDJ04",175,0)
 N DA,Y,X,X0,ICD S Y=""
"RTN","HMPDJ04",176,0)
 ;DE2818, ^AUPNVPOV( - ICR 3094
"RTN","HMPDJ04",177,0)
 S DA=0 F  S DA=$O(^AUPNVPOV("AD",VISIT,DA)) Q:DA<1  D  Q:$L(Y)
"RTN","HMPDJ04",178,0)
 . S X0=$G(^AUPNVPOV(DA,0)) Q:$P(X0,U,12)'="P"
"RTN","HMPDJ04",179,0)
 . S X=+$P(X0,U,4),ICD=$$ICD^HMPDVSIT(+X0)
"RTN","HMPDJ04",180,0)
 . S Y=ICD_U_$$EXTERNAL^DILFD(9000010.07,.04,,X)
"RTN","HMPDJ04",181,0)
 Q Y
"RTN","HMPDJ04",182,0)
 ;
"RTN","HMPDJ04",183,0)
PROV(ARR,I,IEN,ROLE,PRIM) ; -- add providers
"RTN","HMPDJ04",184,0)
 S @ARR@("providers",I,"providerUid")=$$SETUID^HMPUTILS("user",,+IEN)
"RTN","HMPDJ04",185,0)
 S @ARR@("providers",I,"providerName")=$$GET1^DIQ(200,(+IEN)_",",.01)  ;DE2818
"RTN","HMPDJ04",186,0)
 S @ARR@("providers",I,"role")=ROLE
"RTN","HMPDJ04",187,0)
 S:$G(PRIM) @ARR@("providers",I,"primary")="true"
"RTN","HMPDJ04",188,0)
 Q
"RTN","HMPDJ04",189,0)
 ;
"RTN","HMPDJ04",190,0)
NAME(IEN) ; -- Return a string 'name' for the visit
"RTN","HMPDJ04",191,0)
 N Y,X0,LOC,DATE
"RTN","HMPDJ04",192,0)
 S X0=$G(^AUPNVSIT(+$G(IEN),0)),Y=""  ;DE2818, ICR 2028
"RTN","HMPDJ04",193,0)
 S DATE=+X0,LOC=+$P(X0,U,22) S:LOC LOC=$$GET1^DIQ(44,LOC_",",.01)_" "  ;DE2818
"RTN","HMPDJ04",194,0)
 S Y=LOC_$$FMTE^XLFDT(DATE,"1D") ;Mon DD, YYYY
"RTN","HMPDJ04",195,0)
 Q Y
"RTN","HMPDJ04",196,0)
 ;
"RTN","HMPDJ04",197,0)
FAC(IEN)  ; -- Return Facility for the visit
"RTN","HMPDJ04",198,0)
 Q:'+$G(IEN) ""
"RTN","HMPDJ04",199,0)
 N FAC S FAC=+$$GET1^DIQ(9000010,IEN_",",.06,"I")
"RTN","HMPDJ04",200,0)
 Q:FAC $$STA^XUAF4(FAC)_U_$P($$NS^XUAF4(FAC),U)
"RTN","HMPDJ04",201,0)
 S FAC=+$$GET1^DIQ(9000010,IEN_",",.22,"I")
"RTN","HMPDJ04",202,0)
 Q $$FAC^HMPD(FAC)
"RTN","HMPDJ04",203,0)
 ;
"RTN","HMPDJ04",204,0)
STCODE(IEN)  ;  -- Return stop code information for the visit Q:'+$G(IEN) ""
"RTN","HMPDJ04",205,0)
 Q:'+$G(IEN) ""
"RTN","HMPDJ04",206,0)
 N STCODE,LIEN S STCODE=+$$GET1^DIQ(9000010,IEN_",",.08,"I")
"RTN","HMPDJ04",207,0)
 Q:STCODE $$AMIS^HMPDVSIT(STCODE)
"RTN","HMPDJ04",208,0)
 S LIEN=+$$GET1^DIQ(9000010,IEN_",",.22,"I")
"RTN","HMPDJ04",209,0)
 I LIEN S STCODE=+$$GET1^DIQ(44,LIEN_",",8,"I")
"RTN","HMPDJ04",210,0)
 Q:STCODE $$AMIS^HMPDVSIT(STCODE)
"RTN","HMPDJ04",211,0)
 Q ""
"RTN","HMPDJ04",212,0)
 ;
"RTN","HMPDJ04",213,0)
STOPCODE(X,Y)  ;  -- Return stop code info for JSON
"RTN","HMPDJ04",214,0)
 S @Y@("stopCodeUid")="urn:va:stop-code:"_$P(X,U)
"RTN","HMPDJ04",215,0)
 S @Y@("stopCodeName")=$P(X,U,2)
"RTN","HMPDJ04",216,0)
 Q
"RTN","HMPDJ04",217,0)
 ;
"RTN","HMPDJ04A")
0^10^B59768993
"RTN","HMPDJ04A",1,0)
HMPDJ04A ;ASMR/MKB - Admissions,PTF;Nov 12, 2015 16:42:22
"RTN","HMPDJ04A",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ04A",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ04A",4,0)
 ;
"RTN","HMPDJ04A",5,0)
 ; External References          DBIA#
"RTN","HMPDJ04A",6,0)
 ; -------------------          -----
"RTN","HMPDJ04A",7,0)
 ; ^AUPNVSIT                     2028
"RTN","HMPDJ04A",8,0)
 ; ^DGPM                         1865
"RTN","HMPDJ04A",9,0)
 ; ^DIC(42                      10039
"RTN","HMPDJ04A",10,0)
 ; ^DPT                         10035
"RTN","HMPDJ04A",11,0)
 ; ^SC                          10040
"RTN","HMPDJ04A",12,0)
 ; ^VA(200                      10060
"RTN","HMPDJ04A",13,0)
 ; DGPTFAPI                      3157
"RTN","HMPDJ04A",14,0)
 ; DIC                           2051
"RTN","HMPDJ04A",15,0)
 ; DILFD                         2055
"RTN","HMPDJ04A",16,0)
 ; DIQ                           2056
"RTN","HMPDJ04A",17,0)
 ; ICDCODE                       3990
"RTN","HMPDJ04A",18,0)
 ; ICPTCOD                       1995
"RTN","HMPDJ04A",19,0)
 ; VADPT                        10061
"RTN","HMPDJ04A",20,0)
 ; XUAF4                         2171
"RTN","HMPDJ04A",21,0)
 ;
"RTN","HMPDJ04A",22,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ04A",23,0)
 Q
"RTN","HMPDJ04A",24,0)
 ;
"RTN","HMPDJ04A",25,0)
ADM(ID,DATE) ; -- admission [from VSIT1]
"RTN","HMPDJ04A",26,0)
 N ADM,VADMVT,VAIP,VAERR,MVT,SPEC,HLOC,FAC,ICD,I
"RTN","HMPDJ04A",27,0)
 S ID=$G(ID),DATE=+$G(DATE) Q:ID=""  ;Q:DATE<1
"RTN","HMPDJ04A",28,0)
 I ID S VAIP("D")=DATE,VST=+ID
"RTN","HMPDJ04A",29,0)
 I ID?1"H"1.N S VAIP("E")=+$E(ID,2,99),VST=0
"RTN","HMPDJ04A",30,0)
 D IN5^VADPT Q:'$G(VAIP(1))  ;deleted
"RTN","HMPDJ04A",31,0)
 S VADMVT=+$G(VAIP(13)),ID="H"_VADMVT
"RTN","HMPDJ04A",32,0)
 S ADM("localId")=ID,ADM("uid")=$$SETUID^HMPUTILS("visit",DFN,ID)
"RTN","HMPDJ04A",33,0)
 S:'DATE DATE=+$G(VAIP(13,1)) S:'VST VST=$$VISIT(DFN,DATE)
"RTN","HMPDJ04A",34,0)
 S (ADM("dateTime"),ADM("stay","arrivalDateTime"))=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ04A",35,0)
 S:$L($P(VAIP(6),U,2)) ADM("roomBed")=$P(VAIP(6),U,2)
"RTN","HMPDJ04A",36,0)
 ;DE2818, (#.105) CURRENT ADMISSION, changed ^DPT to FileMan, ICR 10035
"RTN","HMPDJ04A",37,0)
 S MVT=13,I=0 I VADMVT=$$GET1^DIQ(2,DFN_",",.105,"I") D  ;if current admission,
"RTN","HMPDJ04A",38,0)
 . S ADM("current")="true",MVT=14  ; use last movement info
"RTN","HMPDJ04A",39,0)
 . S X=$$GET1^DIQ(2,DFN_",",.101,"I") S:$L(X) ADM("roomBed")=X  ;(#.101) ROOM-BED, DE2818
"RTN","HMPDJ04A",40,0)
 . K HMPADMIT  ;kill flag from HMPDJ0
"RTN","HMPDJ04A",41,0)
 S SPEC=$G(VAIP(MVT,6)),ADM("specialty")=$P(SPEC,U,2)
"RTN","HMPDJ04A",42,0)
 S X=$$SERV^HMPDVSIT(+SPEC),ADM("service")=X
"RTN","HMPDJ04A",43,0)
 ;DE2818, changed from ^DIC(42) to FileMan, ICR 10039
"RTN","HMPDJ04A",44,0)
 S HLOC=+$$GET1^DIQ(42,+$G(VAIP(MVT,4))_",",44,"I"),FAC=$$FAC^HMPD(+HLOC) I HLOC D
"RTN","HMPDJ04A",45,0)
 . S ADM("locationUid")=$$SETUID^HMPUTILS("location",,+HLOC)
"RTN","HMPDJ04A",46,0)
 . ;DE2818 begin, changed ^SC to FileMan, ICR 10040
"RTN","HMPDJ04A",47,0)
 . S X=$$GET1^DIQ(44,HLOC_",",1) S:X]"" ADM("shortLocationName")=X  ;(#1) ABBREVIATION
"RTN","HMPDJ04A",48,0)
 . S ADM("locationName")=$$GET1^DIQ(44,HLOC_",",.01)  ;(#.01) NAME
"RTN","HMPDJ04A",49,0)
 . S X=$$AMIS^HMPDVSIT($$GET1^DIQ(44,HLOC_",",8,"I"))  ;(#8) STOP CODE NUMBER
"RTN","HMPDJ04A",50,0)
 . ;DE2818, end
"RTN","HMPDJ04A",51,0)
 . S:$L($G(X)) ADM("stopCodeUid")="urn:va:stop-code:"_$P(X,U),ADM("stopCodeName")=$P(X,U,2)
"RTN","HMPDJ04A",52,0)
 . S ADM("summary")="${"_ADM("service")_"}:"_ADM("locationName")
"RTN","HMPDJ04A",53,0)
 D FACILITY^HMPUTILS(FAC,"ADM")
"RTN","HMPDJ04A",54,0)
 S ADM("categoryCode")="urn:va:encounter-category:AD",ADM("categoryName")="Admission"
"RTN","HMPDJ04A",55,0)
 S ADM("patientClassCode")="urn:va:patient-class:IMP",ADM("patientClassName")="Inpatient"
"RTN","HMPDJ04A",56,0)
 I $G(VAIP(17)) S ADM("stay","dischargeDateTime")=$$JSONDT^HMPUTILS(+$G(VAIP(17,1)))
"RTN","HMPDJ04A",57,0)
 I $G(VAIP(18)) S I=I+1 D PROV("ADM",I,+VAIP(18),"A")         ;attending
"RTN","HMPDJ04A",58,0)
 I $G(VAIP(MVT,5)) S I=I+1 D PROV("ADM",I,+VAIP(MVT,5),"P",1) ;primary
"RTN","HMPDJ04A",59,0)
 S ICD=$$POV^HMPDJ04(VST) S:'ICD ICD=$$PTF^HMPDVSIT(DFN,VAIP(12)) ;PTF>ICD
"RTN","HMPDJ04A",60,0)
 I $L(ICD)<2 S ADM("reasonName")=$G(VAIP(MVT,7))
"RTN","HMPDJ04A",61,0)
 E  S ADM("reasonUid")=$$SETNCS^HMPUTILS("icd",ICD),ADM("reasonName")=$P(ICD,U,2)
"RTN","HMPDJ04A",62,0)
 S X=$$CPT^HMPDJ04(VST),ADM("typeName")=$S(X:$P($$CPT^ICPTCOD(X),U,3),1:$$CATG^HMPDVSIT("H"))
"RTN","HMPDJ04A",63,0)
 D MVT(VADMVT)   ;sub-movements
"RTN","HMPDJ04A",64,0)
 ; TIU(VST,.ADM) ;notes/summary
"RTN","HMPDJ04A",65,0)
 ; Next 2 lines added for visits whose IDs start with an "H".  JD - 1/26/15
"RTN","HMPDJ04A",66,0)
 S ADM("lastUpdateTime")=$$EN^HMPSTMP("adm") ;RHL 20150102
"RTN","HMPDJ04A",67,0)
 S ADM("stampTime")=ADM("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ04A",68,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ04A",69,0)
 I $G(HMPMETA) D ADD^HMPMETA("visit",ADM("uid"),ADM("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ04A",70,0)
 D ADD^HMPDJ("ADM","visit")
"RTN","HMPDJ04A",71,0)
 Q
"RTN","HMPDJ04A",72,0)
 ;
"RTN","HMPDJ04A",73,0)
TIU(VISIT,ARR) ; -- add notes to ARR("document")
"RTN","HMPDJ04A",74,0)
 N X,Y,I,HMPX,LT,NT,DA,CNT,HMPY
"RTN","HMPDJ04A",75,0)
 D FIND^DIC(8925,,.01,"QX",+$G(VISIT),,"V",,,"HMPX")
"RTN","HMPDJ04A",76,0)
 S Y="",(I,CNT)=0
"RTN","HMPDJ04A",77,0)
 F  S I=$O(HMPX("DILIST",1,I)) Q:I<1  D
"RTN","HMPDJ04A",78,0)
 . S LT=$G(HMPX("DILIST","ID",I,.01)) Q:$P(LT," ")="Addendum"
"RTN","HMPDJ04A",79,0)
 . S DA=$G(HMPX("DILIST",2,I))
"RTN","HMPDJ04A",80,0)
 . S NT=$$GET1^DIQ(8925,+DA_",",".01:1501")
"RTN","HMPDJ04A",81,0)
 . S CNT=CNT+1,ARR("documents",CNT,"uid")=$$SETUID^HMPUTILS("document",DFN,+DA)
"RTN","HMPDJ04A",82,0)
 . S ARR("documents",CNT,"localTitle")=LT
"RTN","HMPDJ04A",83,0)
 . S:$L(NT) ARR("documents",CNT,"nationalTitle")=NT
"RTN","HMPDJ04A",84,0)
 Q
"RTN","HMPDJ04A",85,0)
 ;
"RTN","HMPDJ04A",86,0)
PROV(ARR,I,IEN,ROLE,PRIM) ; -- add providers
"RTN","HMPDJ04A",87,0)
 S @ARR@("providers",I,"providerUid")=$$SETUID^HMPUTILS("user",,+IEN)
"RTN","HMPDJ04A",88,0)
 S @ARR@("providers",I,"providerName")=$$GET1^DIQ(200,IEN_",",.01)  ;DE2818, changed ^VA(200) to FileMan ICR 10060
"RTN","HMPDJ04A",89,0)
 S @ARR@("providers",I,"role")=ROLE
"RTN","HMPDJ04A",90,0)
 S:$G(PRIM) @ARR@("providers",I,"primary")="true"
"RTN","HMPDJ04A",91,0)
 Q
"RTN","HMPDJ04A",92,0)
 ;
"RTN","HMPDJ04A",93,0)
MVT(CA) ; -- add movements to ADM("movement",i,"attribute")
"RTN","HMPDJ04A",94,0)
 N DATE,DA,CNT,X S (DATE,CNT)=0
"RTN","HMPDJ04A",95,0)
 ;DE2818, ^DGPM( - ICR 1865
"RTN","HMPDJ04A",96,0)
 F  S DATE=$O(^DGPM("APCA",DFN,CA,DATE)) Q:DATE<1  S DA=+$O(^(DATE,0)) I DA'=CA D
"RTN","HMPDJ04A",97,0)
 . S X0=$G(^DGPM(DA,0)),CNT=CNT+1
"RTN","HMPDJ04A",98,0)
 . S ADM("movements",CNT,"localId")=DA
"RTN","HMPDJ04A",99,0)
 . S ADM("movements",CNT,"dateTime")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ04A",100,0)
 . S ADM("movements",CNT,"movementType")=$$EXTERNAL^DILFD(405,.02,,$P(X0,U,2))
"RTN","HMPDJ04A",101,0)
 . S X=+$P(X0,U,19) I X D
"RTN","HMPDJ04A",102,0)
 .. S ADM("movements",CNT,"providerUid")=$$SETUID^HMPUTILS("user",,X)
"RTN","HMPDJ04A",103,0)
 .. S ADM("movements",CNT,"providerName")=$$GET1^DIQ(200,X_",",.01)  ;DE2818, changed ^VA(200) to FileMan ICR 10060
"RTN","HMPDJ04A",104,0)
 . S X=+$P(X0,U,9)
"RTN","HMPDJ04A",105,0)
 . S:X ADM("movements",CNT,"specialty")=$$EXTERNAL^DILFD(405,.09,,X)
"RTN","HMPDJ04A",106,0)
 . ;DE2818, changed ^DIC(42) to FileMan, ICR 10039
"RTN","HMPDJ04A",107,0)
 . S HLOC=+$$GET1^DIQ(42,+$P(X0,U,6)_",",44,"I"),FAC=$$FAC^HMPD(HLOC) I HLOC D
"RTN","HMPDJ04A",108,0)
 .. S ADM("movements",CNT,"locationUid")=$$SETUID^HMPUTILS("location",,HLOC)
"RTN","HMPDJ04A",109,0)
 .. ;DE2818, changed ^SC to FileMan, ICR 10040
"RTN","HMPDJ04A",110,0)
 .. S ADM("movements",CNT,"locationName")=$$GET1^DIQ(44,HLOC_",",.01)  ;(#.01) NAME
"RTN","HMPDJ04A",111,0)
 Q
"RTN","HMPDJ04A",112,0)
 ;
"RTN","HMPDJ04A",113,0)
PTFA(HMPLID) ; -- find ID in ^PXRMINDX(45) and call PTF1 if successful
"RTN","HMPDJ04A",114,0)
 ;Purpose - Build ^TMP("HMPPX") from ^PXRMINDX(45,HMPISYS,"PNI",DFN)
"RTN","HMPDJ04A",115,0)
 ;
"RTN","HMPDJ04A",116,0)
 ;Called by - PTF^HMPDJ0 (if HMPID is set)
"RTN","HMPDJ04A",117,0)
 ;
"RTN","HMPDJ04A",118,0)
 ;Assumptions -
"RTN","HMPDJ04A",119,0)
 ;1. ID is being passed and DFN variable exists
"RTN","HMPDJ04A",120,0)
 ;2. ^TMP("HMPPX") does not already exist
"RTN","HMPDJ04A",121,0)
 ;
"RTN","HMPDJ04A",122,0)
 ;              
"RTN","HMPDJ04A",123,0)
 ;Modification History -
"RTN","HMPDJ04A",124,0)
 ;US5630 (TW)  1. HMPISYS can be either "ICD" (ICD-9) or "10D" (ICD-10)
"RTN","HMPDJ04A",125,0)
 ;             2. Namespaced variables and enhanced newing
"RTN","HMPDJ04A",126,0)
 ; 
"RTN","HMPDJ04A",127,0)
 N HMPLEN,HMPTYP,HMPID,HMPISYS,HMPTYP,HMPDX,HMPDT,HMPITEM,HMPRDT,HMPX
"RTN","HMPDJ04A",128,0)
 S HMPLEN=$L(HMPLID,";"),HMPTYP=$P(HMPLID,";",HMPLEN),HMPID=$P(HMPLID,";",1,HMPLEN-1)
"RTN","HMPDJ04A",129,0)
 ; DE2818, ^PXRMINDX - ICR 4290
"RTN","HMPDJ04A",130,0)
 ;Get ICD System from ^PXRMINDX Xref and loop for remaining subscripts
"RTN","HMPDJ04A",131,0)
 S HMPISYS="" F  S HMPISYS=$O(^PXRMINDX(45,HMPISYS)) Q:HMPISYS=""  D
"RTN","HMPDJ04A",132,0)
 . I '$D(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP)) Q
"RTN","HMPDJ04A",133,0)
 . S HMPDX="" F  S HMPDX=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX)) Q:HMPDX=""  D
"RTN","HMPDJ04A",134,0)
 .. S HMPDT=0  F  S HMPDT=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX,HMPDT)) Q:HMPDT=""  D
"RTN","HMPDJ04A",135,0)
 ... S HMPITEM=""  F  S HMPITEM=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX,HMPDT,HMPITEM)) Q:HMPITEM=""  D
"RTN","HMPDJ04A",136,0)
 .... I HMPITEM'[HMPID Q
"RTN","HMPDJ04A",137,0)
 .... S HMPRDT=9999999-HMPDT
"RTN","HMPDJ04A",138,0)
 .... S HMPX=HMPDX_U_HMPDT_U_HMPISYS
"RTN","HMPDJ04A",139,0)
 .... S ^TMP("HMPPX",$J,HMPRDT,HMPLID)=HMPX
"RTN","HMPDJ04A",140,0)
 Q:'$D(^TMP("HMPPX",$J))
"RTN","HMPDJ04A",141,0)
 D PTF1
"RTN","HMPDJ04A",142,0)
 K ^TMP("HMPPX",$J)
"RTN","HMPDJ04A",143,0)
 Q
"RTN","HMPDJ04A",144,0)
 ;
"RTN","HMPDJ04A",145,0)
PTF1 ; Set PTF data into PTF array
"RTN","HMPDJ04A",146,0)
 ;Purpose - Get data from ^TMP("HMPPX"), lookup addl PTF, set into PTF array and ^TMP
"RTN","HMPDJ04A",147,0)
 ;
"RTN","HMPDJ04A",148,0)
 ;Called by - PTFA^HMPDJ04A if HMPID is set, otherwise PTF^HMPDJ0
"RTN","HMPDJ04A",149,0)
 ;
"RTN","HMPDJ04A",150,0)
 ;Assumptions -
"RTN","HMPDJ04A",151,0)
 ;1. HMPLID (local ID) is being passed and DFN,HMPRDT variables exist
"RTN","HMPDJ04A",152,0)
 ;2. ^TMP("HMPPX",$J,HMPRDT,ID)=DxCode^[Discharge]Date exists
"RTN","HMPDJ04A",153,0)
 ;
"RTN","HMPDJ04A",154,0)
 ;Modification History -
"RTN","HMPDJ04A",155,0)
 ;US5630 (TW)- HMPISYS can be either "ICD9" or "10D" (ICD-10)
"RTN","HMPDJ04A",156,0)
 ;
"RTN","HMPDJ04A",157,0)
 N HMPTMP,PTF,HMPP,HMPTYP,HMPDIS,VAIN,HMPADM,VAINDT,HMPLOC,HMPFAC,HMPX,HMPISYS
"RTN","HMPDJ04A",158,0)
 S HMPTMP=$G(^TMP("HMPPX",$J,HMPRDT,HMPLID))
"RTN","HMPDJ04A",159,0)
 S PTF("localId")=HMPLID
"RTN","HMPDJ04A",160,0)
 S PTF("uid")=$$SETUID^HMPUTILS("ptf",DFN,HMPLID)
"RTN","HMPDJ04A",161,0)
 S HMPP=$L(HMPLID,";")
"RTN","HMPDJ04A",162,0)
 S HMPTYP=$P(HMPLID,";",HMPP)
"RTN","HMPDJ04A",163,0)
 I HMPTYP="DXLS" S PTF("principalDx")="true"  ; Is this the principal dx?
"RTN","HMPDJ04A",164,0)
 I $P(HMPTYP," ")="M" Q  ; Quit if movement dx
"RTN","HMPDJ04A",165,0)
 S HMPDIS=$P(HMPTMP,U,2)
"RTN","HMPDJ04A",166,0)
 I HMPDIS S VAINDT=HMPDIS-.0001
"RTN","HMPDJ04A",167,0)
 D INP^VADPT  ; Get inpatient VAIN array
"RTN","HMPDJ04A",168,0)
 I '$G(VAIN(1)) Q  ; Quit if not inpatient
"RTN","HMPDJ04A",169,0)
 ;US5630 - TW - Extract Calculated DRG for PTF
"RTN","HMPDJ04A",170,0)
 S PTF("drg")=$$GET1^DIQ(45,+HMPLID_",",9,"")
"RTN","HMPDJ04A",171,0)
 S PTF("admissionUid")=$$SETUID^HMPUTILS("visit",DFN,"H"_VAIN(1))
"RTN","HMPDJ04A",172,0)
 S HMPADM=+$G(VAIN(7))  ; Admission date
"RTN","HMPDJ04A",173,0)
 ;DE2818, changed from ^DIC(42) to FileMan, ICR 10039
"RTN","HMPDJ04A",174,0)
 S HMPLOC=+$$GET1^DIQ(42,+$G(VAIN(4))_",",44,"I")  ; Get location
"RTN","HMPDJ04A",175,0)
 S:HMPADM PTF("arrivalDateTime")=$$JSONDT^HMPUTILS(HMPADM)
"RTN","HMPDJ04A",176,0)
 S:HMPDIS PTF("dischargeDateTime")=$$JSONDT^HMPUTILS(HMPDIS)
"RTN","HMPDJ04A",177,0)
 S HMPFAC=$$FAC^HMPD(HMPLOC) D:HMPFAC FACILITY^HMPUTILS(HMPFAC,"PTF")
"RTN","HMPDJ04A",178,0)
 S PTF("lastUpdateTime")=$$EN^HMPSTMP("ptf") ;RHL 20150102
"RTN","HMPDJ04A",179,0)
 S PTF("stampTime")=PTF("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ04A",180,0)
 ;US5630 - TW - Check for ICD Coding System
"RTN","HMPDJ04A",181,0)
 S HMPDX=$P(HMPTMP,U)
"RTN","HMPDJ04A",182,0)
 S HMPISYS=$P(HMPTMP,U,3)
"RTN","HMPDJ04A",183,0)
 S HMPISYS=$S(HMPISYS="ICD":1,"ICP":2,"10D":30,"10P":31,1:1)  ; Identify ICD coding system for correct lookup
"RTN","HMPDJ04A",184,0)
 S HMPX=$$ICDDX^ICDEX(HMPDX,"",HMPISYS)
"RTN","HMPDJ04A",185,0)
 S PTF("icdCode")=$$SETNCS^HMPUTILS("icd",$P(HMPX,U,2))
"RTN","HMPDJ04A",186,0)
 S PTF("icdName")=$P(HMPX,U,4)
"RTN","HMPDJ04A",187,0)
  ;US6734 - pre-compile metastamp
"RTN","HMPDJ04A",188,0)
 I $G(HMPMETA) D ADD^HMPMETA("ptf",PTF("uid"),PTF("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ04A",189,0)
 D ADD^HMPDJ("PTF","ptf")
"RTN","HMPDJ04A",190,0)
 Q
"RTN","HMPDJ04A",191,0)
 ;
"RTN","HMPDJ04A",192,0)
VISIT(DFN,DATE) ; -- Return visit# for admission
"RTN","HMPDJ04A",193,0)
 N X,Y
"RTN","HMPDJ04A",194,0)
 S X=9999999-$P(DATE,".")_"."_$P(DATE,".",2)
"RTN","HMPDJ04A",195,0)
 S Y=+$O(^AUPNVSIT("AAH",DFN,X,0))  ;DE2818, ICR 2028
"RTN","HMPDJ04A",196,0)
 Q Y
"RTN","HMPDJ04E")
0^11^B17743110
"RTN","HMPDJ04E",1,0)
HMPDJ04E ;SLC/MKB,ASMR/RRB - EDIS VISIT;6/25/12  16:11
"RTN","HMPDJ04E",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ04E",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ04E",4,0)
 ;
"RTN","HMPDJ04E",5,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ04E",6,0)
 ;
"RTN","HMPDJ04E",7,0)
 ; External References          DBIA#
"RTN","HMPDJ04E",8,0)
 ; -------------------          -----
"RTN","HMPDJ04E",9,0)
 ; EDP(230                       6275
"RTN","HMPDJ04E",10,0)
 ;
"RTN","HMPDJ04E",11,0)
 ; DE2818/RRB SQA findings changed top line from EDIS to EDIS VISITS
"RTN","HMPDJ04E",12,0)
 Q
"RTN","HMPDJ04E",13,0)
 ;
"RTN","HMPDJ04E",14,0)
EDP1(ID) ; -- ED visit
"RTN","HMPDJ04E",15,0)
 ;DE2818 modified to use FM calls to pull data from the EDP files
"RTN","HMPDJ04E",16,0)
 N IENS,EDP,X0,FAC,VST,LOC,LOC0,X,I,ICD,FILE,FLDS,FLGS,ARR,ERR
"RTN","HMPDJ04E",17,0)
 S IENS=$$FIND1^DIC(230,"","Q",ID,"V","") Q:IENS<1
"RTN","HMPDJ04E",18,0)
 S IENS=IENS_",",FLGS="IE",ARR="EDP",ERR="EDPERR",FLDS=".01;3.5;3.6;3.7;3.8;3.3;.08;.09;1.1;.02;.14;3.2"
"RTN","HMPDJ04E",19,0)
 D GETS^DIQ(230,IENS,FLDS,FLGS,ARR,ERR)
"RTN","HMPDJ04E",20,0)
 S X0=$G(^AUPNVSIT(ID,0))
"RTN","HMPDJ04E",21,0)
 ;.01 LOG ENTRY TIME
"RTN","HMPDJ04E",22,0)
 ;.08 TIME IN
"RTN","HMPDJ04E",23,0)
 ;.08 TIME OUT
"RTN","HMPDJ04E",24,0)
 ;1.1 COMPLAINT
"RTN","HMPDJ04E",25,0)
 ;.02 INSTITUTION
"RTN","HMPDJ04E",26,0)
 ;.14 CLINIC
"RTN","HMPDJ04E",27,0)
 ;#3.2) STATUS [2P:233.1]
"RTN","HMPDJ04E",28,0)
 ;(#3.3) ACUITY [3P:233.1] ^ 
"RTN","HMPDJ04E",29,0)
 ;(#3.4) LOC [4P:231.8] 
"RTN","HMPDJ04E",30,0)
 ;(#3.5) MD ASSIGNED [5P:200]
"RTN","HMPDJ04E",31,0)
 ;(#3.6) NURSE ASSIGNED [6P:200]
"RTN","HMPDJ04E",32,0)
 ;(#3.7) RESIDENT ASSIGNED [7P:200] ^ 
"RTN","HMPDJ04E",33,0)
 ;#3.8) COMMENT [8F]
"RTN","HMPDJ04E",34,0)
 ;(#3.9) HELD LOC [9P:231.8] ^ 
"RTN","HMPDJ04E",35,0)
 S VST("localId")=ID,VST("uid")=$$SETUID^HMPUTILS("visit",DFN,ID)
"RTN","HMPDJ04E",36,0)
 S VST("dateTime")=$$JSONDT^HMPUTILS(+X0)
"RTN","HMPDJ04E",37,0)
 S:$G(EDP(230,IENS,.08,"I"))'="" VST("stay","arrivalDateTime")=$$JSONDT^HMPUTILS($G(EDP(230,IENS,.08,"I")))
"RTN","HMPDJ04E",38,0)
 S:$G(EDP(230,IENS,.09,"I"))'="" VST("stay","dischargeDateTime")=$$JSONDT^HMPUTILS($G(EDP(230,IENS,.09,"I")))
"RTN","HMPDJ04E",39,0)
 S:$G(EDP(230,IENS,.02,"I"))'="" FAC=$G(EDP(230,IENS,.02,"I"))
"RTN","HMPDJ04E",40,0)
 S:$G(EDP(230,IENS,.14,"I"))'="" LOC=$G(EDP(230,IENS,.14,"I")),LOC0=$S(LOC:$G(^SC(LOC,0)),1:"")
"RTN","HMPDJ04E",41,0)
 S:FAC X=$$STA^XUAF4(FAC)_U_$P($$NS^XUAF4(FAC),U)
"RTN","HMPDJ04E",42,0)
 S:'FAC X=$$FAC^HMPD(LOC) D FACILITY^HMPUTILS(X,"VST")
"RTN","HMPDJ04E",43,0)
 S VST("categoryCode")="urn:va:encounter-category:OV"
"RTN","HMPDJ04E",44,0)
 S VST("categoryName")="Outpatient Visit"
"RTN","HMPDJ04E",45,0)
 S VST("patientClassCode")="urn:va:patient-class:EMER"
"RTN","HMPDJ04E",46,0)
 S VST("patientClassName")="Emergency"
"RTN","HMPDJ04E",47,0)
 ;
"RTN","HMPDJ04E",48,0)
 S X=$$CPT^HMPDJ04(ID) S:$G(X)'="" VST("typeName")=$P($$CPT^ICPTCOD(X),U,3)
"RTN","HMPDJ04E",49,0)
 I 'X S VST("typeName")=$S(LOC:$P(LOC0,U)_" VISIT",1:"EMERGENCY")
"RTN","HMPDJ04E",50,0)
 S X=$P(X0,U,8) S:X AMIS=$$AMIS^HMPDVSIT(X) I LOC D
"RTN","HMPDJ04E",51,0)
 . I 'X S AMIS=$$AMIS^HMPDVSIT($P(LOC0,U,7))
"RTN","HMPDJ04E",52,0)
 . S VST("locationUid")=$$SETUID^HMPUTILS("location",,+LOC)
"RTN","HMPDJ04E",53,0)
 . S VST("locationName")=$P(LOC0,U)
"RTN","HMPDJ04E",54,0)
 . S X=$$SERV^HMPDVSIT($P(LOC0,U,20)) Q:X=""
"RTN","HMPDJ04E",55,0)
 . S:$L(X) VST("service")=X,VST("summary")="${"_VST("service")_"}:"_$P(LOC0,U)
"RTN","HMPDJ04E",56,0)
 S:$G(AMIS) VST("stopCodeUid")="urn:va:stop-code:"_$P(AMIS,U),VST("stopCodeName")=$P(AMIS,U,2)
"RTN","HMPDJ04E",57,0)
 ;
"RTN","HMPDJ04E",58,0)
 S:$G(EDP(230,IENS,1.1,"E"))'="" VST("reasonName")=$G(EDP(230,IENS,1.1,"E"))
"RTN","HMPDJ04E",59,0)
 S I=0 F  S I=$O(^EDP(230,+IENS,4,I)) Q:I<1  I $P($G(^(I,0)),U,3) D  ;primary Dx
"RTN","HMPDJ04E",60,0)
 . S X=$G(^EDP(230,+IENS,4,I,0)),VST("reasonName")=$P(X,U) Q:'$P(X,U,2)
"RTN","HMPDJ04E",61,0)
 . S ICD=$$ICD^HMPDVSIT($P(X,U,2)) Q:$L(ICD)'>1
"RTN","HMPDJ04E",62,0)
 . S VST("reasonUid")=$$SETNCS^HMPUTILS("icd",$P(ICD,U)),VST("reasonName")=$P(ICD,U,2)
"RTN","HMPDJ04E",63,0)
 ;
"RTN","HMPDJ04E",64,0)
 ; provider(s)
"RTN","HMPDJ04E",65,0)
 S I=0
"RTN","HMPDJ04E",66,0)
 I $G(EDP(230,IENS,3.5,"I"))'="" S I=I+1 D PROV("VST",I,$G(EDP(230,IENS,3.5,"I")),"P",1) ;primary/MD
"RTN","HMPDJ04E",67,0)
 I $G(EDP(230,IENS,3.6,"I"))'="" S I=I+1 D PROV("VST",I,$G(EDP(230,IENS,3.6,"I")),"P",1) ;nurse
"RTN","HMPDJ04E",68,0)
 I $G(EDP(230,IENS,3.7,"I"))'="" S I=I+1 D PROV("VST",I,$G(EDP(230,IENS,3.7,"I")),"P",1) ;resident
"RTN","HMPDJ04E",69,0)
 S:$G(EDP(230,IENS,3.8,"I"))'="" VST("comment")=$G(EDP(230,IENS,3.8,"I"))
"RTN","HMPDJ04E",70,0)
 S:$G(EDP(230,IENS,3.3,"E")) VST("appointmentStatus")=$G(EDP(230,IENS,3.3,"E"))
"RTN","HMPDJ04E",71,0)
 ;
"RTN","HMPDJ04E",72,0)
 ; note(s)
"RTN","HMPDJ04E",73,0)
 ; TIU^HMPDJ04A(ID,.VST)
"RTN","HMPDJ04E",74,0)
 K ^TMP("PXKENC",$J,ID)
"RTN","HMPDJ04E",75,0)
 S VST("lastUpdateTime")=$$EN^HMPSTMP("visit") ;RHL 20150102
"RTN","HMPDJ04E",76,0)
 S VST("stampTime")=VST("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ04E",77,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ04E",78,0)
 I $G(HMPMETA) D ADD^HMPMETA("visit",VST("uid"),VST("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ04E",79,0)
 D ADD^HMPDJ("VST","visit")
"RTN","HMPDJ04E",80,0)
 Q
"RTN","HMPDJ04E",81,0)
 ;
"RTN","HMPDJ04E",82,0)
PROV(ARR,I,IEN,ROLE,PRIM) ; -- add providers
"RTN","HMPDJ04E",83,0)
 S @ARR@("providers",I,"providerUid")=$$SETUID^HMPUTILS("user",,+IEN)
"RTN","HMPDJ04E",84,0)
 S @ARR@("providers",I,"providerName")=$$GET1^DIQ(200,(+IEN)_",",.01)  ;DE2818, ICR 10060
"RTN","HMPDJ04E",85,0)
 S @ARR@("providers",I,"role")=ROLE
"RTN","HMPDJ04E",86,0)
 S:$G(PRIM) @ARR@("providers",I,"primary")="true"
"RTN","HMPDJ04E",87,0)
 Q
"RTN","HMPDJ04E",88,0)
 ;
"RTN","HMPDJ05")
0^12^B94650196
"RTN","HMPDJ05",1,0)
HMPDJ05 ;SLC/MKB,ASMR/RRB,CPC - Medications by order;Jun 28, 2016 15:12:10
"RTN","HMPDJ05",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ05",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ05",4,0)
 ;
"RTN","HMPDJ05",5,0)
 ; External References: see HMPDJ05V for DBIA list
"RTN","HMPDJ05",6,0)
 ; ^OR(100) references - ICR 5771
"RTN","HMPDJ05",7,0)
 ;
"RTN","HMPDJ05",8,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ05",9,0)
 Q
"RTN","HMPDJ05",10,0)
 ;
"RTN","HMPDJ05",11,0)
PS1(ID) ; -- med order
"RTN","HMPDJ05",12,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ05",13,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ05",14,0)
 S ERRMSG="A problem occurred converting order "_ID_" for the medication domain"
"RTN","HMPDJ05",15,0)
 N ORPK,TYPE S ID=+$G(ID)
"RTN","HMPDJ05",16,0)
 S ORPK=$$PKGID^ORX8(ID),TYPE=$E(ORPK,$L(ORPK)) S:TYPE=+TYPE TYPE="R"
"RTN","HMPDJ05",17,0)
 ;
"RTN","HMPDJ05",18,0)
 N ORUPCHUK,ORVP,ORPCL,ORDUZ,ORODT,ORSTRT,ORSTOP,ORL,ORTO,ORSTS,ORNP,ORPV,ORTX
"RTN","HMPDJ05",19,0)
 N MED,CLS,OI,X,LOC,FAC,DRUG,DA,CNT,HMPESP
"RTN","HMPDJ05",20,0)
 S X=$S(ORPK:$E(ORPK,$L(ORPK)),1:"Z") S:X=+X X="R" ;last char = PS file
"RTN","HMPDJ05",21,0)
 S CLS=$S("RSN"[X:"O","UV"[X:"I",1:$$GET1^DIQ(100,ID_",",10,"I"))
"RTN","HMPDJ05",22,0)
 S MED("uid")=$$SETUID^HMPUTILS("med",DFN,ID)
"RTN","HMPDJ05",23,0)
 S MED("orders",1,"orderUid")=$$SETUID^HMPUTILS("order",DFN,ID)
"RTN","HMPDJ05",24,0)
 D KIN(ID) ;DE5462 add parent/child structure
"RTN","HMPDJ05",25,0)
 S X=$$GET1^DIQ(100,ID_",",9,"I") S:X MED("orders",1,"predecessor")=$$SETUID^HMPUTILS("med",DFN,+X)
"RTN","HMPDJ05",26,0)
 S X=$$GET1^DIQ(100,ID_",",9.1,"I") S:X MED("orders",1,"successor")=$$SETUID^HMPUTILS("med",DFN,+X)
"RTN","HMPDJ05",27,0)
 S:ORPK MED("localId")=ORPK_";"_CLS
"RTN","HMPDJ05",28,0)
 D EN^ORX8(ID) S X="" F  S X=$O(ORUPCHUK(X)) Q:X=""  S:$D(ORUPCHUK(X))#2 @X=ORUPCHUK(X)
"RTN","HMPDJ05",29,0)
 S:$G(ORODT) MED("orders",1,"ordered")=$$JSONDT^HMPUTILS(ORODT)
"RTN","HMPDJ05",30,0)
 S:$G(ORNP) MED("orders",1,"providerUid")=$$SETUID^HMPUTILS("user",,+ORNP),MED("orders",1,"providerName")=$P(ORNP,U,2)
"RTN","HMPDJ05",31,0)
 S LOC=+$G(ORL),FAC=$$FAC^HMPD(LOC) I LOC D
"RTN","HMPDJ05",32,0)
 . S MED("orders",1,"locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ05",33,0)
 . S MED("orders",1,"locationName")=$$GET1^DIQ(44,LOC_",",.01)  ;DE2818, ICR 10040
"RTN","HMPDJ05",34,0)
 D FACILITY^HMPUTILS(FAC,"MED")
"RTN","HMPDJ05",35,0)
 S:$G(ORSTRT) MED("overallStart")=$$JSONDT^HMPUTILS(ORSTRT)
"RTN","HMPDJ05",36,0)
 S:$G(ORSTOP) (MED("stopped"),MED("overallStop"))=$$JSONDT^HMPUTILS(ORSTOP)
"RTN","HMPDJ05",37,0)
 S MED("vaStatus")=$P($G(ORSTS),U,2)
"RTN","HMPDJ05",38,0)
 S MED("medStatusName")=$$STATUS^HMPDPSOR(+$G(ORSTS))
"RTN","HMPDJ05",39,0)
 S MED("medStatus")=$$MEDSTAT^HMPDJ05V(MED("medStatusName"))
"RTN","HMPDJ05",40,0)
 I CLS="I" D
"RTN","HMPDJ05",41,0)
 . S:$$GET1^DIQ(44,LOC_",",2802,"I") MED("IMO")="true"  ;DE2818, ICR 10040, (#2802) ADMINISTER INPATIENT MEDS? [25S]
"RTN","HMPDJ05",42,0)
 . S X=$$GET1^DIQ(100,ID_",",36) S:X MED("parent")=X  ;DE2818, ICR 5771, (#36) PARENT
"RTN","HMPDJ05",43,0)
 I ORPK D OEL^PSOORRL(DFN,ORPK_";"_CLS)
"RTN","HMPDJ05",44,0)
 S X=$S(ORPK["N":"N",1:CLS),MED("vaType")=X,MED("medType")=$$TYPE^HMPDJ05V(X)
"RTN","HMPDJ05",45,0)
 I CLS="O" S MED("type")=$S(ORPK["N":"OTC",1:"Prescription")
"RTN","HMPDJ05",46,0)
 S X=$G(HMPESP("COMMENT",1)) S:$L(X) MED("comment")=X
"RTN","HMPDJ05",47,0)
 I $$ISIV^HMPDJ05V G IV1^HMPDJ05V
"RTN","HMPDJ05",48,0)
 ;
"RTN","HMPDJ05",49,0)
A ; - Get order responses
"RTN","HMPDJ05",50,0)
 S OI=$$OI^ORX8(ID) I OI D
"RTN","HMPDJ05",51,0)
 . S X=$P(OI,U,2) S:$E(X,$L(X))=" " X=$E(X,1,$L(X)-1)
"RTN","HMPDJ05",52,0)
 . S MED("name")=X
"RTN","HMPDJ05",53,0)
 . D ZERO^PSS50P7(+$P(OI,U,3),,,"PSOI")
"RTN","HMPDJ05",54,0)
 . S MED("productFormName")=$P($G(^TMP($J,"PSOI",+$P(OI,U,3),.02)),U,2)
"RTN","HMPDJ05",55,0)
 . S:+$G(^TMP($J,"PSOI",+$P(OI,U,3),.09)) MED("supply")="true"
"RTN","HMPDJ05",56,0)
 D RESP^HMPDPSOR(ID,.HMPESP) ;order responses
"RTN","HMPDJ05",57,0)
 S DRUG=+$G(^TMP("PS",$J,"DD",1,0)) S:'DRUG DRUG=+$G(HMPESP("DRUG",1))
"RTN","HMPDJ05",58,0)
 S MED("sig")=$S(CLS="I":"Give: ",1:"")_$G(HMPESP("SIG",1)) ;ORTX(2)
"RTN","HMPDJ05",59,0)
 I CLS="O",'$L($G(HMPESP("SIG",1))),'$D(HMPESP("INSTR")) S MED("sig")=$G(HMPESP("COMMENT",1)) ;old Rx
"RTN","HMPDJ05",60,0)
 ;
"RTN","HMPDJ05",61,0)
B ; - Get dosages
"RTN","HMPDJ05",62,0)
 ;DE2818 begin, ^OR(100) references - ICR 5771
"RTN","HMPDJ05",63,0)
 I '$O(^OR(100,ID,2,0)) D  ;single dose or OP
"RTN","HMPDJ05",64,0)
 . N HMPY,START,STOP,DUR,CONJ,MIN
"RTN","HMPDJ05",65,0)
 . S START=$G(ORSTRT),STOP=$G(ORSTOP),MIN=0
"RTN","HMPDJ05",66,0)
 . S CNT=0 F  S CNT=$O(HMPESP("INSTR",CNT)) Q:CNT<1  D
"RTN","HMPDJ05",67,0)
 .. K HMPY D DOSE(.HMPY,CNT) M MED("dosages",CNT)=HMPY
"RTN","HMPDJ05",68,0)
 .. ;determine start & stop per dose
"RTN","HMPDJ05",69,0)
 .. S MED("dosages",CNT,"relativeStart")=MIN
"RTN","HMPDJ05",70,0)
 .. S DUR=$G(HMPY("complexDuration")),CONJ=$G(HMPY("complexConjunction"))
"RTN","HMPDJ05",71,0)
 .. S STOP=$S(DUR:$$STOP(START,DUR),1:STOP)
"RTN","HMPDJ05",72,0)
 .. S:START MED("dosages",CNT,"start")=$$JSONDT^HMPUTILS(START)
"RTN","HMPDJ05",73,0)
 .. S:STOP MED("dosages",CNT,"stop")=$$JSONDT^HMPUTILS(STOP)
"RTN","HMPDJ05",74,0)
 .. S X=$$RELTIME(START,STOP,DUR,MIN),MED("dosages",CNT,"relativeStop")=$S($E(X)=".":0_X,1:X)
"RTN","HMPDJ05",75,0)
 .. I $E(CONJ)="T",DUR S START=STOP,MIN=X
"RTN","HMPDJ05",76,0)
 I $O(^OR(100,ID,2,0)) D
"RTN","HMPDJ05",77,0)
 . N DD,CONJ,HMPY,MIN
"RTN","HMPDJ05",78,0)
 . M CONJ=HMPESP("CONJ"),DUR=HMPESP("DAYS") S MIN=0
"RTN","HMPDJ05",79,0)
 . S (DA,CNT)=0 F  S DA=$O(^OR(100,ID,2,DA)) Q:DA<1  D  ;child orders
"RTN","HMPDJ05",80,0)
 .. K HMPESP,HMPY D RESP^HMPDPSOR(DA,.HMPESP),DOSE(.HMPY,1)
"RTN","HMPDJ05",81,0)
 .. S CNT=CNT+1 M MED("dosages",CNT)=HMPY
"RTN","HMPDJ05",82,0)
 .. S MED("dosages",CNT,"relativeStart")=MIN
"RTN","HMPDJ05",83,0)
 .. S MED("dosages",CNT,"complexConjunction")=$G(CONJ(CNT))
"RTN","HMPDJ05",84,0)
 .. S MED("dosages",CNT,"complexDuration")=$G(DUR(CNT))
"RTN","HMPDJ05",85,0)
 .. S MED("dosages",CNT,"relatedOrder")=DA
"RTN","HMPDJ05",86,0)
 .. S X=$P($G(^OR(100,DA,0)),U,8,9)
"RTN","HMPDJ05",87,0)
 .. S:$P(X,U) MED("dosages",CNT,"start")=$$JSONDT^HMPUTILS($P(X,U))
"RTN","HMPDJ05",88,0)
 .. S:$P(X,U,2) MED("dosages",CNT,"stop")=$$JSONDT^HMPUTILS($P(X,U,2))
"RTN","HMPDJ05",89,0)
 .. I $P(X,U,2)>$G(ORSTOP) S ORSTOP=$P(X,U,2) ;get last stop time
"RTN","HMPDJ05",90,0)
 .. S X=$$RELTIME($P(X,U),$P(X,U,2),$G(DUR(CNT)),MIN)
"RTN","HMPDJ05",91,0)
 .. S MED("dosages",CNT,"relativeStop")=$S($E(X)=".":0_X,1:X) S:$G(CONJ(CNT))="T" MIN=X
"RTN","HMPDJ05",92,0)
 .. S:'DRUG DD=+$G(HMPESP("DRUG",1)),DD(DD,DA)="" ;dispense drug(s)
"RTN","HMPDJ05",93,0)
 .. ; get ^TMP("PS",$J) from 1st child, if Inpt parent:
"RTN","HMPDJ05",94,0)
 .. I '$D(^TMP("PS",$J)) S ORPK=$$PKGID^ORX8(DA) D OEL^PSOORRL(DFN,ORPK_";"_CLS)
"RTN","HMPDJ05",95,0)
 . S MED("stopped")=$$JSONDT^HMPUTILS($G(ORSTOP)) ;reset from last child order
"RTN","HMPDJ05",96,0)
 . S DD=$O(DD(0)) I DD,'$O(DD(DD)) S DRUG=DD Q    ;1 drug for order
"RTN","HMPDJ05",97,0)
 . S (DD,CNT)=0 F  S DD=$O(DD(DD)) Q:DD<1  S DA=0 F  S DA=$O(DD(DD,DA)) Q:DA<1  S CNT=CNT+1 D NDF(DD,CNT,DA)
"RTN","HMPDJ05",98,0)
 ;
"RTN","HMPDJ05",99,0)
 ;DE2818 end
"RTN","HMPDJ05",100,0)
C ; - Get OP data
"RTN","HMPDJ05",101,0)
 I CLS="O",ORPK'["N" D
"RTN","HMPDJ05",102,0)
 . S MED("orders",1,"quantityOrdered")=$G(HMPESP("QTY",1))
"RTN","HMPDJ05",103,0)
 . S MED("orders",1,"daysSupply")=$G(HMPESP("SUPPLY",1))
"RTN","HMPDJ05",104,0)
 . S MED("orders",1,"vaRouting")=$G(HMPESP("PICKUP",1))
"RTN","HMPDJ05",105,0)
 . S MED("orders",1,"fillsAllowed")=$G(HMPESP("REFILLS",1))
"RTN","HMPDJ05",106,0)
 . S MED("patientInstruction")=$G(HMPESP("PI",1))
"RTN","HMPDJ05",107,0)
 . Q:ORPK["P"!(ORPK["S")  ;pending
"RTN","HMPDJ05",108,0)
 . N HMP,RX0,RX1,FILL,RFD,MW,REL
"RTN","HMPDJ05",109,0)
 . K ^TMP("PSOR",$J) D EN^PSOORDER(DFN,+ORPK)
"RTN","HMPDJ05",110,0)
 . S RX0=$G(^TMP("PSOR",$J,+ORPK,0)),RX1=$G(^(1)),MED("orders",1,"prescriptionId")=$P(RX0,U,5)
"RTN","HMPDJ05",111,0)
 . I '$G(HMPESP("QTY",1)) S MED("orders",1,"quantityOrdered")=$P(RX0,U,6)
"RTN","HMPDJ05",112,0)
 . I '$G(HMPESP("SUPPLY",1)) S MED("orders",1,"daysSupply")=$P(RX0,U,7)
"RTN","HMPDJ05",113,0)
 . S MED("orders",1,"fillsRemaining")=$P(RX0,U,9),MED("lastFilled")=$$JSONDT^HMPUTILS($P(RX0,U,3))
"RTN","HMPDJ05",114,0)
 . S I=$P(RX0,U,2) I I S FILL(I)=I_"^^^"_$P(RX0,U,6,7)_"^^^"_$P(RX0,U,13)_"^^"_$P(RX1,U,6) ;original fill
"RTN","HMPDJ05",115,0)
 . S I=0 F  S I=$O(^TMP("PSOR",$J,+ORPK,"REF",I)) Q:I<1  S X=$G(^(I,0)),FILL(+X)=X
"RTN","HMPDJ05",116,0)
 . S I=0 F  S I=$O(^TMP("PSOR",$J,+ORPK,"RPAR",I)) Q:I<1  S X=$G(^(I,0)),$P(X,U,14)=1,FILL(+X)=X
"RTN","HMPDJ05",117,0)
 . S (I,RFD)=0 F  S RFD=$O(FILL(RFD)) Q:RFD<1  S X=$G(FILL(RFD)) D  ;sort 1st
"RTN","HMPDJ05",118,0)
 .. S I=I+1,MW=$P($P(X,U,10),";"),REL=$P($P(X,U,8),".")
"RTN","HMPDJ05",119,0)
 .. S MED("fills",I,"dispenseDate")=$$JSONDT^HMPUTILS($P(RFD,"."))
"RTN","HMPDJ05",120,0)
 .. S MED("fills",I,"releaseDate")=$$JSONDT^HMPUTILS(REL)
"RTN","HMPDJ05",121,0)
 .. S MED("fills",I,"routing")=MW
"RTN","HMPDJ05",122,0)
 .. S MED("fills",I,"quantityDispensed")=$P(X,U,4)
"RTN","HMPDJ05",123,0)
 .. S MED("fills",I,"daysSupplyDispensed")=$P(X,U,5)
"RTN","HMPDJ05",124,0)
 .. S:$P(X,U,14) MED("fills",I,"partial")=1 ;"true"
"RTN","HMPDJ05",125,0)
 . S X=$S($P(RX0,U,11):$P(RX0,U,11),$P(RX0,U,10):$P(RX0,U,10),1:0)
"RTN","HMPDJ05",126,0)
 . S:X MED("orders",1,"fillCost")=X
"RTN","HMPDJ05",127,0)
 . S X=$$GET1^PSODI(52,+ORPK_",",26,"I") S:X MED("overallStop")=$$JSONDT^HMPUTILS($P(X,U,2)) ;1^expirationDate
"RTN","HMPDJ05",128,0)
 . S X=$$GET1^PSODI(52,+ORPK_",",38.3,"I") S:X MED("prescriptionFinished")=$$JSONDT^HMPUTILS($P(X,U,2)) ;DE5723 1^date prescription finished
"RTN","HMPDJ05",129,0)
 I CLS="I" D
"RTN","HMPDJ05",130,0)
 . S X=$$GET1^DIQ(55.06,+ORPK_","_DFN_",",25,"I")
"RTN","HMPDJ05",131,0)
 . S:X MED("overallStop")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ05",132,0)
 . D BCMA^HMPDJ05V(.MED,DFN,ORPK)
"RTN","HMPDJ05",133,0)
 ;
"RTN","HMPDJ05",134,0)
PSQ ; finish
"RTN","HMPDJ05",135,0)
 D:DRUG NDF(+DRUG)
"RTN","HMPDJ05",136,0)
 S MED("qualifiedName")=$G(MED("name"))
"RTN","HMPDJ05",137,0)
 S X=+$P($G(^TMP("PS",$J,"RXN",0)),U,5)
"RTN","HMPDJ05",138,0)
 S:X MED("orders",1,"pharmacistUid")=$$SETUID^HMPUTILS("user",,X),MED("orders",1,"pharmacistName")=$$GET1^DIQ(200,X_",",.01)  ;DE2818, ICR 10035
"RTN","HMPDJ05",139,0)
 K ^TMP("PS",$J),^TMP($J,"PSOI"),^TMP("PSOR",$J)
"RTN","HMPDJ05",140,0)
 S MED("lastUpdateTime")=$$EN^HMPSTMP("med") ;RHL 20150102
"RTN","HMPDJ05",141,0)
 S MED("stampTime")=MED("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ05",142,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ05",143,0)
 I $G(HMPMETA) D ADD^HMPMETA("med",MED("uid"),MED("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ05",144,0)
 D ADD^HMPDJ("MED","med")
"RTN","HMPDJ05",145,0)
 Q
"RTN","HMPDJ05",146,0)
 ;
"RTN","HMPDJ05",147,0)
KIN(IFN) ; DE5462 - Add parents/children (kin) to order
"RTN","HMPDJ05",148,0)
 N HMPNOJS,HMPORKIN,I
"RTN","HMPDJ05",149,0)
 S HMPNOJS=1 D RELATED^HMPORRPC(.HMPORKIN,IFN)
"RTN","HMPDJ05",150,0)
 S:$D(@HMPORKIN@("parent")) MED("orders",1,"parentOrderUid")=$$SETUID^HMPUTILS("order",DFN,+@HMPORKIN@("parent"))
"RTN","HMPDJ05",151,0)
 S I="" F  S I=$O(@HMPORKIN@("children",I)) Q:I=""  D
"RTN","HMPDJ05",152,0)
 . S MED("orders",1,"childrenOrderUids",I)=$$SETUID^HMPUTILS("order",DFN,+@HMPORKIN@("children",I))
"RTN","HMPDJ05",153,0)
 Q
"RTN","HMPDJ05",154,0)
DOSE(Y,N) ; -- return dosage data from HMPESP(ID,N) to Y("name")
"RTN","HMPDJ05",155,0)
 N X,DOSE,DUR,CONJ S N=+$G(N,1) K Y
"RTN","HMPDJ05",156,0)
 S Y("instructions")=$G(HMPESP("INSTR",N))
"RTN","HMPDJ05",157,0)
 S DOSE=$G(HMPESP("DOSE",N)),X=$P(DOSE,"&",1,2)
"RTN","HMPDJ05",158,0)
 S:$L(X)>1 Y("dose")=$P(X,"&"),Y("units")=$P(X,"&",2)
"RTN","HMPDJ05",159,0)
 S X=$P(DOSE,"&",3,4) S:X Y("amount")=$P(X,"&"),Y("noun")=$P(X,"&",2)
"RTN","HMPDJ05",160,0)
 ; Y("dose")=$S($L(X)>2:$TR(X,"&"," "),1:$P(X,"&"))
"RTN","HMPDJ05",161,0)
 S X=+$G(HMPESP("ROUTE",N)) D ALL^PSS51P2(X,,,,"HMPTE")
"RTN","HMPDJ05",162,0)
 S Y("routeName")=$G(^TMP($J,"HMPTE",X,1))
"RTN","HMPDJ05",163,0)
 S X=$G(HMPESP("SCHEDULE",N)) I $L(X) S Y("scheduleName")=X D SCH^HMPDJ05V(X)
"RTN","HMPDJ05",164,0)
 S X=$G(HMPESP("ADMIN",N)) S:$L(X) Y("adminTimes")=X
"RTN","HMPDJ05",165,0)
 S X=$G(HMPESP("DAYS",N)) S:$L(X) Y("complexDuration")=X,DUR=X
"RTN","HMPDJ05",166,0)
 S X=$G(HMPESP("CONJ",N)) S:$L(X) Y("complexConjunction")=X,CONJ=X
"RTN","HMPDJ05",167,0)
 I $L($G(CONJ)),'$L($G(DUR)) D  ;look ahead to find duration
"RTN","HMPDJ05",168,0)
 . N I,D S I=$O(HMPESP("DAYS",N)),D=$S(I:$G(HMPESP("DAYS",I)),1:"")
"RTN","HMPDJ05",169,0)
 . S:$L(D) Y("complexDuration")=D
"RTN","HMPDJ05",170,0)
 K ^TMP($J,"HMPTE")
"RTN","HMPDJ05",171,0)
 Q
"RTN","HMPDJ05",172,0)
 ;
"RTN","HMPDJ05",173,0)
STOP(BEG,X) ; -- Return date after adding X to BEG
"RTN","HMPDJ05",174,0)
 N D,H,M,UNT,Y
"RTN","HMPDJ05",175,0)
 S Y=BEG,(D,H,M)=0,UNT=$P(X,+X,2),X=+X
"RTN","HMPDJ05",176,0)
 S UNT=$S($E(UNT)=" ":$E(UNT,2),1:$E(UNT)) I UNT="" S UNT="D"
"RTN","HMPDJ05",177,0)
 S:UNT="L" D=30*X
"RTN","HMPDJ05",178,0)
 S:UNT="W" D=7*X
"RTN","HMPDJ05",179,0)
 S:UNT="D" D=X
"RTN","HMPDJ05",180,0)
 S:UNT="H" H=X
"RTN","HMPDJ05",181,0)
 S:UNT="M" M=X
"RTN","HMPDJ05",182,0)
 S Y=$$FMADD^XLFDT(BEG,D,H,M)
"RTN","HMPDJ05",183,0)
 Q Y
"RTN","HMPDJ05",184,0)
 ;
"RTN","HMPDJ05",185,0)
NDF(DRUG,VPI,ORD) ; -- Set NDF data for dispense DRUG ien
"RTN","HMPDJ05",186,0)
 ; code ^ name ^ vuid [^ role ^ concentration ^ order]
"RTN","HMPDJ05",187,0)
 N LEN,HMPX,STR,VUID,X,I
"RTN","HMPDJ05",188,0)
 S DRUG=+$G(DRUG) Q:'DRUG
"RTN","HMPDJ05",189,0)
 D EN^PSSDI(50,,50,"901;902",DRUG,"HMPX")
"RTN","HMPDJ05",190,0)
 S STR=$S($G(HMPX(50,DRUG,901)):$G(HMPX(50,DRUG,901))_" "_$G(HMPX(50,DRUG,902)),1:"")
"RTN","HMPDJ05",191,0)
 D NDF^PSS50(DRUG,,,,,"NDF") S VPI=+$G(VPI,1)
"RTN","HMPDJ05",192,0)
 ;
"RTN","HMPDJ05",193,0)
 S MED("products",VPI,"ingredientRole")="urn:sct:410942007" ;Drug
"RTN","HMPDJ05",194,0)
 S:$G(ORD) MED("products",VPI,"relatedOrder")=ORD
"RTN","HMPDJ05",195,0)
 S:$G(STR) MED("products",VPI,"strength")=STR
"RTN","HMPDJ05",196,0)
 S X=$G(MED("name")) S:$L(X) MED("products",VPI,"ingredientName")=X
"RTN","HMPDJ05",197,0)
 ;
"RTN","HMPDJ05",198,0)
 S X=$G(^TMP($J,"NDF",DRUG,20)) ;VA Generic
"RTN","HMPDJ05",199,0)
 S MED("products",VPI,"ingredientCode")="urn:va:vuid:"_$$VUID^HMPD(+X,50.6)
"RTN","HMPDJ05",200,0)
 S MED("products",VPI,"ingredientCodeName")=$P(X,U,2)
"RTN","HMPDJ05",201,0)
 ;
"RTN","HMPDJ05",202,0)
 S X=$G(^TMP($J,"NDF",DRUG,22)) ;VA Product
"RTN","HMPDJ05",203,0)
 S MED("products",VPI,"suppliedCode")="urn:va:vuid:"_$$VUID^HMPD(+X,50.68)
"RTN","HMPDJ05",204,0)
 S MED("products",VPI,"suppliedName")=$P(X,U,2)
"RTN","HMPDJ05",205,0)
 ;
"RTN","HMPDJ05",206,0)
 S X=$G(^TMP($J,"NDF",DRUG,25)) ;VA Drug Class
"RTN","HMPDJ05",207,0)
 S MED("products",VPI,"drugClassCode")="urn:vadc:"_$P(X,U,2)
"RTN","HMPDJ05",208,0)
 S MED("products",VPI,"drugClassName")=$P(X,U,3)
"RTN","HMPDJ05",209,0)
 ;
"RTN","HMPDJ05",210,0)
 K ^TMP($J,"NDF")
"RTN","HMPDJ05",211,0)
 Q
"RTN","HMPDJ05",212,0)
 ;
"RTN","HMPDJ05",213,0)
RELTIME(START,STOP,DUR,MIN) ; -- Return #min for dose
"RTN","HMPDJ05",214,0)
 N Y S Y=0
"RTN","HMPDJ05",215,0)
 I START>0,STOP>0 S Y=$$FMDIFF^XLFDT(STOP,START,2)\60 I 1
"RTN","HMPDJ05",216,0)
 E  I DUR S Y=$$TOMIN(DUR) I 1
"RTN","HMPDJ05",217,0)
 E  S Y=$G(HMPESP("SUPPLY",1))*1440
"RTN","HMPDJ05",218,0)
 S Y=$S(Y:Y+MIN,1:MIN)
"RTN","HMPDJ05",219,0)
 Q Y
"RTN","HMPDJ05",220,0)
 ;
"RTN","HMPDJ05",221,0)
TOMIN(DUR) ;
"RTN","HMPDJ05",222,0)
 N RESULT,TIME,UNIT
"RTN","HMPDJ05",223,0)
 S UNIT=$$UP^XLFSTR($E($P(DUR," ",2)))
"RTN","HMPDJ05",224,0)
 I UNIT="" Q 0
"RTN","HMPDJ05",225,0)
 S TIME=$P(DUR," ")
"RTN","HMPDJ05",226,0)
 S RESULT=$S(UNIT="M":TIME,UNIT="H":TIME*60,UNIT="D":TIME*1440,UNIT="W":TIME*10080,UNIT="L":TIME*43200,1:0)
"RTN","HMPDJ05",227,0)
 Q RESULT
"RTN","HMPDJ06")
0^65^B65685348
"RTN","HMPDJ06",1,0)
HMPDJ06 ;SLC/MKB,ASMR/RRB/MBS - Laboratory;May 10, 2016 18:20:53
"RTN","HMPDJ06",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ06",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ06",4,0)
 ;
"RTN","HMPDJ06",5,0)
 ; External References          DBIA#
"RTN","HMPDJ06",6,0)
 ; -------------------          -----
"RTN","HMPDJ06",7,0)
 ; ^LAB(60                         91
"RTN","HMPDJ06",8,0)
 ; ^LR                            525
"RTN","HMPDJ06",9,0)
 ; ^PXRMINDX                     4290
"RTN","HMPDJ06",10,0)
 ; ^TMP("LRRR" [LR7OR1]          2503
"RTN","HMPDJ06",11,0)
 ; DIQ                           2056
"RTN","HMPDJ06",12,0)
 ; LR7OR1,^TMP("LRRR"            2503
"RTN","HMPDJ06",13,0)
 ; LRPXAPI                       4245
"RTN","HMPDJ06",14,0)
 ; LRPXAPIU                      4246
"RTN","HMPDJ06",15,0)
 ; XLFSTR                       10104
"RTN","HMPDJ06",16,0)
 ; XUAF4                         2171
"RTN","HMPDJ06",17,0)
 ;
"RTN","HMPDJ06",18,0)
 ; All tags expect DFN, ID, LRDFN, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ06",19,0)
 ;               & ^TMP("LRRR",$J,DFN,HMPSUB,HMPIDT,HMPP),HMPN
"RTN","HMPDJ06",20,0)
 Q
"RTN","HMPDJ06",21,0)
 ;
"RTN","HMPDJ06",22,0)
CH1 ; -- lab ID = CH;HMPIDT;HMPN
"RTN","HMPDJ06",23,0)
 N LAB,LRI,X,X0,SPC,LOINC,ORD,CMMT
"RTN","HMPDJ06",24,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ06",25,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ06",26,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the chemistry domain"
"RTN","HMPDJ06",27,0)
 ;
"RTN","HMPDJ06",28,0)
 M LAB=HMPACC ;get accession info
"RTN","HMPDJ06",29,0)
 S LAB("localId")=ID,LAB("uid")=$$SETUID^HMPUTILS("lab",DFN,ID)
"RTN","HMPDJ06",30,0)
 S LAB("categoryCode")="urn:va:lab-category:CH"
"RTN","HMPDJ06",31,0)
 S LAB("categoryName")="Laboratory"
"RTN","HMPDJ06",32,0)
 S LAB("displayOrder")=HMPP
"RTN","HMPDJ06",33,0)
 S LRI=$G(^LR(LRDFN,"CH",HMPIDT,HMPN))  ;DE2818, ^LR( - ICR525
"RTN","HMPDJ06",34,0)
 S X0=$G(^TMP("LRRR",$J,DFN,"CH",HMPIDT,HMPP)),SPC=+$P(X0,U,19)
"RTN","HMPDJ06",35,0)
 ;DE2818 - ^LAB(60) references - ICR 91
"RTN","HMPDJ06",36,0)
 S LAB("typeId")=+X0,LAB("typeName")=$P($G(^LAB(60,+X0,0)),U)
"RTN","HMPDJ06",37,0)
 S:$L($P(X0,U,2)) LAB("result")=$P(X0,U,2)
"RTN","HMPDJ06",38,0)
 S:$L($P(X0,U,4)) LAB("units")=$P(X0,U,4)
"RTN","HMPDJ06",39,0)
 S X=$P(X0,U,5) I $L(X),X["-" S LAB("low")=$$TRIM^XLFSTR($P(X,"-")),LAB("high")=$$TRIM^XLFSTR($P(X,"-",2))
"RTN","HMPDJ06",40,0)
 S X=$P(X0,U,3) I $L(X) D
"RTN","HMPDJ06",41,0)
 . S:X["*" X=$S(X["L":"LL",1:"HH")
"RTN","HMPDJ06",42,0)
 . S LAB("interpretationCode")="urn:hl7:observation-interpretation:"_X
"RTN","HMPDJ06",43,0)
 . S LAB("interpretationName")=$S(X["L":"Low",1:"High")_$S($L(X)>1:" alert",1:"")
"RTN","HMPDJ06",44,0)
 S LAB("displayName")=$S($L($P(X0,U,15)):$P(X0,U,15),1:LAB("test"))
"RTN","HMPDJ06",45,0)
 S ORD=+$P(X0,U,17) S:ORD LAB("labOrderId")=ORD
"RTN","HMPDJ06",46,0)
 S X=$$ORDER^HMPDLR(ORD,+X0) S:X LAB("orderUid")=$$SETUID^HMPUTILS("order",DFN,X)
"RTN","HMPDJ06",47,0)
 ;DE4624 - If no LOINC code in the lab data, check in the LABRATORY TEST (#60) file
"RTN","HMPDJ06",48,0)
 S LOINC=$P($P(LRI,U,3),"!",3) S:'LOINC LOINC=$$LOINC^HMPDJ06(+X0,SPC)
"RTN","HMPDJ06",49,0)
 I LOINC S LAB("typeCode")="urn:lnc:"_$$GET1^DIQ(95.3,+LOINC_",",.01),LAB("vuid")="urn:va:vuid:"_$$VUID^HMPD(+LOINC,95.3)
"RTN","HMPDJ06",50,0)
 I 'LOINC S LAB("typeCode")="urn:va:ien:60:"_+X0_":"_SPC
"RTN","HMPDJ06",51,0)
 I $D(^TMP("LRRR",$J,DFN,"CH",HMPIDT,"N")) M CMMT=^("N") S LAB("comment")=$$STRING^HMPD(.CMMT)
"RTN","HMPDJ06",52,0)
 S LAB("statusCode")="urn:va:lab-status:completed",LAB("statusName")="completed"
"RTN","HMPDJ06",53,0)
 S LAB("lastUpdateTime")=$$EN^HMPSTMP("lab") ;RHL 20150102
"RTN","HMPDJ06",54,0)
 S LAB("stampTime")=LAB("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ06",55,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ06",56,0)
 I $G(HMPMETA) D ADD^HMPMETA("lab",LAB("uid"),LAB("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ06",57,0)
 D ADD^HMPDJ("LAB","lab")
"RTN","HMPDJ06",58,0)
 Q
"RTN","HMPDJ06",59,0)
 ;
"RTN","HMPDJ06",60,0)
ACC ; -- put accession-level data in HMPACC("attribute")
"RTN","HMPDJ06",61,0)
 N LR0,CDT,SPC,X K HMPACC
"RTN","HMPDJ06",62,0)
 S LR0=$G(^LR(LRDFN,HMPSUB,HMPIDT,0))  ;DE2818, ^LR( - ICR525
"RTN","HMPDJ06",63,0)
 S CDT=9999999-HMPIDT,HMPACC("observed")=$$DATE(CDT)
"RTN","HMPDJ06",64,0)
 S HMPACC("resulted")=$$DATE($P(LR0,U,3)),SPC=+$P(LR0,U,5) I SPC D
"RTN","HMPDJ06",65,0)
 . N IENS,HMPY S IENS=SPC_","
"RTN","HMPDJ06",66,0)
 . D GETS^DIQ(61,IENS,".01;4.1",,"HMPY")
"RTN","HMPDJ06",67,0)
 . S HMPACC("specimen")=$G(HMPY(61,IENS,.01))
"RTN","HMPDJ06",68,0)
 . S HMPACC("sample")=$G(HMPY(61,IENS,4.1))
"RTN","HMPDJ06",69,0)
 S HMPACC("groupUid")=$$SETUID^HMPUTILS("accession",DFN,HMPSUB_";"_HMPIDT)
"RTN","HMPDJ06",70,0)
 S HMPACC("groupName")=$P(LR0,U,6)
"RTN","HMPDJ06",71,0)
 S X=+$P(LR0,U,14) D  D FACILITY^HMPUTILS(X,"HMPACC")
"RTN","HMPDJ06",72,0)
 . S:X X=$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U)
"RTN","HMPDJ06",73,0)
 . I 'X S X=$$FAC^HMPD ;local stn#^name
"RTN","HMPDJ06",74,0)
 Q
"RTN","HMPDJ06",75,0)
 ;
"RTN","HMPDJ06",76,0)
MI ; -- microbiology accession ID = MI;HMPIDT
"RTN","HMPDJ06",77,0)
 N LAB,CDT,LR0,X,ACC,FAC,X0,X1,X2,IDX,HMPM,HMPPX,HMPITM,DA,FLD
"RTN","HMPDJ06",78,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ06",79,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ06",80,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the microbiology domain"
"RTN","HMPDJ06",81,0)
 ;
"RTN","HMPDJ06",82,0)
 S LAB("localId")=ID,LAB("uid")=$$SETUID^HMPUTILS("lab",DFN,ID)
"RTN","HMPDJ06",83,0)
 S LAB("categoryCode")="urn:va:lab-category:MI"
"RTN","HMPDJ06",84,0)
 S LAB("categoryName")="Microbiology"
"RTN","HMPDJ06",85,0)
 S LAB("statusCode")="urn:va:lab-status:completed",LAB("statusName")="completed"
"RTN","HMPDJ06",86,0)
 S CDT=9999999-HMPIDT,LAB("observed")=$$DATE(CDT)
"RTN","HMPDJ06",87,0)
 S LR0=$G(^LR(LRDFN,"MI",HMPIDT,0))  ; DE2818, ^LR( - ICR525
"RTN","HMPDJ06",88,0)
 S:$P(LR0,U,3) LAB("resulted")=$$DATE($P(LR0,U,3))
"RTN","HMPDJ06",89,0)
 S X=+$P(LR0,U,5) I X D  ;specimen
"RTN","HMPDJ06",90,0)
 . N IENS,HMPY S IENS=X_","
"RTN","HMPDJ06",91,0)
 . D GETS^DIQ(61,IENS,".01;2",,"HMPY")
"RTN","HMPDJ06",92,0)
 . S LAB("specimen")=$G(HMPY(61,IENS,.01))
"RTN","HMPDJ06",93,0)
 . S LAB("sample")=$$GET1^DIQ(61,X_",",4.1)
"RTN","HMPDJ06",94,0)
 S LAB("groupName")=$P(LR0,U,6),ACC=$P(ID,";",1,2) ;accession#
"RTN","HMPDJ06",95,0)
 S LAB("groupUid")=$$SETUID^HMPUTILS("accession",DFN,ACC)
"RTN","HMPDJ06",96,0)
 S X=$P(LR0,U,14),FAC=$S(X:$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U),1:$$FAC^HMPD)
"RTN","HMPDJ06",97,0)
 D FACILITY^HMPUTILS(FAC,"LAB")
"RTN","HMPDJ06",98,0)
 ; get results from ^TMP
"RTN","HMPDJ06",99,0)
 S HMPN=0 F  S HMPN=$O(^TMP("LRRR",$J,DFN,HMPSUB,HMPIDT,HMPN)) Q:HMPN<1  D
"RTN","HMPDJ06",100,0)
 . S X0=$G(^TMP("LRRR",$J,DFN,"MI",HMPIDT,HMPN)),X1=$P(X0,U),X2=$P(X0,U,2)
"RTN","HMPDJ06",101,0)
 . I X1="URINE SCREEN" S LAB("urineScreen")=X2 Q
"RTN","HMPDJ06",102,0)
 . ; X1="ORGANISM" S LAB("organism")=$P(X2,";"),LAB("organismQty")=$P(X2,";",2)
"RTN","HMPDJ06",103,0)
 . I X1="GRAM STAIN" S LAB("gramStain",HMPN,"result")=X2 Q
"RTN","HMPDJ06",104,0)
 . I X1="Bacteriology Remark(s)" S LAB("bactRemarks")=X2 Q
"RTN","HMPDJ06",105,0)
 ; get other results from ^PXRMINDX
"RTN","HMPDJ06",106,0)
 S X=$O(^PXRMINDX(63,"PDI",DFN,CDT,"M;T;0")) I X?1"M;T;"1.N D
"RTN","HMPDJ06",107,0)
 . S IDX=$O(^PXRMINDX(63,"PDI",DFN,CDT,X,"")) K HMPM
"RTN","HMPDJ06",108,0)
 . D LRPXRM^LRPXAPI(.HMPM,IDX,X) Q:HMPM<1
"RTN","HMPDJ06",109,0)
 . S LAB("typeName")=$P(HMPM,U,2)
"RTN","HMPDJ06",110,0)
 . S LAB("typeCode")="urn:va:ien:60:"_+HMPM_":"_+$P(HMPM,U,7)
"RTN","HMPDJ06",111,0)
 F HMPPX="M;O;","M;A;" D
"RTN","HMPDJ06",112,0)
 . S HMPITM=HMPPX F  S HMPITM=$O(^PXRMINDX(63,"PDI",DFN,CDT,HMPITM)) Q:$E(HMPITM,1,4)'=HMPPX  D
"RTN","HMPDJ06",113,0)
 .. S IDX=$O(^PXRMINDX(63,"PDI",DFN,CDT,HMPITM,"")) K HMPM
"RTN","HMPDJ06",114,0)
 .. S DA=$P(IDX,";",5),FLD=$P(IDX,";",6)
"RTN","HMPDJ06",115,0)
 .. D LRPXRM^LRPXAPI(.HMPM,IDX,HMPITM) Q:'$L($G(HMPM))
"RTN","HMPDJ06",116,0)
 .. I HMPPX["O" S LAB("organisms",DA,"name")=$P(HMPM,U,2),LAB("organisms",DA,"qty")=$P(HMPM,U,4) Q
"RTN","HMPDJ06",117,0)
 .. I HMPPX["A" D  Q
"RTN","HMPDJ06",118,0)
 ... S LAB("organisms",DA,"drugs",FLD,"name")=$P(HMPM,U,2)
"RTN","HMPDJ06",119,0)
 ... S LAB("organisms",DA,"drugs",FLD,"result")=$P(HMPM,U,3)
"RTN","HMPDJ06",120,0)
 ... S LAB("organisms",DA,"drugs",FLD,"interp")=$P(HMPM,U,4)
"RTN","HMPDJ06",121,0)
 ... S:$L($P(HMPM,U,5)) LAB("organisms",DA,"drugs",FLD,"restrict")=$P(HMPM,U,5)
"RTN","HMPDJ06",122,0)
 ;
"RTN","HMPDJ06",123,0)
 S LAB("results",1,"uid")=ACC
"RTN","HMPDJ06",124,0)
 S LAB("results",1,"resultUid")=$$SETUID^HMPUTILS("document",DFN,ACC)
"RTN","HMPDJ06",125,0)
 S LAB("results",1,"localTitle")="LR MICROBIOLOGY REPORT"
"RTN","HMPDJ06",126,0)
 I $L($G(^LR(LRDFN,"MI",HMPIDT,99))) S LAB("comment")=^(99)  ; DE2818, ^LR( - ICR525
"RTN","HMPDJ06",127,0)
 S LAB("lastUpdateTime")=$$EN^HMPSTMP("lab") ;RHL 20150102
"RTN","HMPDJ06",128,0)
 S LAB("stampTime")=LAB("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ06",129,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ06",130,0)
 I $G(HMPMETA) D ADD^HMPMETA("lab",LAB("uid"),LAB("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ06",131,0)
 D ADD^HMPDJ("LAB","lab")
"RTN","HMPDJ06",132,0)
 Q
"RTN","HMPDJ06",133,0)
 ;
"RTN","HMPDJ06",134,0)
ITEM() ; -- find ITEM string from ^PXRMINDX [uses LRDFN,ID,DFN,CDT]
"RTN","HMPDJ06",135,0)
 N ITM,IDX,Y S Y=""
"RTN","HMPDJ06",136,0)
 S IDX=LRDFN_";"_ID,ITM="M"
"RTN","HMPDJ06",137,0)
 F  S ITM=$O(^PXRMINDX(63,"PI",DFN,ITM)) Q:$E(ITM)'="M"  I $D(^PXRMINDX(63,"PI",DFN,ITM,CDT,IDX)) S Y=ITM Q
"RTN","HMPDJ06",138,0)
 Q Y
"RTN","HMPDJ06",139,0)
 ;
"RTN","HMPDJ06",140,0)
AP ; -- pathology ID = HMPSUB;HMPIDT
"RTN","HMPDJ06",141,0)
 N LAB,LR0,X,I,NODE
"RTN","HMPDJ06",142,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ06",143,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ06",144,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the pathology domain"
"RTN","HMPDJ06",145,0)
 ;
"RTN","HMPDJ06",146,0)
 S LAB("localId")=ID,LAB("organizerType")="accession"
"RTN","HMPDJ06",147,0)
 S LAB("uid")=$$SETUID^HMPUTILS("lab",DFN,ID)
"RTN","HMPDJ06",148,0)
 S LAB("categoryCode")="urn:va:lab-category:"_HMPSUB
"RTN","HMPDJ06",149,0)
 S LAB("categoryName")=$S(HMPSUB="BB":"Blood Bank",HMPSUB="SP":"Surgical Pathology",1:"Pathology")
"RTN","HMPDJ06",150,0)
 S LAB("statusCode")="urn:va:lab-status:completed",LAB("statusName")="completed"
"RTN","HMPDJ06",151,0)
 S CDT=9999999-HMPIDT,LAB("observed")=$$DATE(CDT)
"RTN","HMPDJ06",152,0)
 ;DE2818 begin, ^LR( references - ICR525
"RTN","HMPDJ06",153,0)
 S LR0=$G(^LR(LRDFN,HMPSUB,HMPIDT,0))
"RTN","HMPDJ06",154,0)
 S LAB("resulted")=$$DATE($P(LR0,U,11)),LAB("groupName")=$P(LR0,U,6)
"RTN","HMPDJ06",155,0)
 S X="",I=0 F  S I=$O(^LR(LRDFN,HMPSUB,HMPIDT,.1,I)) Q:I<1  S X=X_$S($L(X):", ",1:"")_$P($G(^(I,0)),U)
"RTN","HMPDJ06",156,0)
 S:$L(X) LAB("specimen")=X
"RTN","HMPDJ06",157,0)
 D FACILITY^HMPUTILS($$FAC^HMPD,"LAB")
"RTN","HMPDJ06",158,0)
 S NODE=$S(HMPSUB="AU":$NA(^LR(LRDFN,101)),1:$NA(^LR(LRDFN,HMPSUB,HMPIDT,.05)))
"RTN","HMPDJ06",159,0)
 S I=0 F  S I=$O(@NODE@(I)) Q:I<1  S X=+$P($G(@NODE@(I,0)),U,2) I X D
"RTN","HMPDJ06",160,0)
 . N LT S LT=$$GET1^DIQ(8925,+X_",",.01) Q:$P(LT," ")="Addendum"
"RTN","HMPDJ06",161,0)
 . S LAB("results",I,"uid")=LAB("uid")
"RTN","HMPDJ06",162,0)
 . S LAB("results",I,"resultUid")=$$SETUID^HMPUTILS("document",DFN,X)
"RTN","HMPDJ06",163,0)
 . S LAB("results",I,"localTitle")=LT
"RTN","HMPDJ06",164,0)
 I '$O(LAB("results",0)) D  ;non-TIU reports
"RTN","HMPDJ06",165,0)
 . S LAB("results",1,"uid")=LAB("uid")
"RTN","HMPDJ06",166,0)
 . S LAB("results",1,"resultUid")=$$SETUID^HMPUTILS("document",DFN,ID)
"RTN","HMPDJ06",167,0)
 . S LAB("results",1,"localTitle")="LR "_$$NAME^HMPDLRA(HMPSUB)_" REPORT"
"RTN","HMPDJ06",168,0)
 ; ;DE2818 end, ^LR( references - ICR525
"RTN","HMPDJ06",169,0)
 S LAB("lastUpdateTime")=$$EN^HMPSTMP("lab") ;RHL 20150102
"RTN","HMPDJ06",170,0)
 S LAB("stampTime")=LAB("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ06",171,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ06",172,0)
 I $G(HMPMETA) D ADD^HMPMETA("lab",LAB("uid"),LAB("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ06",173,0)
 D ADD^HMPDJ("LAB","lab")
"RTN","HMPDJ06",174,0)
 ;
"RTN","HMPDJ06",175,0)
DATE(X) ; -- strip off seconds, return JSON format
"RTN","HMPDJ06",176,0)
 N Y S Y=$G(X)
"RTN","HMPDJ06",177,0)
 I $L($P(Y,".",2))>4 S Y=$P(Y,".")_"."_$E($P(Y,".",2),1,4) ;strip seconds
"RTN","HMPDJ06",178,0)
 S:Y Y=$$JSONDT^HMPUTILS(Y)
"RTN","HMPDJ06",179,0)
 Q Y
"RTN","HMPDJ06",180,0)
LOINC(LTEST,SPC) ;DE4624 - Gets LOINC code from Lab Test/Specimin
"RTN","HMPDJ06",181,0)
 I '$D(^LAB(60,LTEST)) Q ""
"RTN","HMPDJ06",182,0)
 I '$D(^LAB(60,LTEST,1,SPC)) Q ""
"RTN","HMPDJ06",183,0)
 Q +$G(^LAB(60,LTEST,1,SPC,95.3))
"RTN","HMPDJ07")
0^13^B31184394
"RTN","HMPDJ07",1,0)
HMPDJ07 ;SLC/MKB,ASMR/RRB,MBS - Radiology,Surgery;7/7/16  11:03
"RTN","HMPDJ07",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJ07",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ07",4,0)
 ;
"RTN","HMPDJ07",5,0)
 ; External References          DBIA#
"RTN","HMPDJ07",6,0)
 ; -------------------          -----
"RTN","HMPDJ07",7,0)
 ; ^SC                          10040
"RTN","HMPDJ07",8,0)
 ; ^VA(200                      10060
"RTN","HMPDJ07",9,0)
 ; DIC                           2051
"RTN","HMPDJ07",10,0)
 ; DIQ                           2056
"RTN","HMPDJ07",11,0)
 ; RAO7PC1                  2043,2265
"RTN","HMPDJ07",12,0)
 ; SROESTV                       3533
"RTN","HMPDJ07",13,0)
 ;
"RTN","HMPDJ07",14,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT, HMPMETA]
"RTN","HMPDJ07",15,0)
 Q
"RTN","HMPDJ07",16,0)
 ;
"RTN","HMPDJ07",17,0)
RA1(ID) ; -- radiology exam ^TMP($J,"RAE1",DFN,ID)
"RTN","HMPDJ07",18,0)
 N EXAM,X0,SET,PROC,DATE,LOC,X,Y,IENS,ID3,N
"RTN","HMPDJ07",19,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ07",20,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ07",21,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the radiology domain"
"RTN","HMPDJ07",22,0)
 ;
"RTN","HMPDJ07",23,0)
 S X0=$G(^TMP($J,"RAE1",DFN,ID)),SET=$G(^(ID,"CPRS")),PROC=$P(X0,U) Q:X0=""
"RTN","HMPDJ07",24,0)
 S EXAM("localId")=ID,EXAM("uid")=$$SETUID^HMPUTILS("image",DFN,ID)
"RTN","HMPDJ07",25,0)
 S EXAM("name")=PROC,EXAM("case")=$P(X0,U,2),EXAM("category")="RA"
"RTN","HMPDJ07",26,0)
 S DATE=9999999.9999-+ID,EXAM("dateTime")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ07",27,0)
 I $P(X0,U,5) D  ;report exists
"RTN","HMPDJ07",28,0)
 . N NM S NM=$S(+SET=2:$P(SET,U,2),1:PROC) ;2 = shared report
"RTN","HMPDJ07",29,0)
 . S EXAM("results",1,"uid")=$$SETUID^HMPUTILS("document",DFN,ID)
"RTN","HMPDJ07",30,0)
 . S EXAM("results",1,"localTitle")=NM
"RTN","HMPDJ07",31,0)
 . S EXAM("verified")=$S($E($P(X0,U,3))="V":"true",1:"false")
"RTN","HMPDJ07",32,0)
 S:$L($P(X0,U,6)) EXAM("statusName")=$P($P(X0,U,6),"~",2)
"RTN","HMPDJ07",33,0)
 S X=$P(X0,U,7),LOC="" I $L(X) D
"RTN","HMPDJ07",34,0)
 . S EXAM("imageLocation")=X,EXAM("locationName")=X
"RTN","HMPDJ07",35,0)
 . S LOC=+$O(^SC("B",X,0)) ;ICR 10040 DE2818 ASF 11/10/15
"RTN","HMPDJ07",36,0)
 . S EXAM("locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ07",37,0)
 S X=$$FAC^HMPD(LOC) D FACILITY^HMPUTILS(X,"EXAM")
"RTN","HMPDJ07",38,0)
 I $L($P(X0,U,8)) S X=$P($P(X0,U,8),"~",2),EXAM("imagingTypeUid")=$$SETVURN^HMPUTILS("imaging-Type",X)
"RTN","HMPDJ07",39,0)
 S X=$P(X0,U,10) I X D
"RTN","HMPDJ07",40,0)
 . N CPT S CPT=$$CPT^HMPDRA(X)
"RTN","HMPDJ07",41,0)
 . S (EXAM("typeName"),EXAM("summary"))=$P(CPT,U,2)
"RTN","HMPDJ07",42,0)
 . ;I $D(^TMP($J,"RAE1",DFN,ID,"CMOD")) M EXAM("modifier")=^("CMOD")
"RTN","HMPDJ07",43,0)
 I $P(X0,U,11) D
"RTN","HMPDJ07",44,0)
 . S EXAM("orderUid")=$$SETUID^HMPUTILS("order",DFN,+$P(X0,U,11))
"RTN","HMPDJ07",45,0)
 . S EXAM("orderName")=$S($L(SET):$P(SET,U,2),1:PROC)
"RTN","HMPDJ07",46,0)
 S EXAM("hasImages")=$S($P(X0,U,12)="Y":"true",1:"false")
"RTN","HMPDJ07",47,0)
 I $P(X0,U,4)="Y"!($P(X0,U,9)="Y") S EXAM("interpretation")="ABNORMAL"
"RTN","HMPDJ07",48,0)
 S IENS=$P(ID,"-",2)_","_+ID_","_DFN_","
"RTN","HMPDJ07",49,0)
 S X=$$GET1^DIQ(70.03,IENS,27,"I") I X D
"RTN","HMPDJ07",50,0)
 . S EXAM("encounterUid")=$$SETUID^HMPUTILS("visit",DFN,+X)
"RTN","HMPDJ07",51,0)
 . S EXAM("encounterName")=$$NAME^HMPDJ04(+X)
"RTN","HMPDJ07",52,0)
 S ID3=DFN_U_$TR(ID,"-","^") D EN3^RAO7PC1(ID3) D  ;get additional values
"RTN","HMPDJ07",53,0)
 . S EXAM("reason")=$G(^TMP($J,"RAE2",DFN,+$P(ID3,U,3),PROC,"RFS"))
"RTN","HMPDJ07",54,0)
 . ;Get list of providers
"RTN","HMPDJ07",55,0)
 . S X=+$G(^TMP($J,"RAE2",DFN,+$P(ID3,U,3),PROC,"P")) D:X ADDPROV(.EXAM,X,"Primary") ;Primary Interpreting Staff
"RTN","HMPDJ07",56,0)
 . S X=+$G(^TMP($J,"RAE2",DFN,+$P(ID3,U,3),PROC,"V")) D:X ADDPROV(.EXAM,X,"Verifier") ;Verifying Physician
"RTN","HMPDJ07",57,0)
 . S X=$$GET1^DIQ(70.03,IENS,14,"I") D:X ADDPROV(.EXAM,X,"Requestor") ;Requesting Provider
"RTN","HMPDJ07",58,0)
 . S N=0 F  S N=$O(^TMP($J,"RAE2",DFN,+$P(ID3,U,3),PROC,"D",N)) Q:N<1  S X=$G(^(N)) D
"RTN","HMPDJ07",59,0)
 .. S EXAM("diagnosis",N,"code")=X
"RTN","HMPDJ07",60,0)
 .. S:N=1 EXAM("diagnosis",N,"primary")="true"
"RTN","HMPDJ07",61,0)
 .. N EXP S EXP=$$LEX(X) S:EXP EXAM("diagnosis",N,"lexicon")=X
"RTN","HMPDJ07",62,0)
 . K ^TMP($J,"RAE2",DFN)
"RTN","HMPDJ07",63,0)
 S EXAM("kind")="Imaging"
"RTN","HMPDJ07",64,0)
 S EXAM("lastUpdateTime")=$$EN^HMPSTMP("image") ;RHL 20150102
"RTN","HMPDJ07",65,0)
 S EXAM("stampTime")=EXAM("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ07",66,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ07",67,0)
 I $G(HMPMETA) D ADD^HMPMETA("image",EXAM("uid"),EXAM("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ07",68,0)
 D ADD^HMPDJ("EXAM","image")
"RTN","HMPDJ07",69,0)
 Q
"RTN","HMPDJ07",70,0)
ADDPROV(EXAM,X,ROLE) ;Add a provider to the providers array
"RTN","HMPDJ07",71,0)
 Q:'X
"RTN","HMPDJ07",72,0)
 S I=$O(EXAM("providers",999),-1)+1
"RTN","HMPDJ07",73,0)
 S EXAM("providers",I,"providerUid")=$$SETUID^HMPUTILS("user",,X)
"RTN","HMPDJ07",74,0)
 S EXAM("providers",I,"providerName")=$P($G(^VA(200,X,0)),U) ;ICR 10060 DE2818 ASF 11/10/15
"RTN","HMPDJ07",75,0)
 S:ROLE]"" EXAM("providers",I,"providerRole")=ROLE
"RTN","HMPDJ07",76,0)
 Q
"RTN","HMPDJ07",77,0)
 ;
"RTN","HMPDJ07",78,0)
LEX(X) ; -- Return Lexicon ptr for a Dx Code
"RTN","HMPDJ07",79,0)
 N Y,DIC,LEX
"RTN","HMPDJ07",80,0)
 S DIC=78.3,DIC(0)="BFOXZ" D ^DIC
"RTN","HMPDJ07",81,0)
 S LEX=$P($G(Y(0)),U,6)
"RTN","HMPDJ07",82,0)
 Q LEX
"RTN","HMPDJ07",83,0)
 ;
"RTN","HMPDJ07",84,0)
SR1(ID) ; -- surgery
"RTN","HMPDJ07",85,0)
 N SURG,HMPX,HMPY,X,Y,I
"RTN","HMPDJ07",86,0)
 D ONE^SROESTV("HMPY",ID) S HMPX=$G(HMPY(ID)) Q:HMPX=""
"RTN","HMPDJ07",87,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ07",88,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ07",89,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the surgery domain"
"RTN","HMPDJ07",90,0)
 ;
"RTN","HMPDJ07",91,0)
 S SURG("localId")=ID,SURG("uid")=$$SETUID^HMPUTILS("surgery",DFN,ID)
"RTN","HMPDJ07",92,0)
 S X=$P(HMPX,U,2),SURG("statusName")="COMPLETED"
"RTN","HMPDJ07",93,0)
 I X?1"* Aborted * ".E S X=$E(X,13,999),SURG("statusName")="ABORTED"
"RTN","HMPDJ07",94,0)
 S (SURG("typeName"),SURG("summary"))=X
"RTN","HMPDJ07",95,0)
 S SURG("dateTime")=$$JSONDT^HMPUTILS($P(HMPX,U,3))
"RTN","HMPDJ07",96,0)
 S X=$P(HMPX,U,4) I X D
"RTN","HMPDJ07",97,0)
 . S SURG("providers",1,"providerUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ07",98,0)
 . S SURG("providers",1,"providerName")=$P(X,";",2)
"RTN","HMPDJ07",99,0)
 S X=$$GET1^DIQ(130,ID_",",50,"I"),X=$$FAC^HMPD(X)
"RTN","HMPDJ07",100,0)
 D FACILITY^HMPUTILS(X,"SURG")
"RTN","HMPDJ07",101,0)
 S X=$$GET1^DIQ(130,ID_",",.015,"I") I X D
"RTN","HMPDJ07",102,0)
 . S SURG("encounterUid")=$$SETUID^HMPUTILS("visit",DFN,+X)
"RTN","HMPDJ07",103,0)
 . S SURG("encounterName")=$$NAME^HMPDJ04(+X)
"RTN","HMPDJ07",104,0)
 S X=$$GET1^DIQ(136,ID_",",.02,"I") I X D
"RTN","HMPDJ07",105,0)
 . S X=$$CPT^HMPDSR(X)
"RTN","HMPDJ07",106,0)
 . S (SURG("typeName"),SURG("summary"))=$P(X,U,2)
"RTN","HMPDJ07",107,0)
 . S SURG("typeCode")=$$SETNCS^HMPUTILS("cpt",+X)
"RTN","HMPDJ07",108,0)
 S I=0 F  S I=$O(HMPY(ID,I)) Q:I<1  S X=$G(HMPY(ID,I)) I X D
"RTN","HMPDJ07",109,0)
 . N LT S LT=$P(X,U,2) Q:$P(LT," ")="Addendum"
"RTN","HMPDJ07",110,0)
 . S SURG("results",I,"uid")=$$SETUID^HMPUTILS("document",DFN,+X)
"RTN","HMPDJ07",111,0)
 . S SURG("results",I,"localTitle")=LT
"RTN","HMPDJ07",112,0)
 S SURG("kind")="Surgery",SURG("category")="SR"
"RTN","HMPDJ07",113,0)
 K ^TMP("TIULIST",$J)
"RTN","HMPDJ07",114,0)
 S SURG("lastUpdateTime")=$$EN^HMPSTMP("surgery") ;RHL 20150102
"RTN","HMPDJ07",115,0)
 S SURG("stampTime")=SURG("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ07",116,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ07",117,0)
 I $G(HMPMETA) D ADD^HMPMETA("surgery",SURG("uid"),SURG("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ07",118,0)
 D ADD^HMPDJ("SURG","surgery")
"RTN","HMPDJ07",119,0)
 Q
"RTN","HMPDJ08")
0^14^B80070149
"RTN","HMPDJ08",1,0)
HMPDJ08 ;SLC/MKB,ASMR/RRB,ASF,HM - TIU Documents;May 15, 2016 14:15
"RTN","HMPDJ08",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPDJ08",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ08",4,0)
 ;
"RTN","HMPDJ08",5,0)
 ;11/19/14 - Fix missing MCAR documents tag EN1+4, EN1+13  js
"RTN","HMPDJ08",6,0)
 ;
"RTN","HMPDJ08",7,0)
 ; External References          DBIA#
"RTN","HMPDJ08",8,0)
 ; -------------------          -----
"RTN","HMPDJ08",9,0)
 ; ^SC                          10040
"RTN","HMPDJ08",10,0)
 ; ^TIU(8925.1              2321,5677
"RTN","HMPDJ08",11,0)
 ; ^TIU(8926.1                   5678
"RTN","HMPDJ08",12,0)
 ; ^VA(200                      10060
"RTN","HMPDJ08",13,0)
 ; DIQ                           2056
"RTN","HMPDJ08",14,0)
 ; RAO7PC1                       2043
"RTN","HMPDJ08",15,0)
 ; TIUCNSLT                      5546
"RTN","HMPDJ08",16,0)
 ; TIUCP                         3568
"RTN","HMPDJ08",17,0)
 ; TIULQ                         2693
"RTN","HMPDJ08",18,0)
 ; TIULX                         3058
"RTN","HMPDJ08",19,0)
 ; TIUSROI                       5676
"RTN","HMPDJ08",20,0)
 ; TIUSRVLO                 2834,2865
"RTN","HMPDJ08",21,0)
 ; XLFSTR                       10104
"RTN","HMPDJ08",22,0)
 ;
"RTN","HMPDJ08",23,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ08",24,0)
 Q
"RTN","HMPDJ08",25,0)
 ;
"RTN","HMPDJ08",26,0)
TIU1(ID) ; -- document
"RTN","HMPDJ08",27,0)
 I ID[";" D   Q
"RTN","HMPDJ08",28,0)
 . I ID D EN1($$CP1^HMPDJ08A(DFN,ID),"CP") Q  ;CP
"RTN","HMPDJ08",29,0)
 . D EN1($$LR1^HMPDJ08A(DFN,ID),"LR") Q       ;Lab
"RTN","HMPDJ08",30,0)
 I ID["-" D  Q                                ;Radiology
"RTN","HMPDJ08",31,0)
 . S (BEG,END)=9999999.9999-+ID D EN1^RAO7PC1(DFN,BEG,END,"99P")
"RTN","HMPDJ08",32,0)
 . Q:'$D(^TMP($J,"RAE1",DFN,ID))              ;deleted
"RTN","HMPDJ08",33,0)
 . D EN1($$RA1^HMPDJ08A(DFN,ID),"RA") K ^TMP($J,"RAE1")
"RTN","HMPDJ08",34,0)
 D EN1(ID,38)
"RTN","HMPDJ08",35,0)
 Q
"RTN","HMPDJ08",36,0)
 ;
"RTN","HMPDJ08",37,0)
EN1(HMPX,TIU,OUTPUT) ; -- document
"RTN","HMPDJ08",38,0)
 ;  Expects DFN, HMPX=IEN^$$RESOLVE^TIUSRVLO(IEN) or equivalent
"RTN","HMPDJ08",39,0)
 ;          TIU = document class#, or code (CP, RA, LR) if non-TIU
"RTN","HMPDJ08",40,0)
 ;          OUTPUT = store the result in the output array instead (by reference)
"RTN","HMPDJ08",41,0)
 N DOC,IEN,X,HMPTIU,NT,ES,I,TEXT,SUB,HMPY,ERR
"RTN","HMPDJ08",42,0)
 ; --- CP HMPX records with $p1 not the file ien  --- 
"RTN","HMPDJ08",43,0)
 S IEN=$P($G(HMPX),U),TIU=$G(TIU) I TIU="CP" I IEN="" D  Q:IEN=""  ;invalid ien
"RTN","HMPDJ08",44,0)
 . S HMPIEN=+$P(HMPX,$J_",""",2)
"RTN","HMPDJ08",45,0)
 . I +HMPIEN>0 S IEN=+HMPIEN
"RTN","HMPDJ08",46,0)
 . Q
"RTN","HMPDJ08",47,0)
 ; ---
"RTN","HMPDJ08",48,0)
 I +HMPX=HMPX,TIU D  ;get TIU data string, if needed
"RTN","HMPDJ08",49,0)
 . N SHOWADD,DA S SHOWADD=1,DA=+HMPX
"RTN","HMPDJ08",50,0)
 . S HMPX=DA_U_$$RESOLVE^TIUSRVLO(DA)
"RTN","HMPDJ08",51,0)
 ; --- CP HMPX records with $p1 not the file ien  ---
"RTN","HMPDJ08",52,0)
 I +HMPX="" I TIU="CP" D  ;get TIU data string, if needed
"RTN","HMPDJ08",53,0)
 . N SHOWADD,DA S SHOWADD=1,DA=+IEN
"RTN","HMPDJ08",54,0)
 . S HMPX=DA_U_$$RESOLVE^TIUSRVLO(DA)
"RTN","HMPDJ08",55,0)
 ; ---
"RTN","HMPDJ08",56,0)
 Q:"UNKNOWN"[$P($G(HMPX),U,2)  ;null or invalid
"RTN","HMPDJ08",57,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ08",58,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ08",59,0)
 S ERRMSG="A problem occurred converting record "_IEN_" for the document domain"
"RTN","HMPDJ08",60,0)
 S DOC("localId")=IEN,DOC("uid")=$$SETUID^HMPUTILS("document",DFN,IEN)
"RTN","HMPDJ08",61,0)
 S DOC("localTitle")=$P(HMPX,U,2)
"RTN","HMPDJ08",62,0)
 S DOC("referenceDateTime")=$$JSONDT^HMPUTILS($P(HMPX,U,3))
"RTN","HMPDJ08",63,0)
 S X=$P(HMPX,U,6) D  ;S:$L(X) DOC("location")=X
"RTN","HMPDJ08",64,0)
 . N LOC,FAC S LOC=$S($L(X):+$O(^SC("B",X,0)),1:0) ;ICR 10040 DE2818 ASF 11/10/15
"RTN","HMPDJ08",65,0)
 . S X=$$FAC^HMPD(LOC)
"RTN","HMPDJ08",66,0)
 . S DOC("facilityCode")=$P(X,U),DOC("facilityName")=$P(X,U,2)
"RTN","HMPDJ08",67,0)
 S X=$P(HMPX,U,7) I $L(X) S DOC("status")=$$UP^XLFSTR(X)
"RTN","HMPDJ08",68,0)
 S:$P(HMPX,U,11) DOC("images")=+$P(HMPX,U,11)
"RTN","HMPDJ08",69,0)
 S:$L($P(HMPX,U,12)) DOC("subject")=$P(HMPX,U,12)
"RTN","HMPDJ08",70,0)
 I $P(HMPX,U,14)>5 S DOC("parentUid")=$$SETUID^HMPUTILS("document",DFN,$P(HMPX,U,14)) ;ID notes
"RTN","HMPDJ08",71,0)
B ; other TIU data
"RTN","HMPDJ08",72,0)
 D:TIU EXTRACT^TIULQ(IEN,"HMPTIU",,,,1,,1) ;".01:.04;1501:1508")
"RTN","HMPDJ08",73,0)
 S X=$G(HMPTIU(IEN,.01,"I")) S:X DOC("documentDefUid")=$$SETUID^HMPUTILS("doc-def",,X)
"RTN","HMPDJ08",74,0)
 S NT=$S(X:+$G(^TIU(8925.1,X,15)),1:$P(HMPX,U,10)) I NT D  ;ICR 2321 DE2818 ASF 11/10/15
"RTN","HMPDJ08",75,0)
 . S DOC("nationalTitle","vuid")="urn:va:vuid:"_$$VUID^HMPD(NT,8926.1)
"RTN","HMPDJ08",76,0)
 . S DOC("nationalTitle","name")=$$GET1^DIQ(8926.1,NT_",",.01)
"RTN","HMPDJ08",77,0)
 S X=$G(HMPTIU(IEN,1201,"I")) S:X DOC("entered")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ08",78,0)
 S X=$G(HMPTIU(IEN,1601,"I")) S:X DOC("amended")=$$JSONDT^HMPUTILS(X) ;amended date #DE5456
"RTN","HMPDJ08",79,0)
 S X=$G(HMPTIU(IEN,.09,"E")) S:$L(X) DOC("urgency")=X
"RTN","HMPDJ08",80,0)
 S X=TIU I TIU S X=+$G(HMPTIU(IEN,.01,"I")),X=$$CATG^HMPDTIU(X) ;2U type code
"RTN","HMPDJ08",81,0)
 S DOC("documentTypeCode")=X,DOC("documentTypeName")=$$TYPE(X)
"RTN","HMPDJ08",82,0)
 S DOC("documentClass")=$S(X="LR":"LR LABORATORY REPORTS",X="SR":"SURGICAL REPORTS",X="CP":"CLINICAL PROCEDURES",X="RA":"RADIOLOGY REPORTS",X="DS":"DISCHARGE SUMMARY",1:"PROGRESS NOTES")
"RTN","HMPDJ08",83,0)
 S X=$S(TIU:$G(HMPTIU(IEN,.03,"I")),1:$P(HMPX,U,8)) ;visit#
"RTN","HMPDJ08",84,0)
 S:X DOC("encounterUid")=$$SETUID^HMPUTILS("visit",DFN,X),DOC("encounterName")=$$NAME^HMPDJ04(X)
"RTN","HMPDJ08",85,0)
C ; text blocks, signatures
"RTN","HMPDJ08",86,0)
 N HMPT,HMPA,HMPADD
"RTN","HMPDJ08",87,0)
 S DOC("text",1,"dateTime")=DOC("referenceDateTime")
"RTN","HMPDJ08",88,0)
 S DOC("text",1,"status")=$G(DOC("status"))
"RTN","HMPDJ08",89,0)
 S DOC("text",1,"uid")=DOC("uid")
"RTN","HMPDJ08",90,0)
 S HMPT=1,X=$P(HMPX,U,5),I=0
"RTN","HMPDJ08",91,0)
 I X D USER(.I,+X,$P(X,";",3),"AU")    ;author
"RTN","HMPDJ08",92,0)
 M ES=HMPTIU(IEN) S X=$P(HMPX,"//",2) ;non-TIU, put into ES for use:
"RTN","HMPDJ08",93,0)
 I $L(X) S ES(1502,"I")=+X,ES(1502,"E")=$P(X,";",2),ES(1501,"I")=$P(X,";",3)
"RTN","HMPDJ08",94,0)
 ; USER API calling convention
"RTN","HMPDJ08",95,0)
 ; USER(Incrementer,UserIEN,UserDisplayName,UserRole,SignedByDate,SignedByName,SignedByTitle)
"RTN","HMPDJ08",96,0)
 I $G(ES(1501,"I")) D USER(.I,ES(1502,"I"),ES(1502,"E"),"S",ES(1501,"I"),$G(ES(1503,"E")),$G(ES(1504,"E")))
"RTN","HMPDJ08",97,0)
 I $G(ES(1507,"I")) D USER(.I,ES(1508,"I"),ES(1508,"E"),"C",ES(1507,"I"),$G(ES(1509,"E")),$G(ES(1510,"E")))
"RTN","HMPDJ08",98,0)
 I $G(ES(1204,"I")) D USER(.I,ES(1204,"I"),ES(1204,"E"),"ES")    ;expected signer
"RTN","HMPDJ08",99,0)
 I $G(ES(1208,"I")) D USER(.I,ES(1208,"I"),ES(1208,"E"),"EC")    ;expected cosigner
"RTN","HMPDJ08",100,0)
 I $G(ES(1302,"I")) D USER(.I,ES(1302,"I"),ES(1302,"E"),"E")     ;entered
"RTN","HMPDJ08",101,0)
 I $G(ES(1209,"I")) D USER(.I,ES(1209,"I"),ES(1209,"E"),"ATT")   ;attending
"RTN","HMPDJ08",102,0)
 I $G(ES(1601,"I")) D USER(.I,ES(1602,"I"),ES(1602,"E"),"AM",ES(1603,"I"),$G(ES(1604,"E")),$G(ES(1605,"E"))) ;amended by #DE5456
"RTN","HMPDJ08",103,0)
 I $G(HMPTEXT) D
"RTN","HMPDJ08",104,0)
 . S X=$S(TIU:$NA(HMPTIU(IEN,"TEXT")),1:$NA(^TMP("HMPTEXT",$J,IEN)))
"RTN","HMPDJ08",105,0)
 . K ^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",106,0)
 . D SETTEXT^HMPUTILS(X,$NA(^TMP($J,"HMP TIU TEXT")))
"RTN","HMPDJ08",107,0)
 . M DOC("text",1,"content","\")=^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",108,0)
D ; addenda
"RTN","HMPDJ08",109,0)
 S HMPA=0 F  S HMPA=$O(HMPTIU(IEN,"ZADD",HMPA)) Q:HMPA<1  D
"RTN","HMPDJ08",110,0)
 . S HMPT=HMPT+1,I=0 K HMPADD M HMPADD=HMPTIU(IEN,"ZADD",HMPA)
"RTN","HMPDJ08",111,0)
 . S DOC("text",HMPT,"status")=$G(HMPADD(.05,"E"))
"RTN","HMPDJ08",112,0)
 . S DOC("text",HMPT,"uid")=$$SETUID^HMPUTILS("document",DFN,HMPA)
"RTN","HMPDJ08",113,0)
 . S DOC("text",HMPT,"dateTime")=$$JSONDT^HMPUTILS($G(HMPADD(1301,"I")))
"RTN","HMPDJ08",114,0)
 . I $G(HMPADD(1302,"I")) D USER(.I,HMPADD(1302,"I"),HMPADD(1302,"E"),"E")
"RTN","HMPDJ08",115,0)
 . I $G(HMPADD(1202,"I")) D USER(.I,HMPADD(1202,"I"),HMPADD(1202,"E"),"AU")
"RTN","HMPDJ08",116,0)
 . I $G(HMPADD(1501,"I")) D USER(.I,HMPADD(1502,"I"),HMPADD(1502,"E"),"S",HMPADD(1501,"I"))
"RTN","HMPDJ08",117,0)
 . I $G(HMPADD(1507,"I")) D USER(.I,HMPADD(1508,"I"),HMPADD(1508,"E"),"C",HMPADD(1507,"I"))
"RTN","HMPDJ08",118,0)
 . I $G(HMPADD(1204,"I")) D USER(.I,HMPADD(1204,"I"),HMPADD(1204,"E"),"ES")
"RTN","HMPDJ08",119,0)
 . I $G(HMPADD(1208,"I")) D USER(.I,HMPADD(1208,"I"),HMPADD(1208,"E"),"EC")
"RTN","HMPDJ08",120,0)
 . I $G(HMPADD(1209,"I")) D USER(.I,HMPADD(1209,"I"),HMPADD(1209,"E"),"ATT")
"RTN","HMPDJ08",121,0)
 . Q:'$G(HMPTEXT)  K ^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",122,0)
 . D  ; DE3153, replace "not PRINT" with "not VIEW" MARCH 17, 2016 HM
"RTN","HMPDJ08",123,0)
 ..  N V,X,T,R,L S V="HMPTIU",T=" You may not PRINT",R=" You may not VIEW",L=$L(T)
"RTN","HMPDJ08",124,0)
 ..  F  S V=$Q(@V) Q:V=""  S X=@V S:$E(X,1,L)=T @V=R_$E(X,L+1,$L(X))
"RTN","HMPDJ08",125,0)
 . S X=$NA(HMPTIU(IEN,"ZADD",HMPA,"TEXT"))
"RTN","HMPDJ08",126,0)
 . D SETTEXT^HMPUTILS(X,$NA(^TMP($J,"HMP TIU TEXT")))
"RTN","HMPDJ08",127,0)
 . M DOC("text",HMPT,"content","\")=^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",128,0)
ENQ ; end
"RTN","HMPDJ08",129,0)
 K ^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",130,0)
 S DOC("lastUpdateTime")=$$EN^HMPSTMP("document") ;RHL 20150102
"RTN","HMPDJ08",131,0)
 S DOC("stampTime")=DOC("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ08",132,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ08",133,0)
 I '$D(OUTPUT),$G(HMPMETA) D ADD^HMPMETA("document",DOC("uid"),DOC("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ08",134,0)
 I '$D(OUTPUT) D ADD^HMPDJ("DOC","document") Q
"RTN","HMPDJ08",135,0)
 M OUTPUT=DOC
"RTN","HMPDJ08",136,0)
 Q
"RTN","HMPDJ08",137,0)
 ;
"RTN","HMPDJ08",138,0)
USER(N,IEN,NAME,ROLE,DATE,SBN,SBT) ; -- set author, signer(s)
"RTN","HMPDJ08",139,0)
 Q:'$G(IEN)  S N=+$G(N)+1
"RTN","HMPDJ08",140,0)
 S DOC("text",HMPT,"clinicians",N,"uid")=$$SETUID^HMPUTILS("user",,IEN)
"RTN","HMPDJ08",141,0)
 S DOC("text",HMPT,"clinicians",N,"name")=$S($L($G(NAME)):NAME,1:$P($G(^VA(200,IEN,0)),U)) ;ICR 10060 DE2818 ASF 11/10/15
"RTN","HMPDJ08",142,0)
 S DOC("text",HMPT,"clinicians",N,"role")=$G(ROLE)
"RTN","HMPDJ08",143,0)
 Q:'$G(DATE)  ;not co/signed
"RTN","HMPDJ08",144,0)
 S DOC("text",HMPT,"clinicians",N,"signedDateTime")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ08",145,0)
 I '$D(SBN) S SBN=NAME
"RTN","HMPDJ08",146,0)
 S DOC("text",HMPT,"clinicians",N,"signature")=SBN_$S($L($G(SBT)):" "_SBT,1:"")
"RTN","HMPDJ08",147,0)
 ;$$SIG^HMPDTIU(IEN)
"RTN","HMPDJ08",148,0)
 Q
"RTN","HMPDJ08",149,0)
 ;
"RTN","HMPDJ08",150,0)
 ;
"RTN","HMPDJ08",151,0)
 ; ------------ Get/apply search criteria ------------
"RTN","HMPDJ08",152,0)
 ;               [from DOCUMENT^HMPDJ0]
"RTN","HMPDJ08",153,0)
 ;
"RTN","HMPDJ08",154,0)
SETUP ; -- convert FILTER("attribute") = value to TIU criteria
"RTN","HMPDJ08",155,0)
 ; Expects: FILTER("category") = code (see $$CATG)
"RTN","HMPDJ08",156,0)
 ;          FILTER("status")   = 'signed','unsigned','all'
"RTN","HMPDJ08",157,0)
 ; Returns: CLASS,[SUBCLASS,STATUS]
"RTN","HMPDJ08",158,0)
 ;
"RTN","HMPDJ08",159,0)
 K CLASS,SUBCLASS,STATUS
"RTN","HMPDJ08",160,0)
 N TYPE,STS,CP
"RTN","HMPDJ08",161,0)
 S TYPE=$$UP^XLFSTR($G(FILTER("category")))
"RTN","HMPDJ08",162,0)
 S CLASS=0,(SUBCLASS,STATUS)=""
"RTN","HMPDJ08",163,0)
 ;
"RTN","HMPDJ08",164,0)
 ; status [default='signed']
"RTN","HMPDJ08",165,0)
 S STS=$$LOW^XLFSTR($G(FILTER("status")))
"RTN","HMPDJ08",166,0)
 S STATUS=$S(STS?1"unsig".E:2,STS="all":"5^2",1:5)     ;TIUSRVLO statuses
"RTN","HMPDJ08",167,0)
 ;
"RTN","HMPDJ08",168,0)
 ; all documents
"RTN","HMPDJ08",169,0)
 S:TYPE="" TYPE="ALL"
"RTN","HMPDJ08",170,0)
 I TYPE="ALL" S CLASS="3^244^"_+$$CLASS^TIUSROI("SURGICAL REPORTS")_"^CP^LR^RA" Q
"RTN","HMPDJ08",171,0)
 ;
"RTN","HMPDJ08",172,0)
 I TYPE="PN"   S CLASS=3 Q                            ;Progress Notes
"RTN","HMPDJ08",173,0)
 I TYPE="CR"   S CLASS=3,SUBCLASS=$$CLASS^TIUCNSLT Q  ;Consults
"RTN","HMPDJ08",174,0)
 I TYPE="CWAD" S CLASS=3,SUBCLASS="25^27^30^31" Q     ;CWAD
"RTN","HMPDJ08",175,0)
 I TYPE="C"    S CLASS=3,SUBCLASS=30 Q                ;Crisis Note
"RTN","HMPDJ08",176,0)
 I TYPE="W"    S CLASS=3,SUBCLASS=31 Q                ;Clinical Warning
"RTN","HMPDJ08",177,0)
 I TYPE="A"    S CLASS=3,SUBCLASS=25 Q                ;Allergy Note
"RTN","HMPDJ08",178,0)
 I TYPE="D"    S CLASS=3,SUBCLASS=27 Q                ;Advance Directive
"RTN","HMPDJ08",179,0)
 ;
"RTN","HMPDJ08",180,0)
 I TYPE="DS"   S CLASS=244 Q                          ;Discharge Summary
"RTN","HMPDJ08",181,0)
 ;
"RTN","HMPDJ08",182,0)
 I TYPE="SR"   S CLASS=$$CLASS^TIUSROI("SURGICAL REPORTS") Q
"RTN","HMPDJ08",183,0)
 I TYPE="CP" D  Q                                     ;Clin Procedures
"RTN","HMPDJ08",184,0)
 . I STATUS'=2 S CLASS="CP"                           ; if unsigned,
"RTN","HMPDJ08",185,0)
 . E  D CPCLASS^TIUCP(.CP) S CLASS=CP                 ; use TIU class#
"RTN","HMPDJ08",186,0)
 ;
"RTN","HMPDJ08",187,0)
 I TYPE="LR"   S CLASS=$S(STATUS=2:$$LR,1:"LR") Q     ;Lab/Pathology
"RTN","HMPDJ08",188,0)
 ;
"RTN","HMPDJ08",189,0)
 I TYPE="RA"   S CLASS="RA" Q                         ;Radiology
"RTN","HMPDJ08",190,0)
 ;
"RTN","HMPDJ08",191,0)
 Q
"RTN","HMPDJ08",192,0)
 ;
"RTN","HMPDJ08",193,0)
LR() ; -- Return ien of Lab class
"RTN","HMPDJ08",194,0)
 N Y S Y=+$O(^TIU(8925.1,"B","LR LABORATORY REPORTS",0)) ;ICR 2321 DE2818 ASF 11/10/15
"RTN","HMPDJ08",195,0)
 I Y>0,$S($P($G(^TIU(8925.1,Y,0)),U,4)="CL":0,$P($G(^(0)),U,4)="DC":0,1:1) S Y=0
"RTN","HMPDJ08",196,0)
 Q Y
"RTN","HMPDJ08",197,0)
 ;
"RTN","HMPDJ08",198,0)
MATCH(DOC,STS) ; -- Return 1 or 0, if document DA matches search criteria
"RTN","HMPDJ08",199,0)
 N Y,DA,LOCAL,OK S Y=0
"RTN","HMPDJ08",200,0)
 S DA=+$G(DOC) G:DA<1 MQ
"RTN","HMPDJ08",201,0)
 ; include addenda if pulling only unsigned items
"RTN","HMPDJ08",202,0)
 I $P(DOC,U,2)?1"Addendum ".E,STATUS'=2 G MQ
"RTN","HMPDJ08",203,0)
 ; TIU unsigned list can include completed parent notes
"RTN","HMPDJ08",204,0)
 I $G(STS)=2,$P(DOC,U,7)'="unsigned" G MQ
"RTN","HMPDJ08",205,0)
 S LOCAL=$$GET1^DIQ(8925,DA_",",.01,"I") ;local Title 8925.1 ien
"RTN","HMPDJ08",206,0)
 I $L(SUBCLASS) D  G:'OK MQ
"RTN","HMPDJ08",207,0)
 . N I,X S OK=0
"RTN","HMPDJ08",208,0)
 . F I=1:1:$L(SUBCLASS,"^") S X=$P(SUBCLASS,U,I) I $$ISA^TIULX(LOCAL,X) S OK=1 Q
"RTN","HMPDJ08",209,0)
 S Y=1
"RTN","HMPDJ08",210,0)
MQ Q Y
"RTN","HMPDJ08",211,0)
 ;
"RTN","HMPDJ08",212,0)
TYPE(X) ; -- Return name of category type X
"RTN","HMPDJ08",213,0)
 S X=$G(X)
"RTN","HMPDJ08",214,0)
 I X="PN" Q "Progress Note"
"RTN","HMPDJ08",215,0)
 I X="DS" Q "Discharge Summary"
"RTN","HMPDJ08",216,0)
 I X="CP" Q "Clinical Procedure"
"RTN","HMPDJ08",217,0)
 I X="SR" Q "Surgery Report"
"RTN","HMPDJ08",218,0)
 I X="LR" Q "Laboratory Report"
"RTN","HMPDJ08",219,0)
 I X="RA" Q "Radiology Report"
"RTN","HMPDJ08",220,0)
 I X="CR" Q "Consult Report"
"RTN","HMPDJ08",221,0)
 I X="C"  Q "Crisis Note"
"RTN","HMPDJ08",222,0)
 I X="W"  Q "Clinical Warning"
"RTN","HMPDJ08",223,0)
 I X="A"  Q "Allergy/Adverse Reaction"
"RTN","HMPDJ08",224,0)
 I X="D"  Q "Advance Directive"
"RTN","HMPDJ08",225,0)
 Q ""
"RTN","HMPDJ09")
0^67^B140504631
"RTN","HMPDJ09",1,0)
HMPDJ09 ;SLC/MKB,ASMR/RRB,OB,MAT,CPC,HM - PCE;Apr 13, 2016 16:04:25
"RTN","HMPDJ09",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPDJ09",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ09",4,0)
 ;
"RTN","HMPDJ09",5,0)
 ;DE4068 - reworked all PCRMINDX references to include ICD10
"RTN","HMPDJ09",6,0)
 ;
"RTN","HMPDJ09",7,0)
 ; External References          DBIA#
"RTN","HMPDJ09",8,0)
 ; -------------------          -----
"RTN","HMPDJ09",9,0)
 ; ^AUPNVSIT                     2028
"RTN","HMPDJ09",10,0)
 ; ^PXRMINDX                     4290
"RTN","HMPDJ09",11,0)
 ; ^SC                          10040
"RTN","HMPDJ09",12,0)
 ; ^VA(200                      10060
"RTN","HMPDJ09",13,0)
 ; DIC                           2051
"RTN","HMPDJ09",14,0)
 ; DILFD                         2055
"RTN","HMPDJ09",15,0)
 ; DIQ                           2056
"RTN","HMPDJ09",16,0)
 ; PXAPI,^TMP("PXKENC"           1894
"RTN","HMPDJ09",17,0)
 ; VALM1                        10116
"RTN","HMPDJ09",18,0)
 ; XUAF4                         2171
"RTN","HMPDJ09",19,0)
 ;
"RTN","HMPDJ09",20,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ09",21,0)
 Q
"RTN","HMPDJ09",22,0)
 ;
"RTN","HMPDJ09",23,0)
PX(FNUM) ; -- PCE item(s)
"RTN","HMPDJ09",24,0)
 I $G(HMPID) D PXA(HMPID) Q
"RTN","HMPDJ09",25,0)
 N HMPIDT,ID D SORT ;sort ^PXRMINDX into ^TMP("HMPPX",$J,IDT)
"RTN","HMPDJ09",26,0)
 S HMPIDT=0 F  S HMPIDT=$O(^TMP("HMPPX",$J,HMPIDT)) Q:HMPIDT<1  D  Q:HMPI'<HMPMAX
"RTN","HMPDJ09",27,0)
 . S ID=0 F  S ID=$O(^TMP("HMPPX",$J,HMPIDT,ID)) Q:ID<1  D PX1 Q:HMPI'<HMPMAX
"RTN","HMPDJ09",28,0)
 K ^TMP("HMPPX",$J)
"RTN","HMPDJ09",29,0)
 Q
"RTN","HMPDJ09",30,0)
 ;
"RTN","HMPDJ09",31,0)
PXA(ID) ; -- find ID in ^PXRMINDX(FNUM), fall thru to PX1 if successful
"RTN","HMPDJ09",32,0)
 N N,ROOT,IDX,P,ITEM,DATE,HMPIDT,ICDSYS
"RTN","HMPDJ09",33,0)
 S N=+$P(FNUM,".",2) K ^TMP("HMPPX",$J)
"RTN","HMPDJ09",34,0)
 I N=7!(N=18) S ROOT="^PXRMINDX("_FNUM_",""PPI"","_+$G(DFN)
"RTN","HMPDJ09",35,0)
 E  S ROOT="^PXRMINDX("_FNUM_",""PI"","_+$G(DFN)
"RTN","HMPDJ09",36,0)
 S IDX=ROOT_")" F  S IDX=$Q(@IDX) Q:$P(IDX,",",1,3)'=ROOT  D
"RTN","HMPDJ09",37,0)
 . S P=$L(IDX,",") Q:ID'=+$P(IDX,",",P)  ;last subscript
"RTN","HMPDJ09",38,0)
 . S DATE=+$P(IDX,",",P-1),ITEM=+$P(IDX,",",P-2)
"RTN","HMPDJ09",39,0)
 . S HMPIDT=9999999-DATE,^TMP("HMPPX",$J,HMPIDT,ID)=ITEM_U_DATE
"RTN","HMPDJ09",40,0)
 ;DE4068 also check for ICD10
"RTN","HMPDJ09",41,0)
 I N=7 S ROOT="^PXRMINDX("_FNUM_",""10D"",""PPI"","_+$G(DFN) D
"RTN","HMPDJ09",42,0)
 . S IDX=ROOT_")" F  S IDX=$Q(@IDX) Q:$P(IDX,",",1,4)'=ROOT  D
"RTN","HMPDJ09",43,0)
 ..  S P=$L(IDX,",") Q:ID'=+$P(IDX,",",P)  ;last subscript
"RTN","HMPDJ09",44,0)
 ..  S DATE=+$P(IDX,",",P-1),ITEM=+$P(IDX,",",P-2)
"RTN","HMPDJ09",45,0)
 ..  S HMPIDT=9999999-DATE,^TMP("HMPPX",$J,HMPIDT,ID)=ITEM_U_DATE
"RTN","HMPDJ09",46,0)
 Q:'$D(^TMP("HMPPX",$J))  ;not found
"RTN","HMPDJ09",47,0)
PX1 ; -- PCE ^TMP("HMPPX",$J,HMPIDT,ID)=ITM^DATE for FNUM
"RTN","HMPDJ09",48,0)
 N N,COLL,FAC,FLD,HMPF,I,LOC,LOTIEN,PCE,TAG,TMP,VISIT,X,X0,X12,Y
"RTN","HMPDJ09",49,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ09",50,0)
 N ERR,FLDS,FLG,VISITIEN
"RTN","HMPDJ09",51,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ09",52,0)
 S N=+$P(FNUM,".",2),TAG=$S(N=7:"VPOV",N=11:"VIMM",N=12:"VSKIN",N=13:"VXAM",N=16:"VPEDU",N=18:"VCPT",1:"VHF")
"RTN","HMPDJ09",53,0)
 S ERRMSG="A problem occurred converting record "_ID_" for "_TAG
"RTN","HMPDJ09",54,0)
 D @(TAG_"^PXPXRM(ID,.HMPF)")
"RTN","HMPDJ09",55,0)
 ;
"RTN","HMPDJ09",56,0)
 S PCE("localId")=ID,TMP=$G(^TMP("HMPPX",$J,HMPIDT,ID))
"RTN","HMPDJ09",57,0)
 S COLL=$S(N=7:"pov",N=11:"immunization",N=12:"skin",N=13:"exam",N=16:"education",N=18:"cpt",1:"factor")
"RTN","HMPDJ09",58,0)
 S PCE("uid")=$$SETUID^HMPUTILS(COLL,DFN,ID)
"RTN","HMPDJ09",59,0)
 ; TAG=$S(N=23:"recorded",N=11:"administeredDateTime",1:"dateTimeEntered")
"RTN","HMPDJ09",60,0)
 S TAG=$S(N=11:"administeredDateTime",1:"entered")
"RTN","HMPDJ09",61,0)
 S PCE(TAG)=$$JSONDT^HMPUTILS($P(TMP,U,2)) I $L(PCE(TAG))<14 S PCE(TAG)=$E(PCE(TAG)_"000000",1,14)
"RTN","HMPDJ09",62,0)
 I N=7!(N=18) I $G(FILTER("freshnessDateTime")) S PCE(TAG)=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime")) ;DE4068
"RTN","HMPDJ09",63,0)
 S PCE("name")=$$EXTERNAL^DILFD(FNUM,.01,,+TMP)
"RTN","HMPDJ09",64,0)
 S VISIT=+$G(HMPF("VISIT")),PCE("encounterUid")=$$SETUID^HMPUTILS("visit",DFN,VISIT)
"RTN","HMPDJ09",65,0)
 S PCE("encounterName")=$$NAME^HMPDJ04(VISIT)
"RTN","HMPDJ09",66,0)
 ;DE2818, ^AUPNVSIT - ICR 2028
"RTN","HMPDJ09",67,0)
 ; get VISIT information 0th node
"RTN","HMPDJ09",68,0)
 ; 9000010 - Visit 
"RTN","HMPDJ09",69,0)
 S VISITIEN=VISIT_",",FLG="I",FLDS=".06;.22;"
"RTN","HMPDJ09",70,0)
 D GETS^DIQ(9000010,VISITIEN,FLDS,FLG,"X0","ERR")
"RTN","HMPDJ09",71,0)
 S FAC=$G(X0(9000010,VISITIEN,.06,"I")),LOC=$G(X0(9000010,VISITIEN,.22,"I"))
"RTN","HMPDJ09",72,0)
 ;
"RTN","HMPDJ09",73,0)
 S:FAC X=$$STA^XUAF4(FAC)_U_$P($$NS^XUAF4(FAC),U)
"RTN","HMPDJ09",74,0)
 S:'FAC X=$$FAC^HMPD(LOC)
"RTN","HMPDJ09",75,0)
 D FACILITY^HMPUTILS(X,"PCE")
"RTN","HMPDJ09",76,0)
 ;DE2818 ^SC global reference changed to FileMan
"RTN","HMPDJ09",77,0)
 S:LOC PCE("locationUid")=$$SETUID^HMPUTILS("location",,LOC),PCE("locationName")=$$GET1^DIQ(44,LOC_",",.01)
"RTN","HMPDJ09",78,0)
 S:$L($G(HMPF("COMMENTS"))) PCE("comment")=HMPF("COMMENTS")
"RTN","HMPDJ09",79,0)
POV I FNUM=9000010.07 D  G PXQ
"RTN","HMPDJ09",80,0)
 . S X=$G(HMPF("PRIMARY/SECONDARY")),PCE("type")=$S($L(X):X,1:"U")
"RTN","HMPDJ09",81,0)
 . S X=PCE("name"),PCE("icdCode")=$$SETNCS^HMPUTILS("icd",X)
"RTN","HMPDJ09",82,0)
 . S X=$G(HMPF("PROVIDER NARRATIVE")),PCE("name")=$$EXTERNAL^DILFD(9000010.07,.04,,X)
"RTN","HMPDJ09",83,0)
CPT I FNUM=9000010.18 D  G PXQ
"RTN","HMPDJ09",84,0)
 . S X=$G(HMPF("PRINCIPAL PROCEDURE")),PCE("type")=$S($L(X):X,1:"U")
"RTN","HMPDJ09",85,0)
 . S X=PCE("name"),PCE("cptCode")=$$SETNCS^HMPUTILS("cpt",X)
"RTN","HMPDJ09",86,0)
 . S X=$G(HMPF("PROVIDER NARRATIVE")),PCE("name")=$$EXTERNAL^DILFD(9000010.18,.04,,X)
"RTN","HMPDJ09",87,0)
 . S PCE("quantity")=HMPF("QUANTITY")
"RTN","HMPDJ09",88,0)
 S X=$G(HMPF("VALUE")),FLD=$S(FNUM=9000010.16:.06,1:.04)
"RTN","HMPDJ09",89,0)
 S Y=$$EXTERNAL^DILFD(FNUM,FLD,,X)
"RTN","HMPDJ09",90,0)
IM I FNUM=9000010.11 D  G PXQ ;immunization
"RTN","HMPDJ09",91,0)
 . D VIMM(ID,.HMPF,VISIT)
"RTN","HMPDJ09",92,0)
 . D:$L($G(HMPF("IMMCODE"))) VIMIMM(HMPF("IMMCODE"),.HMPF)
"RTN","HMPDJ09",93,0)
 . I $L($G(HMPF("LOTNUMBER"))) D
"RTN","HMPDJ09",94,0)
 .. S LOTIEN=$$FIND1^DIC(9999999.41,,"MX",HMPF("LOTNUMBER"),"B",,"ERR")
"RTN","HMPDJ09",95,0)
 .. D VIML(LOTIEN,.HMPF)
"RTN","HMPDJ09",96,0)
 .. S PCE("lotNumber")=HMPF("LOTNUMBER")
"RTN","HMPDJ09",97,0)
 .. S PCE("manufacturer")=HMPF("MANUFACTURER")
"RTN","HMPDJ09",98,0)
 .. S PCE("expirationDate")=$E($$JSONDT^HMPUTILS(HMPF("EXPDATE"))_"000000",1,14)
"RTN","HMPDJ09",99,0)
 . S:$L($G(HMPF("INFOSRC"))) PCE("eventInformationSource")=HMPF("INFOSRC")
"RTN","HMPDJ09",100,0)
 . S:$L($G(HMPF("ENCLOC"))) PCE("encounterLocation")=HMPF("ENCLOC")
"RTN","HMPDJ09",101,0)
 . S:$L($G(HMPF("ORDPRV"))) PCE("orderingProvider")=HMPF("ORDPRV")
"RTN","HMPDJ09",102,0)
 . S:$L($G(HMPF("CVXCODE"))) PCE("cvxCode")=HMPF("CVXCODE")
"RTN","HMPDJ09",103,0)
 . S:$L($G(HMPF("ROUTE"))) PCE("routeOfAdministration")=HMPF("ROUTE")
"RTN","HMPDJ09",104,0)
 . S:$L($G(HMPF("ADMNSITE"))) PCE("siteOfAdministration")=HMPF("ADMNSITE")
"RTN","HMPDJ09",105,0)
 . I $L($G(HMPF("EVNTDAT"))) D
"RTN","HMPDJ09",106,0)
 .. S PCE("eventDate")=$E($$JSONDT^HMPUTILS(HMPF("EVNTDAT"))_"000000",1,14)
"RTN","HMPDJ09",107,0)
 . S:$L($G(HMPF("DOSE"))) PCE("dosage")=HMPF("DOSE")
"RTN","HMPDJ09",108,0)
 . S:$L($G(HMPF("DOSEUNITS"))) PCE("dosageUnits")=HMPF("DOSEUNITS")
"RTN","HMPDJ09",109,0)
 . S:$L($G(HMPF("VISDAT"))) PCE("visData")=HMPF("VISDAT")
"RTN","HMPDJ09",110,0)
 . S:$L($G(HMPF("REMARKS"))) PCE("remarks")=HMPF("REMARKS")
"RTN","HMPDJ09",111,0)
 . S:$L(Y) PCE("seriesName")=Y,PCE("seriesCode")=$$SETUID^HMPUTILS("series",DFN,Y)
"RTN","HMPDJ09",112,0)
 . I $L($G(HMPF("REACTION"))) D
"RTN","HMPDJ09",113,0)
 .. S PCE("reactionName")=$$EXTERNAL^DILFD(9000010.11,.06,,HMPF("REACTION"))
"RTN","HMPDJ09",114,0)
 .. S PCE("reactionCode")=$$SETUID^HMPUTILS("reaction",DFN,HMPF("REACTION"))
"RTN","HMPDJ09",115,0)
 . S PCE("contraindicated")=$S(+$G(HMPF("CONTRAINDICATED")):"true",1:"false")
"RTN","HMPDJ09",116,0)
 . I '$D(^TMP("PXKENC",$J,VISIT)) D ENCEVENT^PXAPI(VISIT,1)
"RTN","HMPDJ09",117,0)
 . S X12=$G(^TMP("PXKENC",$J,VISIT,"IMM",ID,12))
"RTN","HMPDJ09",118,0)
 . S X=$P(X12,U,4) S:'X X=$P(X12,U,2)
"RTN","HMPDJ09",119,0)
 . I 'X S I=0 F  S I=$O(^TMP("PXKENC",$J,VISIT,"PRV",I)) Q:I<1  I $P($G(^TMP("PXKENC",$J,VISIT,"PRV",I,0)),U,4)="P" S X=+^TMP("PXKENC",$J,VISIT,"PRV",I,0) Q
"RTN","HMPDJ09",120,0)
 . ;DE2818, ^VA(200 reference changed to FileMan
"RTN","HMPDJ09",121,0)
 . S:X PCE("performerUid")=$$SETUID^HMPUTILS("user",,+X),PCE("performerName")=$$GET1^DIQ(200,X_",",.01)
"RTN","HMPDJ09",122,0)
 . ; CPT mapping
"RTN","HMPDJ09",123,0)
 . S X=+$$FIND1^DIC(811.1,,"QX",+TMP_";AUTTIMM(","B") I X>0 D
"RTN","HMPDJ09",124,0)
 .. S Y=$$GET1^DIQ(811.1,X_",",.02,"I") Q:Y<1
"RTN","HMPDJ09",125,0)
 .. N CPT S CPT=$G(@(U_$P(Y,";",2)_+Y_",0)"))
"RTN","HMPDJ09",126,0)
 .. S PCE("cptCode")=$$SETNCS^HMPUTILS("cpt",+CPT)
"RTN","HMPDJ09",127,0)
 .. S (PCE("summary"),PCE("cptName"))=$P(CPT,U,2)
"RTN","HMPDJ09",128,0)
 . ; US14129 - Add cdc full vaccine name to return
"RTN","HMPDJ09",129,0)
 . M:$D(HMPF("CDCNAME")) PCE("cdcFullVaccineName","\")=HMPF("CDCNAME")
"RTN","HMPDJ09",130,0)
 . N I S I="" F  S I=$O(HMPF("VIS",I)) Q:'I  D
"RTN","HMPDJ09",131,0)
 . . S PCE("vis",I,"visName")=$G(HMPF("VIS",I,"VISNAME"))
"RTN","HMPDJ09",132,0)
 . . S PCE("vis",I,"editionDate")=$G(HMPF("VIS",I,"EDITIONDATE"))
"RTN","HMPDJ09",133,0)
 . . S PCE("vis",I,"language")=$G(HMPF("VIS",I,"LANGUAGE"))
"RTN","HMPDJ09",134,0)
 . . S PCE("vis",I,"offeredDate")=$G(HMPF("VIS",I,"OFFEREDDATE"))
"RTN","HMPDJ09",135,0)
HF I FNUM=9000010.23 D  G PXQ ;health factor
"RTN","HMPDJ09",136,0)
 . S:$L(X) PCE("severityUid")=$$SETVURN^HMPUTILS("factor-severity",X),PCE("severityName")=$$LOWER^VALM1(Y)
"RTN","HMPDJ09",137,0)
 . S X=$$GET1^DIQ(9999999.64,+TMP_",",.03,"I") I X D
"RTN","HMPDJ09",138,0)
 .. S PCE("categoryUid")=$$SETVURN^HMPUTILS("factor-category",X)
"RTN","HMPDJ09",139,0)
 .. S PCE("categoryName")=$$EXTERNAL^DILFD(9999999.64,.03,"",X)
"RTN","HMPDJ09",140,0)
 . S X=$$GET1^DIQ(9999999.64,+TMP_",",.08)
"RTN","HMPDJ09",141,0)
 . I $E(X)="Y" S PCE("display")="true"
"RTN","HMPDJ09",142,0)
 . S PCE("kind")="Health Factor",PCE("summary")=PCE("name")
"RTN","HMPDJ09",143,0)
SK I FNUM=9000010.12 D  ;skin test [fall thru to set result]
"RTN","HMPDJ09",144,0)
 . S:$L($G(HMPF("READING"))) PCE("reading")=HMPF("READING")
"RTN","HMPDJ09",145,0)
 . S:$G(HMPF("DATE READ")) PCE("dateRead")=$$JSONDT^HMPUTILS(HMPF("DATE READ"))
"RTN","HMPDJ09",146,0)
 S:$L(Y) PCE("result")=Y
"RTN","HMPDJ09",147,0)
PXQ ;finish
"RTN","HMPDJ09",148,0)
 S PCE("lastUpdateTime")=$$EN^HMPSTMP(COLL) ; RHL 20150115
"RTN","HMPDJ09",149,0)
 S PCE("stampTime")=PCE("lastUpdateTime")   ; RHL 20150115
"RTN","HMPDJ09",150,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ09",151,0)
 I $G(HMPMETA) D ADD^HMPMETA(COLL,PCE("uid"),PCE("stampTime")) Q:HMPMETA=1  ;US11019/US6734
"RTN","HMPDJ09",152,0)
 D ADD^HMPDJ("PCE",COLL)
"RTN","HMPDJ09",153,0)
 Q
"RTN","HMPDJ09",154,0)
 ;
"RTN","HMPDJ09",155,0)
SORT ; -- build ^TMP("HMPPX",$J,9999999-DATE,DA)=ITEM^DATE in range
"RTN","HMPDJ09",156,0)
 N TYPE,ITEM,DATE,DA,IDT K ^TMP("HMPPX",$J)
"RTN","HMPDJ09",157,0)
 I FNUM=9000010.07!(FNUM=9000010.18) G PPI
"RTN","HMPDJ09",158,0)
PI ; from ^PXRMINDX(FNUM,"PI",DFN,ITEM,DATE,DA)
"RTN","HMPDJ09",159,0)
 ;DE2818, ^PXRMINDX - ICR 4290
"RTN","HMPDJ09",160,0)
 S ITEM=0 F  S ITEM=$O(^PXRMINDX(FNUM,"PI",+$G(DFN),ITEM)) Q:ITEM<1  D
"RTN","HMPDJ09",161,0)
 . S DATE=0 F  S DATE=$O(^PXRMINDX(FNUM,"PI",+$G(DFN),ITEM,DATE)) Q:DATE<1  D
"RTN","HMPDJ09",162,0)
 .. Q:DATE<HMPSTART  Q:DATE>HMPSTOP  S IDT=9999999-DATE
"RTN","HMPDJ09",163,0)
 .. S DA=0 F  S DA=$O(^PXRMINDX(FNUM,"PI",+$G(DFN),ITEM,DATE,DA)) Q:DA<1  S ^TMP("HMPPX",$J,IDT,DA)=ITEM_U_DATE
"RTN","HMPDJ09",164,0)
 Q
"RTN","HMPDJ09",165,0)
PPI ; from ^PXRMINDX(FNUM,"PPI",DFN,TYPE,ITEM,DATE,DA)
"RTN","HMPDJ09",166,0)
 S TYPE="" F  S TYPE=$O(^PXRMINDX(FNUM,"PPI",+$G(DFN),TYPE)) Q:TYPE=""  D
"RTN","HMPDJ09",167,0)
 . S ITEM=0 F  S ITEM=$O(^PXRMINDX(FNUM,"PPI",+$G(DFN),TYPE,ITEM)) Q:ITEM<1  D
"RTN","HMPDJ09",168,0)
 .. S DATE=0 F  S DATE=$O(^PXRMINDX(FNUM,"PPI",+$G(DFN),TYPE,ITEM,DATE)) Q:DATE<1  D
"RTN","HMPDJ09",169,0)
 ... Q:DATE<HMPSTART  Q:DATE>HMPSTOP  S IDT=9999999-DATE
"RTN","HMPDJ09",170,0)
 ... S DA=0 F  S DA=$O(^PXRMINDX(FNUM,"PPI",+$G(DFN),TYPE,ITEM,DATE,DA)) Q:DA<1  S ^TMP("HMPPX",$J,IDT,DA)=ITEM_U_DATE
"RTN","HMPDJ09",171,0)
 Q:FNUM=9000010.18  ;
"RTN","HMPDJ09",172,0)
 ;for POV also check ICD10 CODES
"RTN","HMPDJ09",173,0)
 S TYPE="" F  S TYPE=$O(^PXRMINDX(FNUM,"10D","PPI",+$G(DFN),TYPE)) Q:TYPE=""  D
"RTN","HMPDJ09",174,0)
 . S ITEM="" F  S ITEM=$O(^PXRMINDX(FNUM,"10D","PPI",+$G(DFN),TYPE,ITEM)) Q:ITEM=""  D
"RTN","HMPDJ09",175,0)
 .. S DATE=0 F  S DATE=$O(^PXRMINDX(FNUM,"10D","PPI",+$G(DFN),TYPE,ITEM,DATE)) Q:DATE<1  D
"RTN","HMPDJ09",176,0)
 ... Q:DATE<HMPSTART  Q:DATE>HMPSTOP  S IDT=9999999-DATE
"RTN","HMPDJ09",177,0)
 ... S DA=0 F  S DA=$O(^PXRMINDX(FNUM,"10D","PPI",+$G(DFN),TYPE,ITEM,DATE,DA)) Q:DA<1  S ^TMP("HMPPX",$J,IDT,DA)=ITEM_U_DATE
"RTN","HMPDJ09",178,0)
 Q
"RTN","HMPDJ09",179,0)
PTF ; from ^PXRMINDX(45,"ICD9","PNI",DFN,TYPE,ITEM,DATE,DA)
"RTN","HMPDJ09",180,0)
 ;Purpose - Build ^TMP("HMPPX") from ^PXRMINDX(45,HMPISYS,"PNI",DFN)
"RTN","HMPDJ09",181,0)
 ;
"RTN","HMPDJ09",182,0)
 ;Called by - PTF^HMPDJ0 (if HMPID is not set)
"RTN","HMPDJ09",183,0)
 ;
"RTN","HMPDJ09",184,0)
 ;Assumptions -
"RTN","HMPDJ09",185,0)
 ;1. DFN, HMPSTART and HMPSTOP variables have been set in prior code
"RTN","HMPDJ09",186,0)
 ;2. ^TMP("HMPPX") does not exist and needs to be built
"RTN","HMPDJ09",187,0)
 ;3. '$G(HMPID)
"RTN","HMPDJ09",188,0)
 ;
"RTN","HMPDJ09",189,0)
 ;Modification History -
"RTN","HMPDJ09",190,0)
 ;US5630 (TW) - HMPISYS can be either "ICD" or "10D" (ICD-10)
"RTN","HMPDJ09",191,0)
 ;
"RTN","HMPDJ09",192,0)
 N HMPISYS,HMPTYP,HMPDX,HMPDT,HMPITEM,HMPRDT
"RTN","HMPDJ09",193,0)
 S HMPISYS="" F  S HMPISYS=$O(^PXRMINDX(45,HMPISYS)) Q:HMPISYS=""  D 
"RTN","HMPDJ09",194,0)
 . Q:'$D(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN)))
"RTN","HMPDJ09",195,0)
 . S HMPTYP="" F  S HMPTYP=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP)) Q:HMPTYP=""  D
"RTN","HMPDJ09",196,0)
 .. S HMPDX=0 F  S HMPDX=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX)) Q:HMPDX=""  D
"RTN","HMPDJ09",197,0)
 ... S HMPDT=0 F  S HMPDT=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX,HMPDT)) Q:HMPDT<1  D
"RTN","HMPDJ09",198,0)
 .... Q:HMPDT<HMPSTART  Q:HMPDT>HMPSTOP  S HMPRDT=9999999-HMPDT
"RTN","HMPDJ09",199,0)
 .... S HMPITEM="" F  S HMPITEM=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX,HMPDT,HMPITEM)) Q:HMPITEM=""  S ^TMP("HMPPX",$J,HMPRDT,HMPITEM_";"_HMPTYP)=HMPDX_U_HMPDT_U_HMPISYS
"RTN","HMPDJ09",200,0)
 Q
"RTN","HMPDJ09",201,0)
VIML(LOT,IMDATA) ;VIMM2.0 Return IMMUNIZATION LOT data (Lot #, Expiration Date, and Mfr. can also be in COMMENTS)
"RTN","HMPDJ09",202,0)
 N ARR,DATA,ERR,FILE,FLDS,FLGS,IEN
"RTN","HMPDJ09",203,0)
 S FILE=9999999.41 ;IMMUNIZATION LOT
"RTN","HMPDJ09",204,0)
 S IEN=LOT_",",FLDS=".02;.09",FLGS="IE",ARR="DATA",ERR="ERR"
"RTN","HMPDJ09",205,0)
 D GETS^DIQ(FILE,IEN,FLDS,FLGS,ARR,ERR)
"RTN","HMPDJ09",206,0)
 ;
"RTN","HMPDJ09",207,0)
 ; --- Expiration Date & Manufacturer
"RTN","HMPDJ09",208,0)
 S IMDATA("EXPDATE")=$G(DATA(FILE,IEN,.09,"I"))
"RTN","HMPDJ09",209,0)
 S IMDATA("MANUFACTURER")=$G(DATA(FILE,IEN,.02,"E"))
"RTN","HMPDJ09",210,0)
 Q
"RTN","HMPDJ09",211,0)
VIMM(DA,IMDATA,VISIT) ;VIMM2.0 Return data for a specified V IMMUNIZATION entry.
"RTN","HMPDJ09",212,0)
 N ADMIN1,ARR,DATA,ERR,FLDS,FLGS,IEN,INFO1,ROUTE1,TEMP,TMPGBL,VIS,VISIEN
"RTN","HMPDJ09",213,0)
 ; 9000010.11 - V IMMUNIZATION
"RTN","HMPDJ09",214,0)
 S IEN=DA_",",FLDS=".01;.02;.03;.04;.05;.06;.07;.08;.09;.12;1101;1201;1202;1203;1204;1205;1206;1207;1301;1302;1303;1312;1313;80101;80102;81101;81201;81202;81203;2*"
"RTN","HMPDJ09",215,0)
 S FLGS="IE",ARR="DATA",ERR="ERR"
"RTN","HMPDJ09",216,0)
 D GETS^DIQ(9000010.11,IEN,FLDS,FLGS,ARR,ERR)
"RTN","HMPDJ09",217,0)
 ;
"RTN","HMPDJ09",218,0)
 ; Immunization Code
"RTN","HMPDJ09",219,0)
 ;US14129 - This line was causing VIMIMM to be sent the vaccine *name* not IEN. Had to fix it for the story.
"RTN","HMPDJ09",220,0)
 S IMDATA("IMMCODE")=$G(DATA(9000010.11,IEN,.01,"I"))
"RTN","HMPDJ09",221,0)
 ;
"RTN","HMPDJ09",222,0)
 ; Dosage & Units
"RTN","HMPDJ09",223,0)
 S IMDATA("DOSE")=$G(DATA(9000010.11,IEN,1312,"E"))
"RTN","HMPDJ09",224,0)
 S IMDATA("DOSEUNITS")=$G(DATA(9000010.11,IEN,1313,"E"))
"RTN","HMPDJ09",225,0)
 ;
"RTN","HMPDJ09",226,0)
 ; Lot Number
"RTN","HMPDJ09",227,0)
 S IMDATA("LOTNUMBER")=$G(DATA(9000010.11,IEN,1207,"E"))
"RTN","HMPDJ09",228,0)
 ;
"RTN","HMPDJ09",229,0)
 ; Ordering Provider
"RTN","HMPDJ09",230,0)
 S IMDATA("ORDPRV")=$G(DATA(9000010.11,IEN,1202,"E"))
"RTN","HMPDJ09",231,0)
 ;
"RTN","HMPDJ09",232,0)
 ; Admin / Encounter Provuder
"RTN","HMPDJ09",233,0)
 S IMDATA("ADMNPRV")=$G(DATA(9000010.11,IEN,1204,"E"))
"RTN","HMPDJ09",234,0)
 ;
"RTN","HMPDJ09",235,0)
 ; Event Date and Time
"RTN","HMPDJ09",236,0)
 S IMDATA("EVNTDAT")=$G(DATA(9000010.11,IEN,1201,"I"))
"RTN","HMPDJ09",237,0)
 ;
"RTN","HMPDJ09",238,0)
 ; Remarks
"RTN","HMPDJ09",239,0)
 ; DE3454 - added logic for word processing field data - HM 
"RTN","HMPDJ09",240,0)
 N CT,X,WP,COUNT
"RTN","HMPDJ09",241,0)
 S X=$$GET1^DIQ(9000010.11,IEN,1101,"","WP"),COUNT=0
"RTN","HMPDJ09",242,0)
 I $D(WP(1)) S CT="" D
"RTN","HMPDJ09",243,0)
 . F  S CT=$O(WP(CT)) Q:CT=""  S COUNT=COUNT+1
"RTN","HMPDJ09",244,0)
 I COUNT>0 S IMDATA("REMARKS")="",CT="" D
"RTN","HMPDJ09",245,0)
 . F  S CT=$O(WP(CT)) Q:CT=""  D
"RTN","HMPDJ09",246,0)
 . . S IMDATA("REMARKS")=$S(CT'=COUNT:IMDATA("REMARKS")_WP(CT)_" "_$C(13)_$C(10),CT=COUNT:IMDATA("REMARKS")_WP(CT),1:0)
"RTN","HMPDJ09",247,0)
 ;
"RTN","HMPDJ09",248,0)
 ; Comments
"RTN","HMPDJ09",249,0)
 S IMDATA("COMMENTS")=$G(DATA(9000010.11,IEN,81101,"E"))
"RTN","HMPDJ09",250,0)
 ;
"RTN","HMPDJ09",251,0)
 ; Information Source
"RTN","HMPDJ09",252,0)
 S IMDATA("INFOSRC")=$G(DATA(9000010.11,IEN,1301,"E"))
"RTN","HMPDJ09",253,0)
 ;
"RTN","HMPDJ09",254,0)
 ; Route
"RTN","HMPDJ09",255,0)
 S IMDATA("ROUTE")=$G(DATA(9000010.11,IEN,1302,"E"))
"RTN","HMPDJ09",256,0)
 ;
"RTN","HMPDJ09",257,0)
 ; Administration Site
"RTN","HMPDJ09",258,0)
 S IMDATA("ADMNSITE")=$G(DATA(9000010.11,IEN,1303,"E"))
"RTN","HMPDJ09",259,0)
 ;
"RTN","HMPDJ09",260,0)
 ; Vaccine Information Statement (VIS)
"RTN","HMPDJ09",261,0)
 S IMDATA("VISDAT")=$$VIMVIS(.DATA)
"RTN","HMPDJ09",262,0)
 ;US14129 - Add More VIS data to extract
"RTN","HMPDJ09",263,0)
 D VIMVISNW(.DATA,.IMDATA)
"RTN","HMPDJ09",264,0)
 Q
"RTN","HMPDJ09",265,0)
VIMIMM(IMMCODE,IMDATA) ;VIMM2.0 Return data for an IMMUNIZATION entry.
"RTN","HMPDJ09",266,0)
 N ARR,DATA,ERR,FLDS,FLGS,IEN
"RTN","HMPDJ09",267,0)
 ; 9999999.14 - Immunization
"RTN","HMPDJ09",268,0)
 S IEN=IMMCODE_",",FLDS=".03;2",FLGS="IE",ARR="DATA",ERR="ERR"
"RTN","HMPDJ09",269,0)
 D GETS^DIQ(9999999.14,IEN,FLDS,FLGS,ARR,ERR)
"RTN","HMPDJ09",270,0)
 ;
"RTN","HMPDJ09",271,0)
 ; CVX code
"RTN","HMPDJ09",272,0)
 S IMDATA("CVXCODE")=$G(DATA(9999999.14,IEN,.03,"E"))
"RTN","HMPDJ09",273,0)
 ; US14129 - Add cdc full vaccine name to return
"RTN","HMPDJ09",274,0)
 ; Use our existing API to format the Word Processing data for JSON
"RTN","HMPDJ09",275,0)
 D SETTEXT^HMPUTILS($NA(DATA(9999999.14,IEN,2)),$NA(IMDATA("CDCNAME")))
"RTN","HMPDJ09",276,0)
 Q
"RTN","HMPDJ09",277,0)
VIMVIS(DATA) ;VIMM2.0 Return an IMMUNIZATION's VACCINE INFORMATION STATEMENT(s).
"RTN","HMPDJ09",278,0)
 N DT,SC,SL,VDX,VIS,VISALL,VISIEN
"RTN","HMPDJ09",279,0)
 S (DT,VIS,VISALL,VDX)="",SL="/",SC=";"
"RTN","HMPDJ09",280,0)
 S VISIEN="" F  S VISIEN=$O(DATA(9000010.112,VISIEN)) Q:VISIEN=""  D
"RTN","HMPDJ09",281,0)
 . S VIS=$G(DATA(9000010.112,VISIEN,".01","E"))
"RTN","HMPDJ09",282,0)
 . I $D(DATA(9000010.112,VISIEN,".02","I")) D
"RTN","HMPDJ09",283,0)
 . . S DT=$G(DATA(9000010.112,VISIEN,".02","I")),DT=$E($$JSONDT^HMPUTILS(DT)_"000000",1,14)
"RTN","HMPDJ09",284,0)
 . I $G(DT),$G(VIS)'="" S VISALL(VIS_SL_DT_SC)=""
"RTN","HMPDJ09",285,0)
 S (VDX,VIS)="" F  S VDX=$O(VISALL(VDX)) Q:VDX=""  S VIS=VIS_" "_$C(13)_$C(10)_VDX ; DE3454 - added logic for word processing field data - HM 
"RTN","HMPDJ09",286,0)
 Q VIS
"RTN","HMPDJ09",287,0)
 ;
"RTN","HMPDJ09",288,0)
VIMVISNW(DATA,IMDATA) ;US14129 - Add VIS data to extract
"RTN","HMPDJ09",289,0)
 N PTVISIEN,VISIEN,IEN,LANGIEN
"RTN","HMPDJ09",290,0)
 S PTVISIEN="" F I=1:1 S PTVISIEN=$O(DATA(9000010.112,PTVISIEN)) Q:PTVISIEN=""  D
"RTN","HMPDJ09",291,0)
 . S VISIEN=$G(DATA(9000010.112,PTVISIEN,".01","I"))_"," Q:'VISIEN
"RTN","HMPDJ09",292,0)
 . I $D(DATA(9000010.112,PTVISIEN,".01","E")) S IMDATA("VIS",I,"VISNAME")=$G(DATA(9000010.112,PTVISIEN,".01","E"))
"RTN","HMPDJ09",293,0)
 . S:$G(DATA(9000010.112,PTVISIEN,".02","I")) IMDATA("VIS",I,"OFFEREDDATE")=$$JSONDT^HMPUTILS(DATA(9000010.112,PTVISIEN,".02","I"))
"RTN","HMPDJ09",294,0)
 . D GETS^DIQ(920,VISIEN,".01;.02;.04","IE","DATA","ERR")
"RTN","HMPDJ09",295,0)
 . S:$G(DATA(920,VISIEN,".02","I")) IMDATA("VIS",I,"EDITIONDATE")=$$JSONDT^HMPUTILS(DATA(920,VISIEN,".02","I"))
"RTN","HMPDJ09",296,0)
 . ;Need to pull NAME (#1), not CODE (#.01), field from language file.
"RTN","HMPDJ09",297,0)
 . S LANGIEN=$G(DATA(920,VISIEN,".04","I")) S:LANGIEN IMDATA("VIS",I,"LANGUAGE")=$$GET1^DIQ(.85,LANGIEN_",",1)
"RTN","HMPDJ09",298,0)
 Q
"RTN","HMPDJ1")
0^66^B18436618
"RTN","HMPDJ1",1,0)
HMPDJ1 ;SLC/MKB,ASMR/RRB,CK - HMP Patient Object RPCs;May 15, 2016 14:15
"RTN","HMPDJ1",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPDJ1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ1",4,0)
 ;
"RTN","HMPDJ1",5,0)
 Q
"RTN","HMPDJ1",6,0)
 ;
"RTN","HMPDJ1",7,0)
PUT(HMP,PAT,TYPE,JSON) ; -- Save/update JSON OBJECT in ^HMP(800000.1), return UID if successful
"RTN","HMPDJ1",8,0)
 ; RPC = HMP PUT PATIENT DATA
"RTN","HMPDJ1",9,0)
 ;
"RTN","HMPDJ1",10,0)
 N ARRAY,CNT,ERR,HMPERR,UID,DA,X,I,DFN,HMPSYS
"RTN","HMPDJ1",11,0)
 ;M JSON=INPUT(0)
"RTN","HMPDJ1",12,0)
 D DECODE^HMPJSON("JSON","ARRAY","HMPERR")
"RTN","HMPDJ1",13,0)
 ;N XCNT S XCNT=$O(^XTMP("AGPARRAY",""),-1),XCNT=XCNT+1
"RTN","HMPDJ1",14,0)
 ;M ^XTMP("AGPARRAY",XCNT,"DATA")=ARRAY
"RTN","HMPDJ1",15,0)
 ;S ^XTMP("AGPARRAY",XCNT,"TYPE")=TYPE
"RTN","HMPDJ1",16,0)
 ;M ^XTMP("AGPARRAY")=ARRAY
"RTN","HMPDJ1",17,0)
 I $D(HMPERR) D  Q  ;S X=$G(ERR(1)) K ERR S ERR=X G PTQ
"RTN","HMPDJ1",18,0)
 . K ARRAY N HMPTMP,HMPTXT
"RTN","HMPDJ1",19,0)
 . S HMPTXT(1)="Problem decoding json input."
"RTN","HMPDJ1",20,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.JSON)
"RTN","HMPDJ1",21,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","ARRAY","HMPERR")
"RTN","HMPDJ1",22,0)
 . S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPDJ1",23,0)
 . M HMP(1)=ARRAY
"RTN","HMPDJ1",24,0)
 . S HMP(2)="}}"
"RTN","HMPDJ1",25,0)
 ;
"RTN","HMPDJ1",26,0)
 S UID=$G(ARRAY("uid")),HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJ1",27,0)
 I $L(UID) S DA=+$O(^HMP(800000.1,"B",UID,0)) I DA<1 S ERR=$$ERR(3,UID) G PTQ
"RTN","HMPDJ1",28,0)
 I '$L(UID) D  G:$D(ERR) PTQ Q:$D(HMPERR)
"RTN","HMPDJ1",29,0)
 . D NEW Q:$D(ERR)
"RTN","HMPDJ1",30,0)
 . S ARRAY("uid")=UID K JSON
"RTN","HMPDJ1",31,0)
 . D ENCODE^HMPJSON("ARRAY","JSON","HMPERR")
"RTN","HMPDJ1",32,0)
 . I $D(HMPERR) D  Q  ;S X=$G(ERR(1)) K ERR S ERR=X Q
"RTN","HMPDJ1",33,0)
 .. K JSON N HMPTMP,HMPTXT
"RTN","HMPDJ1",34,0)
 .. S HMPTXT(1)="Problem encoding json output."
"RTN","HMPDJ1",35,0)
 .. D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.ARRAY)
"RTN","HMPDJ1",36,0)
 .. K HMPERR D ENCODE^HMPJSON("HMPTMP","JSON","HMPERR")
"RTN","HMPDJ1",37,0)
 .. S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPDJ1",38,0)
 .. M HMP(1)=JSON
"RTN","HMPDJ1",39,0)
 .. S HMP(2)="}}"
"RTN","HMPDJ1",40,0)
 ;
"RTN","HMPDJ1",41,0)
 K ^HMP(800000.1,DA,1) S ^(1,0)="^800000.101^^",CNT=0
"RTN","HMPDJ1",42,0)
 S I="" F  S I=$O(JSON(I)) Q:I=""  S CNT=CNT+1,^HMP(800000.1,DA,1,CNT,0)=JSON(I)
"RTN","HMPDJ1",43,0)
 S:$G(CNT) ^HMP(800000.1,DA,1,0)="^800000.101^"_CNT_U_CNT
"RTN","HMPDJ1",44,0)
 ;
"RTN","HMPDJ1",45,0)
PTQ ; add item count and terminating characters
"RTN","HMPDJ1",46,0)
 I $D(ERR) S HMP="{""apiVersion"":""1.01"",""error"":{""message"":"""_ERR_"""},""success"":false}" Q
"RTN","HMPDJ1",47,0)
 S HMP="{""apiVersion"":""1.01"",""data"":{""updated"":"_""""_$$HL7NOW_""""_",""uid"":"""_UID_"""},""success"":true}"
"RTN","HMPDJ1",48,0)
 S DFN=+$P(UID,":",5)
"RTN","HMPDJ1",49,0)
 D POST^HMPEVNT(DFN,TYPE,DA) ;UID)
"RTN","HMPDJ1",50,0)
 Q
"RTN","HMPDJ1",51,0)
 ;
"RTN","HMPDJ1",52,0)
NEW ; -- create new entry in ^HMP(800000.1) from PAT,TYPE,HMPSYS
"RTN","HMPDJ1",53,0)
 ;  Return UID & DA, or ERR
"RTN","HMPDJ1",54,0)
 N DFN,ICN
"RTN","HMPDJ1",55,0)
 S DFN=+$G(PAT),ICN="",TYPE=$G(TYPE)
"RTN","HMPDJ1",56,0)
 I 'DFN,DFN[";" S ICN=+$P($G(DFN),";",2),DFN=+$G(DFN)
"RTN","HMPDJ1",57,0)
 I 'DFN,ICN S DFN=+$$GETDFN^MPIF001(ICN)
"RTN","HMPDJ1",58,0)
 I 'DFN!'$L($G(^DPT(DFN,0))) S ERR=$$ERR(1,DFN) Q  ; IA 10035, DE2818
"RTN","HMPDJ1",59,0)
 I TYPE="" S ERR=$$ERR(2,"null") Q
"RTN","HMPDJ1",60,0)
 ;
"RTN","HMPDJ1",61,0)
 S DA=$$NEXTIFN I DA<1 S ERR=$$ERR(4) Q
"RTN","HMPDJ1",62,0)
 S UID="urn:va:"_TYPE_":"_HMPSYS_":"_DFN_":"_DA
"RTN","HMPDJ1",63,0)
 S ^HMP(800000.1,DA,0)=UID_U_DFN_U_TYPE
"RTN","HMPDJ1",64,0)
 S ^HMP(800000.1,"B",UID,DA)=""
"RTN","HMPDJ1",65,0)
 S ^HMP(800000.1,"C",DFN,TYPE,DA)=""
"RTN","HMPDJ1",66,0)
 Q
"RTN","HMPDJ1",67,0)
 ;
"RTN","HMPDJ1",68,0)
NEXTIFN() ; -- Returns next available IFN
"RTN","HMPDJ1",69,0)
 N I,HDR,TOTAL,DA
"RTN","HMPDJ1",70,0)
 L +^HMP(800000.1,0):$S($G(DILOCKTM)>0:DILOCKTM,1:5)
"RTN","HMPDJ1",71,0)
 I '$T Q "^"
"RTN","HMPDJ1",72,0)
 S HDR=$G(^HMP(800000.1,0)),TOTAL=+$P(HDR,U,4),I=$O(^HMP(800000.1,"?"),-1)
"RTN","HMPDJ1",73,0)
 F I=(I+1):1 Q:'$D(^HMP(800000.1,I,0))
"RTN","HMPDJ1",74,0)
 S DA=I,$P(HDR,U,3,4)=DA_U_(TOTAL+1) S ^HMP(800000.1,0)=HDR
"RTN","HMPDJ1",75,0)
 L -^HMP(800000.1,0)
"RTN","HMPDJ1",76,0)
 Q DA
"RTN","HMPDJ1",77,0)
 ;
"RTN","HMPDJ1",78,0)
ERR(X,VAL) ; -- return error message
"RTN","HMPDJ1",79,0)
 N MSG  S MSG="Error"
"RTN","HMPDJ1",80,0)
 I X=1  S MSG="Patient with dfn '"_$G(VAL)_"' not found"
"RTN","HMPDJ1",81,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPDJ1",82,0)
 I X=3  S MSG="UID '"_$G(VAL)_"' not found"
"RTN","HMPDJ1",83,0)
 I X=4  S MSG="Unable to create new object"
"RTN","HMPDJ1",84,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPDJ1",85,0)
 Q MSG
"RTN","HMPDJ1",86,0)
 ;
"RTN","HMPDJ1",87,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPDJ1",88,0)
 Q $$FMTHL7^HMPSTMP($$NOW^XLFDT)  ; DE5016
"RTN","HMPDJ1",89,0)
 ;
"RTN","HMPDJ1",90,0)
CONV ; -- convert uid format
"RTN","HMPDJ1",91,0)
 N DA,X0,UID,HMPSYS,DFN,COLL,NEW,I,JSON,HMPY,ERR,CNT
"RTN","HMPDJ1",92,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJ1",93,0)
 S DA=0 F  S DA=$O(^HMP(800000.1,DA)) Q:DA<1  D
"RTN","HMPDJ1",94,0)
 . S X0=$G(^HMP(800000.1,DA,0)),UID=$P(X0,U)
"RTN","HMPDJ1",95,0)
 . K ^HMP(800000.1,"B",UID,DA),JSON
"RTN","HMPDJ1",96,0)
 . S DFN=$P(X0,"^",2),COLL=$P(X0,"^",3)
"RTN","HMPDJ1",97,0)
 . S NEW="urn:va:"_COLL_":"_HMPSYS_":"_DFN_":"_DA
"RTN","HMPDJ1",98,0)
 . S $P(^HMP(800000.1,DA,0),U)=NEW,^HMP(800000.1,"B",NEW,DA)=""
"RTN","HMPDJ1",99,0)
 . ;decode JSON object, reset uid
"RTN","HMPDJ1",100,0)
 . S I=0 F  S I=$O(^HMP(800000.1,DA,1,I)) Q:I<1  S JSON(I)=$G(^(I,0))
"RTN","HMPDJ1",101,0)
 . Q:'$D(JSON)  K HMPY,ERR
"RTN","HMPDJ1",102,0)
 . D DECODE^HMPJSON("JSON","HMPY","ERR") I $D(ERR) W !,DA Q
"RTN","HMPDJ1",103,0)
 . S HMPY("uid")=NEW K JSON
"RTN","HMPDJ1",104,0)
 . D ENCODE^HMPJSON("HMPY","JSON","ERR") I $D(ERR) W !,DA Q
"RTN","HMPDJ1",105,0)
 . K ^HMP(800000.1,DA,1) S ^(1,0)="^800000.101^^",CNT=0
"RTN","HMPDJ1",106,0)
 . S I="" F  S I=$O(JSON(I)) Q:I=""  S CNT=CNT+1,^HMP(800000.1,DA,1,CNT,0)=JSON(I)
"RTN","HMPDJ1",107,0)
 . S:$G(CNT) ^HMP(800000.1,DA,1,0)="^800000.101^"_CNT_U_CNT
"RTN","HMPDJ1",108,0)
 Q
"RTN","HMPDJ2")
0^68^B21343271
"RTN","HMPDJ2",1,0)
HMPDJ2 ;SLC/MKB,ASMR/RRB,CK - HMP Object RPCs;May 15, 2016 14:15
"RTN","HMPDJ2",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPDJ2",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ2",4,0)
 ;
"RTN","HMPDJ2",5,0)
 Q
"RTN","HMPDJ2",6,0)
 ;
"RTN","HMPDJ2",7,0)
GET(HMP,FILTER) ; -- Return search results as JSON in @HMP@(n)
"RTN","HMPDJ2",8,0)
 ; RPC = HMP GET OBJECT
"RTN","HMPDJ2",9,0)
 N TYPE,HMPMAX,HMPI,HMPID,HMPERR,IEN
"RTN","HMPDJ2",10,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPDJ2",11,0)
 ;
"RTN","HMPDJ2",12,0)
 ; parse & validate input parameters
"RTN","HMPDJ2",13,0)
 S TYPE=$G(FILTER("collection")),TYPE=$$LOW^XLFSTR(TYPE)
"RTN","HMPDJ2",14,0)
 S HMPMAX=+$G(FILTER("max"),9999) ;??
"RTN","HMPDJ2",15,0)
 S HMPID=$G(FILTER("id"))
"RTN","HMPDJ2",16,0)
 ;
"RTN","HMPDJ2",17,0)
 ;set error trap
"RTN","HMPDJ2",18,0)
 N $ES,$ET,ERRARRY,ERRDOM,ERRPAT,ERRMSG
"RTN","HMPDJ2",19,0)
 ;S $ET="D ERRHDLR^HMPDERRH G ERRQ^HMPDJ0"
"RTN","HMPDJ2",20,0)
 S ERRDOM="hmp",ERRMSG=$G(TYPE)
"RTN","HMPDJ2",21,0)
 K ^TMP($J,"HMP ERROR")
"RTN","HMPDJ2",22,0)
 ;
"RTN","HMPDJ2",23,0)
 ; extract data
"RTN","HMPDJ2",24,0)
 I $L(HMPID) D  G GQ
"RTN","HMPDJ2",25,0)
 . S IEN=+HMPID I 'IEN S IEN=+$O(^HMP(800000.11,"B",HMPID,0)) ;IEN or UID
"RTN","HMPDJ2",26,0)
 . D:IEN HMP1^HMPDJ02(800000.11,IEN)
"RTN","HMPDJ2",27,0)
 I TYPE="" S HMPERR="Missing or invalid collection type" G GQ
"RTN","HMPDJ2",28,0)
 S IEN=0 F  S IEN=$O(^HMP(800000.11,"C",TYPE,IEN)) Q:IEN<1  D HMP1^HMPDJ02(800000.11,IEN)
"RTN","HMPDJ2",29,0)
 ;
"RTN","HMPDJ2",30,0)
GQ ;build return JSON
"RTN","HMPDJ2",31,0)
 D GTQ^HMPDJ
"RTN","HMPDJ2",32,0)
 Q
"RTN","HMPDJ2",33,0)
 ;
"RTN","HMPDJ2",34,0)
DEL(HMP,HMPID) ; -- Delete object HMPID from ^HMP(800000.11)
"RTN","HMPDJ2",35,0)
 ; RPC = HMP DELETE OBJECT
"RTN","HMPDJ2",36,0)
 ;
"RTN","HMPDJ2",37,0)
 N ACTION,ERR,UID,DA,DIK,TYPE
"RTN","HMPDJ2",38,0)
 S UID=$G(HMPID) I '$L(UID) S ERR=$$ERR(3,"null") G PTQ
"RTN","HMPDJ2",39,0)
 S DA=+$O(^HMP(800000.11,"B",UID,0)) I DA<1 S ERR=$$ERR(3,UID) G PTQ
"RTN","HMPDJ2",40,0)
 S DIK="^HMP(800000.11," D ^DIK
"RTN","HMPDJ2",41,0)
 S ACTION="@",TYPE=$P(UID,":",3)
"RTN","HMPDJ2",42,0)
 G PTQ
"RTN","HMPDJ2",43,0)
 Q
"RTN","HMPDJ2",44,0)
 ;
"RTN","HMPDJ2",45,0)
PUT(HMP,TYPE,JSON) ; -- Save/update JSON OBJECT in ^HMP(800000.11), return UID if successful
"RTN","HMPDJ2",46,0)
 ; RPC = HMP PUT OBJECT
"RTN","HMPDJ2",47,0)
 ;
"RTN","HMPDJ2",48,0)
 N ACTION,ARRAY,CNT,ERR,HMPERR,UID,DA,X,I,HMPSYS
"RTN","HMPDJ2",49,0)
 D DECODE^HMPJSON("JSON","ARRAY","HMPERR")
"RTN","HMPDJ2",50,0)
 ;N XCNT S XCNT=$O(^XTMP("AGPARRAY",""),-1),XCNT=XCNT+1
"RTN","HMPDJ2",51,0)
 ;M ^XTMP("AGPARRAY",XCNT,"DATA")=ARRAY
"RTN","HMPDJ2",52,0)
 ;S ^XTMP("AGPARRAY",XCNT,"TYPE")=TYPE
"RTN","HMPDJ2",53,0)
 I $D(HMPERR) D  Q  ;S X=$G(ERR(1)) K ERR S ERR=X G PTQ
"RTN","HMPDJ2",54,0)
 . K ARRAY N HMPTMP,HMPTXT
"RTN","HMPDJ2",55,0)
 . S HMPTXT(1)="Problem decoding json input."
"RTN","HMPDJ2",56,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.JSON)
"RTN","HMPDJ2",57,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","ARRAY","HMPERR")
"RTN","HMPDJ2",58,0)
 . S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPDJ2",59,0)
 . M HMP(1)=ARRAY
"RTN","HMPDJ2",60,0)
 . S HMP(2)="}}"
"RTN","HMPDJ2",61,0)
 ;
"RTN","HMPDJ2",62,0)
 S UID=$G(ARRAY("uid")),HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJ2",63,0)
 I $L(UID) S DA=+$O(^HMP(800000.11,"B",UID,0)) I DA<1 S ERR=$$ERR(3,UID) G PTQ
"RTN","HMPDJ2",64,0)
 ;I $L(UID) S DA=+$O(^HMP(800000.11,"B",UID,0)) I DA<1 D NEW1(UID)
"RTN","HMPDJ2",65,0)
 I '$L(UID) D  G:$D(ERR) PTQ Q:$D(HMPERR)
"RTN","HMPDJ2",66,0)
 . D NEW Q:$D(ERR)
"RTN","HMPDJ2",67,0)
 . S ARRAY("uid")=UID K JSON
"RTN","HMPDJ2",68,0)
 . D ENCODE^HMPJSON("ARRAY","JSON","HMPERR")
"RTN","HMPDJ2",69,0)
 . I $D(HMPERR) D  Q  ;S X=$G(ERR(1)) K ERR S ERR=X Q
"RTN","HMPDJ2",70,0)
 .. K JSON N HMPTMP,HMPTXT
"RTN","HMPDJ2",71,0)
 .. S HMPTXT(1)="Problem encoding json output."
"RTN","HMPDJ2",72,0)
 .. D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.ARRAY)
"RTN","HMPDJ2",73,0)
 .. K HMPERR D ENCODE^HMPJSON("HMPTMP","JSON","HMPERR")
"RTN","HMPDJ2",74,0)
 .. S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPDJ2",75,0)
 .. M HMP(1)=JSON
"RTN","HMPDJ2",76,0)
 .. S HMP(2)="}}"
"RTN","HMPDJ2",77,0)
 ;
"RTN","HMPDJ2",78,0)
 K ^HMP(800000.11,DA,1) S ^(1,0)="^800000.111^^",CNT=0
"RTN","HMPDJ2",79,0)
 S I="" F  S I=$O(JSON(I)) Q:I=""  S CNT=CNT+1,^HMP(800000.11,DA,1,CNT,0)=JSON(I)
"RTN","HMPDJ2",80,0)
 S:$G(CNT) ^HMP(800000.11,DA,1,0)="^800000.111^"_CNT_U_CNT
"RTN","HMPDJ2",81,0)
 ;
"RTN","HMPDJ2",82,0)
PTQ ; add item count and terminating characters
"RTN","HMPDJ2",83,0)
 I $D(ERR) S HMP="{""apiVersion"":""1.01"",""error"":{""message"":"""_ERR_"""},""success"":false}" Q
"RTN","HMPDJ2",84,0)
 S HMP="{""apiVersion"":""1.01"",""data"":{""updated"":"_""""_$$HL7NOW_""""_",""uid"":"""_UID_"""},""success"":true}"
"RTN","HMPDJ2",85,0)
 D POSTX^HMPEVNT(TYPE,DA,$G(ACTION)) ;UID)
"RTN","HMPDJ2",86,0)
 Q
"RTN","HMPDJ2",87,0)
 ;
"RTN","HMPDJ2",88,0)
NEW1(UID) ; -- create new entry in ^HMP(800000.11) from PAT,TYPE,HMPSYS
"RTN","HMPDJ2",89,0)
 ;  Return UID & DA, or ERR
"RTN","HMPDJ2",90,0)
 S TYPE=$G(TYPE)
"RTN","HMPDJ2",91,0)
 I TYPE="" S ERR=$$ERR(2,"null") Q
"RTN","HMPDJ2",92,0)
 ;
"RTN","HMPDJ2",93,0)
 S DA=$$NEXTIFN I DA<1 S ERR=$$ERR(4) Q
"RTN","HMPDJ2",94,0)
 S UID="urn:va:"_TYPE_":"_HMPSYS_":"_DA
"RTN","HMPDJ2",95,0)
 S ^HMP(800000.11,DA,0)=UID_U_U_TYPE
"RTN","HMPDJ2",96,0)
 S ^HMP(800000.11,"B",UID,DA)=""
"RTN","HMPDJ2",97,0)
 S ^HMP(800000.11,"C",TYPE,DA)=""
"RTN","HMPDJ2",98,0)
 Q
"RTN","HMPDJ2",99,0)
 ;
"RTN","HMPDJ2",100,0)
NEW ; -- create new entry in ^HMP(800000.11) from PAT,TYPE,HMPSYS
"RTN","HMPDJ2",101,0)
 ;  Return UID & DA, or ERR
"RTN","HMPDJ2",102,0)
 S TYPE=$G(TYPE)
"RTN","HMPDJ2",103,0)
 I TYPE="" S ERR=$$ERR(2,"null") Q
"RTN","HMPDJ2",104,0)
 ;
"RTN","HMPDJ2",105,0)
 S DA=$$NEXTIFN I DA<1 S ERR=$$ERR(4) Q
"RTN","HMPDJ2",106,0)
 S UID="urn:va:"_TYPE_":"_HMPSYS_":"_DA
"RTN","HMPDJ2",107,0)
 S ^HMP(800000.11,DA,0)=UID_U_U_TYPE
"RTN","HMPDJ2",108,0)
 S ^HMP(800000.11,"B",UID,DA)=""
"RTN","HMPDJ2",109,0)
 S ^HMP(800000.11,"C",TYPE,DA)=""
"RTN","HMPDJ2",110,0)
 Q
"RTN","HMPDJ2",111,0)
 ;
"RTN","HMPDJ2",112,0)
NEXTIFN() ; -- Returns next available IFN
"RTN","HMPDJ2",113,0)
 N I,HDR,TOTAL,DA
"RTN","HMPDJ2",114,0)
 L +^HMP(800000.11,0):$S($G(DILOCKTM)>0:DILOCKTM,1:5)
"RTN","HMPDJ2",115,0)
 I '$T Q "^"
"RTN","HMPDJ2",116,0)
 S HDR=$G(^HMP(800000.11,0)),TOTAL=+$P(HDR,U,4),I=$O(^HMP(800000.11,"?"),-1)
"RTN","HMPDJ2",117,0)
 F I=(I+1):1 Q:'$D(^HMP(800000.11,I,0))
"RTN","HMPDJ2",118,0)
 S DA=I,$P(HDR,U,3,4)=DA_U_(TOTAL+1) S ^HMP(800000.11,0)=HDR
"RTN","HMPDJ2",119,0)
 L -^HMP(800000.11,0)
"RTN","HMPDJ2",120,0)
 Q DA
"RTN","HMPDJ2",121,0)
 ;
"RTN","HMPDJ2",122,0)
ERR(X,VAL) ; -- return error message
"RTN","HMPDJ2",123,0)
 N MSG  S MSG="Error"
"RTN","HMPDJ2",124,0)
 I X=1  S MSG="Patient with dfn '"_$G(VAL)_"' not found"
"RTN","HMPDJ2",125,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPDJ2",126,0)
 I X=3  S MSG="UID '"_$G(VAL)_"' not found"
"RTN","HMPDJ2",127,0)
 I X=4  S MSG="Unable to create new object"
"RTN","HMPDJ2",128,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPDJ2",129,0)
 Q MSG
"RTN","HMPDJ2",130,0)
 ;
"RTN","HMPDJ2",131,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPDJ2",132,0)
 Q $$FMTHL7^HMPSTMP($$NOW^XLFDT)  ; DE5016
"RTN","HMPDJ2",133,0)
 ;
"RTN","HMPDJFS")
0^69^B75039687
"RTN","HMPDJFS",1,0)
HMPDJFS ;SLC/KCM,ASMR/RRB,JD,CK,CPC -- Asynchronous Extracts and Freshness via stream;Apr 27, 2016 10:35:07
"RTN","HMPDJFS",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPDJFS",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFS",4,0)
 ;
"RTN","HMPDJFS",5,0)
 ; JD - 1/14/15 - Removed "+" from "$$GETICN^MPIF001(DFN)" so that the
"RTN","HMPDJFS",6,0)
 ;                full value of icn (<icn>V<checksum>) could be captured. US4194.
"RTN","HMPDJFS",7,0)
 ; JD - 3/16/15 - Added checks to prevent restaging of data if the data has
"RTN","HMPDJFS",8,0)
 ;                already been staged.  US4304
"RTN","HMPDJFS",9,0)
 ; CPC - 3/4/16 - Prevent dual execution. DE3411
"RTN","HMPDJFS",10,0)
 ;
"RTN","HMPDJFS",11,0)
 ; PUT/POST   call $$TAG^ROUTINE(.args,.body)
"RTN","HMPDJFS",12,0)
 ; GET/DELETE call   TAG^ROUTINE(.response,.args)
"RTN","HMPDJFS",13,0)
 ;
"RTN","HMPDJFS",14,0)
 Q
"RTN","HMPDJFS",15,0)
 ;
"RTN","HMPDJFS",16,0)
API(HMPFRSP,ARGS) ;
"RTN","HMPDJFS",17,0)
 N HMPFERR,HMPFHMP,HMPFLOG,CNT,ACNT
"RTN","HMPDJFS",18,0)
 K ^TMP("HMPF",$J)
"RTN","HMPDJFS",19,0)
 S HMPFHMP=$TR($G(ARGS("server")),"~","=")
"RTN","HMPDJFS",20,0)
 S HMPFRSP=$NA(^TMP("HMPF",$J))
"RTN","HMPDJFS",21,0)
 S HMPFLOG=+$$GET^XPAR("ALL","HMP LOG LEVEL")
"RTN","HMPDJFS",22,0)
 I HMPFLOG D LOGREQ(HMPFHMP,.ARGS)
"RTN","HMPDJFS",23,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJFS",24,0)
 I '$L(HMPFHMP) D SETERR("Missing HMP Server ID") QUIT
"RTN","HMPDJFS",25,0)
 I '$O(^HMP(800000,"B",HMPFHMP,0)) D SETERR("HMP Server not registered") QUIT
"RTN","HMPDJFS",26,0)
 ;
"RTN","HMPDJFS",27,0)
 ; begin select case
"RTN","HMPDJFS",28,0)
 I ARGS("command")="putPtSubscription" D  G XAPI
"RTN","HMPDJFS",29,0)
 . N LOC
"RTN","HMPDJFS",30,0)
 . S LOC=$$PUTSUB^HMPDJFSP(.ARGS) ; Added ELSE for US4304
"RTN","HMPDJFS",31,0)
 . I $L(LOC) S ^TMP("HMPF",$J,1)="{""apiVersion"":""1.0"",""location"":"""_LOC_""""_$$PROGRESS_"}"
"RTN","HMPDJFS",32,0)
 I ARGS("command")="startOperationalDataExtract" D  G XAPI
"RTN","HMPDJFS",33,0)
 . N HMPX2,LOC
"RTN","HMPDJFS",34,0)
 . S ARGS("localId")="OPD"  ; use OPD to indicate "sync operational"
"RTN","HMPDJFS",35,0)
 . ; Next 2 lines added for US4304
"RTN","HMPDJFS",36,0)
 . S HMPX2="HMPFX~"_$G(HMPFHMP)_"~OPD"
"RTN","HMPDJFS",37,0)
 . D  ;DE5181 submit ODS only if not already run or running
"RTN","HMPDJFS",38,0)
 ..  N HMPUID
"RTN","HMPDJFS",39,0)
 ..  I $D(^XTMP(HMPX2)) S LOC="/hmp/subscription/operational data/" Q
"RTN","HMPDJFS",40,0)
 ..  S HMPUID=$O(^HMP(800000,"B",HMPFHMP,0))
"RTN","HMPDJFS",41,0)
 ..  I HMPUID,$P($G(^HMP(800000,HMPUID,0)),U,3)=2 S LOC="/hmp/subscription/operational data/" Q
"RTN","HMPDJFS",42,0)
 ..  S LOC=$$PUTSUB^HMPDJFSP(.ARGS)
"RTN","HMPDJFS",43,0)
 . I $L(LOC) S ^TMP("HMPF",$J,1)="{""apiVersion"":""1.0"",""location"":"""_LOC_"""}"
"RTN","HMPDJFS",44,0)
 I ARGS("command")="getPtUpdates" D  G XAPI
"RTN","HMPDJFS",45,0)
 . L +^TMP("HMPDJFSG "_$G(HMPFHMP)):2 E  D SETERR^HMPDJFS("Only one extract can run for a single server") Q  ;DE3411
"RTN","HMPDJFS",46,0)
 . D GETSUB^HMPDJFSG(HMPFRSP,.ARGS)
"RTN","HMPDJFS",47,0)
 . L -^TMP("HMPDJFSG "_$G(HMPFHMP)) ;DE3411
"RTN","HMPDJFS",48,0)
 I ARGS("command")="resetAllSubscriptions" D  G XAPI
"RTN","HMPDJFS",49,0)
 . D RESETSVR(.ARGS)
"RTN","HMPDJFS",50,0)
 . S ^TMP("HMPF",$J,1)="{""apiVersion"":""1.0"",""removed"":""true""}"
"RTN","HMPDJFS",51,0)
 I ARGS("command")="checkHealth" D  G XAPI
"RTN","HMPDJFS",52,0)
 . D HLTHCHK^HMPDJFSM(.ARGS)
"RTN","HMPDJFS",53,0)
 ; else
"RTN","HMPDJFS",54,0)
 D SETERR("command not recognized")  ; should not get this far
"RTN","HMPDJFS",55,0)
 ;
"RTN","HMPDJFS",56,0)
XAPI ; end select case
"RTN","HMPDJFS",57,0)
 ;
"RTN","HMPDJFS",58,0)
 I HMPFLOG=2 D LOGRSP(HMPFHMP)
"RTN","HMPDJFS",59,0)
 Q
"RTN","HMPDJFS",60,0)
 ;
"RTN","HMPDJFS",61,0)
LOGREQ(SRV,ARGS) ; Log the request
"RTN","HMPDJFS",62,0)
 I $D(^XTMP("HMPFLOG",0,"start")) D  Q:'$$GET^XPAR("ALL","HMP LOG LEVEL")
"RTN","HMPDJFS",63,0)
 . N ELAPSED S ELAPSED=$$HDIFF^XLFDT($H,^XTMP("HMPFLOG",0,"start"),2)
"RTN","HMPDJFS",64,0)
 . I ELAPSED>$$GET^XPAR("ALL","HMP LOG LIMIT") D PUT^XPAR("SYS","HMP LOG LEVEL",1,0)
"RTN","HMPDJFS",65,0)
 E  D
"RTN","HMPDJFS",66,0)
 . D NEWXTMP("HMPFLOG",1,"HMP Freshness Logging")
"RTN","HMPDJFS",67,0)
 . S ^XTMP("HMPFLOG",0,"start")=$H
"RTN","HMPDJFS",68,0)
 S ^XTMP("HMPFLOG",0,"total")=$G(^XTMP("HMPFLOG",0,"total"))+1
"RTN","HMPDJFS",69,0)
 S:'$L(SRV) SRV="unknown"
"RTN","HMPDJFS",70,0)
 N SEQ
"RTN","HMPDJFS",71,0)
 S SEQ=+$G(^XTMP("HMPFLOG",SRV))+1,^XTMP("HMPFLOG",SRV)=SEQ
"RTN","HMPDJFS",72,0)
 M ^XTMP("HMPFLOG",SRV,SEQ,"request")=ARGS
"RTN","HMPDJFS",73,0)
 S HMPFLOG("seq")=SEQ
"RTN","HMPDJFS",74,0)
 Q
"RTN","HMPDJFS",75,0)
LOGRSP(SRV) ; Log the response
"RTN","HMPDJFS",76,0)
 M ^XTMP("HMPFLOG",SRV,HMPFLOG("seq"),"response")=^TMP("HMPF",$J)
"RTN","HMPDJFS",77,0)
 Q
"RTN","HMPDJFS",78,0)
 ;
"RTN","HMPDJFS",79,0)
 ; delete a patient subscription
"RTN","HMPDJFS",80,0)
DELSUB(RSP,ARGS) ; cancel a subscription
"RTN","HMPDJFS",81,0)
 ; DELETE with: /hmp/subscription/{hmpSrvId}/patient/{pid}
"RTN","HMPDJFS",82,0)
 ; remove patient from HMP SUBSCRIPTION file
"RTN","HMPDJFS",83,0)
 ; remove ^XTMP(HMPX and ^XTMP(HMPH nodes
"RTN","HMPDJFS",84,0)
 ; look ahead (from lastId) and remove any nodes for the patient
"RTN","HMPDJFS",85,0)
 N DFN,HMPSRV,BATCH,HMPSRVID
"RTN","HMPDJFS",86,0)
 K ^TMP("HMPF",$J)
"RTN","HMPDJFS",87,0)
 S DFN=$$DFN(ARGS("pid")) Q:$D(HMPFERR)
"RTN","HMPDJFS",88,0)
 S HMPSRV=ARGS("hmpSrvId")
"RTN","HMPDJFS",89,0)
 S BATCH="HMPFX~"_HMPSRV_"~"_DFN
"RTN","HMPDJFS",90,0)
 L +^XTMP("HMPFP",DFN,HMPSRV):20 E  D SETERR("unable to get lock") Q
"RTN","HMPDJFS",91,0)
 ; if extract still running, it should remove itself when it finishes
"RTN","HMPDJFS",92,0)
 K ^XTMP("HMPFX~"_HMPSRV_"~"_DFN) ; kill extract nodes
"RTN","HMPDJFS",93,0)
 K ^XTMP("HMPFH~"_HMPSRV_"~"_DFN) ; kill held freshness updates
"RTN","HMPDJFS",94,0)
 ; remove all nodes for this patient between "last" and "next"
"RTN","HMPDJFS",95,0)
 ; loop forward from "last" in ^XTMP("HMPFP",0,hmpSrv) and remove nodes for this DFN
"RTN","HMPDJFS",96,0)
 K ^XTMP("HMPFP",DFN,HMPSRV)      ; kill subscription
"RTN","HMPDJFS",97,0)
 D DELPT(DFN,HMPSRV)
"RTN","HMPDJFS",98,0)
 L -^XTMP("HMPFP",DFN,HMPSRV)
"RTN","HMPDJFS",99,0)
 S RSP="{""apiVersion"":""1.0"",""success"":""true""}" ; if successful
"RTN","HMPDJFS",100,0)
 Q
"RTN","HMPDJFS",101,0)
DELPT(DFN,SRV) ; delete patient DFN for server SRV
"RTN","HMPDJFS",102,0)
 N DIK,DA
"RTN","HMPDJFS",103,0)
 S DA(1)=$O(^HMP(800000,"B",SRV,"")) Q:'DA(1)
"RTN","HMPDJFS",104,0)
 S DA=DFN Q:'DA
"RTN","HMPDJFS",105,0)
 S DIK="^HMP(800000,"_DA(1)_",1,"
"RTN","HMPDJFS",106,0)
 D ^DIK
"RTN","HMPDJFS",107,0)
 Q
"RTN","HMPDJFS",108,0)
 ;
"RTN","HMPDJFS",109,0)
 ; --- post freshness updates (internal to VistA)
"RTN","HMPDJFS",110,0)
 ;
"RTN","HMPDJFS",111,0)
POST(DFN,TYPE,ID,ACT,SERVER,NODES) ; adds new freshness item, return DT-seq
"RTN","HMPDJFS",112,0)
 ; if initializing use: ^XTMP("HMPFH-hmpserverid-dfn",seq#)    -hold
"RTN","HMPDJFS",113,0)
 ;       otherwise use: ^XTMP("HMPFS-hmpserverid-date",seq#)   -stream
"RTN","HMPDJFS",114,0)
 ;
"RTN","HMPDJFS",115,0)
 ; loop through subscribing streams for this patient
"RTN","HMPDJFS",116,0)
 ; if patient is initialized for an hmp server send events directly to stream
"RTN","HMPDJFS",117,0)
 ; otherwise, events go to temporary holding area
"RTN","HMPDJFS",118,0)
 ; initial extracts always sent directly to stream
"RTN","HMPDJFS",119,0)
 N HMPSRV,INIT,STREAM,DATE,SEQ,CNT
"RTN","HMPDJFS",120,0)
 S DATE=$$DT^XLFDT
"RTN","HMPDJFS",121,0)
 S HMPSRV="" F  S HMPSRV=$O(^HMP(800000,"AITEM",DFN,HMPSRV)) Q:'$L(HMPSRV)  D
"RTN","HMPDJFS",122,0)
 . I SERVER'="",HMPSRV'=SERVER Q
"RTN","HMPDJFS",123,0)
 . I '$D(^HMP(800000,"AITEM",DFN,HMPSRV)) Q          ; patient not subscribed
"RTN","HMPDJFS",124,0)
 . S INIT=(^HMP(800000,"AITEM",DFN,HMPSRV)=2),CNT=1  ; 2 means patient initialized
"RTN","HMPDJFS",125,0)
 . I $E(TYPE,1,4)="sync" S INIT=1                 ; sync* goes to main stream
"RTN","HMPDJFS",126,0)
 . I TYPE="syncDomain" S CNT=+$P(ID,":",3) S:CNT<1 CNT=1 ; CNT must be >0
"RTN","HMPDJFS",127,0)
 . S STREAM=$S(INIT:"HMPFS~",1:"HMPFH~")_HMPSRV_"~"_$S(INIT:DATE,1:DFN)
"RTN","HMPDJFS",128,0)
 . I '$D(^XTMP(STREAM)) D NEWXTMP(STREAM,8,"HMP Freshness Stream")
"RTN","HMPDJFS",129,0)
 . L +^XTMP(STREAM):5 E  S $EC=",Uno lock obtained," Q  ; throw error
"RTN","HMPDJFS",130,0)
 . S SEQ=$G(^XTMP(STREAM,"last"),0)+CNT
"RTN","HMPDJFS",131,0)
 . S ^XTMP(STREAM,SEQ)=DFN_U_TYPE_U_ID_U_$G(ACT)_U_$P($H,",",2)
"RTN","HMPDJFS",132,0)
 . S ^XTMP(STREAM,"last")=SEQ
"RTN","HMPDJFS",133,0)
 . L -^XTMP(STREAM)
"RTN","HMPDJFS",134,0)
 . ; NODES(hmpserverid)=streamDate^sequence -- optionally returned
"RTN","HMPDJFS",135,0)
 . S NODES($P(STREAM,"~",2))=$S(INIT:DATE,1:0)_U_SEQ
"RTN","HMPDJFS",136,0)
 Q
"RTN","HMPDJFS",137,0)
 ;
"RTN","HMPDJFS",138,0)
NEWXTMP(NODE,DAYS,DESC) ; Set a new node in ^XTMP
"RTN","HMPDJFS",139,0)
 K ^XTMP(NODE)
"RTN","HMPDJFS",140,0)
 S ^XTMP(NODE,0)=$$HTFM^XLFDT(+$H+DAYS)_U_$$HTFM^XLFDT(+$H)_U_DESC
"RTN","HMPDJFS",141,0)
 Q
"RTN","HMPDJFS",142,0)
PIDS(DFN) ; return string containing patient id's ready for JSON
"RTN","HMPDJFS",143,0)
 ; expects HMPFSYS, HMPFHMP
"RTN","HMPDJFS",144,0)
 Q:'DFN ""
"RTN","HMPDJFS",145,0)
 ;
"RTN","HMPDJFS",146,0)
 N X
"RTN","HMPDJFS",147,0)
 S X=",""pid"":"""_$$PID(DFN)_""""
"RTN","HMPDJFS",148,0)
 S X=X_",""systemId"":"""_HMPSYS_""""
"RTN","HMPDJFS",149,0)
 S X=X_",""localId"":"""_DFN_""""
"RTN","HMPDJFS",150,0)
 S X=X_",""icn"":"""_$$GETICN^MPIF001(DFN)_"""" ; US4194
"RTN","HMPDJFS",151,0)
 Q X
"RTN","HMPDJFS",152,0)
 ;
"RTN","HMPDJFS",153,0)
PID(DFN) ; return most likely PID (ICN or SYS;DFN)
"RTN","HMPDJFS",154,0)
 Q:'DFN ""
"RTN","HMPDJFS",155,0)
 I '$D(HMPSYS) S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJFS",156,0)
 Q HMPSYS_";"_DFN            ; otherwise use SysId;DFN
"RTN","HMPDJFS",157,0)
 ;
"RTN","HMPDJFS",158,0)
DFN(PID) ; return the DFN given the PID (ICN or SYS;DFN)
"RTN","HMPDJFS",159,0)
 N DFN
"RTN","HMPDJFS",160,0)
 S PID=$TR(PID,":",";")
"RTN","HMPDJFS",161,0)
 I PID'[";" D  Q DFN  ; treat as ICN
"RTN","HMPDJFS",162,0)
 . S DFN=$$GETDFN^MPIF001(PID)
"RTN","HMPDJFS",163,0)
 . I DFN<0 D SETERR($P(DFN,"^",2))
"RTN","HMPDJFS",164,0)
 ; otherwise
"RTN","HMPDJFS",165,0)
 I $P(PID,";")'=$$SYS^HMPUTILS D SETERR("DFN unknown to this system") Q 0
"RTN","HMPDJFS",166,0)
 Q $P(PID,";",2)
"RTN","HMPDJFS",167,0)
 ;
"RTN","HMPDJFS",168,0)
PROGRESS(LASTITM) ; set the node in REF with progress properties
"RTN","HMPDJFS",169,0)
 ; expects HMPFHMP,HMPSYS
"RTN","HMPDJFS",170,0)
 N RSLT,HMPIEN,CNT,STS,TS,DFN,FIRST
"RTN","HMPDJFS",171,0)
 S HMPIEN=$O(^HMP(800000,"B",HMPFHMP,0)) Q:'HMPIEN ""
"RTN","HMPDJFS",172,0)
 S CNT=0,RSLT=""
"RTN","HMPDJFS",173,0)
 F STS=0,1 D  ; 0=uninitialized, 1=initializing
"RTN","HMPDJFS",174,0)
 . S FIRST=1
"RTN","HMPDJFS",175,0)
 . S RSLT=$S(STS=0:",""waitingPids"":[",1:RSLT_"],""processingPids"":[")
"RTN","HMPDJFS",176,0)
 . S TS=0 F  S TS=$O(^HMP(800000,HMPIEN,1,"AP",STS,TS)) Q:'TS  D  Q:CNT>99
"RTN","HMPDJFS",177,0)
 . . S DFN=0 F  S DFN=$O(^HMP(800000,HMPIEN,1,"AP",STS,TS,DFN)) Q:'DFN  D
"RTN","HMPDJFS",178,0)
 . . . S CNT=CNT+1
"RTN","HMPDJFS",179,0)
 . . . S RSLT=RSLT_$S(FIRST=1:"",1:",")_""""_HMPSYS_";"_DFN_""""
"RTN","HMPDJFS",180,0)
 . . . S FIRST=0
"RTN","HMPDJFS",181,0)
 S RSLT=RSLT_"]"
"RTN","HMPDJFS",182,0)
 ;
"RTN","HMPDJFS",183,0)
 N STRM,STRMDT,CURRDT
"RTN","HMPDJFS",184,0)
 I $G(LASTITM)="" S LASTITM=$P(^HMP(800000,HMPIEN,0),U,2)
"RTN","HMPDJFS",185,0)
 I $L(LASTITM,"-")<2 S LASTITM=$$DT^XLFDT_"-"_+LASTITM
"RTN","HMPDJFS",186,0)
 S STRMDT=$P(LASTITM,"-"),CURRDT=$$DT^XLFDT,SEQ=$P(LASTITM,"-",2)
"RTN","HMPDJFS",187,0)
 S CNT=0 F  D  Q:$$FMDIFF^XLFDT(STRMDT,CURRDT,1)'<0
"RTN","HMPDJFS",188,0)
 . S STRM="HMPFS~"_HMPFHMP_"~"_STRMDT
"RTN","HMPDJFS",189,0)
 . S CNT=CNT+$G(^XTMP(STRM,"last"))-SEQ
"RTN","HMPDJFS",190,0)
 . S STRMDT=$$FMADD^XLFDT(STRMDT,1),SEQ=0
"RTN","HMPDJFS",191,0)
 S RSLT=RSLT_",""remainingObjects"":"_CNT
"RTN","HMPDJFS",192,0)
 Q RSLT
"RTN","HMPDJFS",193,0)
 ;
"RTN","HMPDJFS",194,0)
 ; --- handle errors
"RTN","HMPDJFS",195,0)
 ;
"RTN","HMPDJFS",196,0)
SETERR(MSG) ; create error object in ^TMP("HMPFERR",$J) and set HMPFERR
"RTN","HMPDJFS",197,0)
 ; TODO: escape MSG for JSON
"RTN","HMPDJFS",198,0)
 S @HMPFRSP@(1)="{""apiVersion"":""1.0"",""error"":{""message"":"""_MSG_"""}}"
"RTN","HMPDJFS",199,0)
 S ^TMP("HMPFERR",$J,$H)=MSG
"RTN","HMPDJFS",200,0)
 S HMPFERR=1
"RTN","HMPDJFS",201,0)
 Q
"RTN","HMPDJFS",202,0)
 ;
"RTN","HMPDJFS",203,0)
DEBUG(MSG) ;
"RTN","HMPDJFS",204,0)
 S ^TMP("HMPDEBUG",$J,0)=$G(^TMP("HMPDEBUG",$J,0),0)+1
"RTN","HMPDJFS",205,0)
 I $D(MSG)'=1 M ^TMP("HMPDEBUG",$J,^TMP("HMPDEBUG",$J,0))=MSG Q
"RTN","HMPDJFS",206,0)
 S ^TMP("HMPDEBUG",$J,^TMP("HMPDEBUG",$J,0))=MSG
"RTN","HMPDJFS",207,0)
 Q
"RTN","HMPDJFS",208,0)
RESETSVR(ARGS) ;
"RTN","HMPDJFS",209,0)
 N DA,DIE,DIK,DR,IEN,SRV,SRVIEN,X
"RTN","HMPDJFS",210,0)
 S SRV=$G(ARGS("server")) I SRV="" Q
"RTN","HMPDJFS",211,0)
 S DA=$O(^HMP(800000,"B",SRV,"")) I DA'>0 Q
"RTN","HMPDJFS",212,0)
 S SRVIEN=DA
"RTN","HMPDJFS",213,0)
 L +^HMP(800000,SRVIEN):5 E  S $EC=",Uno lock obtained," Q
"RTN","HMPDJFS",214,0)
 ;delete operational data field
"RTN","HMPDJFS",215,0)
 S DIE="^HMP(800000,",DR=".03///@" D ^DIE
"RTN","HMPDJFS",216,0)
 S DA(1)=DA,DA=0
"RTN","HMPDJFS",217,0)
 ;delete patient multiple values
"RTN","HMPDJFS",218,0)
 S DIK="^HMP(800000,"_DA(1)_",1,"
"RTN","HMPDJFS",219,0)
 F  S DA=$O(^HMP(800000,DA(1),1,DA)) Q:DA'>0  D ^DIK
"RTN","HMPDJFS",220,0)
 ;kill server ^XTMP
"RTN","HMPDJFS",221,0)
 S X="HMPF" F  S X=$O(^XTMP(X)) Q:$E(X,1,4)'="HMPF"  D
"RTN","HMPDJFS",222,0)
 . I X[SRV K ^XTMP(X) I 1
"RTN","HMPDJFS",223,0)
 ;kill tidy node
"RTN","HMPDJFS",224,0)
 K ^XTMP("HMPFP","tidy",SRV)
"RTN","HMPDJFS",225,0)
 L -^HMP(800000,SRVIEN)
"RTN","HMPDJFS",226,0)
 Q
"RTN","HMPDJFS",227,0)
 ;
"RTN","HMPDJFS",228,0)
CLEARDOM(SVR,PAT) ;
"RTN","HMPDJFS",229,0)
 Q
"RTN","HMPDJFS",230,0)
 ;
"RTN","HMPDJFS",231,0)
CLEARPAT(SVR,PAT) ;
"RTN","HMPDJFS",232,0)
 I '$D(^XTMP("HMPFP",PAT,SVR)) Q
"RTN","HMPDJFS",233,0)
 ;do we need a check for patient initialized?
"RTN","HMPDJFS",234,0)
 K ^XTMP("HMPFP",PAT,SVR)
"RTN","HMPDJFS",235,0)
 Q
"RTN","HMPDJFS",236,0)
 ;
"RTN","HMPDJFS",237,0)
HMPSET(DA,NEW) ;
"RTN","HMPDJFS",238,0)
 N IEN,NAME
"RTN","HMPDJFS",239,0)
 S IEN=0 F  S IEN=$O(^HMP(800000,IEN)) Q:IEN'>0  D
"RTN","HMPDJFS",240,0)
 .S NAME=$P(^HMP(800000,IEN,0),U)
"RTN","HMPDJFS",241,0)
 .I $D(^HMP(800000,IEN,1,NEW(1)))>0 S ^HMP(800000,"AITEM",NEW(1),NAME)=NEW(2)
"RTN","HMPDJFS",242,0)
 Q
"RTN","HMPDJFS",243,0)
 ;
"RTN","HMPDJFS",244,0)
HMPKILL(DA,OLD) ;
"RTN","HMPDJFS",245,0)
 N NAME
"RTN","HMPDJFS",246,0)
 S NAME=$P($G(^HMP(800000,DA(1),0)),U) I NAME="" Q
"RTN","HMPDJFS",247,0)
 K ^HMP(800000,"AITEM",OLD(1),NAME)
"RTN","HMPDJFS",248,0)
 Q
"RTN","HMPDJFS",249,0)
 ;
"RTN","HMPDJFS",250,0)
HMPOSET(DA,NEW) ;
"RTN","HMPDJFS",251,0)
 N IEN,NAME
"RTN","HMPDJFS",252,0)
 S IEN=0 F  S IEN=$O(^HMP(800000,IEN)) Q:IEN'>0  D
"RTN","HMPDJFS",253,0)
 .S NAME=$P(^HMP(800000,IEN,0),U)
"RTN","HMPDJFS",254,0)
 .S ^HMP(800000,"AITEM","OPD",NAME)=NEW
"RTN","HMPDJFS",255,0)
 Q
"RTN","HMPDJFS",256,0)
 ;
"RTN","HMPDJFS",257,0)
HMPOKILL(DA) ;
"RTN","HMPDJFS",258,0)
 N NAME
"RTN","HMPDJFS",259,0)
 S NAME=$P($G(^HMP(800000,DA,0)),U) I NAME="" Q
"RTN","HMPDJFS",260,0)
 K ^HMP(800000,"AITEM","OPD",NAME)
"RTN","HMPDJFS",261,0)
 Q
"RTN","HMPDJFS",262,0)
KILL ; clear out all ^XTMP nodes
"RTN","HMPDJFS",263,0)
 N X
"RTN","HMPDJFS",264,0)
 S X="HMPF" F  S X=$O(^XTMP(X)) Q:$E(X,1,4)'="HMPF"  W !,X  K ^XTMP(X)
"RTN","HMPDJFS",265,0)
 Q
"RTN","HMPDJFS",266,0)
KILLSVR(SVR) ; clear out for specific machine
"RTN","HMPDJFS",267,0)
 N X
"RTN","HMPDJFS",268,0)
 S X="HMPF" F  S X=$O(^XTMP(X)) Q:$E(X,1,4)'="HMPF"  D
"RTN","HMPDJFS",269,0)
 . I X[SVR W !,X  K ^XTMP(X) I 1
"RTN","HMPDJFS",270,0)
 S X="" F  S X=$O(^XTMP("HMPFP",X)) Q:X=""  D
"RTN","HMPDJFS",271,0)
 . I $D(^XTMP("HMPFP",X,SVR)) K ^XTMP("HMPFP",X,SVR)
"RTN","HMPDJFS",272,0)
 Q
"RTN","HMPDJFSD")
0^16^B6635230
"RTN","HMPDJFSD",1,0)
HMPDJFSD ;SLC/KCM,ASMR/RRB -- Domain Lists for Extract and Freshness Stream;Oct 15, 2015 18:39:51
"RTN","HMPDJFSD",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJFSD",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFSD",4,0)
 ;
"RTN","HMPDJFSD",5,0)
 ; DE2818/RRB: SQA findings 1st 3 lines
"RTN","HMPDJFSD",6,0)
 ;
"RTN","HMPDJFSD",7,0)
 Q
"RTN","HMPDJFSD",8,0)
 ;
"RTN","HMPDJFSD",9,0)
PTDOMS(LIST) ; load default patient domains (put in parameter?); cpc modded order 9/29/2015
"RTN","HMPDJFSD",10,0)
 ;;order
"RTN","HMPDJFSD",11,0)
 ;;vital
"RTN","HMPDJFSD",12,0)
 ;;lab
"RTN","HMPDJFSD",13,0)
 ;;med
"RTN","HMPDJFSD",14,0)
 ;;document
"RTN","HMPDJFSD",15,0)
 ;;allergy
"RTN","HMPDJFSD",16,0)
 ;;auxiliary
"RTN","HMPDJFSD",17,0)
 ;;appointment
"RTN","HMPDJFSD",18,0)
 ;;diagnosis
"RTN","HMPDJFSD",19,0)
 ;;visit
"RTN","HMPDJFSD",20,0)
 ;;factor
"RTN","HMPDJFSD",21,0)
 ;;immunization
"RTN","HMPDJFSD",22,0)
 ;;obs
"RTN","HMPDJFSD",23,0)
 ;;problem
"RTN","HMPDJFSD",24,0)
 ;;procedure
"RTN","HMPDJFSD",25,0)
 ;;consult
"RTN","HMPDJFSD",26,0)
 ;;image
"RTN","HMPDJFSD",27,0)
 ;;surgery
"RTN","HMPDJFSD",28,0)
 ;;task
"RTN","HMPDJFSD",29,0)
 ;;ptf
"RTN","HMPDJFSD",30,0)
 ;;exam
"RTN","HMPDJFSD",31,0)
 ;;cpt
"RTN","HMPDJFSD",32,0)
 ;;education
"RTN","HMPDJFSD",33,0)
 ;;pov
"RTN","HMPDJFSD",34,0)
 ;;skin
"RTN","HMPDJFSD",35,0)
 ;;treatment
"RTN","HMPDJFSD",36,0)
 ;;roadtrip
"RTN","HMPDJFSD",37,0)
 ;;patient
"RTN","HMPDJFSD",38,0)
 ;;zzzzz
"RTN","HMPDJFSD",39,0)
 ;
"RTN","HMPDJFSD",40,0)
 ;;mh
"RTN","HMPDJFSD",41,0)
 ;
"RTN","HMPDJFSD",42,0)
 N I,X
"RTN","HMPDJFSD",43,0)
 F I=1:1 S X=$P($T(PTDOMS+I),";;",2,99) Q:X="zzzzz"  S LIST(I)=X
"RTN","HMPDJFSD",44,0)
 Q
"RTN","HMPDJFSD",45,0)
 ;
"RTN","HMPDJFSD",46,0)
OPDOMS(LIST) ; load default operational domains (put in parameter?)
"RTN","HMPDJFSD",47,0)
 ;;asu-class;^USR(8930)
"RTN","HMPDJFSD",48,0)
 ;;asu-rule;^USR(8930.1)
"RTN","HMPDJFSD",49,0)
 ;;category;^HMP(800000.11)
"RTN","HMPDJFSD",50,0)
 ;;charttab;^HMP(800000.11)
"RTN","HMPDJFSD",51,0)
 ;;displaygroup;^ORD(100.98)
"RTN","HMPDJFSD",52,0)
 ;;doc-def;^TIU(8925.1)
"RTN","HMPDJFSD",53,0)
 ;;labgroup;^LAB(64.5,1,1)
"RTN","HMPDJFSD",54,0)
 ;;labpanel;^LAB(60)
"RTN","HMPDJFSD",55,0)
 ;;location;^SC
"RTN","HMPDJFSD",56,0)
 ;;orderable;^ORD(101.43)
"RTN","HMPDJFSD",57,0)
 ;;page;^HMP(800000.11)
"RTN","HMPDJFSD",58,0)
 ;;pt-select;^DPT
"RTN","HMPDJFSD",59,0)
 ;;personphoto;^HMP(800000.11)
"RTN","HMPDJFSD",60,0)
 ;;pointofcare;^HMP(800000.11)
"RTN","HMPDJFSD",61,0)
 ;;quick;^ORD(101.41)
"RTN","HMPDJFSD",62,0)
 ;;roster;^HMPROSTR
"RTN","HMPDJFSD",63,0)
 ;;route;^PS(51.2)
"RTN","HMPDJFSD",64,0)
 ;;schedule;^PS(51.1)
"RTN","HMPDJFSD",65,0)
 ;;team;^HMP(800000.11)
"RTN","HMPDJFSD",66,0)
 ;;teamposition;^HMP(800000.11)
"RTN","HMPDJFSD",67,0)
 ;;user;^VA(200)
"RTN","HMPDJFSD",68,0)
 ;;usertabprefs;^HMP(800000.11)
"RTN","HMPDJFSD",69,0)
 ;;viewdefdef;^HMP(800000.11)
"RTN","HMPDJFSD",70,0)
 ;;viewdefdefcoldefconfigtemplate;^HMP(800000.11)
"RTN","HMPDJFSD",71,0)
 ;;immunization;^AUTTIMM
"RTN","HMPDJFSD",72,0)
 ;;allergy-list;^GMRD(120.82)
"RTN","HMPDJFSD",73,0)
 ;;sign-symptom;^GMRD(120.83)
"RTN","HMPDJFSD",74,0)
 ;;vital-type;^GMRD(120.51)
"RTN","HMPDJFSD",75,0)
 ;;vital-qualifier;^GMRD(120.52)
"RTN","HMPDJFSD",76,0)
 ;;vital-category;^GMRD(120.53)
"RTN","HMPDJFSD",77,0)
 ;;zzzzz
"RTN","HMPDJFSD",78,0)
 ;
"RTN","HMPDJFSD",79,0)
 ;;problem-list;^LEX(757.01)
"RTN","HMPDJFSD",80,0)
 ;;clioterminology
"RTN","HMPDJFSD",81,0)
 ;;doc-action
"RTN","HMPDJFSD",82,0)
 ;;doc-status
"RTN","HMPDJFSD",83,0)
 ;
"RTN","HMPDJFSD",84,0)
 N I,X
"RTN","HMPDJFSD",85,0)
 F I=1:1 S X=$P($T(OPDOMS+I),";",3) Q:X="zzzzz"  S LIST(I)=X
"RTN","HMPDJFSD",86,0)
 Q
"RTN","HMPDJFSD",87,0)
 ;
"RTN","HMPDJFSG")
0^17^B239094228
"RTN","HMPDJFSG",1,0)
HMPDJFSG ;SLC/KCM,ASMR/RRB,CPC,JD,ASF,CK -- GET for Extract and Freshness Stream;Apr27, 2016 10:35:07
"RTN","HMPDJFSG",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPDJFSG",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFSG",4,0)
 ;
"RTN","HMPDJFSG",5,0)
 ; US3907 - Allow for jobId and rootJobId to be retrieved from ^XTMP.  JD - 1/20/15
"RTN","HMPDJFSG",6,0)
 ; DE2818 - SQA findings. Newed ERRCNT in BLDSERR+2.  RRB - 10/24/2015
"RTN","HMPDJFSG",7,0)
 ; DE3869 - Remove the freshness stream entries with undefined DFNs.  JD - 3/4/16
"RTN","HMPDJFSG",8,0)
 ;
"RTN","HMPDJFSG",9,0)
 Q
"RTN","HMPDJFSG",10,0)
 ; --- retrieve updates for an HMP server's subscriptions
"RTN","HMPDJFSG",11,0)
 ;
"RTN","HMPDJFSG",12,0)
GETSUB(HMPFRSP,ARGS) ; retrieve items from stream
"RTN","HMPDJFSG",13,0)
 ;      GET from: /hmp/subscription/{hmpSrvId}/{last}?limit={limit}
"RTN","HMPDJFSG",14,0)
 ; ARGS("last") : date-seq of last item retrieved (ex. 3131206-27)
"RTN","HMPDJFSG",15,0)
 ; ARGS("max")    : maximum number of items to return (default 99999)   *S68-JCH*
"RTN","HMPDJFSG",16,0)
 ; ARGS("maxSize"): approximate number bytes to return                  *S68-JCH*
"RTN","HMPDJFSG",17,0)
 ;
"RTN","HMPDJFSG",18,0)
 ; HMPFSYS : the id (hash) of the VistA system
"RTN","HMPDJFSG",19,0)
 ; HMPFHMP : the name of the HMP server 
"RTN","HMPDJFSG",20,0)
 ; HMPFSEQ : final sequence (becomes next LASTSEQ)
"RTN","HMPDJFSG",21,0)
 ; HMPFIDX : index to iterate from LASTSEQ to final sequence
"RTN","HMPDJFSG",22,0)
 ; HMPFLAST: used to clean up extracts prior to this
"RTN","HMPDJFSG",23,0)
 ; HMPFSTRM: the extract/freshness stream (HMPFS~hmpSrvId~fmDate) 
"RTN","HMPDJFSG",24,0)
 ; (most variables namespaced since calling variety of extracts)
"RTN","HMPDJFSG",25,0)
 ;
"RTN","HMPDJFSG",26,0)
 K ^TMP("HMPF",$J)
"RTN","HMPDJFSG",27,0)
 N HMPFSYS,HMPFSTRM,HMPFLAST,HMPFDT,HMPFLIM,HMPFMAX,HMPFSIZE,HMPCLFLG
"RTN","HMPDJFSG",28,0)
 N HMPFSEQ,HMPFIDX,HMPFCNT,SNODE,STYPE,HMPFERR,HMPDEL,HMPERR,HMPSTGET,HMPLITEM  ;*S68-JCH*, DE3502
"RTN","HMPDJFSG",29,0)
 S HMPFRSP=$NA(^TMP("HMPF",$J))
"RTN","HMPDJFSG",30,0)
 ; Next line added for US6734 - Make sure OPD metastamp data has been completed before fetching.
"RTN","HMPDJFSG",31,0)
 I '$$OPD^HMPMETA(HMPFHMP) S @HMPFRSP@(1)="{""warning"":""Staging is not complete yet!""}" Q
"RTN","HMPDJFSG",32,0)
 ;
"RTN","HMPDJFSG",33,0)
 S HMPFSYS=$$SYS^HMPUTILS
"RTN","HMPDJFSG",34,0)
 S HMPFHMP("ien")=$O(^HMP(800000,"B",HMPFHMP,0))
"RTN","HMPDJFSG",35,0)
 S HMPFDT=$P($G(ARGS("lastUpdate")),"-")
"RTN","HMPDJFSG",36,0)
 S HMPFSEQ=+$P($G(ARGS("lastUpdate")),"-",2)
"RTN","HMPDJFSG",37,0)
 S HMPSTGET=$G(ARGS("getStatus"))
"RTN","HMPDJFSG",38,0)
 S HMPLITEM="" ; DE3502 initialise tracking of last item type
"RTN","HMPDJFSG",39,0)
 ; stream goes back a maximum of 8 days
"RTN","HMPDJFSG",40,0)
 I HMPFDT<$$FMADD^XLFDT($$DT^XLFDT,-8) S HMPFDT=$$HTFM^XLFDT(+$H-8),HMPFSEQ=0
"RTN","HMPDJFSG",41,0)
 S HMPFLAST=HMPFDT_"-"_HMPFSEQ
"RTN","HMPDJFSG",42,0)
 D LASTUPD(HMPFHMP,HMPFLAST)
"RTN","HMPDJFSG",43,0)
 D SETLIMIT(.ARGS)                            ; set HMPFLIM, HMPFMAX, HMPFSIZE ;*S68-PJH*
"RTN","HMPDJFSG",44,0)
 S HMPFLIM=$G(ARGS("max"),99999)
"RTN","HMPDJFSG",45,0)
 S HMPFSTRM="HMPFS~"_HMPFHMP_"~"_HMPFDT       ; stream identifier
"RTN","HMPDJFSG",46,0)
 I '$D(^XTMP(HMPFSTRM,"job",$J)) S ^XTMP(HMPFSTRM,"job",$J,"start")=$H
"RTN","HMPDJFSG",47,0)
 S ^XTMP(HMPFSTRM,"job",$J)=$H                ; record connection info
"RTN","HMPDJFSG",48,0)
 I '$$VERMATCH(HMPFHMP("ien"),$G(ARGS("extractSchema"))) D NOOP(HMPFLAST) QUIT
"RTN","HMPDJFSG",49,0)
 S HMPFCNT=0,HMPFIDX=HMPFSEQ
"RTN","HMPDJFSG",50,0)
 F  D  Q:HMPFSIZE'<HMPFMAX  D NXTSTRM Q:HMPFSTRM=""  ; *S68-JCH*
"RTN","HMPDJFSG",51,0)
 . F  S HMPFIDX=$O(^XTMP(HMPFSTRM,HMPFIDX)) Q:'HMPFIDX  D  Q:HMPFCNT'<HMPFLIM
"RTN","HMPDJFSG",52,0)
 ..  S SNODE=^XTMP(HMPFSTRM,HMPFIDX),STYPE=$P(SNODE,U,2)
"RTN","HMPDJFSG",53,0)
 ..  K FILTER("freshnessDateTime")
"RTN","HMPDJFSG",54,0)
 ..  ;===JD START===
"RTN","HMPDJFSG",55,0)
 ..  K ARGS("hmp-fst") I $P(SNODE,U,4)="@" S ARGS("hmp-fst")=$P(SNODE,U,5)
"RTN","HMPDJFSG",56,0)
 ..  ;===JD END===
"RTN","HMPDJFSG",57,0)
 ..  S $P(^XTMP(HMPFSTRM,HMPFIDX),U,6)=$P($H,",",2) ; timestamp when sent
"RTN","HMPDJFSG",58,0)
 ..  I STYPE="syncNoop" Q                      ; skip, patient was unsubscribed
"RTN","HMPDJFSG",59,0)
 ..  I STYPE="syncDomain" D DOMITMS Q          ; add multiple extract items
"RTN","HMPDJFSG",60,0)
 ..  S HMPFSEQ=HMPFIDX
"RTN","HMPDJFSG",61,0)
 ..  I STYPE="syncCommand" D SYNCCMD(SNODE) Q  ; command to middle tier
"RTN","HMPDJFSG",62,0)
 ..  I STYPE="syncError" D SYNCERR(SNODE,.HMPERR) Q
"RTN","HMPDJFSG",63,0)
 ..  I STYPE="syncStart" D SYNCSTRT(SNODE) S HMPLITEM="SYNC" Q  ; begin initial extraction ;DE3502
"RTN","HMPDJFSG",64,0)
 ..  I STYPE="syncMeta" D SYNCMETA(SNODE) S HMPLITEM="SYNC" Q   ; US11019 - Build replacement syncstart ;DE3502
"RTN","HMPDJFSG",65,0)
 ..  I STYPE="syncDone" D SYNCDONE(SNODE) S HMPLITEM="SYNC" Q   ; end of initial extraction ;DE3502
"RTN","HMPDJFSG",66,0)
 ..  D FRESHITM(SNODE,.HMPDEL,.HMPERR) S HMPLITEM="FRESH"       ; otherwise, freshness item ;DE3502
"RTN","HMPDJFSG",67,0)
 Q:$G(HMPFERR)
"RTN","HMPDJFSG",68,0)
 D FINISH(.HMPDEL,.HMPERR)
"RTN","HMPDJFSG",69,0)
 ;Check if HMP GLOBAL USAGE MONITOR mail message is required - US8228
"RTN","HMPDJFSG",70,0)
 D CHECK^HMPMETA(HMPFHMP) ; US8228
"RTN","HMPDJFSG",71,0)
 Q
"RTN","HMPDJFSG",72,0)
DOMITMS ; loop thru extract items, OFFSET is last sent
"RTN","HMPDJFSG",73,0)
 ; expects HMPFSTRM,HMPFIDX,HMPFHMP,HMPFSYS
"RTN","HMPDJFSG",74,0)
 ; changes HMPFSEQ,HMPFCNT,HMPFSIZE as each item added  ; *S68-JCH*
"RTN","HMPDJFSG",75,0)
 N X,OFFSET,DFN,PIDS,DOMAIN,TASK,BATCH,COUNT,ITEMNUM,DOMSIZE,SECSIZE
"RTN","HMPDJFSG",76,0)
 S X=^XTMP(HMPFSTRM,HMPFIDX),DFN=$P(X,U),X=$P(X,U,3)
"RTN","HMPDJFSG",77,0)
 S PIDS=$S(DFN:$$PIDS^HMPDJFS(DFN),1:"")
"RTN","HMPDJFSG",78,0)
 S DOMAIN=$P(X,":")               ; domain{#sectionNumber}
"RTN","HMPDJFSG",79,0)
 S TASK=$P(X,":",2)               ; task number in ^XTMP
"RTN","HMPDJFSG",80,0)
 S COUNT=$P(X,":",3)              ; count in this section
"RTN","HMPDJFSG",81,0)
 S DOMSIZE=$P(X,":",4)            ; estimated total for the domain
"RTN","HMPDJFSG",82,0)
 S SECSIZE=$P(X,":",5)            ; section size (for operational)
"RTN","HMPDJFSG",83,0)
 S BATCH="HMPFX~"_HMPFHMP_"~"_DFN ; extract node in ^XTMP
"RTN","HMPDJFSG",84,0)
 S OFFSET=COUNT-(HMPFIDX-HMPFSEQ)
"RTN","HMPDJFSG",85,0)
 F  S OFFSET=$O(^XTMP(BATCH,TASK,DOMAIN,OFFSET)) Q:'OFFSET  D  Q:HMPFCNT'<HMPFLIM
"RTN","HMPDJFSG",86,0)
 . ;;PJH;;S HMPFCNT=HMPFCNT+1            ; increment the count of returned items
"RTN","HMPDJFSG",87,0)
 . S HMPFSEQ=HMPFSEQ+1            ; increment the sequence number in the stream
"RTN","HMPDJFSG",88,0)
 . S HMPFSIZE=$$INCITEM($P(DOMAIN,"#"))  ;                  *S68-JCH*
"RTN","HMPDJFSG",89,0)
 . S ITEMNUM=OFFSET+($P(DOMAIN,"#",2)*SECSIZE)
"RTN","HMPDJFSG",90,0)
 . M ^TMP("HMPF",$J,HMPFCNT)=^XTMP(BATCH,TASK,DOMAIN,OFFSET)
"RTN","HMPDJFSG",91,0)
 . ;S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER(DOMAIN,PIDS,$S('COUNT:0,1:ITEMNUM),+DOMSIZE)
"RTN","HMPDJFSG",92,0)
 . S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER(DOMAIN,PIDS,$S('COUNT:0,1:ITEMNUM),+DOMSIZE,1)  ; *S68-JCH*
"RTN","HMPDJFSG",93,0)
 . S HMPLITEM="SYNC",HMPCLFLG=0 ; DE3502
"RTN","HMPDJFSG",94,0)
 Q
"RTN","HMPDJFSG",95,0)
MIDXTRCT() ; Return true if mid-extract
"RTN","HMPDJFSG",96,0)
 ; from GETSUB expects HMPFSTRM,HMPFSEQ
"RTN","HMPDJFSG",97,0)
 I 'HMPFSEQ Q 0
"RTN","HMPDJFSG",98,0)
 I '$D(^XTMP(HMPFSTRM,HMPFSEQ)) Q 1                  ; middle of extract
"RTN","HMPDJFSG",99,0)
 I $P(^XTMP(HMPFSTRM,HMPFSEQ),U,2)="syncDomain" Q 1  ; just starting extract
"RTN","HMPDJFSG",100,0)
 Q 0
"RTN","HMPDJFSG",101,0)
 ;
"RTN","HMPDJFSG",102,0)
NXTSTRM ; Reset variables for next date in this HMP stream
"RTN","HMPDJFSG",103,0)
 ; from GETSUB expects HMPFSTRM,HMPFDT,HMPFIDX
"RTN","HMPDJFSG",104,0)
 ; HMPFSTRM set to "" if no next stream
"RTN","HMPDJFSG",105,0)
 ; HMPFIDX  set to 0 if next stream, or left as is
"RTN","HMPDJFSG",106,0)
 ; HMPFDT   set to last date actually used
"RTN","HMPDJFSG",107,0)
 N NEXTDT,DONE
"RTN","HMPDJFSG",108,0)
 S NEXTDT=HMPFDT,DONE=0
"RTN","HMPDJFSG",109,0)
 F  D  Q:DONE
"RTN","HMPDJFSG",110,0)
 . S NEXTDT=$$FMADD^XLFDT(NEXTDT,1)
"RTN","HMPDJFSG",111,0)
 . I NEXTDT>$$DT^XLFDT S HMPFSTRM="" S DONE=1 Q
"RTN","HMPDJFSG",112,0)
 . S $P(HMPFSTRM,"~",3)=NEXTDT
"RTN","HMPDJFSG",113,0)
 . I '+$O(^XTMP(HMPFSTRM,0)) Q  ; nothing here, try next date
"RTN","HMPDJFSG",114,0)
 . S HMPFDT=NEXTDT,HMPFIDX=0,HMPFSEQ=0,DONE=1
"RTN","HMPDJFSG",115,0)
 Q
"RTN","HMPDJFSG",116,0)
 ;
"RTN","HMPDJFSG",117,0)
SETLIMIT(ARGS) ; sets HMPFLIM, HMPFMAX, HMPFSIZE variables  *BEGIN*S68-JCH*
"RTN","HMPDJFSG",118,0)
 I $G(ARGS("maxSize")) D  Q
"RTN","HMPDJFSG",119,0)
 . S HMPFLIM="s"
"RTN","HMPDJFSG",120,0)
 . S HMPFMAX=ARGS("maxSize")
"RTN","HMPDJFSG",121,0)
 . D GETLST^XPAR(.HMPFSIZE,"PKG","HMP DOMAIN SIZES","I")
"RTN","HMPDJFSG",122,0)
 . S HMPFSIZE=0
"RTN","HMPDJFSG",123,0)
 ; otherwise
"RTN","HMPDJFSG",124,0)
 S HMPFLIM="c"
"RTN","HMPDJFSG",125,0)
 S HMPFMAX=$G(ARGS("max"),99999)
"RTN","HMPDJFSG",126,0)
 S HMPFSIZE=0
"RTN","HMPDJFSG",127,0)
 Q
"RTN","HMPDJFSG",128,0)
 ;
"RTN","HMPDJFSG",129,0)
INCITEM(DOMAIN) ; increment counters as item added *BEGIN*S68-JCH*
"RTN","HMPDJFSG",130,0)
 S HMPFCNT=HMPFCNT+1
"RTN","HMPDJFSG",131,0)
 I HMPFLIM="s" Q HMPFSIZE+$G(HMPFSIZE(DOMAIN),1200)
"RTN","HMPDJFSG",132,0)
 I HMPFLIM="c" Q HMPFCNT
"RTN","HMPDJFSG",133,0)
 Q 0
"RTN","HMPDJFSG",134,0)
 ;                                                     *END*S68-JCH*
"RTN","HMPDJFSG",135,0)
 ;
"RTN","HMPDJFSG",136,0)
FINISH(HMPDEL,HMPERR) ;reset the FIRST object delimiter, add header and tail
"RTN","HMPDJFSG",137,0)
 ; expects HMPFCNT,HMPFDT,HMPFSEQ,HMPFHMP,HMPFLAST
"RTN","HMPDJFSG",138,0)
 N CLOSE,I,START,TEXT,UID,X,II
"RTN","HMPDJFSG",139,0)
 S X=$G(^TMP("HMPF",$J,1,.3))
"RTN","HMPDJFSG",140,0)
 I $E(X,1,2)="}," S X=$E(X,3,$L(X)),^TMP("HMPF",$J,1,.3)=X
"RTN","HMPDJFSG",141,0)
 S ^TMP("HMPF",$J,.5)=$$APIHDR(HMPFCNT,HMPFDT_"-"_HMPFSEQ)
"RTN","HMPDJFSG",142,0)
 I $D(HMPERR) D
"RTN","HMPDJFSG",143,0)
 .S CLOSE=$S(HMPFCNT:"},",1:""),START=1
"RTN","HMPDJFSG",144,0)
 .S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)=CLOSE_"{""error"":["
"RTN","HMPDJFSG",145,0)
 .S I=0 F  S I=$O(HMPERR(I)) Q:I'>0  D
"RTN","HMPDJFSG",146,0)
 ..S TEXT=HMPERR(I)
"RTN","HMPDJFSG",147,0)
 ..S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)=$S(START:"",1:",")_TEXT S START=0
"RTN","HMPDJFSG",148,0)
 .S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)="]"
"RTN","HMPDJFSG",149,0)
 ; operational sync item or patient
"RTN","HMPDJFSG",150,0)
 ; Check for closing flag & HMPFCNT and if it doesn't exist add a closing brace, always close array
"RTN","HMPDJFSG",151,0)
 S ^TMP("HMPF",$J,HMPFCNT+1)=$S(HMPFCNT&('$G(HMPCLFLG)):"}",1:"")_"]",HMPFCNT=HMPFCNT+1
"RTN","HMPDJFSG",152,0)
 ; modified
"RTN","HMPDJFSG",153,0)
 I $G(HMPSTGET)="true" D  ; true if "getStatus" argument passed in
"RTN","HMPDJFSG",154,0)
 . S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)=",""syncStatii"":[",START=1
"RTN","HMPDJFSG",155,0)
 . S I=0 F  S I=$O(^HMP(800000,I)) Q:+I=0  D
"RTN","HMPDJFSG",156,0)
 . . I $P($G(^HMP(800000,I,0)),"^",1)=HMPFHMP D
"RTN","HMPDJFSG",157,0)
 . . . S II=0 F  S II=$O(^HMP(800000,I,1,II)) Q:+II=0  D
"RTN","HMPDJFSG",158,0)
 . . . . S TEXT="{""pid"":"_II_",""status"":"_$P(^HMP(800000,I,1,II,0),"^",2)_"}"
"RTN","HMPDJFSG",159,0)
 . . . . S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)=$S(START:"",1:",")_TEXT S START=0
"RTN","HMPDJFSG",160,0)
 . S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)="]"
"RTN","HMPDJFSG",161,0)
 ;
"RTN","HMPDJFSG",162,0)
 S ^TMP("HMPF",$J,HMPFCNT+1)="}}"
"RTN","HMPDJFSG",163,0)
 ; remove any ^XTMP nodes that have been successfully sent based on LAST
"RTN","HMPDJFSG",164,0)
 N DATE,SEQ,LASTDT,LASTSEQ,STRM,LSTRM,RSTRM
"RTN","HMPDJFSG",165,0)
 S LASTDT=+$P(HMPFLAST,"-"),LASTSEQ=+$P(HMPFLAST,"-",2)
"RTN","HMPDJFSG",166,0)
 S RSTRM="HMPFS~"_HMPFHMP_"~",LSTRM=$L(RSTRM),STRM=RSTRM
"RTN","HMPDJFSG",167,0)
 F  S STRM=$O(^XTMP(STRM)) Q:'$L(STRM)  Q:$E(STRM,1,LSTRM)'=RSTRM  D
"RTN","HMPDJFSG",168,0)
 . S DATE=$P(STRM,"~",3) Q:DATE>LASTDT
"RTN","HMPDJFSG",169,0)
 . S SEQ=0 F  S SEQ=$O(^XTMP(STRM,"tidy",SEQ)) Q:'SEQ  Q:(DATE=LASTDT)&(SEQ>LASTSEQ)  D TIDYX(STRM,SEQ)
"RTN","HMPDJFSG",170,0)
 Q
"RTN","HMPDJFSG",171,0)
TIDYX(STREAM,SEQ) ; clean up extracts after they have been retrieved
"RTN","HMPDJFSG",172,0)
 ; from FINISH
"RTN","HMPDJFSG",173,0)
 N BATCH,DOMAIN,TASK
"RTN","HMPDJFSG",174,0)
 S BATCH=^XTMP(STREAM,"tidy",SEQ,"batch")
"RTN","HMPDJFSG",175,0)
 S DOMAIN=^XTMP(STREAM,"tidy",SEQ,"domain")
"RTN","HMPDJFSG",176,0)
 S TASK=^XTMP(STREAM,"tidy",SEQ,"task")
"RTN","HMPDJFSG",177,0)
 I DOMAIN="<done>" K ^XTMP(BATCH) I 1
"RTN","HMPDJFSG",178,0)
 E  K ^XTMP(BATCH,TASK,DOMAIN)
"RTN","HMPDJFSG",179,0)
 K ^XTMP(STREAM,"tidy",SEQ)
"RTN","HMPDJFSG",180,0)
 Q
"RTN","HMPDJFSG",181,0)
SYNCCMD(SEQNODE) ; Build syncCommand object and stick in ^TMP
"RTN","HMPDJFSG",182,0)
 ; expects: HMPSYS, HMPFCNT
"RTN","HMPDJFSG",183,0)
 N DFN,CMD,CMDJSON,ERR
"RTN","HMPDJFSG",184,0)
 S DFN=+SEQNODE
"RTN","HMPDJFSG",185,0)
 S CMD("command")=$P($P(SEQNODE,U,3),":")
"RTN","HMPDJFSG",186,0)
 S CMD("domain")=$P($P(SEQNODE,U,3),":",2)
"RTN","HMPDJFSG",187,0)
 S:DFN CMD("pid")=$$PID^HMPDJFS(DFN)
"RTN","HMPDJFSG",188,0)
 S CMD("system")=HMPSYS
"RTN","HMPDJFSG",189,0)
 D ENCODE^HMPJSON("CMD","CMDJSON","ERR")
"RTN","HMPDJFSG",190,0)
 I $D(ERR) S $EC=",UJSON encode error," Q
"RTN","HMPDJFSG",191,0)
 S HMPFSIZE=$$INCITEM("syncCommand")  ; *S68-JCH*
"RTN","HMPDJFSG",192,0)
 M ^TMP("HMPF",$J,HMPFCNT)=CMDJSON
"RTN","HMPDJFSG",193,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER("syncCommand",$$PIDS^HMPDJFS(DFN),1,1)
"RTN","HMPDJFSG",194,0)
 Q
"RTN","HMPDJFSG",195,0)
SYNCSTRT(SEQNODE) ; Build syncStart object with demograhics
"RTN","HMPDJFSG",196,0)
 ; expects HMPFSYS, HMPFHMP, HMPFCNT, HMPFSIZE   *S68-JCH*
"RTN","HMPDJFSG",197,0)
 S HMPFSIZE=$$INCITEM("patient")  ;              *S68-JCH*
"RTN","HMPDJFSG",198,0)
 N DFN,FILTER,DFN,WRAP
"RTN","HMPDJFSG",199,0)
 S DFN=$P($P(SEQNODE,U,3),"~",3) ; HMPFX~hmpSrvId~dfn
"RTN","HMPDJFSG",200,0)
 I DFN D
"RTN","HMPDJFSG",201,0)
 . N RSLT ;cpc 2015/10/01
"RTN","HMPDJFSG",202,0)
 . S FILTER("patientId")=DFN,FILTER("domain")="patient"
"RTN","HMPDJFSG",203,0)
 . D GET^HMPDJ(.RSLT,.FILTER)
"RTN","HMPDJFSG",204,0)
 . M ^TMP("HMPF",$J,HMPFCNT)=^TMP("HMP",$J,1)
"RTN","HMPDJFSG",205,0)
 ; for OPD there is no object, so 4th argument is 0 
"RTN","HMPDJFSG",206,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER("syncStart",$$PIDS^HMPDJFS(DFN),$S(DFN:1,1:-1),$S(DFN:1,1:-1))
"RTN","HMPDJFSG",207,0)
 Q
"RTN","HMPDJFSG",208,0)
SYNCDONE(SEQNODE) ; Build syncStatus object and stick in ^TMP
"RTN","HMPDJFSG",209,0)
 ;  expects: HMPFSYS, HMPFCNT, HMPFHMP, HMPFSIZE  *S68-JCH*
"RTN","HMPDJFSG",210,0)
 N HMPBATCH,DFN,STS,STSJSON,X,ERR
"RTN","HMPDJFSG",211,0)
 S HMPBATCH=$P(SEQNODE,U,3) ; HMPFX~hmpSrvId~dfn
"RTN","HMPDJFSG",212,0)
 S DFN=$P(HMPBATCH,"~",3)
"RTN","HMPDJFSG",213,0)
 S STS("uid")="urn:va:syncStatus:"_HMPFSYS_":"_DFN
"RTN","HMPDJFSG",214,0)
 S STS("initialized")="true"
"RTN","HMPDJFSG",215,0)
 I DFN S STS("localId")=DFN
"RTN","HMPDJFSG",216,0)
 S X="" F  S X=$O(^XTMP(HMPBATCH,0,"count",X)) Q:'$L(X)  D
"RTN","HMPDJFSG",217,0)
 . S STS("domainTotals",X)=^XTMP(HMPBATCH,0,"count",X)
"RTN","HMPDJFSG",218,0)
 ;===JD START===
"RTN","HMPDJFSG",219,0)
 ; If resubscribing a patient, just send demographics
"RTN","HMPDJFSG",220,0)
 I DFN'="OPD",$D(^HMP(800000,"AITEM",DFN)) D
"RTN","HMPDJFSG",221,0)
 . N HMP99
"RTN","HMPDJFSG",222,0)
 . S HMP99=""
"RTN","HMPDJFSG",223,0)
 . ; Reset all domain counts to zero except for demographics
"RTN","HMPDJFSG",224,0)
 . F  S HMP99=$O(STS("domainTotals",HMP99)) Q:'HMP99  I HMP99'="patient" S STS("domainTotals",HMP99)=0
"RTN","HMPDJFSG",225,0)
 ;===JD   END===
"RTN","HMPDJFSG",226,0)
 D ENCODE^HMPJSON("STS","STSJSON","ERR")
"RTN","HMPDJFSG",227,0)
 I $D(ERR) S $EC=",UJSON encode error," Q
"RTN","HMPDJFSG",228,0)
 S HMPFSIZE=$$INCITEM("syncstatus")  ; *S68-JCH*
"RTN","HMPDJFSG",229,0)
 M ^TMP("HMPF",$J,HMPFCNT)=STSJSON
"RTN","HMPDJFSG",230,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER("syncStatus",$$PIDS^HMPDJFS(DFN),1,1)
"RTN","HMPDJFSG",231,0)
 Q
"RTN","HMPDJFSG",232,0)
 ;
"RTN","HMPDJFSG",233,0)
SYNCMETA(SNODE) ; US11019 Build NEW syncStart object
"RTN","HMPDJFSG",234,0)
 ; expects HMPFSYS, HMPFHMP, HMPFCNT
"RTN","HMPDJFSG",235,0)
 ; need to rebuild SNODE because WRAPPER expects it to fall in
"RTN","HMPDJFSG",236,0)
 N BATCH,DFN,WRAP,METADOM
"RTN","HMPDJFSG",237,0)
 S DFN=$P(SNODE,U,1)
"RTN","HMPDJFSG",238,0)
 S METADOM=$P(SNODE,U,3)
"RTN","HMPDJFSG",239,0)
 S BATCH="HMPFX~"_HMPFHMP_"~"_DFN
"RTN","HMPDJFSG",240,0)
 S $P(SNODE,U,3)=BATCH
"RTN","HMPDJFSG",241,0)
 S HMPFSIZE=$$INCITEM("syncmeta") ;need to increment count
"RTN","HMPDJFSG",242,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER("syncStart"_"#"_METADOM,$$PIDS^HMPDJFS(DFN),$S(DFN:1,1:-1),$S(DFN:1,1:-1))
"RTN","HMPDJFSG",243,0)
 S ^TMP("HMPF",$J,HMPFCNT,1)="null" ;always null object with this record
"RTN","HMPDJFSG",244,0)
 S HMPCLFLG=0 ; DE3502
"RTN","HMPDJFSG",245,0)
 Q
"RTN","HMPDJFSG",246,0)
 ;
"RTN","HMPDJFSG",247,0)
SYNCERR(SNODE,HMPERR) ;
"RTN","HMPDJFSG",248,0)
 N BATCH,CNT,DFN,NUM,OFFSET,PIDS,TASK,TOTAL,X
"RTN","HMPDJFSG",249,0)
 S DFN=$P(SNODE,U),X=$P(SNODE,U,3)
"RTN","HMPDJFSG",250,0)
 S PIDS=$$PIDS^HMPDJFS(DFN)
"RTN","HMPDJFSG",251,0)
 S TASK=$P(X,":",2),TOTAL=$P(X,":",4)
"RTN","HMPDJFSG",252,0)
 S BATCH="HMPFX~"_HMPFHMP_"~"_DFN       ; extract node in ^XTMP
"RTN","HMPDJFSG",253,0)
 S CNT=$O(HMPERR(""),-1)
"RTN","HMPDJFSG",254,0)
 S NUM=0 F  S NUM=$O(^XTMP(BATCH,TASK,"error",NUM)) Q:NUM'>0  D
"RTN","HMPDJFSG",255,0)
 .S CNT=CNT+1 S HMPERR(CNT)=$G(^XTMP(BATCH,TASK,"error",NUM,1))
"RTN","HMPDJFSG",256,0)
 Q
"RTN","HMPDJFSG",257,0)
 ;
"RTN","HMPDJFSG",258,0)
FRESHITM(SEQNODE,DELETE,ERROR) ; Get freshness item and stick in ^TMP
"RTN","HMPDJFSG",259,0)
 ; expects HMPFSYS, HMPFHMP
"RTN","HMPDJFSG",260,0)
 N ACT,DFN,DOMAIN,ECNT,FILTER,ID,RSLT,UID,HMP97,HMPI,WRAP,HMPPAT7,HMPPAT8
"RTN","HMPDJFSG",261,0)
 S FILTER("noHead")=1
"RTN","HMPDJFSG",262,0)
 S DFN=$P(SEQNODE,U),DOMAIN=$P(SEQNODE,U,2),ID=$P(SEQNODE,U,3),ACT=$P(SEQNODE,U,4)
"RTN","HMPDJFSG",263,0)
 ;Next 2 IFs added to prevent <UNDEFINED> in LKUP^HMPDJ00.  JD - 3/4/16. DE3869
"RTN","HMPDJFSG",264,0)
 ;Make sure deletes ('@') are not included.
"RTN","HMPDJFSG",265,0)
 ;HMPFSTRM and HMPFIDX are defined in the GETSUB section above.
"RTN","HMPDJFSG",266,0)
 ;For "pt-select", which is an operational data domain, ID=patient IEN and DFN="OPD".
"RTN","HMPDJFSG",267,0)
 ;For ptient domains ID=DFN=patient IEN.
"RTN","HMPDJFSG",268,0)
 ;We want the checks to be for all patient domains and pt-select of the operational data domain.
"RTN","HMPDJFSG",269,0)
 ;Kill the freshness stream entry with the bad patient IEN.
"RTN","HMPDJFSG",270,0)
 I ACT'="@",DFN=+DFN,'$D(^DPT(DFN,0)) K ^XTMP(HMPFSTRM,HMPFIDX) Q  ;For patient domains
"RTN","HMPDJFSG",271,0)
 I ACT'="@",DOMAIN="pt-select",ID=+ID,'$D(^DPT(ID,0)) K ^XTMP(HMPFSTRM,HMPFIDX) Q
"RTN","HMPDJFSG",272,0)
 ;
"RTN","HMPDJFSG",273,0)
 ;==JD START
"RTN","HMPDJFSG",274,0)
 ;Create a phantom "patient" if visit is the domain
"RTN","HMPDJFSG",275,0)
 I DOMAIN="visit" D
"RTN","HMPDJFSG",276,0)
 .S HMPPAT7=HMPFIDX_".99",HMPPAT8=^XTMP(HMPFSTRM,HMPFIDX),$P(HMPPAT8,U,2)="patient"  ;BL;DE2280
"RTN","HMPDJFSG",277,0)
 .S ^XTMP(HMPFSTRM,HMPPAT7)=HMPPAT8
"RTN","HMPDJFSG",278,0)
 ;==JD END
"RTN","HMPDJFSG",279,0)
 ;
"RTN","HMPDJFSG",280,0)
 I ACT'="@" D
"RTN","HMPDJFSG",281,0)
 . S FILTER("id")=ID
"RTN","HMPDJFSG",282,0)
 . S FILTER("domain")=DOMAIN
"RTN","HMPDJFSG",283,0)
 . I DFN="OPD" D GET^HMPEF(.RSLT,.FILTER)
"RTN","HMPDJFSG",284,0)
 . I +DFN>0 D
"RTN","HMPDJFSG",285,0)
 ..  S FILTER("patientId")=DFN
"RTN","HMPDJFSG",286,0)
 ..  D  ; DE3691, add date/time with seconds to FILTER parameters, Feb 29 2016
"RTN","HMPDJFSG",287,0)
 ...   N DAY,SECS,TM S SECS=$P($G(^XTMP(HMPFSTRM,HMPFIDX)),U,5),DAY=$P(HMPFSTRM,"~",3)
"RTN","HMPDJFSG",288,0)
 ...   Q:('DAY)!('$L(SECS))  ; must have date and seconds, could be zero seconds (midnight)
"RTN","HMPDJFSG",289,0)
 ...   S TM=$S(SECS:SECS#60/100+(SECS#3600\60)/100+(SECS\3600)/100,SECS=0:".000001",1:"")  ; if zero (midnight) push to 1 second after
"RTN","HMPDJFSG",290,0)
 ...   Q:'$L(TM)  ; couldn't compute time
"RTN","HMPDJFSG",291,0)
 ...   S FILTER("freshnessDateTime")=DAY+TM
"RTN","HMPDJFSG",292,0)
 ..  D GET^HMPDJ(.RSLT,.FILTER)
"RTN","HMPDJFSG",293,0)
 I ACT'="@",$L($G(^TMP("HMP",$J,"error")))>0 D BLDSERR(DFN,.ERROR)  Q
"RTN","HMPDJFSG",294,0)
 I '$D(^TMP("HMP",$J,1)) S ACT="@"
"RTN","HMPDJFSG",295,0)
 I ACT="@" D
"RTN","HMPDJFSG",296,0)
 . S UID=$$SETUID^HMPUTILS(DOMAIN,$S(+DFN>0:DFN,1:""),ID)
"RTN","HMPDJFSG",297,0)
 . S HMP97=UID
"RTN","HMPDJFSG",298,0)
 . K ^TMP("HMP",$J) S ^TMP("HMP",$J,1)="" ; Need to dummy this up or it will never get set later
"RTN","HMPDJFSG",299,0)
 ;
"RTN","HMPDJFSG",300,0)
 ;Add syncstart, data and syncstatus to JSON for unsolicited updates - US4588 & US3682
"RTN","HMPDJFSG",301,0)
 I (DOMAIN="pt-select")!(DOMAIN="user")!(DOMAIN["asu-")!(DOMAIN="doc-def")!(DFN=+DFN) D  Q
"RTN","HMPDJFSG",302,0)
 .D ADHOC^HMPUTIL1(DOMAIN,.HMPFCNT,DFN)
"RTN","HMPDJFSG",303,0)
 .I $P(HMPFIDX,".",2)=99 K ^XTMP(HMPFSTRM,HMPFIDX) ;Remove the phantom "patient"; JD
"RTN","HMPDJFSG",304,0)
 .S HMPLITEM="FRESH" ; DE3502
"RTN","HMPDJFSG",305,0)
 ;
"RTN","HMPDJFSG",306,0)
 S WRAP=$$WRAPPER(DOMAIN,$$PIDS^HMPDJFS(DFN),1,1) ; N.B. this updates the .3 node on this HMPFCNT
"RTN","HMPDJFSG",307,0)
 F HMPI=1:1 Q:'$D(^TMP("HMP",$J,HMPI))  D
"RTN","HMPDJFSG",308,0)
 . S HMPFCNT=HMPFCNT+1
"RTN","HMPDJFSG",309,0)
 . M ^TMP("HMPF",$J,HMPFCNT)=^TMP("HMP",$J,HMPI)
"RTN","HMPDJFSG",310,0)
 . I HMPLITEM="SYNC" S HMPLITEM="FRESH" I WRAP="," S ^TMP("HMPF",$J,HMPFCNT,.3)="}," Q  ; DE3502 add closing
"RTN","HMPDJFSG",311,0)
 . S ^TMP("HMPF",$J,HMPFCNT,.3)=WRAP
"RTN","HMPDJFSG",312,0)
 Q
"RTN","HMPDJFSG",313,0)
 ;
"RTN","HMPDJFSG",314,0)
BLDSERR(DFN,ERROR) ; Create syncError object in ERRJSON
"RTN","HMPDJFSG",315,0)
 ; expects: HMPBATCH, HMPFSYS, HMPFZTSK
"RTN","HMPDJFSG",316,0)
 N COUNT,ERRVAL,ERROBJ,ERR,ERRCNT,ERRMSG,SYNCERR
"RTN","HMPDJFSG",317,0)
 M ERRVAL=^TMP("HMP",$J,"error")
"RTN","HMPDJFSG",318,0)
 I $G(ERRVAL)="" Q
"RTN","HMPDJFSG",319,0)
 S ERRVAL="{"_ERRVAL_"}"
"RTN","HMPDJFSG",320,0)
 D DECODE^HMPJSON("ERRVAL","ERROBJ","ERR")
"RTN","HMPDJFSG",321,0)
 I $D(ERR) S $EC=",UJSON decode error,"
"RTN","HMPDJFSG",322,0)
 S ERRMSG=ERROBJ("error","message")
"RTN","HMPDJFSG",323,0)
 Q:'$L(ERRMSG)
"RTN","HMPDJFSG",324,0)
 S SYNCERR("uid")="urn:va:syncError:"_HMPFSYS_":"_DFN_":FRESHNESS"
"RTN","HMPDJFSG",325,0)
 S SYNCERR("collection")=DOMAIN
"RTN","HMPDJFSG",326,0)
 S SYNCERR("error")=ERRMSG
"RTN","HMPDJFSG",327,0)
 D ENCODE^HMPJSON("SYNCERR","ERRJSON","ERR") I $D(ERR) S $EC=",UJSON encode error," Q
"RTN","HMPDJFSG",328,0)
 S COUNT=$O(ERROR(""),-1)  ;                      *BEGIN*S68-JCH*
"RTN","HMPDJFSG",329,0)
 S ERRCNT=0 F  S ERRCNT=$O(ERRJSON(ERRCNT)) Q:ERRCNT'>0  D
"RTN","HMPDJFSG",330,0)
 .S COUNT=COUNT+1 M ERROR(COUNT)=ERRJSON(COUNT)  ;  *END*S68-JCH*
"RTN","HMPDJFSG",331,0)
 Q
"RTN","HMPDJFSG",332,0)
WRAPPER(DOMAIN,PIDS,OFFSET,DOMSIZE,FROMXTR) ; return JSON wrapper for each item *S68-JCH*
"RTN","HMPDJFSG",333,0)
 ; add object tag if extract total not zero or if total passed as -1
"RTN","HMPDJFSG",334,0)
 ; seq and total tags only added if non-zero
"RTN","HMPDJFSG",335,0)
 N X,Y,Z,HMPSVERS ;US11019
"RTN","HMPDJFSG",336,0)
 ; Ensure that X exists
"RTN","HMPDJFSG",337,0)
 S X=""
"RTN","HMPDJFSG",338,0)
 S Z=$P(SNODE,U,3)
"RTN","HMPDJFSG",339,0)
 S HMPSVERS=$G(^XTMP(Z,"HMPSVERS")) ;US11019 If HMPSVERS=0 then running in previous mode
"RTN","HMPDJFSG",340,0)
 S HMPSTMP=$G(^XTMP(Z,"HMPSTMP")) ;; PJH - THIS USED ONLY FOR OPD COMPILE IN PRIOR VERSION - NEEDS REMOVING US6734
"RTN","HMPDJFSG",341,0)
 ; This was working for operational data, not patient data
"RTN","HMPDJFSG",342,0)
 ; DFN will be OPD if this is operational data (non-obvious I know)
"RTN","HMPDJFSG",343,0)
 I DFN="OPD" D
"RTN","HMPDJFSG",344,0)
 . S:$P($G(DOMAIN),"#")'="syncStart" X="},{""collection"":"""_$P(DOMAIN,"#")_""""_PIDS ;US11019
"RTN","HMPDJFSG",345,0)
 E  S X="},{""collection"":"""_$P(DOMAIN,"#")_""""_PIDS  ; If ONLY patient data exists
"RTN","HMPDJFSG",346,0)
 I HMPLITEM="FRESH" I $E(X)="}" S X=$E(X,2,$L(X)) ; DE3502 - remove closing when coming from Fresh
"RTN","HMPDJFSG",347,0)
 I $P(DOMAIN,"#")="syncStart",$O(^XTMP(Z,0))]"" D  Q X
"RTN","HMPDJFSG",348,0)
 .; --- Start US3907 ---
"RTN","HMPDJFSG",349,0)
 .; Pass JobId and RootJobId back in the response if we were given them
"RTN","HMPDJFSG",350,0)
 .; This bridges the gap between Job status and Sync Status (since VistA will be giving the syncStatus)
"RTN","HMPDJFSG",351,0)
 .; US11019 use domain specific Job id
"RTN","HMPDJFSG",352,0)
 .S Y=$S($P(DOMAIN,"#",2)="":$G(^XTMP(Z,"JOBID")),1:$G(^XTMP(Z,"JOBID",$P(DOMAIN,"#",2)))) ;US11019
"RTN","HMPDJFSG",353,0)
 .I Y]"" S X=X_",""jobId"":"""_Y_""""
"RTN","HMPDJFSG",354,0)
 .S Y=$G(^XTMP(Z,"ROOTJOBID"))
"RTN","HMPDJFSG",355,0)
 .I Y]"" S X=X_",""rootJobId"":"""_Y_""""
"RTN","HMPDJFSG",356,0)
 .; --- End US3907 ---
"RTN","HMPDJFSG",357,0)
 .I DFN'="OPD" D METAPT^HMPMETA(SNODE,$S(HMPSVERS:$P(DOMAIN,"#",2),1:"")) Q  ; US11019 extra para ;Collect Patient metastamp data from XTMP - US6734
"RTN","HMPDJFSG",358,0)
 .D METAOP^HMPMETA(SNODE) ; Collect OPD metastamp data from XTMP - US6734
"RTN","HMPDJFSG",359,0)
 S X=X_","
"RTN","HMPDJFSG",360,0)
 ; if batched by extract  *S68-JCH*
"RTN","HMPDJFSG",361,0)
 I $G(OFFSET)>-1 S X=X_"""seq"":"_OFFSET_","
"RTN","HMPDJFSG",362,0)
 I $G(DOMSIZE)>-1 S X=X_"""total"":"_DOMSIZE_","
"RTN","HMPDJFSG",363,0)
 I $G(OFFSET)>-1 S X=X_"""object"":"
"RTN","HMPDJFSG",364,0)
 Q X
"RTN","HMPDJFSG",365,0)
 ;
"RTN","HMPDJFSG",366,0)
APIHDR(COUNT,LASTITM) ; return JSON
"RTN","HMPDJFSG",367,0)
 ; expects HMPFSYS
"RTN","HMPDJFSG",368,0)
 I $P($G(LASTITM),".",2)="99" S LASTITM=$P(LASTITM,".")  ;make sure lastUpdate is correct;JD;BL;DE2280
"RTN","HMPDJFSG",369,0)
 N X
"RTN","HMPDJFSG",370,0)
 S X="{""apiVersion"":1.02,""params"":{""domain"":"""_$$KSP^XUPARAM("WHERE")_""""
"RTN","HMPDJFSG",371,0)
 S X=X_",""systemId"":"""_HMPFSYS_"""},""data"":{""updated"":"""_$$HL7NOW^HMPDJ_""""
"RTN","HMPDJFSG",372,0)
 S X=X_",""totalItems"":"_COUNT_",""lastUpdate"":"""_LASTITM_""""_$$PROGRESS^HMPDJFS(LASTITM)
"RTN","HMPDJFSG",373,0)
 S X=X_",""items"":["
"RTN","HMPDJFSG",374,0)
 Q X
"RTN","HMPDJFSG",375,0)
 ;
"RTN","HMPDJFSG",376,0)
NOOP(LASTITM) ; No-op, don't return any items
"RTN","HMPDJFSG",377,0)
 S ^TMP("HMPF",$J,.5)=$$APIHDR(0,LASTITM)_"]}}"
"RTN","HMPDJFSG",378,0)
 Q
"RTN","HMPDJFSG",379,0)
VERMATCH(HMPIEN,VERSION) ; true if middle tier HMP and VistA version match
"RTN","HMPDJFSG",380,0)
 ; versions match, queue any patients waiting for match
"RTN","HMPDJFSG",381,0)
 I $P($$GET^XPAR("PKG","HMP JSON SCHEMA"),".")=$P(VERSION,".") D  QUIT 1
"RTN","HMPDJFSG",382,0)
 . Q:'$G(^XTMP("HMPFS~"_HMPIEN,"waiting"))  ; no patients awaiting queuing
"RTN","HMPDJFSG",383,0)
 . S ^XTMP("HMPFS~"_HMPIEN,"waiting")=0
"RTN","HMPDJFSG",384,0)
 . N DOMAINS,BATCH,HMPNAME
"RTN","HMPDJFSG",385,0)
 . S HMPNAME=$P(^HMP(800000,HMPIEN,0),U)
"RTN","HMPDJFSG",386,0)
 . D PTDOMS^HMPDJFSD(.DOMAINS)
"RTN","HMPDJFSG",387,0)
 . S DFN=0 F  S DFN=$O(^XTMP("HMPFS~"_HMPIEN,"waiting",DFN)) Q:'DFN  D
"RTN","HMPDJFSG",388,0)
 . . Q:'$D(^HMP(800000,HMPIEN,1,DFN))  ; subscription cancelled while waiting  *S68-JCH*
"RTN","HMPDJFSG",389,0)
 . . S BATCH="HMPFX~"_HMPNAME_"~"_DFN
"RTN","HMPDJFSG",390,0)
 . . D QUINIT^HMPDJFSP(BATCH,DFN,.DOMAINS)
"RTN","HMPDJFSG",391,0)
 . K ^XTMP("HMPFS~"_HMPIEN)
"RTN","HMPDJFSG",392,0)
 ;
"RTN","HMPDJFSG",393,0)
 ; otherwise, hold things
"RTN","HMPDJFSG",394,0)
 D NEWXTMP^HMPDJFS("HMPFS~"_HMPIEN,8,"HMP Awaiting Version Match")
"RTN","HMPDJFSG",395,0)
 S ^XTMP("HMPFS~"_HMPIEN,"waiting")=1
"RTN","HMPDJFSG",396,0)
 Q 0
"RTN","HMPDJFSG",397,0)
 ;
"RTN","HMPDJFSG",398,0)
LASTUPD(HMPSRV,LASTUPD) ; save the last update
"RTN","HMPDJFSG",399,0)
 ; TODO: change this to use Fileman call
"RTN","HMPDJFSG",400,0)
 N IEN,CURRUPD,REPEAT
"RTN","HMPDJFSG",401,0)
 S IEN=$O(^HMP(800000,"B",HMPSRV,0)) Q:'IEN
"RTN","HMPDJFSG",402,0)
 Q:LASTUPD["^"
"RTN","HMPDJFSG",403,0)
 S CURRUPD=$P(^HMP(800000,IEN,0),"^",2),REPEAT=$P(^HMP(800000,IEN,0),"^",4)
"RTN","HMPDJFSG",404,0)
 I LASTUPD=CURRUPD S $P(^HMP(800000,IEN,0),"^",4)=REPEAT+1 QUIT
"RTN","HMPDJFSG",405,0)
 S $P(^HMP(800000,IEN,0),"^",2)=LASTUPD,$P(^HMP(800000,IEN,0),"^",4)=0
"RTN","HMPDJFSG",406,0)
 Q
"RTN","HMPDJFSG",407,0)
JSONOUT ; Write out JSON in ^TMP
"RTN","HMPDJFSG",408,0)
 N X
"RTN","HMPDJFSG",409,0)
 S X=$NA(^TMP("HMPF",$J))
"RTN","HMPDJFSG",410,0)
 F  S X=$Q(@X) Q:($QS(X,1)'="HMPF")!($QS(X,2)'=$J)  W !,@X
"RTN","HMPDJFSG",411,0)
 Q
"RTN","HMPDJFSG",412,0)
 ;
"RTN","HMPDJFSM")
0^18^B83803111
"RTN","HMPDJFSM",1,0)
HMPDJFSM ;SLC/KCM,ASMR/RRB,CK-PROTOCOLS & API's FOR MONITORING ;2016-07-25 14:32
"RTN","HMPDJFSM",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;Sep 01, 2011;Build 24
"RTN","HMPDJFSM",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFSM",4,0)
 ;
"RTN","HMPDJFSM",5,0)
 Q  ; no entry at top
"RTN","HMPDJFSM",6,0)
 ;
"RTN","HMPDJFSM",7,0)
 ;
"RTN","HMPDJFSM",8,0)
 ;
"RTN","HMPDJFSM",9,0)
 ; contents
"RTN","HMPDJFSM",10,0)
 ;
"RTN","HMPDJFSM",11,0)
 ; subroutines that support API^HMPDJFS
"RTN","HMPDJFSM",12,0)
 ;
"RTN","HMPDJFSM",13,0)
 ; HLTHCHK: check health of VistA Server subscription
"RTN","HMPDJFSM",14,0)
 ; $$HLTHINFO = domain progress in json
"RTN","HMPDJFSM",15,0)
 ; $$HLTHHDR = domain-progress header in json
"RTN","HMPDJFSM",16,0)
 ;
"RTN","HMPDJFSM",17,0)
 ; subroutines that support SRV^HMPEQ & EVTS^HMPEQ
"RTN","HMPDJFSM",18,0)
 ;
"RTN","HMPDJFSM",19,0)
 ; $$LSTREAM = latest stream for this server
"RTN","HMPDJFSM",20,0)
 ; $$WAIT = # seconds the batch has been waiting
"RTN","HMPDJFSM",21,0)
 ; $$LOBJ = last domain>count retrieved for this batch
"RTN","HMPDJFSM",22,0)
 ;
"RTN","HMPDJFSM",23,0)
 ; subroutines that support protocol menu HMPM EVT QUE MGR MENU
"RTN","HMPDJFSM",24,0)
 ;
"RTN","HMPDJFSM",25,0)
 ; $$GETSRV = protocol HMPM EVT QUE CHANGE SERVER [Change Server]
"RTN","HMPDJFSM",26,0)
 ; EMERSTOP: protocol HMPM EVT QUE EMERGENCY STOP [not distributed]
"RTN","HMPDJFSM",27,0)
 ; RSTRTFR: protocol HMPM EVT QUE RESTART FRESHNESS [not distributed]
"RTN","HMPDJFSM",28,0)
 ; SETFRUP: set flag for freshness updates
"RTN","HMPDJFSM",29,0)
 ; CHGFTYP: change the freshness update flag for domain
"RTN","HMPDJFSM",30,0)
 ; STOPFTYP: stop freshness updates for domain
"RTN","HMPDJFSM",31,0)
 ; STRTFTYP: resume freshness updates for domain
"RTN","HMPDJFSM",32,0)
 ; $$GETFTYP = select & return domain from list
"RTN","HMPDJFSM",33,0)
 ; SHOWFTYP: show freshness domains
"RTN","HMPDJFSM",34,0)
 ; EVNTYPS: protocol HMPM EVT QUE CHANGE DOMAIN [Change Domain]
"RTN","HMPDJFSM",35,0)
 ;
"RTN","HMPDJFSM",36,0)
 ; 
"RTN","HMPDJFSM",37,0)
 ;
"RTN","HMPDJFSM",38,0)
 ; subroutines that support API^HMPDJFS
"RTN","HMPDJFSM",39,0)
 ;
"RTN","HMPDJFSM",40,0)
 ;
"RTN","HMPDJFSM",41,0)
ADDPT(PAT) ; Add patient to server
"RTN","HMPDJFSM",42,0)
 N SRV,ARGS,RESULT
"RTN","HMPDJFSM",43,0)
 I '$G(PAT) S PAT=$$GETPAT() Q:'PAT
"RTN","HMPDJFSM",44,0)
 S SRV=$$GETSRV() Q:SRV'>0
"RTN","HMPDJFSM",45,0)
 I $G(^HMP(800000,"AITEM",PAT,SRV))>0 W !,"Patient "_PAT_" already synced."
"RTN","HMPDJFSM",46,0)
 ;
"RTN","HMPDJFSM",47,0)
 S ARGS("command")="putPtSubscription"
"RTN","HMPDJFSM",48,0)
 S ARGS("server")=$P(^HMP(800000,SRV,0),"^")
"RTN","HMPDJFSM",49,0)
 S ARGS("localId")=PAT
"RTN","HMPDJFSM",50,0)
 D API^HMPDJFS(.RESULT,.ARGS)
"RTN","HMPDJFSM",51,0)
 I ^TMP("HMPF",$J,1)["location" W !,$P($G(^DPT(PAT,0)),"^")," is being synced."
"RTN","HMPDJFSM",52,0)
 ; IA10035, DE2818
"RTN","HMPDJFSM",53,0)
 E  W !,"Subscription failed."
"RTN","HMPDJFSM",54,0)
 Q
"RTN","HMPDJFSM",55,0)
 ;
"RTN","HMPDJFSM",56,0)
GETPAT() ; Return DFN for a patient
"RTN","HMPDJFSM",57,0)
 N DIC,Y
"RTN","HMPDJFSM",58,0)
 S DIC=2,DIC(0)="AEMQ"  ; DE2818, changed to file number, not global
"RTN","HMPDJFSM",59,0)
 D ^DIC
"RTN","HMPDJFSM",60,0)
 Q +Y
"RTN","HMPDJFSM",61,0)
 ;
"RTN","HMPDJFSM",62,0)
HLTHCHK(ARGS) ; check health of VistA Server subscription
"RTN","HMPDJFSM",63,0)
 ; called by:
"RTN","HMPDJFSM",64,0)
 ;   API^HMPDJFS: asynchronous extracts & freshness via stream
"RTN","HMPDJFSM",65,0)
 ; calls:
"RTN","HMPDJFSM",66,0)
 ;   SETERR^HMPDJFS: log error
"RTN","HMPDJFSM",67,0)
 ;   $$HLTHINFO = progress for this domain
"RTN","HMPDJFSM",68,0)
 ;   $$HLTHHDR = json header for progress report
"RTN","HMPDJFSM",69,0)
 ; input:
"RTN","HMPDJFSM",70,0)
 ;   .ARGS("server") = HMP Server Id
"RTN","HMPDJFSM",71,0)
 ;  also these, created by API^HMPDJFS, passed thru symbol table:
"RTN","HMPDJFSM",72,0)
 ;   HMPFRSP = [unused?]
"RTN","HMPDJFSM",73,0)
 ;   HMPFHMP = server name
"RTN","HMPDJFSM",74,0)
 ;   HMPSYS = system id
"RTN","HMPDJFSM",75,0)
 ; output: in ^TMP("HMPF",$job,node): list of active extracts
"RTN","HMPDJFSM",76,0)
 ;   {pid="ABCD;229",domainsCompleted=8,domainsPending=20,
"RTN","HMPDJFSM",77,0)
 ;   objectCount=137,subscribeTime=20140609112734,
"RTN","HMPDJFSM",78,0)
 ;   extractStatus="initializing"}
"RTN","HMPDJFSM",79,0)
 ;
"RTN","HMPDJFSM",80,0)
 N HMPIEN,STS,TIME,DFN
"RTN","HMPDJFSM",81,0)
 S HMPIEN=$O(^HMP(800000,"B",HMPFHMP,0))
"RTN","HMPDJFSM",82,0)
 I 'HMPIEN D SETERR^HMPDJFS("Server not registered") QUIT
"RTN","HMPDJFSM",83,0)
 S NODE=0
"RTN","HMPDJFSM",84,0)
 S STS="" F  S STS=$O(^HMP(800000,HMPIEN,1,"AP",STS)) Q:'$L(STS)  D
"RTN","HMPDJFSM",85,0)
 . S TIME="" F  S TIME=$O(^HMP(800000,HMPIEN,1,"AP",STS,TIME)) Q:'$L(TIME)  D
"RTN","HMPDJFSM",86,0)
 . . S DFN="" F  S DFN=$O(^HMP(800000,HMPIEN,1,"AP",STS,TIME,DFN)) Q:'DFN  D
"RTN","HMPDJFSM",87,0)
 . . . S NODE=NODE+1
"RTN","HMPDJFSM",88,0)
 . . . S ^TMP("HMPF",$J,NODE)=$$HLTHINFO(HMPFHMP,HMPIEN,DFN)
"RTN","HMPDJFSM",89,0)
 S ^TMP("HMPF",$J,.5)=$$HLTHHDR(NODE)
"RTN","HMPDJFSM",90,0)
 S ^TMP("HMPF",$J,NODE+1)="]}}"
"RTN","HMPDJFSM",91,0)
 ;
"RTN","HMPDJFSM",92,0)
 quit  ; end of HLTHCHK
"RTN","HMPDJFSM",93,0)
 ;
"RTN","HMPDJFSM",94,0)
 ;
"RTN","HMPDJFSM",95,0)
HLTHINFO(SRV,SRVIEN,DFN) ; domain progress in json
"RTN","HMPDJFSM",96,0)
 ; called by:
"RTN","HMPDJFSM",97,0)
 ;   HLTHCHK
"RTN","HMPDJFSM",98,0)
 ; calls:
"RTN","HMPDJFSM",99,0)
 ;   $$HTFM^XLFDT = convert $horolog date-time to fileman
"RTN","HMPDJFSM",100,0)
 ;   $$PID^HMPDJFS = convert patient dfn to patient id format
"RTN","HMPDJFSM",101,0)
 ;   $$FMTHL7^XLFDT = convert fileman date-time to hl7 (iso)
"RTN","HMPDJFSM",102,0)
 ;   ENCODE^HMPJSON: convert mumps array to json to return
"RTN","HMPDJFSM",103,0)
 ; input:
"RTN","HMPDJFSM",104,0)
 ;   SRV = name of server, to use in ^XTMP subscripts
"RTN","HMPDJFSM",105,0)
 ;   SRVIEN = record # in file HMP Subscription (800000)
"RTN","HMPDJFSM",106,0)
 ;   DFN = record # in file Patient (2)
"RTN","HMPDJFSM",107,0)
 ; output = string of JSON reporting progress for this domain
"RTN","HMPDJFSM",108,0)
 ;   {pid,domainsCompleted,domainsPending,objectCount,queuedTime,
"RTN","HMPDJFSM",109,0)
 ;   phase(waiting,extracting)
"RTN","HMPDJFSM",110,0)
 ;
"RTN","HMPDJFSM",111,0)
 N BATCH,QTIME,DONE,PEND,CNT,DOM,INFO,STS,JSON
"RTN","HMPDJFSM",112,0)
 S BATCH="HMPFX~"_SRV_"~"_DFN
"RTN","HMPDJFSM",113,0)
 S QTIME=$G(^XTMP(BATCH,0,"time")) S:$L(QTIME) QTIME=$$HTFM^XLFDT(QTIME)
"RTN","HMPDJFSM",114,0)
 S DONE=0,PEND=0,CNT=0
"RTN","HMPDJFSM",115,0)
 S DOM="" F  S DOM=$O(^XTMP(BATCH,0,"status",DOM)) Q:DOM=""  D
"RTN","HMPDJFSM",116,0)
 . S CNT=CNT+$G(^XTMP(BATCH,0,"count",DOM))
"RTN","HMPDJFSM",117,0)
 . I $G(^XTMP(BATCH,0,"status",DOM)) S DONE=DONE+1 QUIT
"RTN","HMPDJFSM",118,0)
 . S PEND=PEND+1
"RTN","HMPDJFSM",119,0)
 S INFO("pid")=$$PID^HMPDJFS(DFN)
"RTN","HMPDJFSM",120,0)
 S INFO("domainsCompleted")=DONE
"RTN","HMPDJFSM",121,0)
 S INFO("domainsPending")=PEND
"RTN","HMPDJFSM",122,0)
 S INFO("objectCount")=CNT
"RTN","HMPDJFSM",123,0)
 I $L(QTIME) S INFO("queuedTime")=$$FMTHL7^HMPSTMP(QTIME)  ; DE5016
"RTN","HMPDJFSM",124,0)
 S STS=$P($G(^HMP(800000,SRVIEN,1,DFN,0)),"^",2)
"RTN","HMPDJFSM",125,0)
 S INFO("extractStatus")=$S(STS=1:"initializing",STS=2:"initialized",1:"uninitialized")
"RTN","HMPDJFSM",126,0)
 D ENCODE^HMPJSON("INFO","JSON")
"RTN","HMPDJFSM",127,0)
 ;
"RTN","HMPDJFSM",128,0)
 quit JSON(1) ; return domain progress ; end of $$HLTHINFO
"RTN","HMPDJFSM",129,0)
 ;
"RTN","HMPDJFSM",130,0)
 ;
"RTN","HMPDJFSM",131,0)
HLTHHDR(COUNT) ; domain-progress header in json
"RTN","HMPDJFSM",132,0)
 ; called by:
"RTN","HMPDJFSM",133,0)
 ;   HLTHCHK
"RTN","HMPDJFSM",134,0)
 ; calls:
"RTN","HMPDJFSM",135,0)
 ;   $$KSP^XUPARAM = return kernel system parameter WHERE (domain)
"RTN","HMPDJFSM",136,0)
 ;   $$HL7NOW^HMPDJ = current date-time in hl7 (iso) format
"RTN","HMPDJFSM",137,0)
 ; input:
"RTN","HMPDJFSM",138,0)
 ;   COUNT = total # items
"RTN","HMPDJFSM",139,0)
 ;   HMPSYS = system id [passed through symbol table]
"RTN","HMPDJFSM",140,0)
 ; output = json header
"RTN","HMPDJFSM",141,0)
 ;
"RTN","HMPDJFSM",142,0)
 N X
"RTN","HMPDJFSM",143,0)
 S X="{""apiVersion"":1.02,""params"":{""domain"":"""_$$KSP^XUPARAM("WHERE")_""""
"RTN","HMPDJFSM",144,0)
 S X=X_",""systemId"":"""_HMPSYS_"""},""data"":{""updated"":"""_$$HL7NOW^HMPDJ_""""
"RTN","HMPDJFSM",145,0)
 S X=X_",""totalItems"":"_COUNT
"RTN","HMPDJFSM",146,0)
 S X=X_",""items"":["
"RTN","HMPDJFSM",147,0)
 ;
"RTN","HMPDJFSM",148,0)
 quit X ; return domain-progress header ; end of $$HLTHHDR
"RTN","HMPDJFSM",149,0)
 ;
"RTN","HMPDJFSM",150,0)
 ;
"RTN","HMPDJFSM",151,0)
 ;
"RTN","HMPDJFSM",152,0)
 ; subroutines that support SRV^HMPEQ & EVTS^HMPEQ
"RTN","HMPDJFSM",153,0)
 ;
"RTN","HMPDJFSM",154,0)
 ;
"RTN","HMPDJFSM",155,0)
 ;
"RTN","HMPDJFSM",156,0)
LSTREAM(SRV) ; latest stream for this server
"RTN","HMPDJFSM",157,0)
 ; called by:
"RTN","HMPDJFSM",158,0)
 ;   EVTS^HMPEQ: return events for server's last stream
"RTN","HMPDJFSM",159,0)
 ;   SRV^HMPEQ: process one server
"RTN","HMPDJFSM",160,0)
 ; calls: none
"RTN","HMPDJFSM",161,0)
 ; input:
"RTN","HMPDJFSM",162,0)
 ;   SRV = ien of server in file HMP Subscription (8000000)
"RTN","HMPDJFSM",163,0)
 ; output = last stream id for this server
"RTN","HMPDJFSM",164,0)
 ;
"RTN","HMPDJFSM",165,0)
 N STREAM
"RTN","HMPDJFSM",166,0)
 S STREAM="HMPFS~"_$P($G(^HMP(800000,SRV,0)),"^")_"~9999999"
"RTN","HMPDJFSM",167,0)
 S STREAM=$O(^XTMP(STREAM),-1)
"RTN","HMPDJFSM",168,0)
 ;
"RTN","HMPDJFSM",169,0)
 quit STREAM ; return last stream id ; end of $$LSTREAM
"RTN","HMPDJFSM",170,0)
 ;
"RTN","HMPDJFSM",171,0)
 ;
"RTN","HMPDJFSM",172,0)
WAIT(BATCH) ; # seconds the batch has been waiting
"RTN","HMPDJFSM",173,0)
 ; called by:
"RTN","HMPDJFSM",174,0)
 ;   SRV^HMPEQ: process one server
"RTN","HMPDJFSM",175,0)
 ; calls:
"RTN","HMPDJFSM",176,0)
 ;   $$HDIFF^XLFDT
"RTN","HMPDJFSM",177,0)
 ; input:
"RTN","HMPDJFSM",178,0)
 ;   BATCH = extract batch
"RTN","HMPDJFSM",179,0)
 ; output = # seconds the batch has been waiting
"RTN","HMPDJFSM",180,0)
 ;
"RTN","HMPDJFSM",181,0)
 N START
"RTN","HMPDJFSM",182,0)
 S START=$G(^XTMP(BATCH,0,"time")) Q:'START 0
"RTN","HMPDJFSM",183,0)
 N WAIT S WAIT=$$HDIFF^XLFDT($H,START,2)
"RTN","HMPDJFSM",184,0)
 ;
"RTN","HMPDJFSM",185,0)
 quit WAIT ; return # seconds waiting ; end of $$WAIT
"RTN","HMPDJFSM",186,0)
 ;
"RTN","HMPDJFSM",187,0)
 ;
"RTN","HMPDJFSM",188,0)
LOBJ(BATCH,TASK) ; last domain>count retrieved for this batch
"RTN","HMPDJFSM",189,0)
 ; called by:
"RTN","HMPDJFSM",190,0)
 ;   SRV^HMPEQ: process one server
"RTN","HMPDJFSM",191,0)
 ; calls: none
"RTN","HMPDJFSM",192,0)
 ; input:
"RTN","HMPDJFSM",193,0)
 ;   BATCH = extract batch
"RTN","HMPDJFSM",194,0)
 ;   TASK = extract-batch task id
"RTN","HMPDJFSM",195,0)
 ; output = last domain if any, or <finished> if none
"RTN","HMPDJFSM",196,0)
 ;
"RTN","HMPDJFSM",197,0)
 Q:'TASK "no task"
"RTN","HMPDJFSM",198,0)
 N LASTITM,DOMAIN,NUM
"RTN","HMPDJFSM",199,0)
 S LASTITM=""
"RTN","HMPDJFSM",200,0)
 S DOMAIN="",LASTITM=""
"RTN","HMPDJFSM",201,0)
 F  S DOMAIN=$O(^XTMP(BATCH,0,"status",DOMAIN)) Q:'$L(DOMAIN)  D  Q:$L(LASTITM)
"RTN","HMPDJFSM",202,0)
 . I $G(^XTMP(BATCH,0,"status",DOMAIN)) Q  ; domain complete
"RTN","HMPDJFSM",203,0)
 . S NUM=$O(^XTMP(BATCH,TASK,DOMAIN,""),-1)
"RTN","HMPDJFSM",204,0)
 . S LASTITM=DOMAIN_$S(NUM:" #"_NUM,1:"")
"RTN","HMPDJFSM",205,0)
 N LAST S LAST=$S('$L(LASTITM):"<finished>",1:LASTITM)
"RTN","HMPDJFSM",206,0)
 ;
"RTN","HMPDJFSM",207,0)
 quit LAST ; return last domain if any ; end of $$LOBJ
"RTN","HMPDJFSM",208,0)
 ;
"RTN","HMPDJFSM",209,0)
 ;
"RTN","HMPDJFSM",210,0)
 ;
"RTN","HMPDJFSM",211,0)
 ; subroutines that support protocol menu HMPM EVT QUE MGR MENU
"RTN","HMPDJFSM",212,0)
 ;
"RTN","HMPDJFSM",213,0)
 ;
"RTN","HMPDJFSM",214,0)
 ;
"RTN","HMPDJFSM",215,0)
GETSRV() ; protocol HMPM EVT QUE CHANGE SERVER [Change Server]
"RTN","HMPDJFSM",216,0)
 ; called by:
"RTN","HMPDJFSM",217,0)
 ;   protocol unwinder
"RTN","HMPDJFSM",218,0)
 ; calls:
"RTN","HMPDJFSM",219,0)
 ;   ^DIC: select server subscription to monitor
"RTN","HMPDJFSM",220,0)
 ; input:
"RTN","HMPDJFSM",221,0)
 ;   file HMP Subscription (800000)
"RTN","HMPDJFSM",222,0)
 ; output = IEN of server to monitor
"RTN","HMPDJFSM",223,0)
 ;
"RTN","HMPDJFSM",224,0)
 N DIC,Y
"RTN","HMPDJFSM",225,0)
 S DIC="^HMP(800000,",DIC(0)="AEMQ",DIC("A")="Select HMP server instance: "
"RTN","HMPDJFSM",226,0)
 D ^DIC
"RTN","HMPDJFSM",227,0)
 ;
"RTN","HMPDJFSM",228,0)
 Q +Y ; return the IEN for the server to monitor ; end of $$GETSRV
"RTN","HMPDJFSM",229,0)
 ;
"RTN","HMPDJFSM",230,0)
 ;
"RTN","HMPDJFSM",231,0)
EMERSTOP ; protocol HMPM EVT QUE EMERGENCY STOP [not distributed]
"RTN","HMPDJFSM",232,0)
 ; called by:
"RTN","HMPDJFSM",233,0)
 ;   protocol unwinder
"RTN","HMPDJFSM",234,0)
 ; calls:
"RTN","HMPDJFSM",235,0)
 ;   SETFRUP: set flag for freshness updates
"RTN","HMPDJFSM",236,0)
 ; input:
"RTN","HMPDJFSM",237,0)
 ;   user selects a domain to stop freshness updates
"RTN","HMPDJFSM",238,0)
 ; output: freshness updates stopped for selected domain
"RTN","HMPDJFSM",239,0)
 ;
"RTN","HMPDJFSM",240,0)
 ; Emergency Stop for Freshness
"RTN","HMPDJFSM",241,0)
 ;
"RTN","HMPDJFSM",242,0)
 D SETFRUP(0)
"RTN","HMPDJFSM",243,0)
 ;
"RTN","HMPDJFSM",244,0)
 quit  ; end of EMERSTOP
"RTN","HMPDJFSM",245,0)
 ;
"RTN","HMPDJFSM",246,0)
 ;
"RTN","HMPDJFSM",247,0)
RSTRTFR ; protocol HMPM EVT QUE RESTART FRESHNESS [not distributed]
"RTN","HMPDJFSM",248,0)
 ; called by:
"RTN","HMPDJFSM",249,0)
 ;   protocol unwinder
"RTN","HMPDJFSM",250,0)
 ; calls:
"RTN","HMPDJFSM",251,0)
 ;   SETFRUP: set flag for freshness updates
"RTN","HMPDJFSM",252,0)
 ; input:
"RTN","HMPDJFSM",253,0)
 ;   user selects a domain to resume freshness updates
"RTN","HMPDJFSM",254,0)
 ; output: freshness updates resumed for selected domain
"RTN","HMPDJFSM",255,0)
 ;
"RTN","HMPDJFSM",256,0)
 ; Re-start freshness updates
"RTN","HMPDJFSM",257,0)
 ;
"RTN","HMPDJFSM",258,0)
 D SETFRUP(1)
"RTN","HMPDJFSM",259,0)
 ;
"RTN","HMPDJFSM",260,0)
 quit  ; end of RSTRTFR
"RTN","HMPDJFSM",261,0)
 ;
"RTN","HMPDJFSM",262,0)
 ;
"RTN","HMPDJFSM",263,0)
SETFRUP(START) ; set flag for freshness updates
"RTN","HMPDJFSM",264,0)
 ; called by:
"RTN","HMPDJFSM",265,0)
 ;   EMERSTOP
"RTN","HMPDJFSM",266,0)
 ;   RSTRTFR
"RTN","HMPDJFSM",267,0)
 ; calls:
"RTN","HMPDJFSM",268,0)
 ;   EVNTYPS: load event types
"RTN","HMPDJFSM",269,0)
 ;   $$GETFTYP = select & return domain from list
"RTN","HMPDJFSM",270,0)
 ;   CHGFTYP: change freshness update flag for a type
"RTN","HMPDJFSM",271,0)
 ; input:
"RTN","HMPDJFSM",272,0)
 ;   START = 0 to stop, 1 to resume
"RTN","HMPDJFSM",273,0)
 ;   user selects a domain to stop or resume freshness updates
"RTN","HMPDJFSM",274,0)
 ; output:
"RTN","HMPDJFSM",275,0)
 ;   freshness updates stopped or resumed for selected domain
"RTN","HMPDJFSM",276,0)
 ;
"RTN","HMPDJFSM",277,0)
 I 'START D
"RTN","HMPDJFSM",278,0)
 . W !,"WARNING!  This will stop freshness updates for the HMP."
"RTN","HMPDJFSM",279,0)
 . W !,"          It will be necessary to re-synch patient data.",!
"RTN","HMPDJFSM",280,0)
 I START D
"RTN","HMPDJFSM",281,0)
 . W !,"This will --RESUME-- freshness updates for the HMP."
"RTN","HMPDJFSM",282,0)
 . W !,"It may be necessary to re-synch patient and operational data.",!
"RTN","HMPDJFSM",283,0)
 N TYPLST,ALPHA,I,TYPE
"RTN","HMPDJFSM",284,0)
 D EVNTYPS(.TYPLST)
"RTN","HMPDJFSM",285,0)
 S I=0 F  S I=$O(TYPLST(I)) Q:'I  S ALPHA(TYPLST(I))=""
"RTN","HMPDJFSM",286,0)
 S TYPE=$$GETFTYP(.ALPHA,START)
"RTN","HMPDJFSM",287,0)
 Q:TYPE=""
"RTN","HMPDJFSM",288,0)
 I TYPE="*" D  Q
"RTN","HMPDJFSM",289,0)
 . S TYPE="" F  S TYPE=$O(ALPHA(TYPE)) Q:TYPE=""  D CHGFTYP(TYPE,START)
"RTN","HMPDJFSM",290,0)
 D CHGFTYP(TYPE,START)
"RTN","HMPDJFSM",291,0)
 ;
"RTN","HMPDJFSM",292,0)
 quit  ; end of SETFRUP
"RTN","HMPDJFSM",293,0)
 ;
"RTN","HMPDJFSM",294,0)
 ;
"RTN","HMPDJFSM",295,0)
CHGFTYP(TYPE,START) ; change the freshness update flag for a type
"RTN","HMPDJFSM",296,0)
 ; called by:
"RTN","HMPDJFSM",297,0)
 ;   SETFRUP
"RTN","HMPDJFSM",298,0)
 ; calls:
"RTN","HMPDJFSM",299,0)
 ;   STRTFTYP: resume freshness updates for domain
"RTN","HMPDJFSM",300,0)
 ;   STOPFTYP: stop freshness updates for domain
"RTN","HMPDJFSM",301,0)
 ; input:
"RTN","HMPDJFSM",302,0)
 ;   TYPE = domain to change
"RTN","HMPDJFSM",303,0)
 ;   START = 0 to stop, 1 to resume
"RTN","HMPDJFSM",304,0)
 ; output:
"RTN","HMPDJFSM",305,0)
 ;
"RTN","HMPDJFSM",306,0)
 I START D STRTFTYP(TYPE) Q
"RTN","HMPDJFSM",307,0)
 ; otherwise
"RTN","HMPDJFSM",308,0)
 D STOPFTYP(TYPE)
"RTN","HMPDJFSM",309,0)
 ;
"RTN","HMPDJFSM",310,0)
 quit  ; end of CHGFTYP
"RTN","HMPDJFSM",311,0)
 ;
"RTN","HMPDJFSM",312,0)
 ;
"RTN","HMPDJFSM",313,0)
STOPFTYP(TYPE) ; stop freshness updates for domain
"RTN","HMPDJFSM",314,0)
 ; called by:
"RTN","HMPDJFSM",315,0)
 ;   CHGFTYP
"RTN","HMPDJFSM",316,0)
 ; calls:
"RTN","HMPDJFSM",317,0)
 ;   NEWXTMP^HMPDJFS: set a new node in ^XTMP
"RTN","HMPDJFSM",318,0)
 ; input:
"RTN","HMPDJFSM",319,0)
 ;   TYPE = domain to stop
"RTN","HMPDJFSM",320,0)
 ; output:
"RTN","HMPDJFSM",321,0)
 ;   freshness updates stopped for domain
"RTN","HMPDJFSM",322,0)
 ;   ^XTMP("HMP-off",domain) = 1
"RTN","HMPDJFSM",323,0)
 ;  if missing, header node ^XTMP("HMP-off",0) is set to
"RTN","HMPDJFSM",324,0)
 ;    = when to purge ^ today ^ Switch off HMP freshness updates
"RTN","HMPDJFSM",325,0)
 ;
"RTN","HMPDJFSM",326,0)
 I '$D(^XTMP("HMP-off",0)) D NEWXTMP^HMPDJFS("HMP-off",999,"Switch off HMP freshness updates")
"RTN","HMPDJFSM",327,0)
 W !,"Stopping freshness updates for: ",TYPE
"RTN","HMPDJFSM",328,0)
 S ^XTMP("HMP-off",TYPE)=1
"RTN","HMPDJFSM",329,0)
 ;
"RTN","HMPDJFSM",330,0)
 quit  ; end of STOPFTYP
"RTN","HMPDJFSM",331,0)
 ;
"RTN","HMPDJFSM",332,0)
 ;
"RTN","HMPDJFSM",333,0)
STRTFTYP(TYPE) ; resume freshness updates for domain
"RTN","HMPDJFSM",334,0)
 ; called by:
"RTN","HMPDJFSM",335,0)
 ;   CHGFTYP
"RTN","HMPDJFSM",336,0)
 ; calls: none
"RTN","HMPDJFSM",337,0)
 ; input:
"RTN","HMPDJFSM",338,0)
 ;   TYPE = domain to resume
"RTN","HMPDJFSM",339,0)
 ; output:
"RTN","HMPDJFSM",340,0)
 ;   freshness updates resumed for domain
"RTN","HMPDJFSM",341,0)
 ;   ^XTMP("HMP-off",TYPE) deleted
"RTN","HMPDJFSM",342,0)
 ;
"RTN","HMPDJFSM",343,0)
 W !,"Resuming freshness updates for: ",TYPE
"RTN","HMPDJFSM",344,0)
 K ^XTMP("HMP-off",TYPE)
"RTN","HMPDJFSM",345,0)
 ;
"RTN","HMPDJFSM",346,0)
 quit  ; end of STRTFTYP
"RTN","HMPDJFSM",347,0)
 ;
"RTN","HMPDJFSM",348,0)
 ;
"RTN","HMPDJFSM",349,0)
GETFTYP(ALPHA,START) ; select & return domain from list
"RTN","HMPDJFSM",350,0)
 ; called by:
"RTN","HMPDJFSM",351,0)
 ;   SETFRUP
"RTN","HMPDJFSM",352,0)
 ; calls:
"RTN","HMPDJFSM",353,0)
 ;   SHOWFTYP: Show freshness types
"RTN","HMPDJFSM",354,0)
 ;   $$LOW^XLFSTR = convert domain name to lower case
"RTN","HMPDJFSM",355,0)
 ; input:
"RTN","HMPDJFSM",356,0)
 ;  .ALPHA(domain name) = "" for all selectable domains
"RTN","HMPDJFSM",357,0)
 ;   START = 0 to stop, 1 to resume
"RTN","HMPDJFSM",358,0)
 ;   user prompted to select a domain
"RTN","HMPDJFSM",359,0)
 ; output = domain name
"RTN","HMPDJFSM",360,0)
 ;
"RTN","HMPDJFSM",361,0)
 N X,T,P
"RTN","HMPDJFSM",362,0)
 S P=$S(START:"start",1:"stop")
"RTN","HMPDJFSM",363,0)
 F  D  Q:X'["?"
"RTN","HMPDJFSM",364,0)
 . D SHOWFTYP(.ALPHA)
"RTN","HMPDJFSM",365,0)
 . W !!,"Choose domain to "_P_" (* "_P_"s all): "
"RTN","HMPDJFSM",366,0)
 . R X:300 S:$E(X)="^" X="" Q:X=""  Q:X="*"
"RTN","HMPDJFSM",367,0)
 . S X=$$LOW^XLFSTR(X)
"RTN","HMPDJFSM",368,0)
 . Q:$D(ALPHA(X))
"RTN","HMPDJFSM",369,0)
 . S T=$O(ALPHA(X))
"RTN","HMPDJFSM",370,0)
 . I X=$E(T,1,$L(X)) W "  ",T S X=T Q
"RTN","HMPDJFSM",371,0)
 . W "  ??",! S X="?"
"RTN","HMPDJFSM",372,0)
 ;
"RTN","HMPDJFSM",373,0)
 quit X ; return selected domain ; end of $$GETFTYP
"RTN","HMPDJFSM",374,0)
 ;
"RTN","HMPDJFSM",375,0)
 ;
"RTN","HMPDJFSM",376,0)
SHOWFTYP(ALPHA) ; show freshness domains
"RTN","HMPDJFSM",377,0)
 ; called by:
"RTN","HMPDJFSM",378,0)
 ;   $$GETFTYP
"RTN","HMPDJFSM",379,0)
 ; calls: none
"RTN","HMPDJFSM",380,0)
 ; input:
"RTN","HMPDJFSM",381,0)
 ;  .ALPHA(domain name) = "" for all selectable domains
"RTN","HMPDJFSM",382,0)
 ; output:
"RTN","HMPDJFSM",383,0)
 ;   list of domains is reported on current device
"RTN","HMPDJFSM",384,0)
 ;
"RTN","HMPDJFSM",385,0)
 N I,X,P
"RTN","HMPDJFSM",386,0)
 S I=0,X="" F  S X=$O(ALPHA(X)) Q:'$L(X)  D
"RTN","HMPDJFSM",387,0)
 . S I=I+1,P=I#3
"RTN","HMPDJFSM",388,0)
 . W:P=1 !,X
"RTN","HMPDJFSM",389,0)
 . W:P=2 ?26,X
"RTN","HMPDJFSM",390,0)
 . W:P=0 ?52,X
"RTN","HMPDJFSM",391,0)
 ;
"RTN","HMPDJFSM",392,0)
 quit  ; end of SHOWFTYP
"RTN","HMPDJFSM",393,0)
 ;
"RTN","HMPDJFSM",394,0)
 ;
"RTN","HMPDJFSM",395,0)
EVNTYPS(LIST) ; protocol HMPM EVT QUE CHANGE DOMAIN [Change Domain]
"RTN","HMPDJFSM",396,0)
 ;;allergy
"RTN","HMPDJFSM",397,0)
 ;;med
"RTN","HMPDJFSM",398,0)
 ;;auxiliary
"RTN","HMPDJFSM",399,0)
 ;;appointment
"RTN","HMPDJFSM",400,0)
 ;;diagnosis
"RTN","HMPDJFSM",401,0)
 ;;document
"RTN","HMPDJFSM",402,0)
 ;;factor
"RTN","HMPDJFSM",403,0)
 ;;immunization
"RTN","HMPDJFSM",404,0)
 ;;lab
"RTN","HMPDJFSM",405,0)
 ;;obs
"RTN","HMPDJFSM",406,0)
 ;;order
"RTN","HMPDJFSM",407,0)
 ;;problem
"RTN","HMPDJFSM",408,0)
 ;;procedure
"RTN","HMPDJFSM",409,0)
 ;;consult
"RTN","HMPDJFSM",410,0)
 ;;image
"RTN","HMPDJFSM",411,0)
 ;;surgery
"RTN","HMPDJFSM",412,0)
 ;;task
"RTN","HMPDJFSM",413,0)
 ;;visit
"RTN","HMPDJFSM",414,0)
 ;;vital
"RTN","HMPDJFSM",415,0)
 ;;mh
"RTN","HMPDJFSM",416,0)
 ;;ptf
"RTN","HMPDJFSM",417,0)
 ;;exam
"RTN","HMPDJFSM",418,0)
 ;;cpt
"RTN","HMPDJFSM",419,0)
 ;;education
"RTN","HMPDJFSM",420,0)
 ;;pov
"RTN","HMPDJFSM",421,0)
 ;;skin
"RTN","HMPDJFSM",422,0)
 ;;treatment
"RTN","HMPDJFSM",423,0)
 ;;roadtrip
"RTN","HMPDJFSM",424,0)
 ;;diet
"RTN","HMPDJFSM",425,0)
 ;;pt-select
"RTN","HMPDJFSM",426,0)
 ;;patient
"RTN","HMPDJFSM",427,0)
 ;;roster
"RTN","HMPDJFSM",428,0)
 ;;user
"RTN","HMPDJFSM",429,0)
 ;;zzzzz
"RTN","HMPDJFSM",430,0)
 N I,X
"RTN","HMPDJFSM",431,0)
 F I=1:1 S X=$P($T(EVNTYPS+I),";;",2,99) Q:X="zzzzz"  S LIST(I)=X
"RTN","HMPDJFSM",432,0)
 ;
"RTN","HMPDJFSM",433,0)
 quit
"RTN","HMPDJFSM",434,0)
 ;
"RTN","HMPDJFSM",435,0)
 ; called by:
"RTN","HMPDJFSM",436,0)
 ;   protocol unwinder
"RTN","HMPDJFSM",437,0)
 ; calls: none
"RTN","HMPDJFSM",438,0)
 ; input:
"RTN","HMPDJFSM",439,0)
 ;   $text table above
"RTN","HMPDJFSM",440,0)
 ; output:
"RTN","HMPDJFSM",441,0)
 ;  .LIST(#) = domain name
"RTN","HMPDJFSM",442,0)
 ;
"RTN","HMPDJFSM",443,0)
 ; load event types
"RTN","HMPDJFSM",444,0)
 ;
"RTN","HMPDJFSM",445,0)
 ; end of EVNTYPS
"RTN","HMPDJFSM",446,0)
 ;
"RTN","HMPDJFSM",447,0)
 ;
"RTN","HMPDJFSM",448,0)
EOR ; end of routine HMPDJFSM
"RTN","HMPDJFSP")
0^19^B224332595
"RTN","HMPDJFSP",1,0)
HMPDJFSP ;SLC/KCM.ASMR/RRB,CPC-PUT/POST for extract & freshness ;2016-07-01 14:06Z
"RTN","HMPDJFSP",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;Sep 01, 2011;Build 24
"RTN","HMPDJFSP",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFSP",4,0)
 ;
"RTN","HMPDJFSP",5,0)
 quit  ; no entry at top of HMPDJFSP
"RTN","HMPDJFSP",6,0)
 ;
"RTN","HMPDJFSP",7,0)
 ;
"RTN","HMPDJFSP",8,0)
 ; primary development history
"RTN","HMPDJFSP",9,0)
 ;
"RTN","HMPDJFSP",10,0)
 ; 2015-11-04 asmr/rrb: fix first three lines for sac compliance,
"RTN","HMPDJFSP",11,0)
 ; [DE2818/RRB: SQA findings 1st 3 lines].
"RTN","HMPDJFSP",12,0)
 ;
"RTN","HMPDJFSP",13,0)
 ; 2016-03-29/04-13 asmr-ven/toad: change $$CHKSIZE to call
"RTN","HMPDJFSP",14,0)
 ; $$GETSIZE^HMPMONX instead of $$GETSIZE^HMPUTILS, refactor, fix org
"RTN","HMPDJFSP",15,0)
 ;
"RTN","HMPDJFSP",16,0)
 ; more development here to log later
"RTN","HMPDJFSP",17,0)
 ;
"RTN","HMPDJFSP",18,0)
 ; 2016-06-30/07-01 asmr-ven/toad: map calls in and out, migrate
"RTN","HMPDJFSP",19,0)
 ; DQINIT,QUINIT,DOMOPD,$$TOTAL,MVFRUPD to HMPDJFSQ to get HMPDJFSP
"RTN","HMPDJFSP",20,0)
 ; under SAC size limit.
"RTN","HMPDJFSP",21,0)
 ;
"RTN","HMPDJFSP",22,0)
 ;
"RTN","HMPDJFSP",23,0)
 ; --- create a new patient subscription
"RTN","HMPDJFSP",24,0)
 ;
"RTN","HMPDJFSP",25,0)
PUTSUB(ARGS) ; return location after creating a new subscription
"RTN","HMPDJFSP",26,0)
 ; called by:
"RTN","HMPDJFSP",27,0)
 ;   API^HMPDJFS
"RTN","HMPDJFSP",28,0)
 ; falls through to:
"RTN","HMPDJFSP",29,0)
 ;   QREJOIN
"RTN","HMPDJFSP",30,0)
 ; calls:
"RTN","HMPDJFSP",31,0)
 ;   $$TM^%ZTLOAD
"RTN","HMPDJFSP",32,0)
 ;   SETERR^HMPDJFS
"RTN","HMPDJFSP",33,0)
 ;   $$GETDFN^MPIF001
"RTN","HMPDJFSP",34,0)
 ;   SETERR^HMPDJFS
"RTN","HMPDJFSP",35,0)
 ;   OPDOMS^HMPDJFSD
"RTN","HMPDJFSP",36,0)
 ;   PTDOMS^HMPDJFSD
"RTN","HMPDJFSP",37,0)
 ;   SETPAT
"RTN","HMPDJFSP",38,0)
 ;   NEWXTMP^HMPDJFS
"RTN","HMPDJFSP",39,0)
 ;   SETMARK
"RTN","HMPDJFSP",40,0)
 ;   INIT^HMPMETA
"RTN","HMPDJFSP",41,0)
 ;   $$HTFM^XLFDT
"RTN","HMPDJFSP",42,0)
 ;   SAVETASK^HMPDJFSQ
"RTN","HMPDJFSP",43,0)
 ;   $$PID^HMPDJFS
"RTN","HMPDJFSP",44,0)
 ; output:
"RTN","HMPDJFSP",45,0)
 ;  fn returns      : /hmp/subscription/{hmpSrvId}/patient/{sysId;dfn}
"RTN","HMPDJFSP",46,0)
 ;                  : "" if error, errors in ^TMP("HMPFERR",$J)
"RTN","HMPDJFSP",47,0)
 ; .ARGS("server")  : name of HMP server
"RTN","HMPDJFSP",48,0)
 ; .ARGS("localId") : dfn for patient to subscribe or "OPD" (operational data)
"RTN","HMPDJFSP",49,0)
 ; .ARGS("icn")     : icn for patient to subscribe
"RTN","HMPDJFSP",50,0)
 ; .ARGS("domains") : optional array of domains to initialize (deprecated)
"RTN","HMPDJFSP",51,0)
 ;
"RTN","HMPDJFSP",52,0)
 I '$$TM^%ZTLOAD D SETERR^HMPDJFS("Taskman not running") Q ""
"RTN","HMPDJFSP",53,0)
 ;
"RTN","HMPDJFSP",54,0)
 N HMPSRV,HMPFDFN,HMPBATCH,HMPFERR,I,NEWSUB,DOMAINS,HMPSVERS,HMPSTMP,HMPPRITY,HMPQBTCH ;US13442
"RTN","HMPDJFSP",55,0)
 ;
"RTN","HMPDJFSP",56,0)
 ; make sure we can identify the patient ("OPD" signals sync operational)
"RTN","HMPDJFSP",57,0)
 S HMPFDFN=$G(ARGS("localId"))
"RTN","HMPDJFSP",58,0)
 S HMPSVERS=+$G(ARGS("HMPSVERS")) ;US11019 get sync version
"RTN","HMPDJFSP",59,0)
 I HMPFDFN'="OPD" D  Q:$G(HMPFERR) ""
"RTN","HMPDJFSP",60,0)
 . I '$L(HMPFDFN),$L(ARGS("icn")) S HMPFDFN=+$$GETDFN^MPIF001(ARGS("icn"))
"RTN","HMPDJFSP",61,0)
 . I 'HMPFDFN D SETERR^HMPDJFS("No patient specified") Q
"RTN","HMPDJFSP",62,0)
 . I '$D(^DPT(HMPFDFN)) D SETERR^HMPDJFS("Patient not found")  ; IA 10035, DE2818
"RTN","HMPDJFSP",63,0)
 ;
"RTN","HMPDJFSP",64,0)
 ; make sure server is known and create batch id
"RTN","HMPDJFSP",65,0)
 S HMPSRV=HMPFHMP  ; TODO: switch to HMPFHMP as server ien
"RTN","HMPDJFSP",66,0)
 I '$L(HMPSRV) D SETERR^HMPDJFS("Missing HMP Server ID") Q ""
"RTN","HMPDJFSP",67,0)
 S HMPSRV("ien")=$O(^HMP(800000,"B",HMPSRV,0))
"RTN","HMPDJFSP",68,0)
 I 'HMPSRV("ien") D SETERR^HMPDJFS("HMP Server not registered") Q ""
"RTN","HMPDJFSP",69,0)
 S HMPBATCH="HMPFX~"_HMPSRV_"~"_HMPFDFN
"RTN","HMPDJFSP",70,0)
 S HMPQBTCH="HMPFS~"_HMPSRV_"~queue"
"RTN","HMPDJFSP",71,0)
 ;
"RTN","HMPDJFSP",72,0)
 ; set up domains to extract
"RTN","HMPDJFSP",73,0)
 D @($S(HMPFDFN="OPD":"OPDOMS",1:"PTDOMS")_"^HMPDJFSD(.DOMAINS)")
"RTN","HMPDJFSP",74,0)
 ;
"RTN","HMPDJFSP",75,0)
 ; ejk US5647
"RTN","HMPDJFSP",76,0)
 ; code below restores selective domain functionality.
"RTN","HMPDJFSP",77,0)
 ; once the complete list of domains is returned from HMPDJFSD,
"RTN","HMPDJFSP",78,0)
 ; if ARGS("domains") is passed in, anything not in that parameter
"RTN","HMPDJFSP",79,0)
 ; will be excluded from the ODS extract.
"RTN","HMPDJFSP",80,0)
 I $G(ARGS("domains"))'="" D
"RTN","HMPDJFSP",81,0)
 .F I=1:1 Q:'$D(DOMAINS(I))  I ARGS("domains")'[DOMAINS(I) K DOMAINS(I)
"RTN","HMPDJFSP",82,0)
 ;
"RTN","HMPDJFSP",83,0)
 ; see if this is new subscription and task extract if new
"RTN","HMPDJFSP",84,0)
 D SETPAT(HMPFDFN,HMPSRV,.NEWSUB) Q:$G(HMPFERR) ""
"RTN","HMPDJFSP",85,0)
 ;For operational data set stamptime as time subscription placed US6734
"RTN","HMPDJFSP",86,0)
 S HMPSTMP=$$EN^HMPSTMP("NOW") ;DE3377
"RTN","HMPDJFSP",87,0)
 ;
"RTN","HMPDJFSP",88,0)
 ;cpc US11019 following chunk of code moved out of QUINIT as was being called multiple times
"RTN","HMPDJFSP",89,0)
 ;US11019 get array of job ids by domain
"RTN","HMPDJFSP",90,0)
 ; only done once when beginning the batch, no matter how many tasked jobs
"RTN","HMPDJFSP",91,0)
 L +^XTMP(HMPBATCH):5 E  D SETERR^HMPDJFS("Cannot lock batch:"_HMPBATCH) QUIT
"RTN","HMPDJFSP",92,0)
 I '$D(^XTMP(HMPBATCH)) D
"RTN","HMPDJFSP",93,0)
 . D NEWXTMP^HMPDJFS(HMPBATCH,2,"HMP Patient Extract")
"RTN","HMPDJFSP",94,0)
 . ;US11019 - store domain specific job ids
"RTN","HMPDJFSP",95,0)
 . N EMPB S EMPB="jobDomainId-" ;US11019
"RTN","HMPDJFSP",96,0)
 . F  S EMPB=$O(ARGS(EMPB)) Q:EMPB=""  Q:EMPB'["jobDomainId-"  S:'HMPSVERS HMPSVERS=1 S ^XTMP(HMPBATCH,"JOBID",$P(EMPB,"jobDomainId-",2))=ARGS(EMPB) ; US11019 3rd version
"RTN","HMPDJFSP",97,0)
 . S ^XTMP(HMPBATCH,"HMPSVERS")=HMPSVERS ;US11019 store sync version
"RTN","HMPDJFSP",98,0)
 . I $G(ARGS("jobId"))]"" S ^XTMP(HMPBATCH,"JOBID")=ARGS("jobId")  ;US3907 /US11019
"RTN","HMPDJFSP",99,0)
 . I $G(ARGS("rootJobId"))]"" S ^XTMP(HMPBATCH,"ROOTJOBID")=ARGS("rootJobId")  ;US3907
"RTN","HMPDJFSP",100,0)
 . S ^XTMP(HMPBATCH,0,"time")=$H
"RTN","HMPDJFSP",101,0)
 . ; US6734 - setting of syncStart for OPD only
"RTN","HMPDJFSP",102,0)
 . I HMPFDFN="OPD" D SETMARK("Start",HMPFDFN,HMPBATCH),INIT^HMPMETA(HMPBATCH,HMPFDFN,.ARGS) ; US6734
"RTN","HMPDJFSP",103,0)
 L -^XTMP(HMPBATCH)
"RTN","HMPDJFSP",104,0)
 ;cpc US11019 end moved code
"RTN","HMPDJFSP",105,0)
 ;US13442
"RTN","HMPDJFSP",106,0)
 S HMPPRITY=1 S:+$G(ARGS("HMPPriority")) HMPPRITY=+ARGS("HMPPriority")
"RTN","HMPDJFSP",107,0)
 I '$D(^XTMP(HMPQBTCH,0)) D  ;check basic controls exist
"RTN","HMPDJFSP",108,0)
 . S ^XTMP(HMPQBTCH,0)=$$HTFM^XLFDT(+$H+5)_U_$$HTFM^XLFDT(+$H)_U_"HMP task queue"
"RTN","HMPDJFSP",109,0)
 . S ^XTMP(HMPQBTCH,0,0)=2 ;default concurrent patients
"RTN","HMPDJFSP",110,0)
 ;put task onto task queue if new subscription for patient
"RTN","HMPDJFSP",111,0)
 I NEWSUB,+HMPFDFN D SAVETASK^HMPDJFSQ Q "/hmp/subscription/"_HMPSRV_"/patient/"_$$PID^HMPDJFS(HMPFDFN)
"RTN","HMPDJFSP",112,0)
 ;
"RTN","HMPDJFSP",113,0)
QREJOIN  ; task And come back in from queue
"RTN","HMPDJFSP",114,0)
 ; falls through from:
"RTN","HMPDJFSP",115,0)
 ;   PUTSUB
"RTN","HMPDJFSP",116,0)
 ; called by:
"RTN","HMPDJFSP",117,0)
 ;   NEWTASK^HMPDJFSQ: ZTRTN="QREJOIN^HMPDJFSP"
"RTN","HMPDJFSP",118,0)
 ; calls:
"RTN","HMPDJFSP",119,0)
 ;   UPDSTS
"RTN","HMPDJFSP",120,0)
 ;   QUINIT^HMPDJFSQ
"RTN","HMPDJFSP",121,0)
 ;   SETMARK
"RTN","HMPDJFSP",122,0)
 ;   $$PID^HMPDJFS
"RTN","HMPDJFSP",123,0)
 ;
"RTN","HMPDJFSP",124,0)
 ;Every Domain in it's own task (unless running in original mode)
"RTN","HMPDJFSP",125,0)
 I NEWSUB D  Q:$G(HMPFERR) ""
"RTN","HMPDJFSP",126,0)
 . ; if patient's extracts are held (version mismatch), put DFN on wait list
"RTN","HMPDJFSP",127,0)
 . I +HMPFDFN,$G(^XTMP("HMPFS~"_HMPSRV("ien"),"waiting")) S ^XTMP("HMPFS~"_HMPSRV("ien"),"waiting",HMPFDFN)="" QUIT
"RTN","HMPDJFSP",128,0)
 . D UPDSTS(HMPFDFN,$P(HMPBATCH,"~",2),1) ;moved from background job to once in foreground 12/17/2015
"RTN","HMPDJFSP",129,0)
 . I 'HMPSVERS N HMPFDOM M HMPFDOM=DOMAINS D QUINIT^HMPDJFSQ(HMPBATCH,HMPFDFN,.HMPFDOM) Q  ;US11019 Enable previous behavior
"RTN","HMPDJFSP",130,0)
 . S I="" F  S I=$O(DOMAINS(I)) Q:'I  D
"RTN","HMPDJFSP",131,0)
 ..  N HMPFDOM
"RTN","HMPDJFSP",132,0)
 ..  S HMPFDOM(1)=DOMAINS(I)
"RTN","HMPDJFSP",133,0)
 ..  D QUINIT^HMPDJFSQ(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPDJFSP",134,0)
 ;===JD START===
"RTN","HMPDJFSP",135,0)
 ; For patient resubscribes, need to send demographics ONLY
"RTN","HMPDJFSP",136,0)
 I 'NEWSUB,HMPFDFN'="OPD",'$D(^XTMP(HMPBATCH,0,"status")) D  ;DE3331 check expanded to ensure not current
"RTN","HMPDJFSP",137,0)
 . N HMPFDOM,HMPDSAVE ;DE3331
"RTN","HMPDJFSP",138,0)
 . M HMPDSAVE=DOMAINS ;DE3331
"RTN","HMPDJFSP",139,0)
 . K DOMAINS S DOMAINS(1)="patient"
"RTN","HMPDJFSP",140,0)
 . M HMPFDOM=DOMAINS
"RTN","HMPDJFSP",141,0)
 . D QUINIT^HMPDJFSQ(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPDJFSP",142,0)
 . I $G(HMPSVERS) S I="" F  S I=$O(HMPDSAVE(I)) Q:'I  D  ;DE3331 create empty metastamp entries for remaining domains
"RTN","HMPDJFSP",143,0)
 ..  I HMPDSAVE(I)'="patient" D SETMARK("Meta",HMPFDFN,HMPDSAVE(I))
"RTN","HMPDJFSP",144,0)
 ;===JD END===
"RTN","HMPDJFSP",145,0)
 Q "/hmp/subscription/"_HMPSRV_"/patient/"_$$PID^HMPDJFS(HMPFDFN)
"RTN","HMPDJFSP",146,0)
 ;
"RTN","HMPDJFSP",147,0)
 ;
"RTN","HMPDJFSP",148,0)
QUINIT(HMPBATCH,HMPFDFN,HMPFDOM) ; Queue the initial extracts for a patient
"RTN","HMPDJFSP",149,0)
 ; called by:
"RTN","HMPDJFSP",150,0)
 ;   VERMATCH^HMPDJFSG
"RTN","HMPDJFSP",151,0)
 ;   CVTSEL^HMPP3I
"RTN","HMPDJFSP",152,0)
 ; calls:
"RTN","HMPDJFSP",153,0)
 ;   QUINIT^HMPDJFSQ
"RTN","HMPDJFSP",154,0)
 ;
"RTN","HMPDJFSP",155,0)
 do QUINIT^HMPDJFSQ(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPDJFSP",156,0)
 ;
"RTN","HMPDJFSP",157,0)
 quit  ; end of QUINIT
"RTN","HMPDJFSP",158,0)
 ;
"RTN","HMPDJFSP",159,0)
 ;
"RTN","HMPDJFSP",160,0)
SETDOM(ATTRIB,DOMAIN,VALUE,HMPMETA) ; Set value for a domain ; cpc TA41760
"RTN","HMPDJFSP",161,0)
 ; called by:
"RTN","HMPDJFSP",162,0)
 ;   QUINIT^HMPDJFSQ
"RTN","HMPDJFSP",163,0)
 ;   QUINIT^HMPMETA
"RTN","HMPDJFSP",164,0)
 ;   DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",165,0)
 ;   DOMPT
"RTN","HMPDJFSP",166,0)
 ;   MOD4STRM
"RTN","HMPDJFSP",167,0)
 ; calls: none
"RTN","HMPDJFSP",168,0)
 ; input:
"RTN","HMPDJFSP",169,0)
 ;   ATTRIB: "status" or "count" attribute
"RTN","HMPDJFSP",170,0)
 ;   VALUE:
"RTN","HMPDJFSP",171,0)
 ;      for status, VALUE: 0=waiting, 1=ready
"RTN","HMPDJFSP",172,0)
 ;      for count,  VALUE: count of items
"RTN","HMPDJFSP",173,0)
 ;      don't update to finished value if just tracking metastamp
"RTN","HMPDJFSP",174,0)
 ;
"RTN","HMPDJFSP",175,0)
 I $G(HMPMETA)'="" S ^XTMP(HMPBATCH,0,ATTRIB,DOMAIN,$S(HMPMETA=1:"MetaStamp",HMPMETA=2:"Combined",1:"Staging"),$S(VALUE:"Stop",1:"Start"))=$H Q:(HMPMETA=1&VALUE)  ;cpc TA41760 10/7/2015 add time logging
"RTN","HMPDJFSP",176,0)
 S ^XTMP(HMPBATCH,0,ATTRIB,DOMAIN)=VALUE
"RTN","HMPDJFSP",177,0)
 Q
"RTN","HMPDJFSP",178,0)
 ;
"RTN","HMPDJFSP",179,0)
 ;
"RTN","HMPDJFSP",180,0)
SETMARK(TYPE,HMPFDFN,HMPBATCH) ; Post markers for begin and end of initial synch
"RTN","HMPDJFSP",181,0)
 ; called by:
"RTN","HMPDJFSP",182,0)
 ;   PUTSUB
"RTN","HMPDJFSP",183,0)
 ;   PUTSUB-QREJOIN
"RTN","HMPDJFSP",184,0)
 ;   QUINIT^HMPMETA
"RTN","HMPDJFSP",185,0)
 ;   DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",186,0)
 ; calls:
"RTN","HMPDJFSP",187,0)
 ;   POST^HMPDJFS
"RTN","HMPDJFSP",188,0)
 ;   SETTIDY
"RTN","HMPDJFSP",189,0)
 ;
"RTN","HMPDJFSP",190,0)
 ; ^XTMP("HMPFP","tidy",hmpServer,fmDate,sequence)=batch
"RTN","HMPDJFSP",191,0)
 Q:$G(HMPENVIR("converting"))  ; don't set markers during conversion
"RTN","HMPDJFSP",192,0)
 N HMPSRV,NODES,X
"RTN","HMPDJFSP",193,0)
 S HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",194,0)
 D POST^HMPDJFS(HMPFDFN,"sync"_TYPE,HMPBATCH,"",HMPSRV,.NODES)
"RTN","HMPDJFSP",195,0)
 Q:TYPE="Start"!(TYPE="Meta")  ; US11019
"RTN","HMPDJFSP",196,0)
 D SETTIDY("<done>",.NODES)
"RTN","HMPDJFSP",197,0)
 Q
"RTN","HMPDJFSP",198,0)
 ;
"RTN","HMPDJFSP",199,0)
 ;
"RTN","HMPDJFSP",200,0)
DQINIT ; task Dequeue initial extracts
"RTN","HMPDJFSP",201,0)
 ; called by: none
"RTN","HMPDJFSP",202,0)
 ; calls:
"RTN","HMPDJFSP",203,0)
 ;   DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",204,0)
 ;
"RTN","HMPDJFSP",205,0)
 do DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",206,0)
 ;
"RTN","HMPDJFSP",207,0)
 quit  ; end of DQINIT
"RTN","HMPDJFSP",208,0)
 ;
"RTN","HMPDJFSP",209,0)
 ;
"RTN","HMPDJFSP",210,0)
DOMPT(HMPFADOM) ; Load a patient domain
"RTN","HMPDJFSP",211,0)
 ; called by:
"RTN","HMPDJFSP",212,0)
 ;   DQBACKDM^HMPDJFS1
"RTN","HMPDJFSP",213,0)
 ;   DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",214,0)
 ; calls:
"RTN","HMPDJFSP",215,0)
 ;   $$CHNKCNT
"RTN","HMPDJFSP",216,0)
 ;   GET^HMPDJ
"RTN","HMPDJFSP",217,0)
 ;   SETDOM
"RTN","HMPDJFSP",218,0)
 ;   CHNKFIN
"RTN","HMPDJFSP",219,0)
 ;
"RTN","HMPDJFSP",220,0)
 N FILTER,RSLT,HMPFEST,HMPCHNK  ; *S68-JCH*
"RTN","HMPDJFSP",221,0)
 S FILTER("noHead")=1
"RTN","HMPDJFSP",222,0)
 S FILTER("domain")=HMPFADOM
"RTN","HMPDJFSP",223,0)
 S FILTER("patientId")=HMPFDFN
"RTN","HMPDJFSP",224,0)
 ; -- domain var used for chunking patient objects using <domain>#<number> construct  *BEGIN*S68-JCH*
"RTN","HMPDJFSP",225,0)
 S HMPCHNK=HMPFADOM
"RTN","HMPDJFSP",226,0)
 S HMPCHNK("trigger count")=$$CHNKCNT(HMPFADOM)  ; *END*S68-JCH*
"RTN","HMPDJFSP",227,0)
 D GET^HMPDJ(.RSLT,.FILTER) ;US11019 I $G(HMPMETA) D SETDOM("status",HMPFADOM,1,1) Q  ;US11019/US6734 - do not update stream if compiling metastamp ; CPC TA41760
"RTN","HMPDJFSP",228,0)
 I $G(HMPMETA)=1 D SETDOM("status",HMPFADOM,1,1) Q  ;US11019/US6734 - do not update stream if compiling metastamp ; CPC TA41760
"RTN","HMPDJFSP",229,0)
 ; add to HMPFS queue if total>0 OR this is the first chunck (#0) section  *S68-JCH*
"RTN","HMPDJFSP",230,0)
 I ($G(@RSLT@("total"),0)>0)!($P(HMPCHNK,"#",2)=0) D CHNKFIN  ; *S68-JCH*
"RTN","HMPDJFSP",231,0)
 Q
"RTN","HMPDJFSP",232,0)
 ;
"RTN","HMPDJFSP",233,0)
 ;
"RTN","HMPDJFSP",234,0)
DOMOPD(HMPFADOM) ; Load an operational domain in smaller batches
"RTN","HMPDJFSP",235,0)
 ; called by: none
"RTN","HMPDJFSP",236,0)
 ; calls:
"RTN","HMPDJFSP",237,0)
 ;   DOMOPD^HMPDJFSQ
"RTN","HMPDJFSP",238,0)
 ;
"RTN","HMPDJFSP",239,0)
 do DOMOPD^HMPDJFSQ(HMPFADOM)
"RTN","HMPDJFSP",240,0)
 ;
"RTN","HMPDJFSP",241,0)
 quit  ; end of DOMOPD
"RTN","HMPDJFSP",242,0)
 ;
"RTN","HMPDJFSP",243,0)
 ;
"RTN","HMPDJFSP",244,0)
CHNKCNT(DOMAIN) ; -- get patient object chunk count trigger                        *BEGIN*S68-JCH*
"RTN","HMPDJFSP",245,0)
 ; called by:
"RTN","HMPDJFSP",246,0)
 ;   DOMPT
"RTN","HMPDJFSP",247,0)
 ; calls:
"RTN","HMPDJFSP",248,0)
 ;   $$GET^XPAR
"RTN","HMPDJFSP",249,0)
 ; input:
"RTN","HMPDJFSP",250,0)
 ;   DOMAIN := current domain name being processed
"RTN","HMPDJFSP",251,0)
 ;
"RTN","HMPDJFSP",252,0)
 Q $S(+$$GET^XPAR("PKG","HMP DOMAIN SIZES",$P($G(DOMAIN),"#"),"Q")>3000:500,1:1000)  ; *END*S68-JCH*
"RTN","HMPDJFSP",253,0)
 ;
"RTN","HMPDJFSP",254,0)
 ;
"RTN","HMPDJFSP",255,0)
CHNKINIT(HMP,HMPI) ; -- init chunk section callback  *BEGIN*S68-JCH*
"RTN","HMPDJFSP",256,0)
 ; called by:
"RTN","HMPDJFSP",257,0)
 ;   GET^HMPDJ
"RTN","HMPDJFSP",258,0)
 ;   DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",259,0)
 ;   CHNKCHK
"RTN","HMPDJFSP",260,0)
 ; calls: none
"RTN","HMPDJFSP",261,0)
 ; input by ref:
"RTN","HMPDJFSP",262,0)
 ;   HMP := $NA of location for chunk of objects
"RTN","HMPDJFSP",263,0)
 ;   HMPI := number of objects in @HMP
"RTN","HMPDJFSP",264,0)
 ;
"RTN","HMPDJFSP",265,0)
 ; -- quit if not in chunking mode
"RTN","HMPDJFSP",266,0)
 Q:'$D(HMPCHNK)
"RTN","HMPDJFSP",267,0)
 ;
"RTN","HMPDJFSP",268,0)
 S $P(HMPCHNK,"#",2)=$S(HMPCHNK["#":$P(HMPCHNK,"#",2)+1,1:0)
"RTN","HMPDJFSP",269,0)
 S HMP=$NA(^XTMP(HMPBATCH,HMPFZTSK,HMPCHNK))
"RTN","HMPDJFSP",270,0)
 K @HMP
"RTN","HMPDJFSP",271,0)
 S HMPI=0
"RTN","HMPDJFSP",272,0)
 Q  ; *END*S68-JCH*
"RTN","HMPDJFSP",273,0)
 ;
"RTN","HMPDJFSP",274,0)
 ;
"RTN","HMPDJFSP",275,0)
CHNKCHK(HMP,HMPI) ; -- check if chunk should be queued callback *BEGIN*S68-JCH*
"RTN","HMPDJFSP",276,0)
 ; called by:
"RTN","HMPDJFSP",277,0)
 ;   ADD^HMPDJ
"RTN","HMPDJFSP",278,0)
 ;   HMP1^HMPDJ02
"RTN","HMPDJFSP",279,0)
 ; calls:
"RTN","HMPDJFSP",280,0)
 ;   GTQ^HMPDJ
"RTN","HMPDJFSP",281,0)
 ;   CHNKFIN
"RTN","HMPDJFSP",282,0)
 ;   CHKXTMP
"RTN","HMPDJFSP",283,0)
 ;   CHNKINIT
"RTN","HMPDJFSP",284,0)
 ; input by ref:
"RTN","HMPDJFSP",285,0)
 ;   HMP := $NA of location for chunk of objects
"RTN","HMPDJFSP",286,0)
 ;   HMPI := number of objects in @HMP
"RTN","HMPDJFSP",287,0)
 ;
"RTN","HMPDJFSP",288,0)
 ; quit if not in chunking mode
"RTN","HMPDJFSP",289,0)
 Q:'$D(HMPCHNK)
"RTN","HMPDJFSP",290,0)
 ;
"RTN","HMPDJFSP",291,0)
 ; execute 'whether to chunk' criteria
"RTN","HMPDJFSP",292,0)
 Q:HMPI<HMPCHNK("trigger count")
"RTN","HMPDJFSP",293,0)
 ; -- add tail to json to section
"RTN","HMPDJFSP",294,0)
 D GTQ^HMPDJ
"RTN","HMPDJFSP",295,0)
 ; -- finish section and put on HMPFS~ queue
"RTN","HMPDJFSP",296,0)
 D CHNKFIN
"RTN","HMPDJFSP",297,0)
 ; -- check ^XTMP size before continuing; may have to HANG if too big
"RTN","HMPDJFSP",298,0)
 D CHKXTMP(HMPBATCH,HMPFZTSK)  ; US5074 disable loopback
"RTN","HMPDJFSP",299,0)
 ; -- initialize for next section
"RTN","HMPDJFSP",300,0)
 D CHNKINIT(.HMP,.HMPI)
"RTN","HMPDJFSP",301,0)
 Q  ; *END*S68-JCH*
"RTN","HMPDJFSP",302,0)
 ;
"RTN","HMPDJFSP",303,0)
 ;
"RTN","HMPDJFSP",304,0)
CHNKFIN ; -- finish chunk section callback *BEGIN*S68-JCH*
"RTN","HMPDJFSP",305,0)
 ; called by:
"RTN","HMPDJFSP",306,0)
 ;   DOMPT
"RTN","HMPDJFSP",307,0)
 ;   CHNKCHK
"RTN","HMPDJFSP",308,0)
 ; calls:
"RTN","HMPDJFSP",309,0)
 ;   MOD4STRM
"RTN","HMPDJFSP",310,0)
 ;   POSTSEC
"RTN","HMPDJFSP",311,0)
 ;
"RTN","HMPDJFSP",312,0)
 ; -- quit if not in chunking mode
"RTN","HMPDJFSP",313,0)
 Q:'$D(HMPCHNK)
"RTN","HMPDJFSP",314,0)
 ;
"RTN","HMPDJFSP",315,0)
 D MOD4STRM(HMPCHNK)
"RTN","HMPDJFSP",316,0)
 ; -- domain#number, <no estimated do> , chunk trigger count for domain
"RTN","HMPDJFSP",317,0)
 D POSTSEC(HMPCHNK,,HMPCHNK("trigger count"))
"RTN","HMPDJFSP",318,0)
 Q  ; *END*S68-JCH*
"RTN","HMPDJFSP",319,0)
 ;
"RTN","HMPDJFSP",320,0)
 ;
"RTN","HMPDJFSP",321,0)
MOD4STRM(DOMAIN) ; modify extract to be ready for stream
"RTN","HMPDJFSP",322,0)
 ; called by:
"RTN","HMPDJFSP",323,0)
 ;   DOMOPD^HMPDJFSQ
"RTN","HMPDJFSP",324,0)
 ;   CHNKFIN
"RTN","HMPDJFSP",325,0)
 ; calls:
"RTN","HMPDJFSP",326,0)
 ;   SETDOM
"RTN","HMPDJFSP",327,0)
 ; expects:
"RTN","HMPDJFSP",328,0)
 ;   HMPBATCH, HMPFSYS, HMPFZTSK
"RTN","HMPDJFSP",329,0)
 ; results are in:
"RTN","HMPDJFSP",330,0)
 ;   ^XTMP("HMPFX~hmpsrv~dfn",DFN,DOMAIN,...)
"RTN","HMPDJFSP",331,0)
 ;
"RTN","HMPDJFSP",332,0)
 ; syncError: {uid,collection,error}  uid=urn:va:syncError:sysId:dfn:extract
"RTN","HMPDJFSP",333,0)
 N DFN,HMPSRV,COUNT,DOMONLY
"RTN","HMPDJFSP",334,0)
 S DOMONLY=$P(DOMAIN,"#")
"RTN","HMPDJFSP",335,0)
 S DFN=$P(HMPBATCH,"~",3),HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",336,0)
 S COUNT=+$G(^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"total"),0)
"RTN","HMPDJFSP",337,0)
 I COUNT=0 S ^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,1,1)="null"
"RTN","HMPDJFSP",338,0)
 ;
"RTN","HMPDJFSP",339,0)
 S ^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"total")=COUNT  ; include errors and/or empty
"RTN","HMPDJFSP",340,0)
 D SETDOM("count",DOMONLY,$G(^XTMP(HMPBATCH,0,"count",DOMONLY),0)+COUNT)
"RTN","HMPDJFSP",341,0)
 Q
"RTN","HMPDJFSP",342,0)
 ;
"RTN","HMPDJFSP",343,0)
 ;
"RTN","HMPDJFSP",344,0)
POSTSEC(DOMAIN,ETOTAL,SECSIZE) ; post domain section to stream and set tidy nodes
"RTN","HMPDJFSP",345,0)
 ; called by:
"RTN","HMPDJFSP",346,0)
 ;   DOMOPD^HMPDJFSQ
"RTN","HMPDJFSP",347,0)
 ;   CHNKFIN
"RTN","HMPDJFSP",348,0)
 ; calls:
"RTN","HMPDJFSP",349,0)
 ;   POST^HMPDJFS
"RTN","HMPDJFSP",350,0)
 ;   SETTIDY
"RTN","HMPDJFSP",351,0)
 ;
"RTN","HMPDJFSP",352,0)
 N DFN,HMPSRV,COUNT,X,NODES
"RTN","HMPDJFSP",353,0)
 S COUNT=^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"total")
"RTN","HMPDJFSP",354,0)
 S ETOTAL=$G(ETOTAL,COUNT)
"RTN","HMPDJFSP",355,0)
 s SECSIZE=$G(SECSIZE,0)
"RTN","HMPDJFSP",356,0)
 S DFN=$P(HMPBATCH,"~",3)
"RTN","HMPDJFSP",357,0)
 S HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",358,0)
 D POST^HMPDJFS(DFN,"syncDomain",DOMAIN_":"_HMPFZTSK_":"_COUNT_":"_ETOTAL_":"_SECSIZE,"",HMPSRV,.NODES)
"RTN","HMPDJFSP",359,0)
 D SETTIDY(DOMAIN,.NODES)
"RTN","HMPDJFSP",360,0)
 I $G(HMPQREF)'="" S @HMPQREF=$P($H,",",2) ;update heartbeat US13442
"RTN","HMPDJFSP",361,0)
 Q
"RTN","HMPDJFSP",362,0)
 ;
"RTN","HMPDJFSP",363,0)
 ;
"RTN","HMPDJFSP",364,0)
SETTIDY(DOMAIN,NODES) ; Set tidy nodes for clean-up of the extracts in ^XTMP
"RTN","HMPDJFSP",365,0)
 ; called by:
"RTN","HMPDJFSP",366,0)
 ;   SETMARK
"RTN","HMPDJFSP",367,0)
 ;   POSTSEC
"RTN","HMPDJFSP",368,0)
 ; calls: none
"RTN","HMPDJFSP",369,0)
 ; expects:
"RTN","HMPDJFSP",370,0)
 ;   HMPBATCH,HMPFZTSK
"RTN","HMPDJFSP",371,0)
 ;
"RTN","HMPDJFSP",372,0)
 N X,STREAM,SEQ
"RTN","HMPDJFSP",373,0)
 S X="" F  S X=$O(NODES(X)) Q:X=""  D      ; iterate hmp servers
"RTN","HMPDJFSP",374,0)
 . S STREAM="HMPFS~"_X_"~"_$P(NODES(X),U)  ; HMPFS~hmpSrv~fmDate
"RTN","HMPDJFSP",375,0)
 . S SEQ=$P(NODES(X),U,2)
"RTN","HMPDJFSP",376,0)
 . S ^XTMP(STREAM,"tidy",SEQ,"batch")=HMPBATCH
"RTN","HMPDJFSP",377,0)
 . S ^XTMP(STREAM,"tidy",SEQ,"domain")=DOMAIN
"RTN","HMPDJFSP",378,0)
 . S ^XTMP(STREAM,"tidy",SEQ,"task")=HMPFZTSK
"RTN","HMPDJFSP",379,0)
 Q
"RTN","HMPDJFSP",380,0)
 ;
"RTN","HMPDJFSP",381,0)
 ;
"RTN","HMPDJFSP",382,0)
MVFRUPD(HMPBATCH,HMPFDFN) ; Move freshness updates over active stream
"RTN","HMPDJFSP",383,0)
 ; called by: none
"RTN","HMPDJFSP",384,0)
 ; calls:
"RTN","HMPDJFSP",385,0)
 ;   MVFRUPD^HMPDJFSQ
"RTN","HMPDJFSP",386,0)
 ;
"RTN","HMPDJFSP",387,0)
 do MVFRUPD^HMPDJFSQ(HMPBATCH,HMPFDFN)
"RTN","HMPDJFSP",388,0)
 ;
"RTN","HMPDJFSP",389,0)
 quit  ; end of MVFRUPD
"RTN","HMPDJFSP",390,0)
 ;
"RTN","HMPDJFSP",391,0)
 ;
"RTN","HMPDJFSP",392,0)
BLDSERR(DFN,DOMAIN,ERRJSON) ; Create syncError object in ERRJSON
"RTN","HMPDJFSP",393,0)
 ; called by: none
"RTN","HMPDJFSP",394,0)
 ; calls:
"RTN","HMPDJFSP",395,0)
 ;   DECODE^HMPJSON
"RTN","HMPDJFSP",396,0)
 ;   ENCODE^HMPJSON
"RTN","HMPDJFSP",397,0)
 ; expects:
"RTN","HMPDJFSP",398,0)
 ;   HMPBATCH, HMPFSYS, HMPFZTSK
"RTN","HMPDJFSP",399,0)
 ;
"RTN","HMPDJFSP",400,0)
 N COUNT,ERRVAL,ERROBJ,ERR,ERRMSG,SYNCERR
"RTN","HMPDJFSP",401,0)
 M ERRVAL=^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"error")
"RTN","HMPDJFSP",402,0)
 I $G(ERRVAL)="" Q
"RTN","HMPDJFSP",403,0)
 S ERRVAL="{"_ERRVAL_"}"
"RTN","HMPDJFSP",404,0)
 D DECODE^HMPJSON("ERRVAL","ERROBJ","ERR")
"RTN","HMPDJFSP",405,0)
 I $D(ERR) S $EC=",UJSON decode error,"
"RTN","HMPDJFSP",406,0)
 K ^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"error")
"RTN","HMPDJFSP",407,0)
 S ERRMSG=ERROBJ("error","message")
"RTN","HMPDJFSP",408,0)
 Q:'$L(ERRMSG)
"RTN","HMPDJFSP",409,0)
 S SYNCERR("uid")="urn:va:syncError:"_HMPFSYS_":"_DFN_":"_DOMAIN
"RTN","HMPDJFSP",410,0)
 S SYNCERR("collection")=DOMAIN
"RTN","HMPDJFSP",411,0)
 S SYNCERR("error")=ERRMSG
"RTN","HMPDJFSP",412,0)
 D ENCODE^HMPJSON("SYNCERR","ERRJSON","ERR") I $D(ERR) S $EC=",UJSON encode error," Q
"RTN","HMPDJFSP",413,0)
 S COUNT=$O(^TMP("HMPERR",$J,""),-1)+1
"RTN","HMPDJFSP",414,0)
 M ^TMP("HMPERR",$J,COUNT)=ERRJSON
"RTN","HMPDJFSP",415,0)
 Q
"RTN","HMPDJFSP",416,0)
 ;
"RTN","HMPDJFSP",417,0)
 ;
"RTN","HMPDJFSP",418,0)
POSTERR(COUNT,DFN) ; put error into ^XTMP(batch)
"RTN","HMPDJFSP",419,0)
 ; called by:
"RTN","HMPDJFSP",420,0)
 ;   DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",421,0)
 ; calls:
"RTN","HMPDJFSP",422,0)
 ;   POST^HMPDJFS
"RTN","HMPDJFSP",423,0)
 ;
"RTN","HMPDJFSP",424,0)
 N CNT,NODE,HMPSRV
"RTN","HMPDJFSP",425,0)
 S HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",426,0)
 S CNT=0 F  S CNT=$O(^TMP("HMPERR",$J,CNT)) Q:CNT'>0  D
"RTN","HMPDJFSP",427,0)
 .S NODE=$G(^TMP("HMPERR",$J,CNT,1))
"RTN","HMPDJFSP",428,0)
 .S ^XTMP(HMPBATCH,HMPFZTSK,"error",CNT,1)=NODE
"RTN","HMPDJFSP",429,0)
 .I CNT>1 S ^XTMP(HMPBATCH,HMPFZTSK,"error",CNT,.3)=","
"RTN","HMPDJFSP",430,0)
 D POST^HMPDJFS(DFN,"syncError","error:"_HMPFZTSK_":"_COUNT_":"_COUNT,"",HMPSRV)
"RTN","HMPDJFSP",431,0)
 Q
"RTN","HMPDJFSP",432,0)
 ;
"RTN","HMPDJFSP",433,0)
 ;
"RTN","HMPDJFSP",434,0)
INITDONE(HMPBATCH) ; Return 1 if all domains are done
"RTN","HMPDJFSP",435,0)
 ; called by:
"RTN","HMPDJFSP",436,0)
 ;   DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",437,0)
 ; calls: none
"RTN","HMPDJFSP",438,0)
 ;
"RTN","HMPDJFSP",439,0)
 N X,DONE
"RTN","HMPDJFSP",440,0)
 S X="",DONE=1
"RTN","HMPDJFSP",441,0)
 F  S X=$O(^XTMP(HMPBATCH,0,"status",X)) Q:'$L(X)  I '^(X) S DONE=0
"RTN","HMPDJFSP",442,0)
 Q DONE
"RTN","HMPDJFSP",443,0)
 ;
"RTN","HMPDJFSP",444,0)
 ;
"RTN","HMPDJFSP",445,0)
SETPAT(DFN,SRV,NEWSUB) ; Add patient to 800000 if not there
"RTN","HMPDJFSP",446,0)
 ; called by:
"RTN","HMPDJFSP",447,0)
 ;   EN^HMPMETA
"RTN","HMPDJFSP",448,0)
 ;   PUTSUB
"RTN","HMPDJFSP",449,0)
 ; calls:
"RTN","HMPDJFSP",450,0)
 ;   SETERR^HMPDJFS
"RTN","HMPDJFSP",451,0)
 ;   UPDOPD
"RTN","HMPDJFSP",452,0)
 ;   ADDPAT
"RTN","HMPDJFSP",453,0)
 ;
"RTN","HMPDJFSP",454,0)
 N ERR,FDA,IEN,IENROOT
"RTN","HMPDJFSP",455,0)
 S IEN=$O(^HMP(800000,"B",SRV,0))
"RTN","HMPDJFSP",456,0)
 I 'IEN D SETERR^HMPDJFS("Unable to find server: "_SRV) QUIT
"RTN","HMPDJFSP",457,0)
 ; for operational, only start sync if not yet subscribed
"RTN","HMPDJFSP",458,0)
 I DFN="OPD" D  QUIT
"RTN","HMPDJFSP",459,0)
 . L +^HMP(800000,IEN):5 E  D SETERR^HMPDJFS("Unable to lock server: "_SRV) Q
"RTN","HMPDJFSP",460,0)
 . ; status is empty string (not 0) when unsubscribed
"RTN","HMPDJFSP",461,0)
 . S NEWSUB='$L($P($G(^HMP(800000,IEN,0)),U,3))
"RTN","HMPDJFSP",462,0)
 . I NEWSUB D UPDOPD(IEN,1) ; set to subscribed
"RTN","HMPDJFSP",463,0)
 . L -^HMP(800000,IEN)
"RTN","HMPDJFSP",464,0)
 ;
"RTN","HMPDJFSP",465,0)
 ; for patient, check subscribed and get the PID
"RTN","HMPDJFSP",466,0)
 L +^HMP(800000,IEN,1,DFN):5 E  D SETERR^HMPDJFS("Unable to lock patient: "_DFN) Q
"RTN","HMPDJFSP",467,0)
 S NEWSUB='$D(^HMP(800000,IEN,1,DFN))
"RTN","HMPDJFSP",468,0)
 I NEWSUB D ADDPAT(DFN,IEN)
"RTN","HMPDJFSP",469,0)
 L -^HMP(800000,IEN,1,DFN)
"RTN","HMPDJFSP",470,0)
 Q
"RTN","HMPDJFSP",471,0)
 ;
"RTN","HMPDJFSP",472,0)
 ;
"RTN","HMPDJFSP",473,0)
UPDOPD(SRV,STS) ; Update status of operational synch
"RTN","HMPDJFSP",474,0)
 ; called by:
"RTN","HMPDJFSP",475,0)
 ;   UNSUB^HMPMETA
"RTN","HMPDJFSP",476,0)
 ;   UPDSTS
"RTN","HMPDJFSP",477,0)
 ;   SETPAT
"RTN","HMPDJFSP",478,0)
 ; calls:
"RTN","HMPDJFSP",479,0)
 ;   FILE^DIE
"RTN","HMPDJFSP",480,0)
 ;   SETERR^HMPDJFS
"RTN","HMPDJFSP",481,0)
 ;   CLEAN^DILF
"RTN","HMPDJFSP",482,0)
 ;
"RTN","HMPDJFSP",483,0)
 N FDA,ERR,DIERR
"RTN","HMPDJFSP",484,0)
 S FDA(800000,SRV_",",.03)=STS
"RTN","HMPDJFSP",485,0)
 D FILE^DIE("","FDA","ERR")
"RTN","HMPDJFSP",486,0)
 I $D(ERR) D SETERR^HMPDJFS("Error changing operational status")
"RTN","HMPDJFSP",487,0)
 D CLEAN^DILF
"RTN","HMPDJFSP",488,0)
 Q
"RTN","HMPDJFSP",489,0)
 ;
"RTN","HMPDJFSP",490,0)
 ;
"RTN","HMPDJFSP",491,0)
ADDPAT(DFN,SRV) ; Add a patient as subscribed for server
"RTN","HMPDJFSP",492,0)
 ; called by:
"RTN","HMPDJFSP",493,0)
 ;   SETPAT
"RTN","HMPDJFSP",494,0)
 ; calls:
"RTN","HMPDJFSP",495,0)
 ;   $$NOW^XLFDT
"RTN","HMPDJFSP",496,0)
 ;   UPDATE^DIE
"RTN","HMPDJFSP",497,0)
 ;   SETERR^HMPDJFS
"RTN","HMPDJFSP",498,0)
 ;   CLEAN^DILF
"RTN","HMPDJFSP",499,0)
 ;
"RTN","HMPDJFSP",500,0)
 N FDA,FDAIEN,DIERR,ERR,IENS
"RTN","HMPDJFSP",501,0)
 S IENS="?+"_DFN_","_SRV_","
"RTN","HMPDJFSP",502,0)
 S FDAIEN(DFN)=DFN  ; help DINUM to work
"RTN","HMPDJFSP",503,0)
 S FDA(800000.01,IENS,.01)=DFN
"RTN","HMPDJFSP",504,0)
 S FDA(800000.01,IENS,2)=0
"RTN","HMPDJFSP",505,0)
 S FDA(800000.01,IENS,3)=$$NOW^XLFDT
"RTN","HMPDJFSP",506,0)
 D UPDATE^DIE("","FDA","FDAIEN","ERR")
"RTN","HMPDJFSP",507,0)
 I $D(ERR) D SETERR^HMPDJFS("Error adding patient subscription")
"RTN","HMPDJFSP",508,0)
 D CLEAN^DILF
"RTN","HMPDJFSP",509,0)
 Q
"RTN","HMPDJFSP",510,0)
 ;
"RTN","HMPDJFSP",511,0)
 ;
"RTN","HMPDJFSP",512,0)
UPDSTS(DFN,SRVNM,STS) ; Update the sync status
"RTN","HMPDJFSP",513,0)
 ; called by:
"RTN","HMPDJFSP",514,0)
 ;   PUTSUB-QREJOIN
"RTN","HMPDJFSP",515,0)
 ;   MVFRUPD^HMPDJFSQ
"RTN","HMPDJFSP",516,0)
 ; calls:
"RTN","HMPDJFSP",517,0)
 ;   SETERR^HMPDJFS
"RTN","HMPDJFSP",518,0)
 ;   UPDOPD
"RTN","HMPDJFSP",519,0)
 ;   $$NOW^XLFDT
"RTN","HMPDJFSP",520,0)
 ;   FILE^DIE
"RTN","HMPDJFSP",521,0)
 ;   CLEAN^DILF
"RTN","HMPDJFSP",522,0)
 ;
"RTN","HMPDJFSP",523,0)
 N SRV,ERR ;US11019
"RTN","HMPDJFSP",524,0)
 S SRV=$O(^HMP(800000,"B",SRVNM,0)) I 'SRV D SETERR^HMPDJFS("Missing Server") Q
"RTN","HMPDJFSP",525,0)
 I DFN="OPD" D UPDOPD(SRV,STS) QUIT
"RTN","HMPDJFSP",526,0)
 ;
"RTN","HMPDJFSP",527,0)
 S FDA(800000.01,DFN_","_SRV_",",2)=STS
"RTN","HMPDJFSP",528,0)
 S FDA(800000.01,DFN_","_SRV_",",3)=$$NOW^XLFDT
"RTN","HMPDJFSP",529,0)
 D FILE^DIE("","FDA","ERR")
"RTN","HMPDJFSP",530,0)
 I $D(ERR) D SETERR^HMPDJFS("Error updating patient sync status")
"RTN","HMPDJFSP",531,0)
 D CLEAN^DILF
"RTN","HMPDJFSP",532,0)
 Q
"RTN","HMPDJFSP",533,0)
 ;
"RTN","HMPDJFSP",534,0)
 ;
"RTN","HMPDJFSP",535,0)
UPDPAT(DFN,SRV,STS) ; DEPRECATED?
"RTN","HMPDJFSP",536,0)
 ; called by: none
"RTN","HMPDJFSP",537,0)
 ; calls:
"RTN","HMPDJFSP",538,0)
 ;   UPDATE^DIE
"RTN","HMPDJFSP",539,0)
 ;
"RTN","HMPDJFSP",540,0)
 N ERR,FDA,IEN
"RTN","HMPDJFSP",541,0)
 S IEN=$O(^HMP(800000,"B",SRV,"")) I +IEN'>0 Q
"RTN","HMPDJFSP",542,0)
 I DFN="OPD" D
"RTN","HMPDJFSP",543,0)
 . S FDA(800000,"?"_IEN_",",.01)=SRV
"RTN","HMPDJFSP",544,0)
 . S FDA(800000,"?"_IEN_",",.03)=STS
"RTN","HMPDJFSP",545,0)
 I +DFN>0 D
"RTN","HMPDJFSP",546,0)
 .S FDA(800000.01,"?"_DFN_","_IEN_",",.01)=DFN
"RTN","HMPDJFSP",547,0)
 .S FDA(800000.01,"?"_DFN_","_IEN_",",2)=STS
"RTN","HMPDJFSP",548,0)
 D UPDATE^DIE("","FDA","","ERR")
"RTN","HMPDJFSP",549,0)
 Q
"RTN","HMPDJFSP",550,0)
 ;
"RTN","HMPDJFSP",551,0)
 ;
"RTN","HMPDJFSP",552,0)
TOTAL(DOMAIN) ; return size total
"RTN","HMPDJFSP",553,0)
 ; called by: none
"RTN","HMPDJFSP",554,0)
 ; calls:
"RTN","HMPDJFSP",555,0)
 ;   $$TOTAL^HMPDJFSQ
"RTN","HMPDJFSP",556,0)
 ;
"RTN","HMPDJFSP",557,0)
 quit $$TOTAL^HMPDJFSQ(DOMAIN) ; end of $$TOTAL
"RTN","HMPDJFSP",558,0)
 ;
"RTN","HMPDJFSP",559,0)
 ;
"RTN","HMPDJFSP",560,0)
OKTORUN(HMPTTYPE) ;execute 'ok to run' strategy
"RTN","HMPDJFSP",561,0)
 ; called by:
"RTN","HMPDJFSP",562,0)
 ;   CHKSP^HMPUTILS
"RTN","HMPDJFSP",563,0)
 ; calls:
"RTN","HMPDJFSP",564,0)
 ;   $$CHKSIZE
"RTN","HMPDJFSP",565,0)
 ; input:
"RTN","HMPDJFSP",566,0)
 ;   HMPTTYPE := type of task [ 'redoer' | 'extractor' | 'hangLoop']
"RTN","HMPDJFSP",567,0)
 ;          - currently not used but may become useful for strategy algorithms
"RTN","HMPDJFSP",568,0)
 ; output = 1 - ok to run task | 0 - do not run task
"RTN","HMPDJFSP",569,0)
 ;
"RTN","HMPDJFSP",570,0)
 Q $$CHKSIZE
"RTN","HMPDJFSP",571,0)
 ;
"RTN","HMPDJFSP",572,0)
 ;
"RTN","HMPDJFSP",573,0)
CHKSIZE() ; aggregate extract ^XTMP size strategy
"RTN","HMPDJFSP",574,0)
 ;islc/kcm,ven/toad;private;function;clean;silent;sac
"RTN","HMPDJFSP",575,0)
 ; called by:
"RTN","HMPDJFSP",576,0)
 ;   $$OKTORUN
"RTN","HMPDJFSP",577,0)
 ; calls:
"RTN","HMPDJFSP",578,0)
 ;   $$GETSIZE^HMPMONX = size of ehmp's usage of ^xtmp
"RTN","HMPDJFSP",579,0)
 ;   $$GETMAX = max size of that usage allowed
"RTN","HMPDJFSP",580,0)
 ; input:
"RTN","HMPDJFSP",581,0)
 ;   from the database, within $$GETSIZE & $$GETMAX
"RTN","HMPDJFSP",582,0)
 ; output = 1 if ^xtmp extract size is within limit, otherwise 0
"RTN","HMPDJFSP",583,0)
 ; examples:
"RTN","HMPDJFSP",584,0)
 ;   [develop examples]
"RTN","HMPDJFSP",585,0)
 ;
"RTN","HMPDJFSP",586,0)
 quit $$GETMAX>$$GETSIZE^HMPMONX
"RTN","HMPDJFSP",587,0)
 ;
"RTN","HMPDJFSP",588,0)
 ;
"RTN","HMPDJFSP",589,0)
CHKXTMP(HMPBATCH,HMPFZTSK) ; -- ^XTMP check at end each domain loop iteration ; if too big HANG
"RTN","HMPDJFSP",590,0)
 ; called by:
"RTN","HMPDJFSP",591,0)
 ;   DQINIT^HMPDJFSQ
"RTN","HMPDJFSP",592,0)
 ;   CHNKCHK
"RTN","HMPDJFSP",593,0)
 ; calls:
"RTN","HMPDJFSP",594,0)
 ;   $$OKTORUN
"RTN","HMPDJFSP",595,0)
 ;   $$GETSECS
"RTN","HMPDJFSP",596,0)
 ;
"RTN","HMPDJFSP",597,0)
 N HMPOK
"RTN","HMPDJFSP",598,0)
 S HMPOK=0
"RTN","HMPDJFSP",599,0)
 F  D  Q:HMPOK
"RTN","HMPDJFSP",600,0)
 . ; -- if ok to run, continue
"RTN","HMPDJFSP",601,0)
 . I $$OKTORUN("hangLoop") K ^XTMP(HMPBATCH,0,"task",HMPFZTSK,"hanging") S HMPOK=1 Q
"RTN","HMPDJFSP",602,0)
 . S ^("hanging")=$G(^XTMP(HMPBATCH,0,"task",HMPFZTSK,"hanging"))+1
"RTN","HMPDJFSP",603,0)
 . I $G(HMPQREF)'="" S @HMPQREF=$P($H,",",2) ;update heartbeat US13442
"RTN","HMPDJFSP",604,0)
 . H $$GETSECS
"RTN","HMPDJFSP",605,0)
 Q
"RTN","HMPDJFSP",606,0)
 ;
"RTN","HMPDJFSP",607,0)
 ;
"RTN","HMPDJFSP",608,0)
GETMAX() ; return the max allowable aggregate extract size
"RTN","HMPDJFSP",609,0)
 ; called by:
"RTN","HMPDJFSP",610,0)
 ;   MESNOK^HMPMETA
"RTN","HMPDJFSP",611,0)
 ;   MESOK^HMPMETA
"RTN","HMPDJFSP",612,0)
 ;   CHKXTMP
"RTN","HMPDJFSP",613,0)
 ;   $$CHKSIZE
"RTN","HMPDJFSP",614,0)
 ; calls:
"RTN","HMPDJFSP",615,0)
 ;   $$GET^XPAR
"RTN","HMPDJFSP",616,0)
 ;
"RTN","HMPDJFSP",617,0)
 N HMPLIM
"RTN","HMPDJFSP",618,0)
 S HMPLIM=$$GET^XPAR("SYS","HMP EXTRACT DISK SIZE LIMIT")*1000000
"RTN","HMPDJFSP",619,0)
 Q $S(HMPLIM:HMPLIM,1:20000000)  ; if not set, 20mb characters
"RTN","HMPDJFSP",620,0)
 ;
"RTN","HMPDJFSP",621,0)
 ;
"RTN","HMPDJFSP",622,0)
GETSECS() ; return default # of seconds to requeue in future or hang when processing domains
"RTN","HMPDJFSP",623,0)
 ; called by:
"RTN","HMPDJFSP",624,0)
 ;   CHKSP^HMPUTILS
"RTN","HMPDJFSP",625,0)
 ;   CHKXTMP
"RTN","HMPDJFSP",626,0)
 ; calls:
"RTN","HMPDJFSP",627,0)
 ;   $$GET^XPAR
"RTN","HMPDJFSP",628,0)
 ;
"RTN","HMPDJFSP",629,0)
 N SECS
"RTN","HMPDJFSP",630,0)
 S SECS=+$$GET^XPAR("SYS","HMP EXTRACT TASK REQUEUE SECS")
"RTN","HMPDJFSP",631,0)
 Q $S(SECS:SECS,1:10)   ; not set, wait 10 seconds
"RTN","HMPDJFSP",632,0)
 ;
"RTN","HMPDJFSP",633,0)
 ;
"RTN","HMPDJFSP",634,0)
EOR ; end of routine HMPDJFSP
"RTN","HMPDJFSQ")
0^63^B141457837
"RTN","HMPDJFSQ",1,0)
HMPDJFSQ ;ASMR/CPC -- Extract Queue manager ;2016-07-01 14:05Z
"RTN","HMPDJFSQ",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDJFSQ",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFSQ",4,0)
 ;
"RTN","HMPDJFSQ",5,0)
 quit  ; no entry at top of HMPDJFSQ
"RTN","HMPDJFSQ",6,0)
 ;
"RTN","HMPDJFSQ",7,0)
 ;
"RTN","HMPDJFSQ",8,0)
 ; primary development history:
"RTN","HMPDJFSQ",9,0)
 ;
"RTN","HMPDJFSQ",10,0)
 ; original author: Kevin C. Meldrum (kcm)
"RTN","HMPDJFSQ",11,0)
 ; additional author: Chris P. Casey (cpc)
"RTN","HMPDJFSQ",12,0)
 ; additional author: Frederick D. S. Marshall (toad)
"RTN","HMPDJFSQ",13,0)
 ; original org: U.S. Department of Veterans Affairs (va)
"RTN","HMPDJFSQ",14,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPDJFSQ",15,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPDJFSQ",16,0)
 ;
"RTN","HMPDJFSQ",17,0)
 ; va-DNS slc/kcm: original work creating and refining routine
"RTN","HMPDJFSQ",18,0)
 ; HMPDJFSM within VA. Later transferred to ASMR as part of eHMP
"RTN","HMPDJFSQ",19,0)
 ; contract. No timestamp on first line.
"RTN","HMPDJFSQ",20,0)
 ;
"RTN","HMPDJFSQ",21,0)
 ; 2016-05-05 asmr-cpc HMP*2.0*1: create routine HMPDJFSQ from
"RTN","HMPDJFSQ",22,0)
 ; subroutines in HMPDJFSP to bring it down under the SAC size limit;
"RTN","HMPDJFSQ",23,0)
 ; includes NEWQMGR,NEWTASK,QMGR,SAVETASK,QUINIT.
"RTN","HMPDJFSQ",24,0)
 ;
"RTN","HMPDJFSQ",25,0)
 ; 2016-06-30/07-01 asmr-ven/toad: create dev history, contents, EOR;
"RTN","HMPDJFSQ",26,0)
 ; add white space; document all calls in and out; add map; bring
"RTN","HMPDJFSQ",27,0)
 ; subroutines over from HMPDJFSP to fit it under SAC size limit:
"RTN","HMPDJFSQ",28,0)
 ; DQINIT,DOMOPD,$$TOTAL,MVFRUPD.
"RTN","HMPDJFSQ",29,0)
 ;
"RTN","HMPDJFSQ",30,0)
 ;
"RTN","HMPDJFSQ",31,0)
 ; contents
"RTN","HMPDJFSQ",32,0)
 ;
"RTN","HMPDJFSQ",33,0)
 ; initial extracts subroutines
"RTN","HMPDJFSQ",34,0)
 ;
"RTN","HMPDJFSQ",35,0)
 ; QUINIT: Queue the initial extracts for a patient
"RTN","HMPDJFSQ",36,0)
 ; DQINIT: task Dequeue initial extracts
"RTN","HMPDJFSQ",37,0)
 ; DOMOPD: Load an operational domain in smaller batches
"RTN","HMPDJFSQ",38,0)
 ; $$TOTAL = return size total
"RTN","HMPDJFSQ",39,0)
 ; MVFRUPD: Move freshness updates over active stream
"RTN","HMPDJFSQ",40,0)
 ;
"RTN","HMPDJFSQ",41,0)
 ; queue manager subroutines
"RTN","HMPDJFSQ",42,0)
 ;
"RTN","HMPDJFSQ",43,0)
 ; SAVETASK: save task request on job queue
"RTN","HMPDJFSQ",44,0)
 ; NEWQMGR: queuer Start new background Q manager
"RTN","HMPDJFSQ",45,0)
 ; QMGR: task Manage patient queues
"RTN","HMPDJFSQ",46,0)
 ; NEWTASK: queuer Start patient specific extract
"RTN","HMPDJFSQ",47,0)
 ;
"RTN","HMPDJFSQ",48,0)
 ;
"RTN","HMPDJFSQ",49,0)
 ; map
"RTN","HMPDJFSQ",50,0)
 ;
"RTN","HMPDJFSQ",51,0)
 ; PUTSUB-QREJOIN^HMPDJFSP -calls-> QUINIT =queues=> DQINIT
"RTN","HMPDJFSQ",52,0)
 ; DQINIT -calls-> DOMOPD
"RTN","HMPDJFSQ",53,0)
 ; DQINIT -calls-> MVFRUPD
"RTN","HMPDJFSQ",54,0)
 ;
"RTN","HMPDJFSQ",55,0)
 ; PUTSUB^HMPDJFSP -calls-> SAVETASK -calls-> NEWQMGR =queues=> QMGR
"RTN","HMPDJFSQ",56,0)
 ; QMGR -calls-> NEWTASK =queues=> QREJOIN^HMPDJFSP
"RTN","HMPDJFSQ",57,0)
 ;
"RTN","HMPDJFSQ",58,0)
 ;
"RTN","HMPDJFSQ",59,0)
 ;
"RTN","HMPDJFSQ",60,0)
 ; initial extracts subroutines
"RTN","HMPDJFSQ",61,0)
 ;
"RTN","HMPDJFSQ",62,0)
 ;
"RTN","HMPDJFSQ",63,0)
 ;
"RTN","HMPDJFSQ",64,0)
QUINIT(HMPBATCH,HMPFDFN,HMPFDOM) ; Queue the initial extracts for a patient
"RTN","HMPDJFSQ",65,0)
 ; called by:
"RTN","HMPDJFSQ",66,0)
 ;   PUTSUB-QREJOIN^HMPDJFSP
"RTN","HMPDJFSQ",67,0)
 ;   QUINIT^HMPDJFSP
"RTN","HMPDJFSQ",68,0)
 ; calls:
"RTN","HMPDJFSQ",69,0)
 ;   SETDOM^HMPDJFSP: Set value for a domain
"RTN","HMPDJFSQ",70,0)
 ;   DQINIT: ZTRTN="DQINIT^HMPDJFSQ"
"RTN","HMPDJFSQ",71,0)
 ;   ^%ZTLOAD: queue Build HMP Domains for a Patient task
"RTN","HMPDJFSQ",72,0)
 ;   SETERR^HMPDJFS: report error if queue attempt failed
"RTN","HMPDJFSQ",73,0)
 ; input:
"RTN","HMPDJFSQ",74,0)
 ;   HMPBATCH="HMPFX~hmpsrvid~dfn"  example: HMPFX~hmpXYZ~229
"RTN","HMPDJFSQ",75,0)
 ;   HMPFDOM(n)="domainName"
"RTN","HMPDJFSQ",76,0)
 ; 
"RTN","HMPDJFSQ",77,0)
 ; ^XTMP("HMPFX~hmpsrvid~dfn",0)=expires^created^HMP Patient Extract
"RTN","HMPDJFSQ",78,0)
 ;                           ,0,"status",domain)=0:waiting;1:ready
"RTN","HMPDJFSQ",79,0)
 ;                           ,0,"task",taskIen)=""
"RTN","HMPDJFSQ",80,0)
 ;                           ,taskIen,domain,... (extract data)
"RTN","HMPDJFSQ",81,0)
 ;
"RTN","HMPDJFSQ",82,0)
 ; set up the domains to be done by this task
"RTN","HMPDJFSQ",83,0)
 N I S I=0 F  S I=$O(HMPFDOM(I)) Q:'I  D SETDOM^HMPDJFSP("status",HMPFDOM(I),0)
"RTN","HMPDJFSQ",84,0)
 ;
"RTN","HMPDJFSQ",85,0)
 ; create task for this set of domains within the batch
"RTN","HMPDJFSQ",86,0)
 N ZTRTN,ZTDESC,ZTDTH,ZTIO,ZTSAVE,ZTSK
"RTN","HMPDJFSQ",87,0)
 S ZTRTN="DQINIT^HMPDJFSQ",ZTIO="HMP EXTRACT RESOURCE",ZTDTH=$H
"RTN","HMPDJFSQ",88,0)
 S ZTSAVE("HMPBATCH")="",ZTSAVE("HMPFDFN")="",ZTSAVE("HMPFDOM(")=""
"RTN","HMPDJFSQ",89,0)
 S ZTSAVE("HMPENVIR(")="" ; environment information
"RTN","HMPDJFSQ",90,0)
 S ZTSAVE("HMPSTMP")="" ; Operational data stamptime US6734
"RTN","HMPDJFSQ",91,0)
 S ZTSAVE("HMPSVERS")="" ; sync version US11019
"RTN","HMPDJFSQ",92,0)
 S ZTSAVE("HMPQREF")="" ; US13442
"RTN","HMPDJFSQ",93,0)
 S ZTDESC="Build HMP domains for a patient"
"RTN","HMPDJFSQ",94,0)
 D ^%ZTLOAD
"RTN","HMPDJFSQ",95,0)
 I $G(ZTSK) S ^XTMP(HMPBATCH,0,"task",ZTSK)="" Q
"RTN","HMPDJFSQ",96,0)
 D SETERR^HMPDJFS("Task not created")
"RTN","HMPDJFSQ",97,0)
 ;
"RTN","HMPDJFSQ",98,0)
 quit  ; end of QUINIT
"RTN","HMPDJFSQ",99,0)
 ;
"RTN","HMPDJFSQ",100,0)
 ;
"RTN","HMPDJFSQ",101,0)
DQINIT ; task Dequeue initial extracts
"RTN","HMPDJFSQ",102,0)
 ; called by:
"RTN","HMPDJFSQ",103,0)
 ;   QUINIT: ZTRTN="DQINIT^HMPDJFSQ"
"RTN","HMPDJFSQ",104,0)
 ;   QUINIT^HMPDJFSP: ZTRTN="DQINIT^HMPDJFSQ"
"RTN","HMPDJFSQ",105,0)
 ;   DQINIT^HMPDJFSP
"RTN","HMPDJFSQ",106,0)
 ;   QUINIT^HMPMETA
"RTN","HMPDJFSQ",107,0)
 ; calls:
"RTN","HMPDJFSQ",108,0)
 ;   $$SYS^HMPUTILS
"RTN","HMPDJFSQ",109,0)
 ;   $$HDIFF^XLFDT
"RTN","HMPDJFSQ",110,0)
 ;   CHKSP^HMPUTILS
"RTN","HMPDJFSQ",111,0)
 ;   SETMARK^HMPDJFSP
"RTN","HMPDJFSQ",112,0)
 ;   SETDOM^HMPDJFSP
"RTN","HMPDJFSQ",113,0)
 ;   DOMOPD
"RTN","HMPDJFSQ",114,0)
 ;   UPD^HMPMETA
"RTN","HMPDJFSQ",115,0)
 ;   DOMPT^HMPDJFSP
"RTN","HMPDJFSQ",116,0)
 ;   MERGE^HMPMETA
"RTN","HMPDJFSQ",117,0)
 ;   UPD^HMPMETA
"RTN","HMPDJFSQ",118,0)
 ;   MERGE1^HMPMETA
"RTN","HMPDJFSQ",119,0)
 ;   CHKXTMP^HMPDJFSP
"RTN","HMPDJFSQ",120,0)
 ;   $$INITDONE^HMPDJFSP
"RTN","HMPDJFSQ",121,0)
 ;   POSTERR^HMPDJFSP
"RTN","HMPDJFSQ",122,0)
 ;   MVFRUPD
"RTN","HMPDJFSQ",123,0)
 ; expects:
"RTN","HMPDJFSQ",124,0)
 ;   HMPBATCH, HMPFDFN, HMPFDOM, ZTSK
"RTN","HMPDJFSQ",125,0)
 ;
"RTN","HMPDJFSQ",126,0)
 N COUNT,HMPFDOMI,HMPFSYS,HMPFZTSK
"RTN","HMPDJFSQ",127,0)
 F COUNT=1:1:10 Q:$D(^XTMP(HMPBATCH,0,"task",ZTSK))  H .5 ;cpc 9/18/2015 In case job running too quickly
"RTN","HMPDJFSQ",128,0)
 I '$D(^XTMP(HMPBATCH,0,"task",ZTSK)) Q  ; extract was superceded
"RTN","HMPDJFSQ",129,0)
 K ^TMP("HMPERR",$J)
"RTN","HMPDJFSQ",130,0)
 S HMPFSYS=$$SYS^HMPUTILS
"RTN","HMPDJFSQ",131,0)
 S HMPFZTSK=ZTSK ; just in case the unexpected happens to ZTSK
"RTN","HMPDJFSQ",132,0)
 S ^XTMP(HMPBATCH,0,"task",ZTSK,"job")=$J
"RTN","HMPDJFSQ",133,0)
 S ^XTMP(HMPBATCH,0,"task",ZTSK,"wait")=$$HDIFF^XLFDT($H,$G(^XTMP(HMPBATCH,0,"time")),2)
"RTN","HMPDJFSQ",134,0)
 ;
"RTN","HMPDJFSQ",135,0)
 ;  S68 check space
"RTN","HMPDJFSQ",136,0)
 D CHKSP^HMPUTILS($P(HMPBATCH,"~",2)) ; US8228
"RTN","HMPDJFSQ",137,0)
 N HMPMETA ; US6734
"RTN","HMPDJFSQ",138,0)
 F HMPMETA=$S(HMPSVERS:2,1:1):-1:0 D  Q:HMPMETA=2  ;
"RTN","HMPDJFSQ",139,0)
 . I HMPMETA=0,+HMPFDFN D SETMARK^HMPDJFSP("Start",HMPFDFN,HMPBATCH) ; US6734
"RTN","HMPDJFSQ",140,0)
 . S HMPFDOMI=""
"RTN","HMPDJFSQ",141,0)
 . F  S HMPFDOMI=$O(HMPFDOM(HMPFDOMI)) Q:'HMPFDOMI  D
"RTN","HMPDJFSQ",142,0)
 ..  D SETDOM^HMPDJFSP("status",HMPFDOM(HMPFDOMI),0,HMPMETA) ; cpc TA41760
"RTN","HMPDJFSQ",143,0)
 ..  I HMPFDFN="OPD" D
"RTN","HMPDJFSQ",144,0)
 ...   D DOMOPD(HMPFDOM(HMPFDOMI))
"RTN","HMPDJFSQ",145,0)
 ...   I HMPMETA=2 D UPD^HMPMETA(HMPFDOM(HMPFDOMI)) ; US6734 - mark OPD domain as complete in metastamp
"RTN","HMPDJFSQ",146,0)
 ..  I +HMPFDFN D DOMPT^HMPDJFSP(HMPFDOM(HMPFDOMI))
"RTN","HMPDJFSQ",147,0)
 ..  I HMPMETA=1 D:'$O(HMPFDOM(HMPFDOMI)) MERGE^HMPMETA(HMPBATCH) D:HMPFDFN="OPD" UPD^HMPMETA(HMPFDOM(HMPFDOMI)) Q
"RTN","HMPDJFSQ",148,0)
 ..  I HMPMETA=2 D
"RTN","HMPDJFSQ",149,0)
 ...   D MERGE1^HMPMETA(HMPBATCH,HMPFDOM(HMPFDOMI)) ;US11019 - merge data into metastamp
"RTN","HMPDJFSQ",150,0)
 ...   I +HMPFDFN D SETMARK^HMPDJFSP("Meta",HMPFDFN,HMPFDOM(HMPFDOMI)) ;US11019 - new freshness entry replacing syncStart
"RTN","HMPDJFSQ",151,0)
 ...   I HMPFDFN="OPD" D:'$O(HMPFDOM(HMPFDOMI)) MERGE^HMPMETA(HMPBATCH) ; US6734 - merge data into metastamp
"RTN","HMPDJFSQ",152,0)
 ..  D SETDOM^HMPDJFSP("status",HMPFDOM(HMPFDOMI),1,HMPMETA) ; ready ; cpc TA41760
"RTN","HMPDJFSQ",153,0)
 ..  ; if superceded, stop processing domains
"RTN","HMPDJFSQ",154,0)
 ..  I '$D(^XTMP(HMPBATCH,0,"task",HMPFZTSK)) S HMPFDOMI=999 Q
"RTN","HMPDJFSQ",155,0)
 ..  ; -- if more domains, check ^XTMP size before continuing; may have to HANG if too big  *BEGIN*S68-JCH*
"RTN","HMPDJFSQ",156,0)
 ..  I +HMPFDFN,HMPFDOMI'=+$O(HMPFDOM(""),-1) D CHKXTMP^HMPDJFSP(HMPBATCH,HMPFZTSK) ;; US 5074 - removed
"RTN","HMPDJFSQ",157,0)
 ; if superceded, remove extracts produced by this task
"RTN","HMPDJFSQ",158,0)
 I '$D(^XTMP(HMPBATCH,0,"task",HMPFZTSK)) K ^XTMP(HMPBATCH,HMPFZTSK) Q
"RTN","HMPDJFSQ",159,0)
 ; don't assume initialized, since we may split domains to other tasks
"RTN","HMPDJFSQ",160,0)
 I $G(HMPQREF)'="" S @HMPQREF=$P($H,",",2) ;US13442 update heartbeat
"RTN","HMPDJFSQ",161,0)
 I $$INITDONE^HMPDJFSP(HMPBATCH) D  ; if all domains extracted
"RTN","HMPDJFSQ",162,0)
 . S COUNT=$O(^TMP("HMPERR",$J,"")) I COUNT>0 D POSTERR^HMPDJFSP(COUNT,HMPFDFN)
"RTN","HMPDJFSQ",163,0)
 . D SETMARK^HMPDJFSP("Done",HMPFDFN,HMPBATCH) ; - add updated syncStatus
"RTN","HMPDJFSQ",164,0)
 . D MVFRUPD(HMPBATCH,HMPFDFN)        ; - move freshness updates over
"RTN","HMPDJFSQ",165,0)
 . I $G(HMPQREF)'="" K @HMPQREF ;US13442 remove completed entry from queue
"RTN","HMPDJFSQ",166,0)
 ;
"RTN","HMPDJFSQ",167,0)
 K ^XTMP(HMPBATCH,0,"task",HMPFZTSK)  ; this task is done
"RTN","HMPDJFSQ",168,0)
 ;
"RTN","HMPDJFSQ",169,0)
 quit  ; end of DQINIT
"RTN","HMPDJFSQ",170,0)
 ;
"RTN","HMPDJFSQ",171,0)
 ;
"RTN","HMPDJFSQ",172,0)
DOMOPD(HMPFADOM) ; Load an operational domain in smaller batches
"RTN","HMPDJFSQ",173,0)
 ; called by:
"RTN","HMPDJFSQ",174,0)
 ;   DQINIT
"RTN","HMPDJFSQ",175,0)
 ;   DOMOPD^HMPDJFSP
"RTN","HMPDJFSQ",176,0)
 ; calls:
"RTN","HMPDJFSQ",177,0)
 ;   $$TOTAL
"RTN","HMPDJFSQ",178,0)
 ;   GET^HMPEF
"RTN","HMPDJFSQ",179,0)
 ;   MOD4STRM^HMPDJFSP
"RTN","HMPDJFSQ",180,0)
 ;   POSTSEC^HMPDJFSP
"RTN","HMPDJFSQ",181,0)
 ; expects:
"RTN","HMPDJFSQ",182,0)
 ;   HMPBATCH,HMPFZTSK
"RTN","HMPDJFSQ",183,0)
 ;
"RTN","HMPDJFSQ",184,0)
 N FILTER,RSLT,NEXTID,DONE,HMPFEST,HMPFSEC,HMPFSIZE,HMPFLDON ; cpc
"RTN","HMPDJFSQ",185,0)
 S HMPFSIZE=1000               ; section size (adjust to taste)
"RTN","HMPDJFSQ",186,0)
 S HMPFEST=$$TOTAL(HMPFADOM)   ; set estimated domain total
"RTN","HMPDJFSQ",187,0)
 S NEXTID=0,HMPFSEC=0,DONE=0,HMPFLDON=0 ;cpc
"RTN","HMPDJFSQ",188,0)
 S HMPFADOM=HMPFADOM_"#"_HMPFSEC
"RTN","HMPDJFSQ",189,0)
 F  D  Q:DONE
"RTN","HMPDJFSQ",190,0)
 . N FILTER,RSLT
"RTN","HMPDJFSQ",191,0)
 . S FILTER("noHead")=1
"RTN","HMPDJFSQ",192,0)
 . S FILTER("domain")=HMPFADOM ; include section for ^XTMP location
"RTN","HMPDJFSQ",193,0)
 . S FILTER("start")=NEXTID
"RTN","HMPDJFSQ",194,0)
 . S FILTER("limit")=HMPFSIZE
"RTN","HMPDJFSQ",195,0)
 . D GET^HMPEF(.RSLT,.FILTER)
"RTN","HMPDJFSQ",196,0)
 . I $G(HMPMETA)=1 S DONE=1 Q  ;US6734 - do not update stream if compiling metastamp
"RTN","HMPDJFSQ",197,0)
 . I '$D(^XTMP(HMPBATCH,0,"task",HMPFZTSK)) S DONE=1 QUIT  ; superceded
"RTN","HMPDJFSQ",198,0)
 . I $G(^XTMP(HMPBATCH,HMPFZTSK,HMPFADOM,"total"),0)=0,(HMPFSEC>0) S DONE=1 QUIT
"RTN","HMPDJFSQ",199,0)
 . I $G(^XTMP(HMPBATCH,HMPFZTSK,HMPFADOM,"finished")) S DONE=1
"RTN","HMPDJFSQ",200,0)
 . D MOD4STRM^HMPDJFSP(HMPFADOM)
"RTN","HMPDJFSQ",201,0)
 . I DONE S HMPFEST=^XTMP(HMPBATCH,0,"count",$P(HMPFADOM,"#")) S:'HMPFEST HMPFEST=1
"RTN","HMPDJFSQ",202,0)
 . D POSTSEC^HMPDJFSP(HMPFADOM,HMPFEST,HMPFSIZE)
"RTN","HMPDJFSQ",203,0)
 . Q:DONE
"RTN","HMPDJFSQ",204,0)
 . S NEXTID=$G(^XTMP(HMPBATCH,HMPFZTSK,HMPFADOM,"last"),0)
"RTN","HMPDJFSQ",205,0)
 . S HMPFSEC=HMPFSEC+1
"RTN","HMPDJFSQ",206,0)
 . S $P(HMPFADOM,"#",2)=HMPFSEC
"RTN","HMPDJFSQ",207,0)
 ;
"RTN","HMPDJFSQ",208,0)
 quit  ; end of DOMOPD
"RTN","HMPDJFSQ",209,0)
 ;
"RTN","HMPDJFSQ",210,0)
 ;
"RTN","HMPDJFSQ",211,0)
TOTAL(DOMAIN) ; return size total
"RTN","HMPDJFSQ",212,0)
 ; called by:
"RTN","HMPDJFSQ",213,0)
 ;   DOMOPD
"RTN","HMPDJFSQ",214,0)
 ;   $$TOTAL^HMPDJFSP
"RTN","HMPDJFSQ",215,0)
 ; calls: none
"RTN","HMPDJFSQ",216,0)
 ;
"RTN","HMPDJFSQ",217,0)
 N I,X,SIZE,ROOT
"RTN","HMPDJFSQ",218,0)
 S SIZE=0
"RTN","HMPDJFSQ",219,0)
 F I=1:1 S X=$T(OPDOMS+I^HMPDJFSD) Q:$P(X,";",3)="zzzzz"  D  Q:SIZE
"RTN","HMPDJFSQ",220,0)
 . I $P(X,";",3)'=DOMAIN Q
"RTN","HMPDJFSQ",221,0)
 . S ROOT=$P(X,";",4)
"RTN","HMPDJFSQ",222,0)
 . I ROOT="^HMP(800000.11)" S SIZE=$G(^HMP(800000.11,"ACNT",DOMAIN)) Q
"RTN","HMPDJFSQ",223,0)
 . I $L(ROOT) S SIZE=$P($G(@ROOT@(0)),U,4)
"RTN","HMPDJFSQ",224,0)
 ;
"RTN","HMPDJFSQ",225,0)
 quit $S(SIZE:SIZE,1:9999) ; end of $$TOTAL
"RTN","HMPDJFSQ",226,0)
 ;
"RTN","HMPDJFSQ",227,0)
 ;
"RTN","HMPDJFSQ",228,0)
MVFRUPD(HMPBATCH,HMPFDFN) ; Move freshness updates over active stream
"RTN","HMPDJFSQ",229,0)
 ; called by:
"RTN","HMPDJFSQ",230,0)
 ;   DQINIT
"RTN","HMPDJFSQ",231,0)
 ;   MVFRUPD^HMPDJFSP
"RTN","HMPDJFSQ",232,0)
 ; calls:
"RTN","HMPDJFSQ",233,0)
 ;   UPDSTS^HMPDJFSP
"RTN","HMPDJFSQ",234,0)
 ;   POST^HMPDJFS
"RTN","HMPDJFSQ",235,0)
 ;
"RTN","HMPDJFSQ",236,0)
 N I,X,FROM,HMPSRV,DFN,TYPE,ID,ACT
"RTN","HMPDJFSQ",237,0)
 S HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSQ",238,0)
 D UPDSTS^HMPDJFSP(HMPFDFN,HMPSRV,2)              ; now initialized
"RTN","HMPDJFSQ",239,0)
 S FROM="HMPFH~"_HMPSRV_"~"_HMPFDFN
"RTN","HMPDJFSQ",240,0)
 S I=0 F  S I=$O(^XTMP(FROM,I)) Q:'I  D  ; move over held updates
"RTN","HMPDJFSQ",241,0)
 . S X=^XTMP(FROM,I)
"RTN","HMPDJFSQ",242,0)
 . S DFN=$P(X,U),TYPE=$P(X,U,2),ID=$P(X,U,3),ACT=$P(X,U,4)
"RTN","HMPDJFSQ",243,0)
 . D POST^HMPDJFS(DFN,TYPE,ID,ACT,HMPSRV)
"RTN","HMPDJFSQ",244,0)
 K ^XTMP(FROM)
"RTN","HMPDJFSQ",245,0)
 ;
"RTN","HMPDJFSQ",246,0)
 quit  ; end of MVFRUPD
"RTN","HMPDJFSQ",247,0)
 ;
"RTN","HMPDJFSQ",248,0)
 ;
"RTN","HMPDJFSQ",249,0)
 ;
"RTN","HMPDJFSQ",250,0)
 ; queue manager subroutines
"RTN","HMPDJFSQ",251,0)
 ;
"RTN","HMPDJFSQ",252,0)
 ;
"RTN","HMPDJFSQ",253,0)
 ;
"RTN","HMPDJFSQ",254,0)
SAVETASK ; save task request on job queue
"RTN","HMPDJFSQ",255,0)
 ; called by:
"RTN","HMPDJFSQ",256,0)
 ;   PUTSUB^HMPDJFSP
"RTN","HMPDJFSQ",257,0)
 ; calls:
"RTN","HMPDJFSQ",258,0)
 ;   NEWQMGR: Start new background Q manager
"RTN","HMPDJFSQ",259,0)
 ;
"RTN","HMPDJFSQ",260,0)
 N HMPQS
"RTN","HMPDJFSQ",261,0)
 S HMPQS=$O(^XTMP(HMPQBTCH,HMPPRITY,""),-1)+1
"RTN","HMPDJFSQ",262,0)
 S ^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN)=""
"RTN","HMPDJFSQ",263,0)
 M ^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"ARGS")=ARGS
"RTN","HMPDJFSQ",264,0)
 M ^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"DOMAINS")=DOMAINS
"RTN","HMPDJFSQ",265,0)
 M ^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"HMPBATCH")=HMPBATCH
"RTN","HMPDJFSQ",266,0)
 M ^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"HMPSRV")=HMPSRV
"RTN","HMPDJFSQ",267,0)
 S ^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"HMPSVERS")=HMPSVERS
"RTN","HMPDJFSQ",268,0)
 ;check if task manager running if not start one
"RTN","HMPDJFSQ",269,0)
 L +^XTMP(HMPQBTCH,0):1 E  Q
"RTN","HMPDJFSQ",270,0)
 D NEWQMGR
"RTN","HMPDJFSQ",271,0)
 L -^XTMP(HMPQBTCH,0)
"RTN","HMPDJFSQ",272,0)
 ;
"RTN","HMPDJFSQ",273,0)
 quit  ; end of SAVETASK
"RTN","HMPDJFSQ",274,0)
 ;
"RTN","HMPDJFSQ",275,0)
 ;
"RTN","HMPDJFSQ",276,0)
NEWQMGR ; queuer Start new background Q manager
"RTN","HMPDJFSQ",277,0)
 ; called by:
"RTN","HMPDJFSQ",278,0)
 ;   SAVETASK
"RTN","HMPDJFSQ",279,0)
 ; calls:
"RTN","HMPDJFSQ",280,0)
 ;   ZTRTN="QMGR^HMPDJFSQ"
"RTN","HMPDJFSQ",281,0)
 ;   ^%ZTLOAD: queue HMP Patient QMGR task
"RTN","HMPDJFSQ",282,0)
 ;   SETERR^HMPDJFS: report error if queue attempt failed
"RTN","HMPDJFSQ",283,0)
 ;
"RTN","HMPDJFSQ",284,0)
 N ZTRTN,ZTDESC,ZTDTH,ZTIO,ZTSAVE,ZTSK
"RTN","HMPDJFSQ",285,0)
 S ZTRTN="QMGR^HMPDJFSQ",ZTIO="",ZTDTH=$H
"RTN","HMPDJFSQ",286,0)
 S ZTSAVE("HMPQBTCH")=""
"RTN","HMPDJFSQ",287,0)
 S ZTDESC="HMP patient QMGR"
"RTN","HMPDJFSQ",288,0)
 D ^%ZTLOAD
"RTN","HMPDJFSQ",289,0)
 I '$G(ZTSK) D SETERR^HMPDJFS("sync queue manager failed to start")
"RTN","HMPDJFSQ",290,0)
 ;
"RTN","HMPDJFSQ",291,0)
 quit  ; end of NEWQMGR
"RTN","HMPDJFSQ",292,0)
 ;
"RTN","HMPDJFSQ",293,0)
 ;
"RTN","HMPDJFSQ",294,0)
QMGR ; task Manage patient queues
"RTN","HMPDJFSQ",295,0)
 ; called by:
"RTN","HMPDJFSQ",296,0)
 ;   NEWQMGR: queue this subroutine as a task
"RTN","HMPDJFSQ",297,0)
 ; calls:
"RTN","HMPDJFSQ",298,0)
 ;   $$HTFM^XLFDT = convert horolog time to fileman
"RTN","HMPDJFSQ",299,0)
 ;   NEWTASK: Start patient specific extract
"RTN","HMPDJFSQ",300,0)
 ;
"RTN","HMPDJFSQ",301,0)
 L +^XTMP(HMPQBTCH,0):5 E  Q  ;prove running
"RTN","HMPDJFSQ",302,0)
 S $P(^XTMP(HMPQBTCH,0),U,1)=$$HTFM^XLFDT(+$H+5) ;Update deletion times
"RTN","HMPDJFSQ",303,0)
 N HMPQRC,HMPQPC,HMPQNOW,HMPQRUN,HMPQRUNC,HMPQTOTP,HMPQDAT,HMPQUIT,HMPQI,HMPQQ,HMPQREF
"RTN","HMPDJFSQ",304,0)
 S HMPQUIT=0 F  D  H 1 Q:HMPQUIT
"RTN","HMPDJFSQ",305,0)
 . S HMPQTOTP=+$P($G(^XTMP(HMPQBTCH,0,0)),U) I 'HMPQTOTP S HMPQTOTP=2 ;max no of patients to run
"RTN","HMPDJFSQ",306,0)
 . S HMPQNOW=$P($H,",",2)
"RTN","HMPDJFSQ",307,0)
 . K HMPQRUNC S HMPQRUNC=0
"RTN","HMPDJFSQ",308,0)
 . ;de4661 First count current running
"RTN","HMPDJFSQ",309,0)
 . S HMPQQ="^XTMP("""_HMPQBTCH_""",0,0)"
"RTN","HMPDJFSQ",310,0)
 . F HMPQI=0:1 S HMPQQ=$Q(@HMPQQ) Q:HMPQQ'[HMPQBTCH  Q:HMPQQ=""  I $QL(HMPQQ)=4 D  Q:HMPQRUNC>=HMPQTOTP
"RTN","HMPDJFSQ",311,0)
 ..  S HMPQDAT=$G(@HMPQQ),HMPFDFN=$QS(HMPQQ,4)
"RTN","HMPDJFSQ",312,0)
 ..  I HMPQDAT S HMPQRUNC=HMPQRUNC+1,HMPQRUNC(HMPFDFN)=""
"RTN","HMPDJFSQ",313,0)
 . Q:HMPQRUNC>=HMPQTOTP
"RTN","HMPDJFSQ",314,0)
 . S HMPQRUN=HMPQRUNC
"RTN","HMPDJFSQ",315,0)
 . S HMPQQ="^XTMP("""_HMPQBTCH_""",0,0)"
"RTN","HMPDJFSQ",316,0)
 . F HMPQI=0:1 S HMPQQ=$Q(@HMPQQ) Q:HMPQQ'[HMPQBTCH  Q:HMPQQ=""  I $QL(HMPQQ)=4 D  Q:HMPQRUN>=HMPQTOTP
"RTN","HMPDJFSQ",317,0)
 ..  S HMPQDAT=$G(@HMPQQ)
"RTN","HMPDJFSQ",318,0)
 ..  N NEWSUB,HMMPDFN,ARGS,DOMAINS,HMPBATCH,HMPSRV,HMPPRITY,HMPQS,HMPSVERS
"RTN","HMPDJFSQ",319,0)
 ..  S HMPPRITY=$QS(HMPQQ,2),HMPQS=$QS(HMPQQ,3),HMPFDFN=$QS(HMPQQ,4)
"RTN","HMPDJFSQ",320,0)
 ..  I 'HMPQDAT D  Q  ;task job
"RTN","HMPDJFSQ",321,0)
 ...   ;restore data
"RTN","HMPDJFSQ",322,0)
 ...   S NEWSUB=1
"RTN","HMPDJFSQ",323,0)
 ...   M ARGS=^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"ARGS")
"RTN","HMPDJFSQ",324,0)
 ...   M DOMAINS=^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"DOMAINS")
"RTN","HMPDJFSQ",325,0)
 ...   M HMPBATCH=^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"HMPBATCH")
"RTN","HMPDJFSQ",326,0)
 ...   M HMPSRV=^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"HMPSRV")
"RTN","HMPDJFSQ",327,0)
 ...   S HMPSVERS=^XTMP(HMPQBTCH,HMPPRITY,HMPQS,HMPFDFN,"HMPSVERS")
"RTN","HMPDJFSQ",328,0)
 ...   S @HMPQQ=$P($H,",",2) ;set start time
"RTN","HMPDJFSQ",329,0)
 ...   S HMPQREF=HMPQQ
"RTN","HMPDJFSQ",330,0)
 ...   D NEWTASK
"RTN","HMPDJFSQ",331,0)
 ...   S HMPQRUN=HMPQRUN+1
"RTN","HMPDJFSQ",332,0)
 ..  I (HMPQNOW-HMPQDAT)>300!(HMPQNOW>300&((HMPQNOW-HMPQDAT)<0)) K @HMPQQ Q  ;job static too long go to next
"RTN","HMPDJFSQ",333,0)
 ..  I '$D(HMPQRUNC(HMPFDFN)) S HMPQRUN=HMPQRUN+1 ;de4661 - don't add already counted
"RTN","HMPDJFSQ",334,0)
 . I 'HMPQI S HMPQUIT=1 ;nothing left to process
"RTN","HMPDJFSQ",335,0)
 L -^XTMP(HMPQBTCH,0) ;clear lock when ending
"RTN","HMPDJFSQ",336,0)
 ;
"RTN","HMPDJFSQ",337,0)
 quit  ; end of QMGR
"RTN","HMPDJFSQ",338,0)
 ;
"RTN","HMPDJFSQ",339,0)
 ;
"RTN","HMPDJFSQ",340,0)
NEWTASK ; queuer Start patient specific extract
"RTN","HMPDJFSQ",341,0)
 ; called by:
"RTN","HMPDJFSQ",342,0)
 ;   QMGR
"RTN","HMPDJFSQ",343,0)
 ; calls:
"RTN","HMPDJFSQ",344,0)
 ;   ZTRTN="QREJOIN^HMPDJFSP"
"RTN","HMPDJFSQ",345,0)
 ;   ^%ZTLOAD: queue HMP Patient QMGRTSK task
"RTN","HMPDJFSQ",346,0)
 ;   SETERR^HMPDJFS: report error if queue attempt failed
"RTN","HMPDJFSQ",347,0)
 ;
"RTN","HMPDJFSQ",348,0)
 N ZTRTN,ZTDESC,ZTDTH,ZTIO,ZTSAVE,ZTSK
"RTN","HMPDJFSQ",349,0)
 S ZTRTN="QREJOIN^HMPDJFSP",ZTIO="",ZTDTH=$H
"RTN","HMPDJFSQ",350,0)
 S ZTSAVE("HMPQBTCH")=""
"RTN","HMPDJFSQ",351,0)
 S ZTSAVE("HMPBATCH")="",ZTSAVE("HMPFDFN")="",ZTSAVE("DOMAINS(")=""
"RTN","HMPDJFSQ",352,0)
 S ZTSAVE("HMPENVIR(")="",ZTSAVE("ARGS(")=""  ; environment information
"RTN","HMPDJFSQ",353,0)
 S ZTSAVE("HMPSTMP")="" ; Operational data stamptime US6734
"RTN","HMPDJFSQ",354,0)
 S ZTSAVE("HMPSVERS")="" ;sync version US11019
"RTN","HMPDJFSQ",355,0)
 S ZTSAVE("NEWSUB")=""
"RTN","HMPDJFSQ",356,0)
 S ZTSAVE("HMPSRV")="",ZTSAVE("HMPSRV(")=""
"RTN","HMPDJFSQ",357,0)
 S ZTSAVE("HMPQREF")="" ;US13442
"RTN","HMPDJFSQ",358,0)
 S ZTDESC="HMP patient QMGRTSK"
"RTN","HMPDJFSQ",359,0)
 D ^%ZTLOAD
"RTN","HMPDJFSQ",360,0)
 I '$G(ZTSK) D SETERR^HMPDJFS("Task MANAGER TASK not created")
"RTN","HMPDJFSQ",361,0)
 ;
"RTN","HMPDJFSQ",362,0)
 quit  ; end of NEWTASK
"RTN","HMPDJFSQ",363,0)
 ;
"RTN","HMPDJFSQ",364,0)
 ;
"RTN","HMPDJFSQ",365,0)
EOR ; end of routine HMPDJFSQ
"RTN","HMPDMC")
0^15^B58301952
"RTN","HMPDMC",1,0)
HMPDMC ;SLC/MKB,ASMR/RRB,CPC - Clinical Procedures (Medicine);May 31, 2016 19:31:41
"RTN","HMPDMC",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDMC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDMC",4,0)
 ;
"RTN","HMPDMC",5,0)
 ; DE2818, ^SC and ^VA(200) references supprted
"RTN","HMPDMC",6,0)
 ; External References          DBIA#
"RTN","HMPDMC",7,0)
 ; -------------------          -----
"RTN","HMPDMC",8,0)
 ; ^SC                          10040
"RTN","HMPDMC",9,0)
 ; ^TIU(8925.1                   5677
"RTN","HMPDMC",10,0)
 ; ^VA(200                      10060
"RTN","HMPDMC",11,0)
 ; %DT                          10003
"RTN","HMPDMC",12,0)
 ; DILFD                         2055
"RTN","HMPDMC",13,0)
 ; DIQ                           2056
"RTN","HMPDMC",14,0)
 ; GMRCGUIB                      2980
"RTN","HMPDMC",15,0)
 ; ICPTCOD                       1995
"RTN","HMPDMC",16,0)
 ; MCARUTL2                      3279
"RTN","HMPDMC",17,0)
 ; MCARUTL3                      3280
"RTN","HMPDMC",18,0)
 ; MDPS1,^TMP("MDHSP"/"MDPTXT"   4230
"RTN","HMPDMC",19,0)
 ; TIULQ                         2693
"RTN","HMPDMC",20,0)
 ; TIUSRVLO                      2834
"RTN","HMPDMC",21,0)
 ; XUAF4                         2171
"RTN","HMPDMC",22,0)
 Q
"RTN","HMPDMC",23,0)
 ; ------------ Get procedures from VistA ------------
"RTN","HMPDMC",24,0)
 ;
"RTN","HMPDMC",25,0)
EN(DFN,BEG,END,MAX,ID) ; -- find patient's procedures
"RTN","HMPDMC",26,0)
 N HMPITM,RES,HMPN,HMPX,RTN,DATE,CONS,TIUN,X0,DA,GBL,X,Y,%DT,HMPT,LT,NT,LOC
"RTN","HMPDMC",27,0)
 S BEG=$G(BEG,1410101),END=$G(END,4141015),MAX=$G(MAX,9999)
"RTN","HMPDMC",28,0)
 S DFN=+$G(DFN) Q:DFN<1
"RTN","HMPDMC",29,0)
 ;
"RTN","HMPDMC",30,0)
 ; get one procedure
"RTN","HMPDMC",31,0)
 I $G(ID) D  ;reset dates for MDPS1
"RTN","HMPDMC",32,0)
 . N HMPMC,IEN,FILE
"RTN","HMPDMC",33,0)
 . S IEN=+ID,FILE=+$P(ID,"(",2) Q:FILE=702
"RTN","HMPDMC",34,0)
 . D MEDLKUP^MCARUTL3(.HMPMC,FILE,IEN)
"RTN","HMPDMC",35,0)
 . S X=$P(HMPMC,U,6) S:X (BEG,END)=X
"RTN","HMPDMC",36,0)
 ;
"RTN","HMPDMC",37,0)
 ; get all procedures
"RTN","HMPDMC",38,0)
 K ^TMP("MDHSP",$J) S RES=""
"RTN","HMPDMC",39,0)
 D EN1^MDPS1(RES,DFN,BEG,END,MAX,"",0)
"RTN","HMPDMC",40,0)
 S HMPN=0 F  S HMPN=$O(^TMP("MDHSP",$J,HMPN)) Q:HMPN<1  S HMPX=$G(^(HMPN)) D
"RTN","HMPDMC",41,0)
 . I $G(ID),ID'=+$P(HMPX,U,2) Q              ;update one procedure
"RTN","HMPDMC",42,0)
 . S RTN=$P(HMPX,U,3,4) Q:RTN="PRPRO^MDPS4"  ;skip non-CP items
"RTN","HMPDMC",43,0)
 . S X=$P(HMPX,U,6),%DT="TX" D ^%DT S:Y>0 DATE=Y
"RTN","HMPDMC",44,0)
 . S GBL=+$P(HMPX,U,2)_";"_$S(RTN="PR702^MDPS1":"MDD(702,",1:$$ROOT(DFN,$P(HMPX,U,11),DATE))
"RTN","HMPDMC",45,0)
 . Q:'GBL  I $G(ID),ID'=GBL Q                ;unknown, or not requested
"RTN","HMPDMC",46,0)
 . ;
"RTN","HMPDMC",47,0)
 . S CONS=+$P(HMPX,U,13) D:CONS DOCLIST^GMRCGUIB(.HMPD,CONS) S X0=$G(HMPD(0)) ;=^GMR(123,ID,0)
"RTN","HMPDMC",48,0)
 . S TIUN=+$P(HMPX,U,14) S:TIUN TIUN=TIUN_U_$$RESOLVE^TIUSRVLO(TIUN)
"RTN","HMPDMC",49,0)
A . ;
"RTN","HMPDMC",50,0)
 . K HMPITM S HMPITM("id")=GBL,HMPITM("name")=$P(HMPX,U)
"RTN","HMPDMC",51,0)
 . S HMPITM("dateTime")=DATE,HMPITM("category")="CP"
"RTN","HMPDMC",52,0)
 . S X=$P(HMPX,U,7) S:$L(X) HMPITM("interpretation")=X
"RTN","HMPDMC",53,0)
 . I CONS,X0 D
"RTN","HMPDMC",54,0)
 .. N HMPJ S HMPITM("consult")=CONS
"RTN","HMPDMC",55,0)
 .. S HMPITM("requested")=+X0,HMPITM("order")=+$P(X0,U,3)
"RTN","HMPDMC",56,0)
 .. S HMPITM("status")=$$EXTERNAL^DILFD(123,8,,$P(X0,U,12))
"RTN","HMPDMC",57,0)
 .. S HMPJ=0 F  S HMPJ=$O(HMPD(50,HMPJ)) Q:HMPJ<1  S X=+$G(HMPD(50,HMPJ)) D
"RTN","HMPDMC",58,0)
 ... K HMPT D EXTRACT^TIULQ(X,"HMPT",,.01) S LT=$G(HMPT(X,.01,"E"))
"RTN","HMPDMC",59,0)
 ... S NT=$$GET1^DIQ(8925.1,+$G(HMPT(X,.01,"I"))_",",1501)
"RTN","HMPDMC",60,0)
 ... S HMPITM("document",X)=X_U_LT_U_NT  ;ien^local^national title
"RTN","HMPDMC",61,0)
 ... S:$G(HMPTEXT) HMPITM("document",X,"content")=$$TEXT^HMPDTIU(X)
"RTN","HMPDMC",62,0)
 ... S:'TIUN TIUN=X ;get supporting fields
"RTN","HMPDMC",63,0)
B . ;
"RTN","HMPDMC",64,0)
 . I TIUN D
"RTN","HMPDMC",65,0)
 .. S X=$P(TIUN,U,5) S:X HMPITM("provider")=+X_U_$P(X,";",3)
"RTN","HMPDMC",66,0)
 .. S:$P(TIUN,U,11) HMPITM("hasImages")=1
"RTN","HMPDMC",67,0)
 .. K HMPT D EXTRACT^TIULQ(+TIUN,"HMPT",,".03;.05;1211",,,"I")
"RTN","HMPDMC",68,0)
 .. S HMPITM("encounter")=+$G(HMPT(+TIUN,.03,"I"))
"RTN","HMPDMC",69,0)
 .. S LOC=+$G(HMPT(+TIUN,1211,"I")) I LOC S LOC=LOC_U_$P($G(^SC(LOC,0)),U)
"RTN","HMPDMC",70,0)
 .. E  S X=$P(TIUN,U,6) S:$L(X) LOC=+$O(^SC("B",X,0))_U_X
"RTN","HMPDMC",71,0)
 .. S:LOC HMPITM("location")=LOC,HMPITM("facility")=$$FAC^HMPD(+LOC)
"RTN","HMPDMC",72,0)
 .. I '$D(HMPITM("status")) S X=+$G(HMPT(+TIUN,.05,"I")),HMPITM("status")=$S(X<6:"PARTIAL RESULTS",1:"COMPLETE")
"RTN","HMPDMC",73,0)
 .. I '$G(HMPITM("document",+TIUN)) D
"RTN","HMPDMC",74,0)
 ... K HMPT D EXTRACT^TIULQ(+TIUN,"HMPT",,.01,,,"I")
"RTN","HMPDMC",75,0)
 ... S NT=$$GET1^DIQ(8925.1,+$G(HMPT(+TIUN,.01,"I"))_",",1501)
"RTN","HMPDMC",76,0)
 ... S HMPITM("document",+TIUN)=$P(TIUN,U,1,2)_U_NT  ;ien^local^national title
"RTN","HMPDMC",77,0)
 ... S:$G(HMPTEXT) HMPITM("document",+TIUN,"content")=$$TEXT^HMPDTIU(+TIUN)
"RTN","HMPDMC",78,0)
C . ;
"RTN","HMPDMC",79,0)
 . ; if no consult or note/visit ...
"RTN","HMPDMC",80,0)
 . I '$D(HMPITM("facility")) S X=$P(X0,U,21),HMPITM("facility")=$S(X:$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U),1:$$FAC^HMPD)
"RTN","HMPDMC",81,0)
 . I '$D(HMPITM("status")) S HMPITM("status")="COMPLETE"
"RTN","HMPDMC",82,0)
 . ;I DA D  ;get CPT code from #697.2
"RTN","HMPDMC",83,0)
 . ;. K HMPT D GETS^DIQ(697.2,DA_",","1000*",,"HMPT")
"RTN","HMPDMC",84,0)
 . ;. N IENS S IENS=$O(HMPT(697.21,"")) Q:IENS=""
"RTN","HMPDMC",85,0)
 . ;. S X=HMPT(697.21,IENS,.01),HMPITM("type")=$$CPT(X)
"RTN","HMPDMC",86,0)
 . ;
"RTN","HMPDMC",87,0)
 . D XML(.HMPITM)
"RTN","HMPDMC",88,0)
ENQ ;
"RTN","HMPDMC",89,0)
 K ^TMP("MDHSP",$J),^TMP("HMPTEXT",$J)
"RTN","HMPDMC",90,0)
 Q
"RTN","HMPDMC",91,0)
 ;
"RTN","HMPDMC",92,0)
ROOT(DFN,NAME,DATE) ; -- return vptr ID for procedure instance
"RTN","HMPDMC",93,0)
 N HMPMC,Y
"RTN","HMPDMC",94,0)
 D SUB^MCARUTL2(.HMPMC,DFN,NAME,DATE,DATE)
"RTN","HMPDMC",95,0)
 S Y=$S(+$G(HMPMC):$P($G(HMPMC(HMPMC)),U,4)_",",1:"")
"RTN","HMPDMC",96,0)
 Q Y
"RTN","HMPDMC",97,0)
 ;
"RTN","HMPDMC",98,0)
CPT(IEN) ; -- return code^description for CPT code, or "^" if error
"RTN","HMPDMC",99,0)
 N X0,HMPX,N,I,X,Y S IEN=+$G(IEN)
"RTN","HMPDMC",100,0)
 S X0=$$CPT^ICPTCOD(IEN) I X0<0 Q "^"
"RTN","HMPDMC",101,0)
 S Y=$P(X0,U,2,3)                   ;CPT Code^Short Name
"RTN","HMPDMC",102,0)
 S N=$$CPTD^ICPTCOD($P(Y,U),"HMPX") ;CPT Description
"RTN","HMPDMC",103,0)
 I N>0,$L($G(HMPX(1))) D
"RTN","HMPDMC",104,0)
 . S X=$G(HMPX(1)),I=1
"RTN","HMPDMC",105,0)
 . F  S I=$O(HMPX(I)) Q:I<1  Q:HMPX(I)=" "  S X=X_" "_HMPX(I)
"RTN","HMPDMC",106,0)
 . S $P(Y,U,2)=X
"RTN","HMPDMC",107,0)
 Q Y
"RTN","HMPDMC",108,0)
 ;
"RTN","HMPDMC",109,0)
 ; ------------ Get report(s) [via HMPDTIU] ------------
"RTN","HMPDMC",110,0)
 ;
"RTN","HMPDMC",111,0)
RPTS(DFN,BEG,END,MAX) ; -- find patient's medicine reports
"RTN","HMPDMC",112,0)
 N HMPITM,HMPN,HMPX,RTN,TIUN,CONS,HMPD,I,DA,X,Y,%DT,DATE,GBL,RES
"RTN","HMPDMC",113,0)
 S DFN=+$G(DFN) Q:$G(DFN)<1
"RTN","HMPDMC",114,0)
 S BEG=$G(BEG,1410101),END=$G(END,4141015),MAX=$G(MAX,9999),RES=""
"RTN","HMPDMC",115,0)
 K ^TMP("MDHSP",$J) D EN1^MDPS1(RES,DFN,BEG,END,MAX,"",0)
"RTN","HMPDMC",116,0)
 S HMPN=0 F  S HMPN=$O(^TMP("MDHSP",$J,HMPN)) Q:HMPN<1  S HMPX=$G(^(HMPN)) D
"RTN","HMPDMC",117,0)
 . S RTN=$P(HMPX,U,3,4) ;Q:RTN="PRPRO^MDPS4"  ;skip non-CP items
"RTN","HMPDMC",118,0)
 . S TIUN=+$P(HMPX,U,14) K HMPITM
"RTN","HMPDMC",119,0)
 . I TIUN D EN1^HMPDTIU(TIUN,.HMPITM),XML^HMPDTIU(.HMPITM):$D(HMPITM)
"RTN","HMPDMC",120,0)
 . S CONS=+$P(HMPX,U,13) D:CONS DOCLIST^GMRCGUIB(.HMPD,CONS)
"RTN","HMPDMC",121,0)
 . S I=0 F  S I=$O(HMPD(50,I)) Q:I<1  D
"RTN","HMPDMC",122,0)
 .. K HMPITM S DA=+HMPD(50,I) Q:DA=TIUN
"RTN","HMPDMC",123,0)
 .. D EN1^HMPDTIU(DA,.HMPITM),XML^HMPDTIU(.HMPITM):$D(HMPITM)
"RTN","HMPDMC",124,0)
 . Q:TIUN!$G(DA)                             ;done [got TIU note(s)]
"RTN","HMPDMC",125,0)
 . Q:RTN="PR702^MDPS1"                       ;CP, but no TIU note yet
"RTN","HMPDMC",126,0)
 . Q:RTN="PRPRO^MDPS4"                       ;non-CP procedure
"RTN","HMPDMC",127,0)
 . ; find ID for pre-TIU report
"RTN","HMPDMC",128,0)
 . S X=$P(HMPX,U,6),%DT="TX" D ^%DT S:Y>0 DATE=Y
"RTN","HMPDMC",129,0)
 . S GBL=+$P(HMPX,U,2)_";"_$$ROOT(DFN,$P(HMPX,U,11),DATE)
"RTN","HMPDMC",130,0)
 . I GBL D RPT1(DFN,GBL,.HMPITM),XML^HMPDTIU(.HMPITM):$D(HMPITM)
"RTN","HMPDMC",131,0)
 K ^TMP("MDHSP",$J),^TMP("HMPTEXT",$J)
"RTN","HMPDMC",132,0)
 Q
"RTN","HMPDMC",133,0)
 ;
"RTN","HMPDMC",134,0)
RPT1(DFN,ID,RPT) ; -- return report as a TIU document
"RTN","HMPDMC",135,0)
 S DFN=+$G(DFN),ID=$G(ID) Q:DFN<1  Q:'$L(ID)
"RTN","HMPDMC",136,0)
 N HMPY,HMPFN,X
"RTN","HMPDMC",137,0)
 S HMPFN=+$P(ID,"(",2)
"RTN","HMPDMC",138,0)
 D MEDLKUP^MCARUTL3(.HMPY,HMPFN,+ID)
"RTN","HMPDMC",139,0)
 S RPT("id")=ID,RPT("referenceDateTime")=$P(HMPY,U,6)
"RTN","HMPDMC",140,0)
 S RPT("localTitle")=$P(HMPY,U,9),RPT("category")="CP"
"RTN","HMPDMC",141,0)
 S RPT("documentClass")="CLINICAL PROCEDURES"
"RTN","HMPDMC",142,0)
 S RPT("nationalTitle")="4696566^PROCEDURE REPORT"
"RTN","HMPDMC",143,0)
 S RPT("nationalTitleService")="4696471^PROCEDURE"
"RTN","HMPDMC",144,0)
 S RPT("nationalTitleType")="4696123^REPORT"
"RTN","HMPDMC",145,0)
 S:$G(FILTER("loinc")) RPT("loinc")=$P(FILTER("loinc"),U)
"RTN","HMPDMC",146,0)
 S X=$$GET1^DIQ(HMPFN,+ID_",",1506)
"RTN","HMPDMC",147,0)
 S RPT("status")=$S($L(X):X,1:"COMPLETED")
"RTN","HMPDMC",148,0)
 S X=+$$GET1^DIQ(HMPFN,+ID_",",701,"I")
"RTN","HMPDMC",149,0)
 S:X RPT("clinician",1)=X_U_$P($G(^VA(200,X,0)),U)_"^A"
"RTN","HMPDMC",150,0)
 S X=+$$GET1^DIQ(HMPFN,+ID_",",1503,"I")
"RTN","HMPDMC",151,0)
 S:X RPT("clinician",2)=X_U_$P($G(^VA(200,X,0)),U)_"^S^"_$$GET1^DIQ(HMPFN,+ID_",",1505,"I")_U_$$SIG^HMPDTIU(X)
"RTN","HMPDMC",152,0)
 ; RPT("encounter")=$$GET1^DIQ(HMPFN,+ID_",",900,"I")
"RTN","HMPDMC",153,0)
 S RPT("facility")=$$FAC^HMPD
"RTN","HMPDMC",154,0)
 S:$G(HMPTEXT) RPT("content")=$$TEXT(DFN,ID,$P(HMPY,U,9))
"RTN","HMPDMC",155,0)
 Q
"RTN","HMPDMC",156,0)
 ;
"RTN","HMPDMC",157,0)
TEXT(DFN,ID,NAME) ; -- Get report text, return temp array name
"RTN","HMPDMC",158,0)
 N MCARGDA,MCPRO,MDALL,I,X,Y ;de3944
"RTN","HMPDMC",159,0)
 S MCARGDA=+$G(ID),MCPRO=NAME,MDALL=1 D PR690^MDPS1
"RTN","HMPDMC",160,0)
 K ^TMP("HMPTEXT",$J,ID)
"RTN","HMPDMC",161,0)
 S I=0 F  S I=$O(^TMP("MDPTXT",$J,MCARGDA,MCPRO,I)) Q:I<1  S X=$G(^(I,0)),^TMP("HMPTEXT",$J,ID,I)=X
"RTN","HMPDMC",162,0)
 S Y=$NA(^TMP("HMPTEXT",$J,ID))
"RTN","HMPDMC",163,0)
 Q Y
"RTN","HMPDMC",164,0)
 ;
"RTN","HMPDMC",165,0)
 ; ------------ Return data to middle tier ------------
"RTN","HMPDMC",166,0)
 ;
"RTN","HMPDMC",167,0)
XML(PROC) ; -- Return patient procedure as XML
"RTN","HMPDMC",168,0)
 ;  as <element code='123' displayName='ABC' />
"RTN","HMPDMC",169,0)
 N ATT,X,Y,I,J,NAMES
"RTN","HMPDMC",170,0)
 D ADD("<procedure>") S HMPTOTL=$G(HMPTOTL)+1
"RTN","HMPDMC",171,0)
 S ATT="" F  S ATT=$O(PROC(ATT)) Q:ATT=""  D  D:$L(Y) ADD(Y)
"RTN","HMPDMC",172,0)
 . S NAMES=$S(ATT="document":"id^localTitle^nationalTitle^Z",1:"code^name^Z")
"RTN","HMPDMC",173,0)
 . I $O(PROC(ATT,0)) D  S Y="" Q  ;multiples
"RTN","HMPDMC",174,0)
 .. D ADD("<"_ATT_"s>")
"RTN","HMPDMC",175,0)
 .. S I=0 F  S I=$O(PROC(ATT,I)) Q:I<1  D
"RTN","HMPDMC",176,0)
 ... S X=$G(PROC(ATT,I)),Y="<"_ATT_" "_$$LOOP
"RTN","HMPDMC",177,0)
 ... S X=$G(PROC(ATT,I,"content")) I '$L(X) S Y=Y_"/>" D ADD(Y) Q
"RTN","HMPDMC",178,0)
 ... S Y=Y_">" D ADD(Y)
"RTN","HMPDMC",179,0)
 ... S Y="<content xml:space='preserve'>" D ADD(Y)
"RTN","HMPDMC",180,0)
 ... S J=0 F  S J=$O(@X@(J)) Q:J<1  S Y=$$ESC^HMPD(@X@(J)) D ADD(Y)
"RTN","HMPDMC",181,0)
 ... D ADD("</content>"),ADD("</"_ATT_">")
"RTN","HMPDMC",182,0)
 .. D ADD("</"_ATT_"s>")
"RTN","HMPDMC",183,0)
 . S X=$G(PROC(ATT)),Y="" Q:'$L(X)
"RTN","HMPDMC",184,0)
 . I X'["^" S Y="<"_ATT_" value='"_$$ESC^HMPD(X)_"' />" Q
"RTN","HMPDMC",185,0)
 . I $L(X)>1 S Y="<"_ATT_" "_$$LOOP_"/>"
"RTN","HMPDMC",186,0)
 D ADD("</procedure>")
"RTN","HMPDMC",187,0)
 Q
"RTN","HMPDMC",188,0)
 ;
"RTN","HMPDMC",189,0)
LOOP() ; -- build sub-items string from NAMES and X
"RTN","HMPDMC",190,0)
 N STR,P,TAG S STR=""
"RTN","HMPDMC",191,0)
 F P=1:1 S TAG=$P(NAMES,U,P) Q:TAG="Z"  I $L($P(X,U,P)) S STR=STR_TAG_"='"_$$ESC^HMPD($P(X,U,P))_"' "
"RTN","HMPDMC",192,0)
 Q STR
"RTN","HMPDMC",193,0)
 ;
"RTN","HMPDMC",194,0)
ADD(X) ; Add a line @HMP@(n)=X
"RTN","HMPDMC",195,0)
 S HMPI=$G(HMPI)+1
"RTN","HMPDMC",196,0)
 S @HMP@(HMPI)=X
"RTN","HMPDMC",197,0)
 Q
"RTN","HMPDPSOR")
0^20^B2353345
"RTN","HMPDPSOR",1,0)
HMPDPSOR ;SLC/MKB,ASMR/RRB,SRG - Medication extract by order;10/2/15  15:29
"RTN","HMPDPSOR",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPDPSOR",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDPSOR",4,0)
 ;
"RTN","HMPDPSOR",5,0)
 ; External References          DBIA#
"RTN","HMPDPSOR",6,0)
 ; -------------------          -----
"RTN","HMPDPSOR",7,0)
 ; ^OR(100                       5771
"RTN","HMPDPSOR",8,0)
 ; ^ORD(100.98                    873
"RTN","HMPDPSOR",9,0)
 ; ^SC                          10040
"RTN","HMPDPSOR",10,0)
 ; ^VA(200                      10060
"RTN","HMPDPSOR",11,0)
 ; DIQ                           2056
"RTN","HMPDPSOR",12,0)
 ; ORCD                          5493
"RTN","HMPDPSOR",13,0)
 ; ORQ1,^TMP("ORR",$J)           3154
"RTN","HMPDPSOR",14,0)
 ; ORX8                 871,2467,3071
"RTN","HMPDPSOR",15,0)
 ; PSOORRL,^TMP("PS",$J)         2400
"RTN","HMPDPSOR",16,0)
 ; PSS50P7                       4662
"RTN","HMPDPSOR",17,0)
 ; PSS51P2                       4548
"RTN","HMPDPSOR",18,0)
 ;
"RTN","HMPDPSOR",19,0)
 Q
"RTN","HMPDPSOR",20,0)
 ;----------- Get data from VistA --------------
"RTN","HMPDPSOR",21,0)
 ;
"RTN","HMPDPSOR",22,0)
STATUS(X) ; -- return HITSP status for 100.01 #X
"RTN","HMPDPSOR",23,0)
 S X=+$G(X) S:'X X=99  ;no status
"RTN","HMPDPSOR",24,0)
 I X=3 Q "hold"
"RTN","HMPDPSOR",25,0)
 I X=10!(X=11)!(X=5) Q "not active"
"RTN","HMPDPSOR",26,0)
 I X=1!(X=12)!(X=13) Q "not active"
"RTN","HMPDPSOR",27,0)
 I X=14!(X=99)       Q "not active"
"RTN","HMPDPSOR",28,0)
 I X=2!(X=7)!(X=15)  Q "historical"
"RTN","HMPDPSOR",29,0)
 Q "active"
"RTN","HMPDPSOR",30,0)
 ;
"RTN","HMPDPSOR",31,0)
RESP(ORIFN,RESP) ; -- return order responses [internal form]
"RTN","HMPDPSOR",32,0)
 N HMPDLG,I,J,W,ID,TYPE,X,Y
"RTN","HMPDPSOR",33,0)
 I '$D(ORDIALOG) S ORDIALOG=129 D GETDLG1^ORCD(129)
"RTN","HMPDPSOR",34,0)
 D GETORDER^ORCD(+$G(ORIFN),"HMPDLG")
"RTN","HMPDPSOR",35,0)
 S I=0 F  S I=$O(HMPDLG(I)) Q:I<1  D
"RTN","HMPDPSOR",36,0)
 . S ID=$P($G(ORDIALOG(I)),U,2) Q:'$L(ID)
"RTN","HMPDPSOR",37,0)
 . S TYPE=$P($G(ORDIALOG(I,0)),U)
"RTN","HMPDPSOR",38,0)
 . S J=0 F  S J=$O(HMPDLG(I,J)) Q:J<1  I $D(HMPDLG(I,J)) D
"RTN","HMPDPSOR",39,0)
 .. S X=HMPDLG(I,J) I TYPE'="W" S RESP(ID,J)=X Q
"RTN","HMPDPSOR",40,0)
 .. S Y=$G(@X@(1,0)),W=1 F  S W=$O(@X@(W)) Q:W<1  S Y=Y_$S($E(Y,$L(Y))'=" ":" ",1:"")_$G(@X@(W,0))
"RTN","HMPDPSOR",41,0)
 .. S:$L(Y) RESP(ID,J)=Y
"RTN","HMPDPSOR",42,0)
 Q
"RTN","HMPEF")
0^21^B86301720
"RTN","HMPEF",1,0)
HMPEF ;SLC/MKB,ASMR/RRB,JD,SRG,CK - Serve VistA operational data as JSON via RPC;Jun 22, 2016 17:23:52
"RTN","HMPEF",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPEF",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPEF",4,0)
 ;
"RTN","HMPEF",5,0)
 ; DE2818 - SQA findings. Newed L42 and L44 in LOC+1.  RRB - 10/30/2015
"RTN","HMPEF",6,0)
 ;
"RTN","HMPEF",7,0)
 ; ^SC references - IA 10040, HOSPITAL LOCATION file (#44)
"RTN","HMPEF",8,0)
 ; ^DIC(42) references - IA #10039, WARD LOCATION file
"RTN","HMPEF",9,0)
 Q
"RTN","HMPEF",10,0)
 ;
"RTN","HMPEF",11,0)
 ; The following variables can not be newed or killed because they are used
"RTN","HMPEF",12,0)
 ; from upstream by scope (NOT as input parameters):
"RTN","HMPEF",13,0)
 ;      HMPBATCH, HMPFADOM, HMPFLDON, HMPFZTSK, HMPMETA, HMPSTMP, LEX("LIST", and ZTQUEUED.
"RTN","HMPEF",14,0)
GET(HMP,FILTER) ; -- Return search results as JSON in @HMP@(n)
"RTN","HMPEF",15,0)
 ; RPC = HMP GET OPERATIONAL DATA
"RTN","HMPEF",16,0)
 ; where FILTER("domain")  = name of desired data type (see $$TAG)
"RTN","HMPEF",17,0)
 ;       FILTER("limit")   = maximum number of items to return [opt]
"RTN","HMPEF",18,0)
 ;       FILTER("start")   = ien to start search from          [opt]
"RTN","HMPEF",19,0)
 ;       FILTER("id")      = single item id to return          [opt]
"RTN","HMPEF",20,0)
 ;
"RTN","HMPEF",21,0)
 ; HMPLAST - last record processed
"RTN","HMPEF",22,0)
 N HMPSYS,TYPE,HMPMAX,HMPI,HMPID,HMPERR,HMPTN,HMPLAST,HMPCNT,HMPFINI
"RTN","HMPEF",23,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPEF",24,0)
 S HMPSYS=$$SYS^HMPUTILS ;DE4463 - CK - 4/22/2016
"RTN","HMPEF",25,0)
 ;
"RTN","HMPEF",26,0)
 ; parse & validate input parameters
"RTN","HMPEF",27,0)
 S TYPE=$P($G(FILTER("domain")),"#") ;,TYPE=$$LOW^XLFSTR(TYPE)
"RTN","HMPEF",28,0)
 S HMPMAX=+$G(FILTER("limit")),HMPCNT=0
"RTN","HMPEF",29,0)
 S HMPLAST=+$G(FILTER("start"))
"RTN","HMPEF",30,0)
 S HMPID=$G(FILTER("id"))
"RTN","HMPEF",31,0)
 ;
"RTN","HMPEF",32,0)
 K ^TMP($J,"HMP ERROR")
"RTN","HMPEF",33,0)
 ;
"RTN","HMPEF",34,0)
 ; extract data
"RTN","HMPEF",35,0)
 I TYPE="" S HMPERR="Missing or invalid reference type" G GTQ
"RTN","HMPEF",36,0)
 ; *** convert code below to use $$HANDLE^XUSRB4 for zero node in ^XTMP, IA 4770***
"RTN","HMPEF",37,0)
 I $D(ZTQUEUED) S HMP=$NA(^XTMP(HMPBATCH,HMPFZTSK,FILTER("domain"))) K @HMP
"RTN","HMPEF",38,0)
 I TYPE="new",$L($T(EN^HMPEFX)) D EN^HMPEFX(HMPID,HMPMAX) Q
"RTN","HMPEF",39,0)
 S HMPTN=$$TAG(TYPE) Q:'$L(HMPTN)  ;D ERR(2) Q
"RTN","HMPEF",40,0)
 D @HMPTN
"RTN","HMPEF",41,0)
 ;
"RTN","HMPEF",42,0)
GTQ ; add item count and terminating characters
"RTN","HMPEF",43,0)
 N ERROR I $D(^TMP($J,"HMP ERROR"))>0 D BUILDERR(.ERROR) S ERROR(1)=ERROR(1)_"}"
"RTN","HMPEF",44,0)
 I +$G(FILTER("noHead"))=1 D  Q
"RTN","HMPEF",45,0)
 .S @HMP@("total")=+$G(HMPI)
"RTN","HMPEF",46,0)
 .S @HMP@("last")=HMPLAST
"RTN","HMPEF",47,0)
 .S @HMP@("finished")=+$G(HMPFINI)
"RTN","HMPEF",48,0)
 .I $L($G(ERROR(1)))>1 S @HMP@("error")=ERROR(1)
"RTN","HMPEF",49,0)
 I '$D(@HMP)!'$G(HMPI) D  Q
"RTN","HMPEF",50,0)
 .I '$D(^TMP($J,"HMP ERROR")) S @HMP@(1)="""data"":{""totalItems"":0,""items"":[]}}" Q
"RTN","HMPEF",51,0)
 .S @HMP@(1)="""data"":{""totalItems"":0,""items"":[]},"
"RTN","HMPEF",52,0)
 .M @HMP@(2)=ERROR
"RTN","HMPEF",53,0)
 ;
"RTN","HMPEF",54,0)
 I $D(@HMP),$G(HMPI) D
"RTN","HMPEF",55,0)
 . S @HMP@(.5)="{""apiVersion"":""1.01"",""data"":{""updated"":"""_$$HL7NOW_""",""currentItemCount"":"_HMPI
"RTN","HMPEF",56,0)
 . S:$G(HMPCNT) @HMP@(.5)=@HMP@(.5)_",""totalItems"":"_HMPCNT
"RTN","HMPEF",57,0)
 . S:$G(HMPLAST) @HMP@(.5)=@HMP@(.5)_",""last"":"_HMPLAST
"RTN","HMPEF",58,0)
 . S @HMP@(.5)=@HMP@(.5)_",""items"":["
"RTN","HMPEF",59,0)
 . S HMPI=HMPI+1,@HMP@(HMPI)=$S($D(^TMP($J,"HMP ERROR"))>0:"]}",1:"]}}")
"RTN","HMPEF",60,0)
 I $D(^TMP($J,"HMP ERROR"))>0 S HMPI=HMPI+1,@HMP@(HMPI,.3)="," M @HMP@(HMPI)=ERROR ;S HMPI=HMPI+1,@HMP@(HMPI)="}"
"RTN","HMPEF",61,0)
 K ^TMP($J,"HMP ERROR")
"RTN","HMPEF",62,0)
 Q
"RTN","HMPEF",63,0)
 ;
"RTN","HMPEF",64,0)
BUILDERR(RESULT) ;  error array
"RTN","HMPEF",65,0)
 N CNT,COUNT,DOM,DOMCNT,ERRMSG,ERROR,FIELD,MESSAGE,MSG,MSGCNT,T,TEMP
"RTN","HMPEF",66,0)
 S COUNT=$G(^TMP($J,"HMP ERROR","# of Errors"))
"RTN","HMPEF",67,0)
 S MESSAGE="A mumps error occurred when extracting data. A total of "_COUNT_" occurred.\n\r"
"RTN","HMPEF",68,0)
 S CNT=1,ERROR("error","message","\",CNT)="A mumps error occurred when extracting patient data. A total of "_COUNT_" occurred.\n\r"
"RTN","HMPEF",69,0)
 S MSGCNT=0 F  S MSGCNT=$O(^TMP($J,"HMP ERROR","ERROR MESSAGE",MSGCNT)) Q:MSGCNT'>0  D
"RTN","HMPEF",70,0)
 . S CNT=CNT+1,MESSAGE=MESSAGE_$G(^TMP($J,"HMP ERROR","ERROR MESSAGE",MSGCNT))_"\n\r"
"RTN","HMPEF",71,0)
 S RESULT(1)="""error"":{""message"":"_""""_MESSAGE_""""_"}"
"RTN","HMPEF",72,0)
 Q
"RTN","HMPEF",73,0)
 ;
"RTN","HMPEF",74,0)
TAG(X) ; -- linetag for reference domain X
"RTN","HMPEF",75,0)
 N Y S Y="HMP",X=$G(X)
"RTN","HMPEF",76,0)
 ; default = HMP Object (various types)
"RTN","HMPEF",77,0)
 I X="location"      S Y="LOC"
"RTN","HMPEF",78,0)
 I X="pt-select"     S Y="PAT"
"RTN","HMPEF",79,0)
 I X="person"        S Y="NP"
"RTN","HMPEF",80,0)
 I X="user"          S Y="NP"
"RTN","HMPEF",81,0)
 I X="labgroup"      S Y="LABGRP"
"RTN","HMPEF",82,0)
 I X="labpanel"      S Y="LABPNL"
"RTN","HMPEF",83,0)
 I X["orderable"     S Y="OI"
"RTN","HMPEF",84,0)
 I X["schedule"      S Y="SCHEDULE"
"RTN","HMPEF",85,0)
 I X["route"         S Y="ROUTE"
"RTN","HMPEF",86,0)
 I X["quick"         S Y="QO"
"RTN","HMPEF",87,0)
 I X="displayGroup"  S Y="ODG"
"RTN","HMPEF",88,0)
 I X["asu-"          S Y="ASU"
"RTN","HMPEF",89,0)
 I X["doc-"          S Y="ASU"
"RTN","HMPEF",90,0)
 I X="immunization"    S Y="IMMTYPE"
"RTN","HMPEF",91,0)
 I X="allergy-list"         S Y="ALLTYPE"
"RTN","HMPEF",92,0)
 ;I X="problem-list"        S Y="PROB"
"RTN","HMPEF",93,0)
 I X="sign-symptom"   S Y="SIGNS"
"RTN","HMPEF",94,0)
 I X="vital-type"      S Y="VTYPE"
"RTN","HMPEF",95,0)
 I X="vital-qualifier"  S Y="VQUAL"
"RTN","HMPEF",96,0)
 I X="vital-category"   S Y="VCAT"
"RTN","HMPEF",97,0)
 I X["clioterm"      S Y="MDTERMS"
"RTN","HMPEF",98,0)
 Q Y
"RTN","HMPEF",99,0)
 ;
"RTN","HMPEF",100,0)
ERR(X,VAL) ;  return error message
"RTN","HMPEF",101,0)
 N MSG  S MSG="Error"
"RTN","HMPEF",102,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPEF",103,0)
 I X=3  S MSG="UID '"_$G(VAL)_"' not found"
"RTN","HMPEF",104,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPEF",105,0)
 Q MSG
"RTN","HMPEF",106,0)
 ;
"RTN","HMPEF",107,0)
ERRMSG(X,VAL) ; -- return error message
"RTN","HMPEF",108,0)
 N Y S Y="A MUMPS error occurred while extracting "_X_" data"
"RTN","HMPEF",109,0)
 S:$G(VAL) Y=Y_", ien "_VAL
"RTN","HMPEF",110,0)
 Q Y
"RTN","HMPEF",111,0)
 ;
"RTN","HMPEF",112,0)
ERRQ ; -- Quit on error
"RTN","HMPEF",113,0)
 Q
"RTN","HMPEF",114,0)
 ;
"RTN","HMPEF",115,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPEF",116,0)
 Q $$FMTHL7^HMPSTMP($$NOW^XLFDT)  ; DE5016
"RTN","HMPEF",117,0)
 ;
"RTN","HMPEF",118,0)
ALL() ;
"RTN","HMPEF",119,0)
 Q "location;patient;person;orderable;schedule;route;quick;displayGroup;asu-class;asu-rule;asu-role;doc-action;doc-status;clioterm;immunization;allergy-list;sign-symptom;vital-type;vital-qualifier;vital-category"
"RTN","HMPEF",120,0)
 ;
"RTN","HMPEF",121,0)
ADD(ITEM) ; -- add ITEM to @HMP@(HMPI)
"RTN","HMPEF",122,0)
 N HMPY,HMPERR
"RTN","HMPEF",123,0)
 I $G(HMPSTMP)]"" S @ITEM@("stampTime")=HMPSTMP ; US6734
"RTN","HMPEF",124,0)
 E  S @ITEM@("stampTime")=$$EN^HMPSTMP("NOW") ; DE2616 - must add stampTime to receive OPD freshness update from ADHOC^HMPUTIL1
"RTN","HMPEF",125,0)
 D ENCODE^HMPJSON(ITEM,"HMPY","HMPERR")
"RTN","HMPEF",126,0)
 I $D(HMPERR) D  ;return ERRor instead of ITEM
"RTN","HMPEF",127,0)
 . N HMPTMP,HMPTXT,HMPITM
"RTN","HMPEF",128,0)
 . M HMPITM=@ITEM K HMPY
"RTN","HMPEF",129,0)
 . S HMPTXT(1)="Problem encoding json output."
"RTN","HMPEF",130,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.HMPITM)
"RTN","HMPEF",131,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","HMPY","HMPERR")
"RTN","HMPEF",132,0)
 I $D(HMPY) D
"RTN","HMPEF",133,0)
 . Q:'$D(@ITEM@("uid"))
"RTN","HMPEF",134,0)
 . I $G(HMPMETA) D ADD^HMPMETA($P(HMPFADOM,"#"),@ITEM@("uid"),HMPSTMP) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPEF",135,0)
 . I HMPI D COMMA(HMPI)
"RTN","HMPEF",136,0)
 . ;I HMPI,'$G(FILTER("noHead")) D COMMA(HMPI)
"RTN","HMPEF",137,0)
 . S HMPI=HMPI+1 M @HMP@(HMPI)=HMPY
"RTN","HMPEF",138,0)
 Q
"RTN","HMPEF",139,0)
 ;
"RTN","HMPEF",140,0)
COMMA(I) ; -- add comma between items
"RTN","HMPEF",141,0)
 I $D(ZTQUEUED) Q
"RTN","HMPEF",142,0)
 N J S J=+$O(@HMP@(I,"A"),-1) ;last sub-node for item I
"RTN","HMPEF",143,0)
 S J=J+1,@HMP@(I,J)=","
"RTN","HMPEF",144,0)
 Q
"RTN","HMPEF",145,0)
 ;
"RTN","HMPEF",146,0)
TOTAL(ROOT) ; -- Return total #items in @ROOT@(n)
"RTN","HMPEF",147,0)
 Q $P($G(@ROOT@(0)),U,4)
"RTN","HMPEF",148,0)
 ;
"RTN","HMPEF",149,0)
TEST(TYPE,ID,IN) ; -- test GET, write results to screen
"RTN","HMPEF",150,0)
 N OUT,IDX
"RTN","HMPEF",151,0)
 S U="^"
"RTN","HMPEF",152,0)
 S IN("domain")=$G(TYPE)
"RTN","HMPEF",153,0)
 S:$D(ID) IN("id")=ID
"RTN","HMPEF",154,0)
 D GET(.OUT,.IN)
"RTN","HMPEF",155,0)
 ;
"RTN","HMPEF",156,0)
 S IDX=OUT
"RTN","HMPEF",157,0)
 F  S IDX=$Q(@IDX) Q:IDX'?1"^TMP(""HMP"","1.N.E  Q:+$P(IDX,",",2)'=$J  W !,@IDX
"RTN","HMPEF",158,0)
 Q
"RTN","HMPEF",159,0)
 ;
"RTN","HMPEF",160,0)
 ; ** Reference file searches, using FILTER("parameter")
"RTN","HMPEF",161,0)
 ;
"RTN","HMPEF",162,0)
PAT ;Patients
"RTN","HMPEF",163,0)
 N DFN,PAT,HMPPOPD
"RTN","HMPEF",164,0)
 S HMPPOPD=1
"RTN","HMPEF",165,0)
 S HMPCNT=$$TOTAL("^DPT")
"RTN","HMPEF",166,0)
 I $G(HMPID) S DFN=+HMPID D LKUP^HMPDJ00 Q
"RTN","HMPEF",167,0)
 N ERRMSG S ERRMSG="A mumps error occurred while extracting patients."
"RTN","HMPEF",168,0)
 S DFN=+$G(HMPLAST) F  S DFN=$O(^DPT(DFN)) Q:DFN<1  D  I HMPMAX>0,HMPI'<HMPMAX Q
"RTN","HMPEF",169,0)
 . N $ES,$ET
"RTN","HMPEF",170,0)
 . S $ET="D ERRHDLR^HMPDERRH"
"RTN","HMPEF",171,0)
 . I $P($G(^DPT(DFN,0)),U)="" Q
"RTN","HMPEF",172,0)
 . S ERRMSG=$$ERRMSG("Patient",DFN)
"RTN","HMPEF",173,0)
 . K PAT D LKUP^HMPDJ00
"RTN","HMPEF",174,0)
 . S HMPLAST=DFN
"RTN","HMPEF",175,0)
 I DFN<1 S HMPFINI=1
"RTN","HMPEF",176,0)
 Q
"RTN","HMPEF",177,0)
LOC ; Hospital Location (#44) and Ward Location (#42)  /DE2818
"RTN","HMPEF",178,0)
 D LOC^HMPEF1(.HMPFINI,.HMPFLDON,$G(HMPMETA))
"RTN","HMPEF",179,0)
 Q
"RTN","HMPEF",180,0)
 ;
"RTN","HMPEF",181,0)
ACTWRD(IEN) ;Boolean TRUE if active WARD LOCATION
"RTN","HMPEF",182,0)
 ; IEN - IEN in file 42
"RTN","HMPEF",183,0)
 S D0=IEN D WIN^DGPMDDCF Q 'X  ; SRG: need DBIA
"RTN","HMPEF",184,0)
 ;
"RTN","HMPEF",185,0)
ACTLOC(LOC) ;Boolean TRUE if active hospital location
"RTN","HMPEF",186,0)
 ; ^SC - IA 10040
"RTN","HMPEF",187,0)
 N D0,X I +$G(^SC(LOC,"OOS")) Q 0                ; screen out OOS entry
"RTN","HMPEF",188,0)
 S D0=+$G(^SC(LOC,42)) I D0 D WIN^DGPMDDCF Q 'X  ; chk out of svc wards
"RTN","HMPEF",189,0)
 S X=$G(^SC(LOC,"I")) I +X=0 Q 1                 ; no inactivate date
"RTN","HMPEF",190,0)
 I DT>$P(X,U)&($P(X,U,2)=""!(DT<$P(X,U,2))) Q 0  ; chk reactivate date
"RTN","HMPEF",191,0)
 Q 1                                             ; must still be active
"RTN","HMPEF",192,0)
 ;
"RTN","HMPEF",193,0)
NP ;New Persons
"RTN","HMPEF",194,0)
 D NP^HMPEF1
"RTN","HMPEF",195,0)
 Q
"RTN","HMPEF",196,0)
 ;
"RTN","HMPEF",197,0)
KEYS(IEN) ;user's keys
"RTN","HMPEF",198,0)
 N HMPKEY,IENS,X,CNT
"RTN","HMPEF",199,0)
 D GETS^DIQ(200,IEN_",","51*","IE","HMPKEY") S CNT=0
"RTN","HMPEF",200,0)
 S IENS="" F  S IENS=$O(HMPKEY(200.051,IENS)) Q:IENS=""  D
"RTN","HMPEF",201,0)
 . S X=$G(HMPKEY(200.051,IENS,.01,"E")),CNT=CNT+1
"RTN","HMPEF",202,0)
 . S USER("vistaKeys",CNT,"name")=X
"RTN","HMPEF",203,0)
 . S X=$G(HMPKEY(200.051,IENS,3,"I"))
"RTN","HMPEF",204,0)
 . S:X USER("vistaKeys",CNT,"reviewDate")=$$JSONDT^HMPUTILS(X)
"RTN","HMPEF",205,0)
 Q
"RTN","HMPEF",206,0)
 ;
"RTN","HMPEF",207,0)
ODG ;
"RTN","HMPEF",208,0)
 D ADDODG^HMPCORD4
"RTN","HMPEF",209,0)
 Q
"RTN","HMPEF",210,0)
 ;
"RTN","HMPEF",211,0)
OI ;
"RTN","HMPEF",212,0)
 D OI^HMPCORD4("PS^RAP^LRT")
"RTN","HMPEF",213,0)
 Q
"RTN","HMPEF",214,0)
 ;
"RTN","HMPEF",215,0)
PROB ;get problem list OPD store
"RTN","HMPEF",216,0)
 D PROB^HMPEF1(.HMPFINI,LEX)
"RTN","HMPEF",217,0)
 Q
"RTN","HMPEF",218,0)
 ;
"RTN","HMPEF",219,0)
QO ;
"RTN","HMPEF",220,0)
 D QO^HMPCORD4
"RTN","HMPEF",221,0)
 Q
"RTN","HMPEF",222,0)
 ;
"RTN","HMPEF",223,0)
SCHEDULE ;
"RTN","HMPEF",224,0)
 N RESULT
"RTN","HMPEF",225,0)
 D ADDSCH^HMPCORD4
"RTN","HMPEF",226,0)
 Q
"RTN","HMPEF",227,0)
 ;
"RTN","HMPEF",228,0)
ROUTE ;
"RTN","HMPEF",229,0)
 N RESULT
"RTN","HMPEF",230,0)
 D ADDROUTE^HMPCORD4
"RTN","HMPEF",231,0)
 Q
"RTN","HMPEF",232,0)
 ;
"RTN","HMPEF",233,0)
HMP ; HMP Objects
"RTN","HMPEF",234,0)
 N IEN
"RTN","HMPEF",235,0)
 S HMPCNT=$$TOTAL("^HMP(800000.11)")
"RTN","HMPEF",236,0)
 I $L(HMPID) D  Q
"RTN","HMPEF",237,0)
 . I HMPID=+HMPID S IEN=HMPID
"RTN","HMPEF",238,0)
 . E  S IEN=+$O(^HMP(800000.11,"B",HMPID,0))
"RTN","HMPEF",239,0)
 . S ERRMSG=$$ERRMSG("HMP Object",IEN)
"RTN","HMPEF",240,0)
 . D:IEN HMP1^HMPDJ02(800000.11,IEN)
"RTN","HMPEF",241,0)
 S IEN=+$G(HMPLAST) F  S IEN=$O(^HMP(800000.11,"C",TYPE,IEN)) Q:IEN<1  D  I HMPMAX>0,HMPI'<HMPMAX Q
"RTN","HMPEF",242,0)
 . S ERRMSG=$$ERRMSG("HMP Object",IEN)
"RTN","HMPEF",243,0)
 . D HMP1^HMPDJ02(800000.11,IEN) S HMPLAST=IEN
"RTN","HMPEF",244,0)
 I IEN<1 S HMPFINI=1
"RTN","HMPEF",245,0)
 Q
"RTN","HMPEF",246,0)
 ;
"RTN","HMPEF",247,0)
SOURCE(SRC) ;
"RTN","HMPEF",248,0)
 N X S X=""
"RTN","HMPEF",249,0)
 I SRC["SC("        S X="clinic"
"RTN","HMPEF",250,0)
 I SRC["DPT("       S X="patient"
"RTN","HMPEF",251,0)
 I SRC["DIC(42"     S X="ward"
"RTN","HMPEF",252,0)
 I SRC["SCTM"       S X="pcmm"
"RTN","HMPEF",253,0)
 I SRC["OR(100.21"  S X="cprs"
"RTN","HMPEF",254,0)
 I SRC["DIC(45.7"   S X="specialty"
"RTN","HMPEF",255,0)
 I SRC["VA(200"     S X="provider"
"RTN","HMPEF",256,0)
 I SRC["PXRM(810.4" S X="pxrm"
"RTN","HMPEF",257,0)
 Q X
"RTN","HMPEF",258,0)
 ;
"RTN","HMPEF",259,0)
ASU ; ASU files
"RTN","HMPEF",260,0)
 N X,RTN S X=$P($G(TYPE),"-",2)
"RTN","HMPEF",261,0)
 S RTN=$$UP^XLFSTR(X)_"^HMPEASU"
"RTN","HMPEF",262,0)
 I X'="",$L($T(@RTN)) D @RTN
"RTN","HMPEF",263,0)
 Q
"RTN","HMPEF",264,0)
 ;
"RTN","HMPEF",265,0)
MDTERMS ; CP Terminology
"RTN","HMPEF",266,0)
 D:$L($T(TERM^HMPMDUTL)) TERM^HMPMDUTL
"RTN","HMPEF",267,0)
 Q
"RTN","HMPEF",268,0)
LABGRP ;
"RTN","HMPEF",269,0)
 D SHWCUMR2^HMPELAB
"RTN","HMPEF",270,0)
 Q
"RTN","HMPEF",271,0)
LABPNL ;
"RTN","HMPEF",272,0)
 D SHWORPNL^HMPELAB
"RTN","HMPEF",273,0)
 Q
"RTN","HMPEF",274,0)
 ;
"RTN","HMPEF",275,0)
 ;DE2818, changed reference to ^VA(201) to a FileMan call
"RTN","HMPEF",276,0)
ISPROXY(IEN) ; Boolean function, is NEW PERSON entry an APPLICATION PROXY?
"RTN","HMPEF",277,0)
 N APP,HMPMSG,HMPUCLS,T,V
"RTN","HMPEF",278,0)
 ; APP - returned value
"RTN","HMPEF",279,0)
 ; HMPUCLS - user class array
"RTN","HMPEF",280,0)
 ; HMPMSG - FileMan message array
"RTN","HMPEF",281,0)
 ;
"RTN","HMPEF",282,0)
 D GETS^DIQ(200,IEN_",","9.5*","E","HMPUCLS","HMPMSG")  ; get external format
"RTN","HMPEF",283,0)
 S APP=0,T="APPLICATION PROXY",V="HMPUCLS"
"RTN","HMPEF",284,0)
 ; search returned array for value equal to T
"RTN","HMPEF",285,0)
 F  S V=$Q(@V) Q:V=""!APP  S:@V=T APP=1
"RTN","HMPEF",286,0)
 Q APP
"RTN","HMPEF",287,0)
 ;
"RTN","HMPEF",288,0)
IMMTYPE ;immunization types
"RTN","HMPEF",289,0)
 D IMMTYPE^HMPCORD5
"RTN","HMPEF",290,0)
 Q
"RTN","HMPEF",291,0)
 ;
"RTN","HMPEF",292,0)
SIGNS ;SIGNS/SYMPTONS file
"RTN","HMPEF",293,0)
 D SIGNS^HMPCORD5
"RTN","HMPEF",294,0)
 Q
"RTN","HMPEF",295,0)
 ;
"RTN","HMPEF",296,0)
ALLTYPE ;allergy-list types
"RTN","HMPEF",297,0)
 ;BL;REMOVE FROM ODS
"RTN","HMPEF",298,0)
 ;D ALLTYPE^HMPCORD5
"RTN","HMPEF",299,0)
 Q
"RTN","HMPEF",300,0)
 ;
"RTN","HMPEF",301,0)
VTYPE ;vital types
"RTN","HMPEF",302,0)
 D VTYPE^HMPCORD5
"RTN","HMPEF",303,0)
 Q
"RTN","HMPEF",304,0)
 ;
"RTN","HMPEF",305,0)
VQUAL ;vital qualifiers
"RTN","HMPEF",306,0)
 D VQUAL^HMPCORD5
"RTN","HMPEF",307,0)
 Q
"RTN","HMPEF",308,0)
 ;
"RTN","HMPEF",309,0)
VCAT ;vital categories
"RTN","HMPEF",310,0)
 D VCAT^HMPCORD5
"RTN","HMPEF",311,0)
 Q
"RTN","HMPEF",312,0)
 ;
"RTN","HMPEF",313,0)
FILENAME ; text of filenames for search treeview
"RTN","HMPEF",314,0)
 ;;VA Allergies File
"RTN","HMPEF",315,0)
 ;;VA Allergies File (Synonyms)  SPACER ONLY - NOT DISPLAYED
"RTN","HMPEF",316,0)
 ;;National Drug File - Generic Drug Name
"RTN","HMPEF",317,0)
 ;;National Drug file - Trade Name
"RTN","HMPEF",318,0)
 ;;Local Drug File
"RTN","HMPEF",319,0)
 ;;Local Drug File (Synonyms)  SPACER ONLY - NOT DISPLAYED
"RTN","HMPEF",320,0)
 ;;Drug Ingredients File
"RTN","HMPEF",321,0)
 ;;VA Drug Class File
"RTN","HMPEF",322,0)
 ;;
"RTN","HMPEF1")
0^22^B41995874
"RTN","HMPEF1",1,0)
HMPEF1 ;SLC/MKB,ASMR/RRB,JD,SRG,CPC,CK - Serve VistA operational data as JSON via RPC;June 24, 2016 13:17:46
"RTN","HMPEF1",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPEF1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPEF1",4,0)
 ;
"RTN","HMPEF1",5,0)
 ; HMPEF (cont'd)
"RTN","HMPEF1",6,0)
 ;
"RTN","HMPEF1",7,0)
 ; JD - 4/20/16 - Fixed undefined for invalid genders (NP1 block). DE4411
"RTN","HMPEF1",8,0)
 Q
"RTN","HMPEF1",9,0)
 ;
"RTN","HMPEF1",10,0)
LOC(HMPFINI,HMPFLDON,HMPMETA) ; Hospital Location (#44) and Ward Location (#42)  /DE2818
"RTN","HMPEF1",11,0)
 N L42,L44
"RTN","HMPEF1",12,0)
 ;BL;DE2188 This line tag has to make two complete passes through 
"RTN","HMPEF1",13,0)
 ;the two FOR loops. In order to do this it is necessary to clearly 
"RTN","HMPEF1",14,0)
 ;define the loop we are doing. The file 44 and 
"RTN","HMPEF1",15,0)
 ;file 42 loops cannot be done at the same time
"RTN","HMPEF1",16,0)
 ;
"RTN","HMPEF1",17,0)
 ; Need variables to clearly define which pass we are on.
"RTN","HMPEF1",18,0)
 ; 
"RTN","HMPEF1",19,0)
 ; HMPFLDON indicates the loop
"RTN","HMPEF1",20,0)
 ; HMPFLDON=0 means we are on L44
"RTN","HMPEF1",21,0)
 ; HMPFLDON=1 means we are on L42
"RTN","HMPEF1",22,0)
 ;
"RTN","HMPEF1",23,0)
 S HMPCNT=$$TOTAL^HMPEF("^SC")+$$TOTAL^HMPEF("^DIC(42)") ; total file counts will be inaccurate for location domain
"RTN","HMPEF1",24,0)
 ;
"RTN","HMPEF1",25,0)
 ;BL/CPC - Handle single location or ward for restart
"RTN","HMPEF1",26,0)
 I $G(HMPID) I $G(HMPID)'["w" D LOC44(HMPID) Q
"RTN","HMPEF1",27,0)
 I $D(HMPID) I $G(HMPID)["w" D LOC42($TR(HMPID,"w","")) Q
"RTN","HMPEF1",28,0)
 ;
"RTN","HMPEF1",29,0)
 ;BL/CPC - determine if location or ward for restart
"RTN","HMPEF1",30,0)
 I '$G(HMPFLDON) S L44=+$G(HMPLAST),L42=0  ; HMPFLDON=0 means we are on L44
"RTN","HMPEF1",31,0)
 I $G(HMPFLDON) S L44=0,L42=+$G(HMPLAST)  ;  HMPFLDON=1 means we are on L42
"RTN","HMPEF1",32,0)
 ; ^SC - IA 10040
"RTN","HMPEF1",33,0)
 I '$G(HMPFLDON) F  S L44=$O(^SC(L44)) Q:L44<1  D LOC44(L44) I HMPMAX>0,HMPI'<HMPMAX Q  ;BL/cpc
"RTN","HMPEF1",34,0)
 I HMPMAX>0,HMPI'<HMPMAX Q  ;BL/CPC prevents drop through
"RTN","HMPEF1",35,0)
 I $G(HMPMETA)'=1 S HMPFLDON=1 ;BL/cpc mark locations complete ;US11019
"RTN","HMPEF1",36,0)
 ; ^DIC(42) - IA 10039 DE2818
"RTN","HMPEF1",37,0)
 F  S L42=$O(^DIC(42,L42)) Q:L42<1  D LOC42(L42) I HMPMAX>0,HMPI'<HMPMAX Q  ;BL/cpc
"RTN","HMPEF1",38,0)
 I (L44<1)&(L42<1) S HMPFINI=1 ;BL/cpc - fix boolean error
"RTN","HMPEF1",39,0)
 Q
"RTN","HMPEF1",40,0)
 ;
"RTN","HMPEF1",41,0)
LOC44(IEN) ; get one hospital location
"RTN","HMPEF1",42,0)
 N $ES,$ET,ERRMSG
"RTN","HMPEF1",43,0)
 S ERRMSG=$$ERRMSG^HMPEF("Location",IEN)
"RTN","HMPEF1",44,0)
 S $ET="D ERRHDLR^HMPDERRH"
"RTN","HMPEF1",45,0)
 N LOC,X0,X,Y
"RTN","HMPEF1",46,0)
 ; if location is a WARD, ignore because file #42 will be used for wards
"RTN","HMPEF1",47,0)
 S X0=$G(^SC(IEN,0)) I $P(X0,U,3)="W" Q  ; ^SC - IA 10040
"RTN","HMPEF1",48,0)
 S LOC("name")=$P(X0,U)
"RTN","HMPEF1",49,0)
 S LOC("localId")=IEN,LOC("uid")=$$SETUID^HMPUTILS("location",,IEN)
"RTN","HMPEF1",50,0)
 S X=$P(X0,U,2) S:$L(X) LOC("shortName")=X S LOC("type")=$P(X0,U,3)
"RTN","HMPEF1",51,0)
 S LOC("refId")=IEN,LOC("oos")=$S(+$G(^SC(IEN,"OOS")):"true",1:"false")
"RTN","HMPEF1",52,0)
 S X=+$P(X0,U,4) I X D
"RTN","HMPEF1",53,0)
 . S Y=$$NS^XUAF4(X),X=$P(Y,U,2)_U_$P(Y,U)
"RTN","HMPEF1",54,0)
 . D FACILITY^HMPUTILS(X,"LOC")
"RTN","HMPEF1",55,0)
 I '$$ACTLOC^HMPEF(IEN) S LOC("inactive")="true"
"RTN","HMPEF1",56,0)
 D ADD^HMPEF("LOC") S HMPLAST=IEN
"RTN","HMPEF1",57,0)
 Q
"RTN","HMPEF1",58,0)
 ;
"RTN","HMPEF1",59,0)
LOC42(IEN) ; get one ward location
"RTN","HMPEF1",60,0)
 ; IEN - file 42 IEN
"RTN","HMPEF1",61,0)
 ; references to ^DIC(42) via IA #10039
"RTN","HMPEF1",62,0)
 ;
"RTN","HMPEF1",63,0)
 N $ES,$ET,DIV,ERRMSG
"RTN","HMPEF1",64,0)
 S ERRMSG=$$ERRMSG^HMPEF("Ward Location",IEN)
"RTN","HMPEF1",65,0)
 S $ET="D ERRHDLR^HMPDERRH"
"RTN","HMPEF1",66,0)
 N LOC,X,X0,Y
"RTN","HMPEF1",67,0)
 S X0=$G(^DIC(42,IEN,0))
"RTN","HMPEF1",68,0)
 S:$G(^DIC(42,IEN,0))'="" LOC("name")=$P(^DIC(42,IEN,0),U)  ;IA #10039
"RTN","HMPEF1",69,0)
 S LOC("localId")=IEN,LOC("uid")=$$SETUID^HMPUTILS("location",,"w"_IEN)  ; wards have a "w"
"RTN","HMPEF1",70,0)
 S LOC("type")="W"  ; always 'W' for ward
"RTN","HMPEF1",71,0)
 S LOC("refId")=IEN
"RTN","HMPEF1",72,0)
 S LOC("oos")="false" ; occasion of service is always false for ward locations
"RTN","HMPEF1",73,0)
 S DIV=+$P(X0,U,11)
"RTN","HMPEF1",74,0)
 S X=+$P($G(^DG(40.8,DIV,0)),U,7) I X D  ;ICR 417 DE2818 ASF 11/21/15
"RTN","HMPEF1",75,0)
 . S Y=$$NS^XUAF4(X),X=$P(Y,U,2)_U_$P(Y,U)
"RTN","HMPEF1",76,0)
 . D FACILITY^HMPUTILS(X,"LOC")
"RTN","HMPEF1",77,0)
 ; out-of-service flag
"RTN","HMPEF1",78,0)
 I '$$ACTWRD^HMPEF(IEN) S LOC("inactive")="true"  ; boolean field only exists if ward is inactive
"RTN","HMPEF1",79,0)
 D ADD^HMPEF("LOC") S HMPLAST=IEN
"RTN","HMPEF1",80,0)
 Q
"RTN","HMPEF1",81,0)
 ;
"RTN","HMPEF1",82,0)
NP ;New Persons
"RTN","HMPEF1",83,0)
 ; Variables from HMPEF: HMPCNT,HMPID,HMPMAX,HMPI,HMPFINI
"RTN","HMPEF1",84,0)
 N PRV
"RTN","HMPEF1",85,0)
 S HMPCNT=$$TOTAL^HMPEF("^VA(200)")  ; IA 10035
"RTN","HMPEF1",86,0)
 I $G(HMPID) D NP1(HMPID) Q
"RTN","HMPEF1",87,0)
 S PRV=+$G(HMPLAST) ;$S(HMPLAST:HMPLAST,1:.9)
"RTN","HMPEF1",88,0)
 I PRV=0 S PRV=.9
"RTN","HMPEF1",89,0)
 F  S PRV=$O(^VA(200,PRV)) Q:'PRV  I PRV'<1 D NP1(PRV) I HMPMAX>0,HMPI'<HMPMAX Q  ;DE4778
"RTN","HMPEF1",90,0)
 I 'PRV S HMPFINI=1 ;DE4778
"RTN","HMPEF1",91,0)
 Q
"RTN","HMPEF1",92,0)
 ;
"RTN","HMPEF1",93,0)
NP1(IEN) ;one person
"RTN","HMPEF1",94,0)
 N $ES,$ET,ERRMSG
"RTN","HMPEF1",95,0)
 S ERRMSG=$$ERRMSG^HMPEF("person",IEN)
"RTN","HMPEF1",96,0)
 S $ET="D ERRHDLR^HMPDERRH"
"RTN","HMPEF1",97,0)
 N HMPV,FLDS,USER,X,Y
"RTN","HMPEF1",98,0)
 I $$ISPROXY^HMPEF(IEN)=1 Q
"RTN","HMPEF1",99,0)
 K HMPV S FLDS=".01;1;4:9.2;9.5*;19:53.8;654.3;.132:.138"  ;DE5361 6/20/2016 - incomplete Note Addendum Signature Block, send additional fields
"RTN","HMPEF1",100,0)
 D GETS^DIQ(200,IEN_",",FLDS,"IEN","HMPV")
"RTN","HMPEF1",101,0)
 S Y=$NA(HMPV(200,IEN_","))
"RTN","HMPEF1",102,0)
 I '$L($G(@Y@(.01,"E"))) Q  ;DE4778 skip invalid entry
"RTN","HMPEF1",103,0)
 S USER("name")=$G(@Y@(.01,"E"))
"RTN","HMPEF1",104,0)
 S USER("localId")=IEN,USER("uid")=$$SETUID^HMPUTILS("user",,IEN)
"RTN","HMPEF1",105,0)
 S X=$G(@Y@(1,"E")) S:$L(X) USER("initials")=X  ;DE5361
"RTN","HMPEF1",106,0)
 ;Added $Gs to guard against undefined error. DE4411
"RTN","HMPEF1",107,0)
 S:$L($G(@Y@(4,"I"))) USER("genderCode")="urn:va:gender:"_$G(@Y@(4,"I")),USER("genderName")=$G(@Y@(4,"E"))
"RTN","HMPEF1",108,0)
 S X=+$P($G(@Y@(5,"I")),".") S:X USER("dateOfBirth")=$$JSONDT^HMPUTILS(X)
"RTN","HMPEF1",109,0)
 S X=$G(@Y@(7,"I")) S:$L(X) USER("disuser")=$S(X:"true",1:"false")
"RTN","HMPEF1",110,0)
 S X=$G(@Y@(8,"E")) S:$L(X) USER("title")=X
"RTN","HMPEF1",111,0)
 S X=$G(@Y@(9,"E")) S:$L(X) USER("ssn")=X
"RTN","HMPEF1",112,0)
 S X=$G(@Y@(9.2,"I")) S:$L(X) USER("terminated")=$$JSONDT^HMPUTILS(X)
"RTN","HMPEF1",113,0)
 S X=+$G(@Y@(19,"I")) S:X USER("delegateCode")=$$SETUID^HMPUTILS("user",,X),USER("delegateName")=$G(@Y@(19,"E"))
"RTN","HMPEF1",114,0)
 S X=$G(@Y@(20.2,"E")) S:$L(X) USER("signaturePrintedName")=X  ;DE5361
"RTN","HMPEF1",115,0)
 S X=$G(@Y@(20.3,"E")) S:$L(X) USER("signatureTitle")=X  ;DE5361
"RTN","HMPEF1",116,0)
 S X=$G(@Y@(29,"E")) S:$L(X) USER("service")=X
"RTN","HMPEF1",117,0)
 S X=$G(@Y@(53.5,"E")) S:$L(X) USER("providerClass")=X
"RTN","HMPEF1",118,0)
 S X=$G(@Y@(53.6,"E")) S:$L(X) USER("providerType")=X
"RTN","HMPEF1",119,0)
 S X=+$G(@Y@(654.3,"I")) S:X USER("surrogateCode")=$$SETUID^HMPUTILS("user",,X),USER("surrogateName")=$G(@Y@(654.3,"E"))
"RTN","HMPEF1",120,0)
 S X=$G(@Y@(.132,"E")) S:$L(X) USER("officePhone")=X
"RTN","HMPEF1",121,0)
 S X=$G(@Y@(.133,"E")) S:$L(X) USER("phone3")=X
"RTN","HMPEF1",122,0)
 S X=$G(@Y@(.134,"E")) S:$L(X) USER("phone4")=X
"RTN","HMPEF1",123,0)
 S X=$G(@Y@(.135,"E")) S:$L(X) USER("commercialPhone")=X
"RTN","HMPEF1",124,0)
 S X=$G(@Y@(.136,"E")) S:$L(X) USER("fax")=X
"RTN","HMPEF1",125,0)
 S X=$G(@Y@(.137,"E")) S:$L(X) USER("voicePager")=X
"RTN","HMPEF1",126,0)
 S X=$G(@Y@(.138,"E")) S:$L(X) USER("digitalPager")=X
"RTN","HMPEF1",127,0)
 D KEYS^HMPEF(IEN)
"RTN","HMPEF1",128,0)
 D ADD^HMPEF("USER") S HMPLAST=IEN
"RTN","HMPEF1",129,0)
 Q
"RTN","HMPEF1",130,0)
 ;
"RTN","HMPEF1",131,0)
PROB(HMPFINI,LEX) ;get problem list OPD store
"RTN","HMPEF1",132,0)
 N APP,ORAPP,ORDT,ORELEM,ORWLST,IEN,ELEMENT,PLIST,HMPCNT,HMPLAST,LST
"RTN","HMPEF1",133,0)
 S (ORWLST,ORDT,ORELEM)=""
"RTN","HMPEF1",134,0)
 S ORDT=DT
"RTN","HMPEF1",135,0)
 S IEN=0,HMPCNT=0
"RTN","HMPEF1",136,0)
 S LST=$NA(^TMP("ORLEX",$J))
"RTN","HMPEF1",137,0)
 S APP="GMPX"
"RTN","HMPEF1",138,0)
 D CONFIG^LEXSET(APP,"PLS",ORDT)
"RTN","HMPEF1",139,0)
 S (HMPCNT,HMPLAST)=0
"RTN","HMPEF1",140,0)
 ; ^LEX(757.01) - IA 1571 DE2818 ASF 11/21/15
"RTN","HMPEF1",141,0)
 F  S IEN=$O(^LEX(757.01,IEN)) Q:IEN=""!(IEN'?1N.N)  D
"RTN","HMPEF1",142,0)
 . S ORELEM=$G(^LEX(757.01,IEN,0))
"RTN","HMPEF1",143,0)
 . Q:'$D(^LEX(757.01,IEN,1))
"RTN","HMPEF1",144,0)
 . D LOOK^LEXA(ORELEM,,1,,ORDT)
"RTN","HMPEF1",145,0)
 . S ELEMENT=$G(LEX("LIST",1))
"RTN","HMPEF1",146,0)
 . Q:ELEMENT=""
"RTN","HMPEF1",147,0)
 . S ELEMENT=$$LEXXFRM^ORQQPL4(ELEMENT,ORDT,"GMPX")
"RTN","HMPEF1",148,0)
 . S PLIST("uid")=$$SETUID^HMPUTILS("problem-list","",IEN)
"RTN","HMPEF1",149,0)
 . S PLIST("lexIen")=$P(ELEMENT,"^",1)
"RTN","HMPEF1",150,0)
 . S PLIST("lexName")=$P(ELEMENT,"^",2)
"RTN","HMPEF1",151,0)
 . S PLIST("icd")=$P(ELEMENT,"^",3)
"RTN","HMPEF1",152,0)
 . S PLIST("icdIen")=$P(ELEMENT,"^",4)
"RTN","HMPEF1",153,0)
 . S PLIST("codeSys")=$P(ELEMENT,"^",5)
"RTN","HMPEF1",154,0)
 . S PLIST("cCode")=$P(ELEMENT,"^",6)
"RTN","HMPEF1",155,0)
 . S PLIST("dCode")=$P(ELEMENT,"^",7)
"RTN","HMPEF1",156,0)
 . S PLIST("impDt")=$P(ELEMENT,"^",8)
"RTN","HMPEF1",157,0)
 . S HMPCNT=HMPCNT+1 D ADD^HMPEF("PLIST") S HMPLAST=HMPCNT
"RTN","HMPEF1",158,0)
 . Q
"RTN","HMPEF1",159,0)
 S HMPFINI=1
"RTN","HMPEF1",160,0)
 Q
"RTN","HMPEF1",161,0)
 ;
"RTN","HMPEVNT")
0^8^B181881949
"RTN","HMPEVNT",1,0)
HMPEVNT ;SLC/MKB,ASMR/JD,RRB,CPC -- VistA event listeners;Jun 30, 2016 14:15
"RTN","HMPEVNT",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPEVNT",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPEVNT",4,0)
 ;
"RTN","HMPEVNT",5,0)
 ; DE2818 - SQA findings.
"RTN","HMPEVNT",6,0)
 ;          1) Correct unkilled variables by modifying line tags to accept variables as
"RTN","HMPEVNT",7,0)
 ;          parameters and modifying associated protocol routine calls to pass variables
"RTN","HMPEVNT",8,0)
 ;          as parameters. RRB - 10/28/2015
"RTN","HMPEVNT",9,0)
 ;
"RTN","HMPEVNT",10,0)
 ; External References          DBIA#
"RTN","HMPEVNT",11,0)
 ; -------------------          -----
"RTN","HMPEVNT",12,0)
 ; DG FIELD MONITOR              3344
"RTN","HMPEVNT",13,0)
 ; DGPM MOVEMENT EVENTS          1181
"RTN","HMPEVNT",14,0)
 ; GMRA ENTERED IN ERROR         1467
"RTN","HMPEVNT",15,0)
 ; GMRA SIGN-OFF ON DATA         1469
"RTN","HMPEVNT",16,0)
 ; GMRC EVSEND OR                3140
"RTN","HMPEVNT",17,0)
 ; LR70 CH EVSEND OR             6087
"RTN","HMPEVNT",18,0)
 ; MDC OBSERVATION UPDATE        6084
"RTN","HMPEVNT",19,0)
 ; PS EVSEND OR                  2415
"RTN","HMPEVNT",20,0)
 ; PSB EVSEND HMP                6085
"RTN","HMPEVNT",21,0)
 ; PXK VISIT DATA EVENT          1298
"RTN","HMPEVNT",22,0)
 ; RA EVSEND OR                  6086
"RTN","HMPEVNT",23,0)
 ; SDAM APPOINTMENT EVENTS       1320
"RTN","HMPEVNT",24,0)
 ; ^AUPNVSIT                     2028
"RTN","HMPEVNT",25,0)
 ; ^DPT                         10035
"RTN","HMPEVNT",26,0)
 ; ^OR(100                       5771
"RTN","HMPEVNT",27,0)
 ; DIQ                           2056
"RTN","HMPEVNT",28,0)
 ; GMVUTL                        5046
"RTN","HMPEVNT",29,0)
 ; TIUSRVLO                      2834
"RTN","HMPEVNT",30,0)
 ; VADPT                        10061
"RTN","HMPEVNT",31,0)
 ; VASITE                       10112
"RTN","HMPEVNT",32,0)
 ; XLFDT                        10103
"RTN","HMPEVNT",33,0)
 ; XTHC10                        5515
"RTN","HMPEVNT",34,0)
 Q
"RTN","HMPEVNT",35,0)
 ;
"RTN","HMPEVNT",36,0)
 ;Oct 15, 2015 - PB - modified to trigger an unsolicited sync action when an order is discontinued and the patient is subscribed to eHMP
"RTN","HMPEVNT",37,0)
 ;DE3327 - 5/4/16 - JD - Removed the server hardcoding (hmp-development-box).
"RTN","HMPEVNT",38,0)
 ;                       *** NOTE ***
"RTN","HMPEVNT",39,0)
 ;                       It is understood that as of the date of modifying this code (5/4/16), there
"RTN","HMPEVNT",40,0)
 ;                       is one AND ONLY one server entry in the HMP Subscription file (#800000)
"RTN","HMPEVNT",41,0)
 ;                       per site.  This will be fixed in future releases to accommodate multiple
"RTN","HMPEVNT",42,0)
 ;                       servers per site.
"RTN","HMPEVNT",43,0)
 ;
"RTN","HMPEVNT",44,0)
DG(DGDA,DGFIELD,DGFILE) ; -- DG FIELD MONITOR protocol listener  /DE2818 
"RTN","HMPEVNT",45,0)
 Q:$G(DGFILE)'=2         ;Patient file only
"RTN","HMPEVNT",46,0)
 N DFN S DFN=+$G(DGDA)
"RTN","HMPEVNT",47,0)
 ; operational pt-select - *s68 BEGIN
"RTN","HMPEVNT",48,0)
 I "^.01^.02^.03^.09^.101^.351^.361^"[(U_+$G(DGFIELD)_U) D
"RTN","HMPEVNT",49,0)
 . ; -- if patient entry has been deleted, delete pt-select object
"RTN","HMPEVNT",50,0)
 . I $G(DGFIELD)=".01",'$D(^DPT(DFN)) D POSTX("pt-select",DFN,"@") Q  ; *s68 - END
"RTN","HMPEVNT",51,0)
 . D POSTX("pt-select",DFN_"&"_$G(DGFIELD))
"RTN","HMPEVNT",52,0)
 ; subscribed patient
"RTN","HMPEVNT",53,0)
 I $D(^HMP(800000,"AITEM",DFN)),$$FLD(+$G(DGFIELD)) D POST(DFN,"patient",DFN)
"RTN","HMPEVNT",54,0)
 Q
"RTN","HMPEVNT",55,0)
 ;
"RTN","HMPEVNT",56,0)
FLD(X) ; --Return 1 or 0, if X is a field tracked by HMP
"RTN","HMPEVNT",57,0)
 S X=U_+$G(X)_U
"RTN","HMPEVNT",58,0)
 I "^.01^.02^.03^.05^.08^.09^.351^.361^.364^"[X Q 1         ;demographic
"RTN","HMPEVNT",59,0)
 I "^.111^.1112^.112^.113^.114^.115^.131^.132^.134^"[X Q 1  ;addr/phone
"RTN","HMPEVNT",60,0)
 I "^.211^.212^.213^.214^.216^.217^.218^.219^"[X Q 1        ;NOK
"RTN","HMPEVNT",61,0)
 I "^.301^.302^1901^.32102^.32103^.32201^.5295^"[X Q 1      ;serv conn
"RTN","HMPEVNT",62,0)
 ;New fields.  JD - 9/24/15
"RTN","HMPEVNT",63,0)
 I "^.133^"[X Q 1                                           ;email address
"RTN","HMPEVNT",64,0)
 I "^.1211^.1212^.1213^.1214^.1215^.1216^"[X Q 1            ;temporary address
"RTN","HMPEVNT",65,0)
 I "^.331^.332^.333^.334^.335^.336^.337^.338^.339^.33011^"[X Q 1  ;emergency contact addr/phone
"RTN","HMPEVNT",66,0)
 I "^.215^.21011^"[X Q 1                                    ;NOK addr line 3 and work phone
"RTN","HMPEVNT",67,0)
 I "^.3731^"[X Q 1                                          ;service connected conditions
"RTN","HMPEVNT",68,0)
 I "^.18^3^8^16^"[X Q 1                                     ;insurance  
"RTN","HMPEVNT",69,0)
 Q 0
"RTN","HMPEVNT",70,0)
 ;
"RTN","HMPEVNT",71,0)
DGPM(DGPMA,DGPMDA,DGPMP,DGPMT) ; -- DGPM MOVEMENT EVENTS protocol listener  /DE2818
"RTN","HMPEVNT",72,0)
 ;    [expects DFN,DGPM* variables]
"RTN","HMPEVNT",73,0)
 N ADM,ACT S ADM=DGPMDA
"RTN","HMPEVNT",74,0)
 I DGPMT'=1 S ADM=$S(DGPMA:$P(DGPMA,U,14),1:$P(DGPMP,U,14)) Q:ADM<1
"RTN","HMPEVNT",75,0)
 S ACT=$S(DGPMA:"",1:"@")
"RTN","HMPEVNT",76,0)
 I $D(^HMP(800000,"AITEM",DFN)) D POST(DFN,"visit","H"_ADM,ACT)
"RTN","HMPEVNT",77,0)
 ; update roster(s) if current movement
"RTN","HMPEVNT",78,0)
 N ADMX,MVTX,PREV,NEW,OLD,WARD
"RTN","HMPEVNT",79,0)
 S ADMX=$Q(^DGPM("ATID1",DFN)) Q:$QS(ADMX,4)'=ADM
"RTN","HMPEVNT",80,0)
 S MVTX=$Q(^DGPM("APMV",DFN,ADM)) Q:$QS(MVTX,5)'=DGPMDA
"RTN","HMPEVNT",81,0)
 S PREV=$G(DGPMP) I 'PREV,DGPMT'=1 D  ;previous or edited mvt
"RTN","HMPEVNT",82,0)
 . S MVTX=$Q(@MVTX) Q:DFN'=$QS(MVTX,2)  Q:ADM'=$QS(MVTX,3)
"RTN","HMPEVNT",83,0)
 . S PREV=$G(^DGPM(+$QS(MVTX,5),0))
"RTN","HMPEVNT",84,0)
 S NEW=$P(DGPMA,U,6),OLD=$P(PREV,U,6)
"RTN","HMPEVNT",85,0)
 I NEW'=OLD F WARD=NEW,OLD I WARD D
"RTN","HMPEVNT",86,0)
 . S I=0 F  S I=$O(^HMPROSTR("AD",WARD_";DIC(42,",I)) Q:I<1  D POSTX("roster",I)
"RTN","HMPEVNT",87,0)
 Q
"RTN","HMPEVNT",88,0)
 ;-find visit# for corresponding admission [not used]
"RTN","HMPEVNT",89,0)
 N ADM,PTF,IDT,ID,ACT
"RTN","HMPEVNT",90,0)
 I DGPMA S ADM=+DGPMA,PTF=+$P(DGPMA,U,16)
"RTN","HMPEVNT",91,0)
 E  S ADM=+DGPMP,PTF=+$P(DGPMP,U,16)
"RTN","HMPEVNT",92,0)
 I DGPMT'=1 D  Q:ADM<1
"RTN","HMPEVNT",93,0)
 . N VAIP S VAIP("E")=DGPMDA
"RTN","HMPEVNT",94,0)
 . D IN5^VADPT S ADM=+VAIP(13,1),PTF=+VAIP(12)
"RTN","HMPEVNT",95,0)
 S IDT=9999999-$P(ADM,".") S:ADM["." IDT=IDT_"."_$P(ADM,".",2)
"RTN","HMPEVNT",96,0)
 S ID=+$O(^AUPNVSIT("AAH",DFN,IDT,0)) Q:'ID
"RTN","HMPEVNT",97,0)
 S ACT=$S(DGPMA:"",1:"@")
"RTN","HMPEVNT",98,0)
 D POST(DFN,"visit",ID,ACT)
"RTN","HMPEVNT",99,0)
 ; POST(DFN,"ptf",PTF,ACT):DGPMT=3
"RTN","HMPEVNT",100,0)
 Q
"RTN","HMPEVNT",101,0)
 ;
"RTN","HMPEVNT",102,0)
NEWINPT() ; -- is DFN newly admitted?
"RTN","HMPEVNT",103,0)
 N Y S Y=0
"RTN","HMPEVNT",104,0)
 I DGPMT=1,DGPMA,'DGPMP,+$G(^DPT(DFN,.105))=DGPMDA S Y=1 ;new admission
"RTN","HMPEVNT",105,0)
 Q Y
"RTN","HMPEVNT",106,0)
 ;
"RTN","HMPEVNT",107,0)
PCMMT(SCPTTMAF,SCPTTMB4) ; -- SCMC PATIENT TEAM CHANGES protocol listener /DE2818
"RTN","HMPEVNT",108,0)
 ;I '$P($G(SCPTTMB4),U,8),'$P($G(SCPTTMAF),U,8) Q  ;not pc change ;DE5410 removed to track changes to other teams
"RTN","HMPEVNT",109,0)
 N DFN S DFN=$S($G(SCPTTMAF):+SCPTTMAF,1:+$G(SCPTTMB4)) Q:'DFN
"RTN","HMPEVNT",110,0)
 D POST(DFN,"patient",DFN)
"RTN","HMPEVNT",111,0)
 Q
"RTN","HMPEVNT",112,0)
 ;
"RTN","HMPEVNT",113,0)
PCMMTP(SCPTTPAF,SCPTTPB4) ; -- SCMC PATIENT TEAM POSITION CHANGES protocol listener /DE2818
"RTN","HMPEVNT",114,0)
 ;I '$P($G(SCPTTPB4),U,5),'$P($G(SCPTTPAF),U,5) Q  ;not pc change ;DE5410 removed to track changes to other teams
"RTN","HMPEVNT",115,0)
 N TM,DFN
"RTN","HMPEVNT",116,0)
 S TM=$S($G(SCPTTPAF):+SCPTTPAF,1:+$G(SCPTTPB4)) Q:'TM
"RTN","HMPEVNT",117,0)
 ;DE2818
"RTN","HMPEVNT",118,0)
 S DFN=$$GET1^DIQ(404.42,+TM_",",.01,"I")  ;ICR 1922
"RTN","HMPEVNT",119,0)
 D POST(DFN,"patient",DFN)
"RTN","HMPEVNT",120,0)
 Q
"RTN","HMPEVNT",121,0)
 ;
"RTN","HMPEVNT",122,0)
SDAM(SDATA) ; -- SDAM APPOINTMENT EVENTS protocol listener /DE2818
"RTN","HMPEVNT",123,0)
 I $G(SDATA) D  Q  ;appointments
"RTN","HMPEVNT",124,0)
 . N DFN,DATE,HLOC,STS,REASON,PROV
"RTN","HMPEVNT",125,0)
 . S DFN=+$P(SDATA,U,2) Q:DFN<1
"RTN","HMPEVNT",126,0)
 . Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",127,0)
 . S DATE=+$P(SDATA,U,3),HLOC=+$P(SDATA,U,4),(PROV,REASON)=""
"RTN","HMPEVNT",128,0)
 . ;I SDAMEVT=1 K DIR S DIR(0)="F^3:20",DIR("A")="Enter Reason for Appointment: ",DIR("?")="Answer must be 2-20 characters" D ^DIR S REASON=Y
"RTN","HMPEVNT",129,0)
 . ;I SDAMEVT=1 K DIC S DIC="^VA(200,",DIC("A")="Select Patient's Provider: ",DIC(0)="AEQ",D="AK.PROVIDER" D IX^DIC S PROV=$P(Y,"^",1,2)
"RTN","HMPEVNT",130,0)
 . D POST(DFN,"appointment","A;"_DATE_";"_HLOC_";"_REASON_";"_$TR($P(PROV,U,1,2),"^",";"))
"RTN","HMPEVNT",131,0)
 Q
"RTN","HMPEVNT",132,0)
 ;
"RTN","HMPEVNT",133,0)
PCE ; -- PXK VISIT DATA EVENT protocol listener
"RTN","HMPEVNT",134,0)
 N IEN,PX0A,PX0B,DFN,DA,ACT,HMPPXK,ZTRTN,ZTDESC,ZTDTH,ZTIO,ZTSAVE,ZTSK ;DE4195
"RTN","HMPEVNT",135,0)
 S IEN=+$O(^TMP("PXKCO",$J,0)) Q:IEN<1
"RTN","HMPEVNT",136,0)
 S PX0A=$G(^TMP("PXKCO",$J,IEN,"VST",IEN,0,"AFTER")),PX0B=$G(^("BEFORE"))
"RTN","HMPEVNT",137,0)
 S DFN=$S($L(PX0A):+$P(PX0A,U,5),1:+$P(PX0B,U,5))
"RTN","HMPEVNT",138,0)
 Q:DFN<1  Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",139,0)
 ; Visit file
"RTN","HMPEVNT",140,0)
 S ACT=$S(PX0A="":"@",1:"")
"RTN","HMPEVNT",141,0)
 ;DE4195 - put subsequent processing into taskman
"RTN","HMPEVNT",142,0)
 M HMPPXK=^TMP("PXKCO",$J)
"RTN","HMPEVNT",143,0)
 S ZTRTN="PCE2^HMPEVNT",ZTDTH=$H,ZTIO=""
"RTN","HMPEVNT",144,0)
 S ZTSAVE("HMPPXK(")="",ZTSAVE("DFN")="",ZTSAVE("IEN")="",ZTSAVE("ACT")=""
"RTN","HMPEVNT",145,0)
 S ZTDESC="HMP PXK VISIT EVENT HANDLER"
"RTN","HMPEVNT",146,0)
 D ^%ZTLOAD
"RTN","HMPEVNT",147,0)
 Q
"RTN","HMPEVNT",148,0)
PCE2 ; DE4195 - run in taskman
"RTN","HMPEVNT",149,0)
 N DA,SUB
"RTN","HMPEVNT",150,0)
 D POST(DFN,"visit",IEN,ACT)
"RTN","HMPEVNT",151,0)
 ; check V-files
"RTN","HMPEVNT",152,0)
 F SUB="HF","IMM","XAM","CPT","PED","POV","SK" D
"RTN","HMPEVNT",153,0)
 . S DA=0 F  S DA=$O(HMPPXK(IEN,SUB,DA)) Q:DA<1  D
"RTN","HMPEVNT",154,0)
 .. S ACT=$S($G(HMPPXK(IEN,SUB,DA,0,"AFTER"))="":"@",1:"")
"RTN","HMPEVNT",155,0)
 .. D POST(DFN,$$NAME(SUB),DA,ACT)
"RTN","HMPEVNT",156,0)
 Q
"RTN","HMPEVNT",157,0)
 ;
"RTN","HMPEVNT",158,0)
NAME(X) ; -- return object name for V-files
"RTN","HMPEVNT",159,0)
 N Y S Y=""
"RTN","HMPEVNT",160,0)
 I X="HF"  S Y="factor"
"RTN","HMPEVNT",161,0)
 I X="IMM" S Y="immunization"
"RTN","HMPEVNT",162,0)
 I X="XAM" S Y="exam"
"RTN","HMPEVNT",163,0)
 I X="CPT" S Y="cpt"
"RTN","HMPEVNT",164,0)
 I X="PED" S Y="education"
"RTN","HMPEVNT",165,0)
 I X="POV" S Y="pov"
"RTN","HMPEVNT",166,0)
 I X="SK"  S Y="skin"
"RTN","HMPEVNT",167,0)
 Q Y
"RTN","HMPEVNT",168,0)
 ;
"RTN","HMPEVNT",169,0)
ZPCE ; -- old PXK VISIT DATA EVENT protocol listener [not in use]
"RTN","HMPEVNT",170,0)
 N IEN,PX0,PX150,DFN,DA
"RTN","HMPEVNT",171,0)
 S IEN=+$O(^TMP("PXKCO",$J,0)) Q:IEN<1
"RTN","HMPEVNT",172,0)
 S PX0=$G(^TMP("PXKCO",$J,IEN,"VST",IEN,0,"AFTER")) Q:$P(PX0,U,7)="E"
"RTN","HMPEVNT",173,0)
 I PX0="" D POST(DFN,"visit",IEN,"@") Q  ;deleted
"RTN","HMPEVNT",174,0)
 S PX150=$G(^TMP("PXKCO",$J,IEN,"VST",IEN,150,"AFTER")) Q:$P(PX150,U,3)'="P"
"RTN","HMPEVNT",175,0)
 S DFN=+$P(PX0,U,5) Q:DFN<1  Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",176,0)
 D POST(DFN,"visit",IEN)
"RTN","HMPEVNT",177,0)
 S DA=0 F  S DA=$O(^TMP("PXKCO",$J,IEN,"IMM",DA)) Q:DA<1  D POST(DFN,"immunization",DA)
"RTN","HMPEVNT",178,0)
 S DA=0 F  S DA=$O(^TMP("PXKCO",$J,IEN,"HF",DA)) Q:DA<1  D POST(DFN,"factor",DA)
"RTN","HMPEVNT",179,0)
 Q
"RTN","HMPEVNT",180,0)
 ;
"RTN","HMPEVNT",181,0)
XQOR(MSG) ; -- messaging listener (update meds, labs, xrays, consults)
"RTN","HMPEVNT",182,0)
 N HMPMSG,HMPPKG,MSH,ORC,DFN
"RTN","HMPEVNT",183,0)
 S HMPMSG=$S($L($G(MSG)):MSG,1:"MSG") Q:'$O(@HMPMSG@(0))
"RTN","HMPEVNT",184,0)
 S MSH=0 F  S MSH=$O(@HMPMSG@(MSH)) Q:MSH'>0  Q:$E(@HMPMSG@(MSH),1,3)="MSH"
"RTN","HMPEVNT",185,0)
 Q:'MSH  Q:'$L($G(@HMPMSG@(MSH)))
"RTN","HMPEVNT",186,0)
 S HMPPKG=$$TYPE($P(@HMPMSG@(MSH),"|",3))  Q:'$L(HMPPKG)
"RTN","HMPEVNT",187,0)
 S DFN=$$PID Q:DFN<1  Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",188,0)
 S ORC=MSH F  S ORC=$O(@HMPMSG@(+ORC)) Q:ORC'>0  I $E(@HMPMSG@(ORC),1,3)="ORC" D
"RTN","HMPEVNT",189,0)
 . N ORDCNTRL,PKGIFN,ORIFN,PORIFN
"RTN","HMPEVNT",190,0)
 . S ORC=ORC_U_@HMPMSG@(ORC),ORDCNTRL=$TR($P(ORC,"|",2),"@","P")
"RTN","HMPEVNT",191,0)
 . ; QUIT if action failed, conversion, purge, or backdoor verify/new
"RTN","HMPEVNT",192,0)
 . ;I ORDCNTRL["U"!("DE^ZC^ZP^ZR^ZV^SN"[ORDCNTRL) Q
"RTN","HMPEVNT",193,0)
 . I ORDCNTRL["U"!("DE^ZP^ZR^ZV^SN"[ORDCNTRL) Q  ;Oct 15, 2015 - PB - modified to trigger an unsolicited sync action when a signed order is discontinued
"RTN","HMPEVNT",194,0)
 . S ORIFN=+$P($P(ORC,"|",3),U),PKGIFN=$P($P(ORC,"|",4),U)
"RTN","HMPEVNT",195,0)
 . ; If this is a child order get the parent and send it too
"RTN","HMPEVNT",196,0)
 . ; PORIFN = PARENT ORDER IFN
"RTN","HMPEVNT",197,0)
 . S PORIFN=+$P($G(^OR(100,ORIFN,3)),U,9)
"RTN","HMPEVNT",198,0)
 . I $$RESULT D  ;update ancillary domains
"RTN","HMPEVNT",199,0)
 .. D POST(DFN,HMPPKG,PKGIFN)
"RTN","HMPEVNT",200,0)
 .. D:HMPPKG="image" POST(DFN,"document",PKGIFN)
"RTN","HMPEVNT",201,0)
 .. I HMPPKG="lab",PKGIFN'["CH",'$$LRTIU(DFN,PKGIFN) D POST(DFN,"document",$P(PKGIFN,";",4,5))
"RTN","HMPEVNT",202,0)
 . I ORIFN,ORDCNTRL'="ZD" D  ;update order(s)
"RTN","HMPEVNT",203,0)
 .. D POST(DFN,"order",ORIFN)
"RTN","HMPEVNT",204,0)
 .. I PORIFN D POST(DFN,"order",PORIFN)
"RTN","HMPEVNT",205,0)
 .. N ORIG S ORIG=+$P($G(^OR(100,ORIFN,3)),U,5)
"RTN","HMPEVNT",206,0)
 .. I ORIG D POST(DFN,"order",ORIG) ;need fwd ptrs, sig flds
"RTN","HMPEVNT",207,0)
 Q
"RTN","HMPEVNT",208,0)
 ;
"RTN","HMPEVNT",209,0)
RESULT() ; -- Return 1 or 0, if message broadcasts a result
"RTN","HMPEVNT",210,0)
 ;           [may modify PKGIFN for use in POST]
"RTN","HMPEVNT",211,0)
 N Y S Y=0
"RTN","HMPEVNT",212,0)
 I HMPPKG="consult" S Y=1,PKGIFN=+PKGIFN G RQ
"RTN","HMPEVNT",213,0)
 I HMPPKG="med"     S Y=1,PKGIFN=ORIFN G RQ
"RTN","HMPEVNT",214,0)
 I HMPPKG="lab"     S:ORDCNTRL="RE"&($L(PKGIFN,";")>3) Y=1 G RQ
"RTN","HMPEVNT",215,0)
 I HMPPKG="image"   S:PKGIFN["~" Y=1,PKGIFN=$TR($P(PKGIFN,"~",2,3),"~","-") G RQ
"RTN","HMPEVNT",216,0)
RQ Q Y
"RTN","HMPEVNT",217,0)
 ;
"RTN","HMPEVNT",218,0)
LRTIU(DFN,ORPK) ; -- Return 1 or 0, if LR report is in TIU
"RTN","HMPEVNT",219,0)
 I $G(DFN)<1!'$L($G(ORPK)) Q 0
"RTN","HMPEVNT",220,0)
 I ORPK["CH"!(ORPK["MI") Q 0
"RTN","HMPEVNT",221,0)
 N SUB,IDT,LRDFN
"RTN","HMPEVNT",222,0)
 S SUB=$P(ORPK,";",4),IDT=+$P(ORPK,";",5),LRDFN=+$G(^DPT(+DFN,"LR"))
"RTN","HMPEVNT",223,0)
 I $O(^LR(LRDFN,SUB,IDT,.05,0)) Q 1
"RTN","HMPEVNT",224,0)
 Q 0
"RTN","HMPEVNT",225,0)
 ;
"RTN","HMPEVNT",226,0)
NA(MSG) ; -- messaging listener (new backdoor orders)
"RTN","HMPEVNT",227,0)
 N HMPMSG,HMPPKG,MSH,ORC,DFN
"RTN","HMPEVNT",228,0)
 S HMPMSG=$S($L($G(MSG)):MSG,1:"MSG") Q:'$O(@HMPMSG@(0))
"RTN","HMPEVNT",229,0)
 S MSH=0 F  S MSH=$O(@HMPMSG@(MSH)) Q:MSH'>0  Q:$E(@HMPMSG@(MSH),1,3)="MSH"
"RTN","HMPEVNT",230,0)
 Q:'MSH  Q:'$L($G(@HMPMSG@(MSH)))
"RTN","HMPEVNT",231,0)
 S HMPPKG=$$TYPE($P(@HMPMSG@(MSH),"|",5))  Q:'$L(HMPPKG)
"RTN","HMPEVNT",232,0)
 S DFN=$$PID Q:DFN<1  Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",233,0)
 S ORC=MSH F  S ORC=$O(@HMPMSG@(+ORC)) Q:ORC'>0  I $E(@HMPMSG@(ORC),1,3)="ORC" D
"RTN","HMPEVNT",234,0)
 . N ORDCNTRL,ORIFN
"RTN","HMPEVNT",235,0)
 . S ORC=ORC_U_@HMPMSG@(ORC),ORDCNTRL=$TR($P(ORC,"|",2),"@","P")
"RTN","HMPEVNT",236,0)
 . Q:ORDCNTRL'="NA"
"RTN","HMPEVNT",237,0)
 . S ORIFN=+$P($P(ORC,"|",3),U) D POST(DFN,"order",ORIFN)
"RTN","HMPEVNT",238,0)
 . I HMPPKG="med" D POST(DFN,HMPPKG,ORIFN)
"RTN","HMPEVNT",239,0)
 Q
"RTN","HMPEVNT",240,0)
 ;
"RTN","HMPEVNT",241,0)
TYPE(NAME) ; -- Returns type name for XML
"RTN","HMPEVNT",242,0)
 I NAME="LABORATORY"  Q "lab"
"RTN","HMPEVNT",243,0)
 I NAME="PHARMACY"    Q "med"
"RTN","HMPEVNT",244,0)
 I NAME="CONSULTS"    Q "consult"
"RTN","HMPEVNT",245,0)
 I NAME="PROCEDURES"  Q "consult"
"RTN","HMPEVNT",246,0)
 I NAME="RADIOLOGY"   Q "image"
"RTN","HMPEVNT",247,0)
 I NAME="IMAGING"     Q "image"
"RTN","HMPEVNT",248,0)
 I NAME="ORDER ENTRY" Q "order"
"RTN","HMPEVNT",249,0)
 I NAME="DIETETICS"   Q "diet"
"RTN","HMPEVNT",250,0)
 Q ""
"RTN","HMPEVNT",251,0)
 ;
"RTN","HMPEVNT",252,0)
PID() ; -- Returns patient from PID segment in current msg
"RTN","HMPEVNT",253,0)
 N I,SEG,Y S I=MSH
"RTN","HMPEVNT",254,0)
 F  S I=$O(@HMPMSG@(I)) Q:I'>0  S SEG=$E(@HMPMSG@(I),1,3) Q:SEG="ORC"  I SEG="PID" D  Q
"RTN","HMPEVNT",255,0)
 . S Y=+$P(@HMPMSG@(I),"|",4)
"RTN","HMPEVNT",256,0)
 .;I '$D(^DPT(Y,0)) S:$L($P(@HMPMSG@(I),"|",5)) Y=+$P(@HMPMSG@(I),"|",5) ;alt ID for Lab
"RTN","HMPEVNT",257,0)
 Q Y
"RTN","HMPEVNT",258,0)
 ;
"RTN","HMPEVNT",259,0)
PV1() ; -- Returns patient class from PV1 segment in current msg
"RTN","HMPEVNT",260,0)
 N I,SEG,Y S I=MSH,Y=""
"RTN","HMPEVNT",261,0)
 F  S I=$O(@HMPMSG@(I)) Q:I'>0  S SEG=$E(@HMPMSG@(I),1,3) Q:SEG="ORC"  I SEG="PV1" D  Q
"RTN","HMPEVNT",262,0)
 . S Y=$P(@HMPMSG@(I),"|",3)
"RTN","HMPEVNT",263,0)
 I Y="",$G(ORIFN) S Y=$$GET1^DIQ(100,+ORIFN_",",10,"I")
"RTN","HMPEVNT",264,0)
 Q Y
"RTN","HMPEVNT",265,0)
 ;
"RTN","HMPEVNT",266,0)
GMRA(ACT) ; -- GMRA SIGN-OFF ON DATA protocol listener
"RTN","HMPEVNT",267,0)
 ;   also GMRA ENTERED IN ERROR [ACT=@]
"RTN","HMPEVNT",268,0)
 N DFN,IEN
"RTN","HMPEVNT",269,0)
 S DFN=+$G(GMRAPA(0)),IEN=+$G(GMRAPA)
"RTN","HMPEVNT",270,0)
 D POST(DFN,"allergy",IEN,$G(ACT))
"RTN","HMPEVNT",271,0)
 Q
"RTN","HMPEVNT",272,0)
 ;
"RTN","HMPEVNT",273,0)
GMPL(DFN,IEN) ; -- GMPL EVENT protocol listener
"RTN","HMPEVNT",274,0)
 S DFN=+$G(DFN),IEN=+$G(IEN)
"RTN","HMPEVNT",275,0)
 ;N ACT S ACT=$S($P($G(^AUPNPROB(IEN,1)),U,2)="H":"@",1:"")
"RTN","HMPEVNT",276,0)
 D POST(DFN,"problem",IEN) ;,ACT)
"RTN","HMPEVNT",277,0)
 Q
"RTN","HMPEVNT",278,0)
 ;
"RTN","HMPEVNT",279,0)
GMRV(DFN,IEN,ERR) ; -- Vital Measurement file #120.5 AHMP index
"RTN","HMPEVNT",280,0)
 S DFN=+$G(DFN),IEN=+$G(IEN)
"RTN","HMPEVNT",281,0)
 N ACT S ACT=$S($G(ERR):"@",1:"")
"RTN","HMPEVNT",282,0)
 D POST(DFN,"vital",IEN,ACT)
"RTN","HMPEVNT",283,0)
 Q
"RTN","HMPEVNT",284,0)
 ;
"RTN","HMPEVNT",285,0)
MDC(OBS) ; -- MDC OBSERVATION UPDATE protocol listener
"RTN","HMPEVNT",286,0)
 N DFN,ID,ACT
"RTN","HMPEVNT",287,0)
 S DFN=+$G(OBS("PATIENT_ID","I")) Q:DFN<1
"RTN","HMPEVNT",288,0)
 S ID=$G(OBS("OBS_ID","I")) Q:'$L(ID)
"RTN","HMPEVNT",289,0)
 S ACT=$S('$G(OBS("STATUS","I")):"@",1:"")
"RTN","HMPEVNT",290,0)
 D POST(DFN,"obs",ID,ACT)
"RTN","HMPEVNT",291,0)
 I $G(OBS("DOMAIN","VITALS")) D POST(DFN,"vital",ID,ACT)
"RTN","HMPEVNT",292,0)
 Q
"RTN","HMPEVNT",293,0)
 ;
"RTN","HMPEVNT",294,0)
CP(DFN,ID,ACT) ; -- CP Transaction file #702 AHMP index
"RTN","HMPEVNT",295,0)
 S DFN=+$G(DFN),ID=$G(ID)
"RTN","HMPEVNT",296,0)
 D POST(DFN,"document",ID,$G(ACT)) ;de3944 also need to generate document for procedure to link results to
"RTN","HMPEVNT",297,0)
 D POST(DFN,"procedure",ID,$G(ACT))
"RTN","HMPEVNT",298,0)
 Q
"RTN","HMPEVNT",299,0)
 ;
"RTN","HMPEVNT",300,0)
SR(DFN,IEN,ACT) ; -- Surgery [SROERR] update
"RTN","HMPEVNT",301,0)
 S DFN=+$G(DFN),IEN=+$G(IEN)
"RTN","HMPEVNT",302,0)
 D POST(DFN,"surgery",IEN,$G(ACT))
"RTN","HMPEVNT",303,0)
 Q
"RTN","HMPEVNT",304,0)
 ;*s68 - BEGINS
"RTN","HMPEVNT",305,0)
TIU(DFN,IEN) ; -- TIU Document file #8925 AHMP index
"RTN","HMPEVNT",306,0)
 N ACT,STS,DAD
"RTN","HMPEVNT",307,0)
 S DFN=+$G(DFN),IEN=+$G(IEN),ACT=""
"RTN","HMPEVNT",308,0)
 S STS=$G(X(2)),DAD=$G(X(3)) ;X = FM data array for index
"RTN","HMPEVNT",309,0)
 S:DAD IEN=DAD I 'DAD D      ;if addendum, repull entire note
"RTN","HMPEVNT",310,0)
 . ;I STS=15 S ACT="@"       ;retracted; DE3693 - do not delete note from JDS if retracted, March 18, 2016
"RTN","HMPEVNT",311,0)
 . I $G(X2(1))="" S ACT="@"  ;deleted (new title = null)
"RTN","HMPEVNT",312,0)
 D POST(DFN,"document",IEN,ACT)
"RTN","HMPEVNT",313,0)
 ;DE3241 - If TIU update changes CWADF values, trigger patient update so change get in fresh. stream
"RTN","HMPEVNT",314,0)
 ;If this note has a parent document type of "CLINICAL WARNING", "CRISIS NOTE", or "ADVANCE DIRECTIVE"...
"RTN","HMPEVNT",315,0)
 ;parent document type is "Document Class"...
"RTN","HMPEVNT",316,0)
 ;AND this note's status is COMPLETED or AMENDED
"RTN","HMPEVNT",317,0)
 ;THEN this document may update the C, W, or D CWADF values and patient fresh. stream update needs to be triggered
"RTN","HMPEVNT",318,0)
 N DADTYPE,DADNAME,STATUS
"RTN","HMPEVNT",319,0)
 S DADTYPE=$$GET1^DIQ(8925,IEN_",",".04","I") Q:'DADTYPE  Q:$$GET1^DIQ(8925.1,DADTYPE_",",".04","I")'="DC"
"RTN","HMPEVNT",320,0)
 S DADNAME=$$GET1^DIQ(8925.1,DADTYPE_",",".01")
"RTN","HMPEVNT",321,0)
 I $S(DADNAME="CLINICAL WARNING":0,DADNAME="CRISIS NOTE":0,DADNAME="ADVANCE DIRECTIVE":0,1:1) Q
"RTN","HMPEVNT",322,0)
 D POST(DFN,"patient",DFN)
"RTN","HMPEVNT",323,0)
 Q
"RTN","HMPEVNT",324,0)
 ; Deprecated calls
"RTN","HMPEVNT",325,0)
DOCDEF ;
"RTN","HMPEVNT",326,0)
DOCITEM ;
"RTN","HMPEVNT",327,0)
USR ;
"RTN","HMPEVNT",328,0)
 Q
"RTN","HMPEVNT",329,0)
 ; *s68 - END
"RTN","HMPEVNT",330,0)
PSB(PSBIEN) ; -- HMP PSB EVENTS protocol listener (BCMA) /DE2818
"RTN","HMPEVNT",331,0)
 N IEN,DFN,ORPK,TYPE,ORIFN
"RTN","HMPEVNT",332,0)
 S IEN=$S($P($G(PSBIEN),",",2)'="":+$P(PSBIEN,",",2),$G(PSBIEN)="+1":+$G(PSBIEN(1)),1:+$G(PSBIEN))
"RTN","HMPEVNT",333,0)
 S DFN=+$G(^PSB(53.79,IEN,0)),ORPK=$P($G(^(.1)),U)
"RTN","HMPEVNT",334,0)
 Q:DFN<1  Q:ORPK<1  S TYPE=$S(ORPK["V":"IV",ORPK["U":5,1:"") Q:TYPE=""
"RTN","HMPEVNT",335,0)
 S ORIFN=+$P($G(^PS(55,DFN,TYPE,+ORPK,0)),U,21)
"RTN","HMPEVNT",336,0)
 D:ORIFN POST(DFN,"med",ORIFN)
"RTN","HMPEVNT",337,0)
 Q
"RTN","HMPEVNT",338,0)
 ;
"RTN","HMPEVNT",339,0)
XU(IEN,ACT) ; -- XU USER ADD/CHANGE/TERMINATE option listener
"RTN","HMPEVNT",340,0)
 S IEN=+$G(IEN) Q:IEN<1
"RTN","HMPEVNT",341,0)
 D POSTX("user",IEN,$G(ACT))
"RTN","HMPEVNT",342,0)
 Q
"RTN","HMPEVNT",343,0)
 ;
"RTN","HMPEVNT",344,0)
POST(DFN,TYPE,ID,ACT) ; -- track updated patient data
"RTN","HMPEVNT",345,0)
 S DFN=+$G(DFN),TYPE=$G(TYPE),ID=$G(ID)
"RTN","HMPEVNT",346,0)
 Q:DFN<1  Q:TYPE=""  Q:ID=""   ;incomplete request
"RTN","HMPEVNT",347,0)
 Q:$G(^XTMP("HMP-off",TYPE))   ;domain turned 'off'
"RTN","HMPEVNT",348,0)
 Q:'$D(^HMP(800000,"AITEM",DFN))  ;patient not subscribed to
"RTN","HMPEVNT",349,0)
 N HMPDT S HMPDT="HMP-"_DT
"RTN","HMPEVNT",350,0)
 ;S ^XTMP(HMPDT,$$NEXT)=DFN_U_TYPE_U_ID_U_$G(ACT)
"RTN","HMPEVNT",351,0)
 N NODES
"RTN","HMPEVNT",352,0)
 D POST^HMPDJFS(DFN,TYPE,ID,$G(ACT),"",.NODES)
"RTN","HMPEVNT",353,0)
 Q
"RTN","HMPEVNT",354,0)
 ;
"RTN","HMPEVNT",355,0)
POSTX(TYPE,ID,ACT) ; -- track updated reference items
"RTN","HMPEVNT",356,0)
 S TYPE=$G(TYPE),ID=$G(ID)
"RTN","HMPEVNT",357,0)
 Q:TYPE=""  Q:ID=""            ;incomplete request
"RTN","HMPEVNT",358,0)
 Q:$G(^XTMP("HMP-off",TYPE))   ;domain turned 'off'
"RTN","HMPEVNT",359,0)
 N HMPDT S HMPDT="HMP-"_DT ;"HMPEF-"_DT
"RTN","HMPEVNT",360,0)
 ;S ^XTMP(HMPDT,$$NEXT)=U_TYPE_U_ID_U_$G(ACT)
"RTN","HMPEVNT",361,0)
 N NODES
"RTN","HMPEVNT",362,0)
 D POST^HMPDJFS("OPD",TYPE,ID,$G(ACT),"",.NODES)
"RTN","HMPEVNT",363,0)
 Q
"RTN","HMPEVNT",364,0)
 ;
"RTN","HMPEVNT",365,0)
NEXT() ; -- Return next sequential number in ^XTMP(HMPDT,n)
"RTN","HMPEVNT",366,0)
 L +^XTMP(HMPDT):5 ;I'$T ??
"RTN","HMPEVNT",367,0)
 N Y S Y=+$O(^XTMP(HMPDT,"A"),-1)+1
"RTN","HMPEVNT",368,0)
 I '$D(^XTMP(HMPDT,0)) S ^(0)=$$FMADD^XLFDT(DT,3)_U_DT_"^HMP Updates"
"RTN","HMPEVNT",369,0)
 L -^XTMP(HMPDT)
"RTN","HMPEVNT",370,0)
 Q Y
"RTN","HMPEVNT",371,0)
 ;
"RTN","HMPEVNT",372,0)
HTTP(URL,DFN,TYPE,ID) ; -- send message that TYPE/ID has been updated [not in use]
"RTN","HMPEVNT",373,0)
 N DIV,X,HMPX
"RTN","HMPEVNT",374,0)
 S DFN=+$G(DFN) Q:DFN<1  ;patient req'd
"RTN","HMPEVNT",375,0)
 S DIV=$P($$SITE^VASITE,U,3) ;station number
"RTN","HMPEVNT",376,0)
 S URL=$G(URL)_"?division="_DIV_"&dfn="_+$G(DFN)
"RTN","HMPEVNT",377,0)
 I $L($G(TYPE)) S URL=URL_"&type="_TYPE
"RTN","HMPEVNT",378,0)
 I $L($G(ID))   S URL=URL_"&id="_ID
"RTN","HMPEVNT",379,0)
 S ^XTMP("HMP",DFN,"HTTP")=$H
"RTN","HMPEVNT",380,0)
 S X=$$GETURL^XTHC10(URL,,"HMPX")
"RTN","HMPEVNT",381,0)
 ; I X>200 = ERROR
"RTN","HMPEVNT",382,0)
 Q
"RTN","HMPEVNT",383,0)
DGREG ; register a newly registered patient in eHMP during the initial registration - Sep 29, 2015 - Phil Burkhalter
"RTN","HMPEVNT",384,0)
 Q:'+$G(DFN)
"RTN","HMPEVNT",385,0)
 Q:'$D(^DPT(DFN,0))  ; Quit if patient is not in the patient file
"RTN","HMPEVNT",386,0)
 ;check the XPAR for HMP Auto Enrollment with newly registered patients, 
"RTN","HMPEVNT",387,0)
 ;if set to yes for automatically adding a new HMP subscription:
"RTN","HMPEVNT",388,0)
 ;add the patient to HMP(800000 and to a pt-select update. Only want to do an update for the one patient if possible.
"RTN","HMPEVNT",389,0)
 ;if set to no for automatically adding a new HMP subscrption:
"RTN","HMPEVNT",390,0)
 ;only do the pt-select update, DO NOT add to the HMP subscription
"RTN","HMPEVNT",391,0)
 S X=$$GET^XPAR("SYS","HMP AUTOSYNC REG")  ;X=1 Yes auto subscribe patient to HMP, X="" or X=0 No don't auto subscribe the patient to HMP
"RTN","HMPEVNT",392,0)
 I $G(X)'=1 D POSTX(DFN,"patient",DFN) Q  ; Do pt-select
"RTN","HMPEVNT",393,0)
 I $G(X)=1 D
"RTN","HMPEVNT",394,0)
 .Q:$D(^HMP(800000,"AITEM",DFN))  ; Quit if the patient has already been added to the eHMP subscription
"RTN","HMPEVNT",395,0)
 .S ARGS("command")="putPtSubscription",ARGS("localId")=$G(DFN)
"RTN","HMPEVNT",396,0)
 .;DE3327
"RTN","HMPEVNT",397,0)
 .I '$L($G(ARGS("server"))) S ARGS("server")=$P($G(^HMP(800000,1,0)),"^")  ; See comments at the top
"RTN","HMPEVNT",398,0)
 .D API^HMPDJFS(.RSLT,.ARGS) D POSTX(DFN,"patient",DFN)  ; add patient to HMP(800000 and if patient is added, add patient to the freshness stream
"RTN","HMPEVNT",399,0)
 .K ARGS,RSLT
"RTN","HMPEVNT",400,0)
 K X
"RTN","HMPEVNT",401,0)
 Q
"RTN","HMPFPTC")
0^23^B13917826
"RTN","HMPFPTC",1,0)
HMPFPTC ;SLC/MKB,AGP,ASMR/RRB - Patient look-up Utilities at Facility;Nov 04, 2015 18:37:39
"RTN","HMPFPTC",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPFPTC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPFPTC",4,0)
 ;
"RTN","HMPFPTC",5,0)
 Q
"RTN","HMPFPTC",6,0)
 ;
"RTN","HMPFPTC",7,0)
CHKS(HMPZ,DFN) ; perform patient select checks
"RTN","HMPFPTC",8,0)
 ;
"RTN","HMPFPTC",9,0)
 N ACCESS,CHKS,CNT,DEATHDT,ERR,I,IEN,STR,X,HMPY
"RTN","HMPFPTC",10,0)
 ; check for sensitive record
"RTN","HMPFPTC",11,0)
 S STR="patientChecks"
"RTN","HMPFPTC",12,0)
 S ACCESS=0
"RTN","HMPFPTC",13,0)
 D PTSEC^DGSEC4(.HMPY,DFN)  ;IA #3027
"RTN","HMPFPTC",14,0)
 S ACCESS=1
"RTN","HMPFPTC",15,0)
 I HMPY(1)>0 D
"RTN","HMPFPTC",16,0)
 .S CHKS("sensitive","dfn")=DFN
"RTN","HMPFPTC",17,0)
 .S ACCESS=(HMPY(1)<3)
"RTN","HMPFPTC",18,0)
 .S CHKS("sensitive","mayAccess")=$S(ACCESS=1:"true",1:"false")
"RTN","HMPFPTC",19,0)
 .S CHKS("sensitive","logAccess")=$S(HMPY(1)>1:"true",1:"false")
"RTN","HMPFPTC",20,0)
 .S CNT=2,X=""
"RTN","HMPFPTC",21,0)
 .F  S CNT=$O(HMPY(CNT)) Q:CNT'>0  S X=X_$C(13)_$C(10)_$G(HMPY(CNT))
"RTN","HMPFPTC",22,0)
 .S CHKS("sensitive","text")=X
"RTN","HMPFPTC",23,0)
 ;
"RTN","HMPFPTC",24,0)
 ; check for deceased patient, DE2818 changed from direct global reference
"RTN","HMPFPTC",25,0)
 D TOP^HMPXGDPT("DEATHDT",DFN,.351,"E")
"RTN","HMPFPTC",26,0)
 D:$L($G(DEATHDT(2,DFN,.351,"E")))
"RTN","HMPFPTC",27,0)
 . S CHKS("deceased","text")="This patient died on "_DEATHDT(2,DFN,.351,"E")_"."_$C(13)_$C(10)_" Do you wish to continue?"
"RTN","HMPFPTC",28,0)
 ;
"RTN","HMPFPTC",29,0)
 ; check for similar patients
"RTN","HMPFPTC",30,0)
 K HMPY
"RTN","HMPFPTC",31,0)
 N MSG,SIM,SIMPAT,TEXT S MSG=0,SIM=0
"RTN","HMPFPTC",32,0)
 D GUIBS5A^DPTLK6(.HMPY,DFN)  ;IA #3593
"RTN","HMPFPTC",33,0)
 I HMPY(1)>0 D
"RTN","HMPFPTC",34,0)
 .S TEXT=""
"RTN","HMPFPTC",35,0)
 .S I=1 F  S I=$O(HMPY(I)) Q:'I  S X=HMPY(I) D
"RTN","HMPFPTC",36,0)
 .. S SIM=SIM+1
"RTN","HMPFPTC",37,0)
 .. I $E(X)=0 S TEXT=$S($L(TEXT):TEXT_$C(13)_$C(10)_$P(X,U,2),1:$P(X,U,2))
"RTN","HMPFPTC",38,0)
 .. I $E(X)=1 D
"RTN","HMPFPTC",39,0)
 ... ;S CHKS("similar",SIM,"dfn")=$P(X,U,2)
"RTN","HMPFPTC",40,0)
 ... ;S CHKS("similar",SIM,"name")=$P(X,U,3)
"RTN","HMPFPTC",41,0)
 ... ;S CHKS("similar",SIM,"dob")=$$FMTE^XLFDT($P(X,U,4),"D")
"RTN","HMPFPTC",42,0)
 ... ;S CHKS("similar",SIM,"ssn")=$P(X,U,5)
"RTN","HMPFPTC",43,0)
 ... S SIMPAT="Patient Name: "_$P(X,U,3)_" Date of Birth: "_$$FMTE^XLFDT($P(X,U,4),"D")_" SSN: "_$P(X,U,5)
"RTN","HMPFPTC",44,0)
 ... S TEXT=TEXT_$C(13)_$C(10)_SIMPAT
"RTN","HMPFPTC",45,0)
 .S CHKS("similar","text")=TEXT
"RTN","HMPFPTC",46,0)
 ;
"RTN","HMPFPTC",47,0)
 ; possibly check means test: GUIMTD^DPTLK6
"RTN","HMPFPTC",48,0)
 ; possibly check legacy data: I $L($T(HXDATA^A7RDPAGU)...
"RTN","HMPFPTC",49,0)
 ;
"RTN","HMPFPTC",50,0)
 I ACCESS D PRF(DFN,.CHKS)
"RTN","HMPFPTC",51,0)
 S ERR(0)=""
"RTN","HMPFPTC",52,0)
 ;S HMP=$$ENCODE^HMPJSON("CHKS","ERR")
"RTN","HMPFPTC",53,0)
 D ENCODE^HMPJSON("CHKS","HMPZ","ERR")
"RTN","HMPFPTC",54,0)
 Q
"RTN","HMPFPTC",55,0)
 ;
"RTN","HMPFPTC",56,0)
PRF(DFN,CHKS) ; get Patient Record Flags
"RTN","HMPFPTC",57,0)
 N HMPY,EDI,PRF,N,X
"RTN","HMPFPTC",58,0)
 Q:$$GETACT^DGPFAPI(DFN,"HMPY")'>0
"RTN","HMPFPTC",59,0)
 S EDI=0 F  S EDI=$O(HMPY(EDI)) Q:EDI<1  K PRF D
"RTN","HMPFPTC",60,0)
 . S CHKS("patientRecordFlags",EDI,"assignmentStatus")="Active"
"RTN","HMPFPTC",61,0)
 . S CHKS("patientRecordFlags",EDI,"assignTS")=$$JSONDT^HMPUTILS($P($G(HMPY(EDI,"ASSIGNDT")),U))
"RTN","HMPFPTC",62,0)
 . S CHKS("patientRecordFlags",EDI,"approved")=$P($G(HMPY(EDI,"APPRVBY")),U,2)
"RTN","HMPFPTC",63,0)
 . S CHKS("patientRecordFlags",EDI,"nextReviewDT")=$$JSONDT^HMPUTILS($P($G(HMPY(EDI,"REVIEWDT")),U))
"RTN","HMPFPTC",64,0)
 . S CHKS("patientRecordFlags",EDI,"name")=$P($G(HMPY(EDI,"FLAG")),U,2)
"RTN","HMPFPTC",65,0)
 . S CHKS("patientRecordFlags",EDI,"type")=$P($G(HMPY(EDI,"FLAGTYPE")),U,2)
"RTN","HMPFPTC",66,0)
 . S CHKS("patientRecordFlags",EDI,"category")=$P($G(HMPY(EDI,"CATEGORY")),U,2)
"RTN","HMPFPTC",67,0)
 . S CHKS("patientRecordFlags",EDI,"ownerSite")=$P($G(HMPY(EDI,"OWNER")),U,2)
"RTN","HMPFPTC",68,0)
 . S CHKS("patientRecordFlags",EDI,"originatingSite")=$P($G(HMPY(EDI,"ORIGSITE")),U,2)
"RTN","HMPFPTC",69,0)
 . S N=1,X=$G(HMPY(EDI,"NARR",1,0))
"RTN","HMPFPTC",70,0)
 . F  S N=$O(HMPY(EDI,"NARR",N)) Q:N<1  S X=X_$C(13)_$C(10)_$G(HMPY(EDI,"NARR",N,0))
"RTN","HMPFPTC",71,0)
 . S CHKS("patientRecordFlags",EDI,"text")=X
"RTN","HMPFPTC",72,0)
 Q
"RTN","HMPFPTC",73,0)
 ;
"RTN","HMPFPTC",74,0)
LOG(HMPZ,DFN) ; Make entry in security log for sensitive patient access
"RTN","HMPFPTC",75,0)
 N ERR,RESULTS,HMPY,X
"RTN","HMPFPTC",76,0)
 D NOTICE^DGSEC4(.HMPY,DFN) ;IA #3027
"RTN","HMPFPTC",77,0)
 S X=$S(HMPY:"ok",1:"fail")
"RTN","HMPFPTC",78,0)
 S RESULTS("result")=X
"RTN","HMPFPTC",79,0)
 ;S HMP=$$ENCODE^HMPJSON("RESULTS","ERR")
"RTN","HMPFPTC",80,0)
 D ENCODE^HMPJSON("RESULTS","HMPZ","ERR")
"RTN","HMPFPTC",81,0)
 Q
"RTN","HMPFPTC",82,0)
 ;
"RTN","HMPFPTC",83,0)
ENROS(HMPZ,DFNARRAY) ;PROCESS PATIENTS FROM A ROSTER
"RTN","HMPFPTC",84,0)
 N DFN S DFN=0
"RTN","HMPFPTC",85,0)
 F  S DFN=$O(DFNARRAY(DFN)) Q:DFN'>0  D CHKS(.HMPZ,DFN)
"RTN","HMPFPTC",86,0)
 Q
"RTN","HMPFPTC",87,0)
 ;
"RTN","HMPLOG")
0^24^B18006538
"RTN","HMPLOG",1,0)
HMPLOG ; ASMR/hrubovcak - eHMP logging support ;Jun 21, 2016 16:41:12
"RTN","HMPLOG",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;June 13, 2016;Build 24
"RTN","HMPLOG",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPLOG",4,0)
 ;
"RTN","HMPLOG",5,0)
 ; routine created 13 June 2016 for US15658
"RTN","HMPLOG",6,0)
 Q
"RTN","HMPLOG",7,0)
 ;
"RTN","HMPLOG",8,0)
NWNTRY(HMPDTIM,HMPTYP,HMPLOG) ; function, create new entry in HMP EVENT file (#80003)
"RTN","HMPLOG",9,0)
 ; returns new entry IEN
"RTN","HMPLOG",10,0)
 ; HMPDTIM - optional FileMan format date/time.  Must be precise and have time with seconds.
"RTN","HMPLOG",11,0)
 ;   defaults to NOW if not passed or invalid
"RTN","HMPLOG",12,0)
 ; HMPTYP - optional event type, if missing, defaults to O (other)
"RTN","HMPLOG",13,0)
 ; HMPLOG - event log passed by reference, traversed by $QUERY for word-processing text
"RTN","HMPLOG",14,0)
 ;  array is optional, but should be passed with calling routine name and module, at minimum.
"RTN","HMPLOG",15,0)
 ;  this array will remain unchanged
"RTN","HMPLOG",16,0)
 ;
"RTN","HMPLOG",17,0)
 Q:'$L($G(^HMPLOG(800003,0))) -1  ; file not installed, return out-of-bounds value
"RTN","HMPLOG",18,0)
 ;
"RTN","HMPLOG",19,0)
 D DT^DICRW  ; ensure minimum symbol table defined
"RTN","HMPLOG",20,0)
 N G,H,HMPERR,HMPLGFDA,HMPLGIEN,HMPWPTXT,IENS,J,X,Y
"RTN","HMPLOG",21,0)
 ; handle entry creation for speed
"RTN","HMPLOG",22,0)
 L +^HMPLOG(800003,0):DILOCKTM  ; exclusive access for new IEN
"RTN","HMPLOG",23,0)
 S X=$G(^HMPLOG(800003,0)),J=$P(X,U,4)+1,$P(X,U,4)=J,HMPLGIEN=$P(X,U,3)+1\1  ; make it an integer
"RTN","HMPLOG",24,0)
 F  Q:'$D(^HMPLOG(800003,HMPLGIEN))  S HMPLGIEN=HMPLGIEN+1   ; entry IEN to be returned
"RTN","HMPLOG",25,0)
 S ^HMPLOG(800003,HMPLGIEN,0)=HMPLGIEN,^HMPLOG(800003,"B",HMPLGIEN,HMPLGIEN)=""  ; new entry and cross-ref.
"RTN","HMPLOG",26,0)
 S $P(X,U,3)=HMPLGIEN,^HMPLOG(800003,0)=X L -^HMPLOG(800003,0)  ; update zero node and unlock
"RTN","HMPLOG",27,0)
 ;
"RTN","HMPLOG",28,0)
 S J=0 D  ; create word-processing text
"RTN","HMPLOG",29,0)
 . I $G(HMPLOG)]"" S J=J+1,HMPWPTXT(J,0)=HMPLOG  ; if root has text, save it
"RTN","HMPLOG",30,0)
 . S Y="HMPLOG" F  S Y=$Q(@Y) Q:Y=""  S X=@Y,J=J+1,HMPWPTXT(J,0)=$S($L(X):X,1:" ")  ; replace blanks with spaces
"RTN","HMPLOG",31,0)
 . S X=$S($G(DUZ):" DUZ: "_DUZ,1:"")_"   $job: "_$J_"   $i: "_$I_$S($G(ZTSK):"   ZTSK: "_ZTSK,1:"")  ; job info
"RTN","HMPLOG",32,0)
 . S J=J+1,HMPWPTXT(J,0)=X,J=J+1,HMPWPTXT(J,0)=" logged: "_$$HTE^XLFDT($H)
"RTN","HMPLOG",33,0)
 ;
"RTN","HMPLOG",34,0)
 S IENS=HMPLGIEN_","
"RTN","HMPLOG",35,0)
 S Y=$G(HMPDTIM) S:'((Y?7N)!(Y?7N1"."1.6N)&$E(Y,6,7)) Y=$$NOW^XLFDT  ; must be precise date, otherwise NOW
"RTN","HMPLOG",36,0)
 S:'$P(Y,".",2) Y=Y+.000001  ; if no seconds, make time 00:00:01
"RTN","HMPLOG",37,0)
 S HMPLGFDA(800003,IENS,.02)=Y  ; EVENT DATE/TIME
"RTN","HMPLOG",38,0)
 ;
"RTN","HMPLOG",39,0)
 S Y=$E($G(HMPTYP)) S:'(Y?1U) Y="O"  ; default to other
"RTN","HMPLOG",40,0)
 S HMPLGFDA(800003,IENS,.03)=Y  ; TYPE OF EVENT
"RTN","HMPLOG",41,0)
 ;
"RTN","HMPLOG",42,0)
 D FILE^DIE("S","HMPLGFDA","HMPERR")  ; "S" flag to save HMPLGFDA array
"RTN","HMPLOG",43,0)
 ;
"RTN","HMPLOG",44,0)
 I $D(HMPERR("DIERR")) D  ; save new entry error data, just in case (should not happen)
"RTN","HMPLOG",45,0)
 . S H=$H,J=0,G="HMPERR(""DIERR"")"
"RTN","HMPLOG",46,0)
 . S ^TMP($T(+0),$J,H,"NEW",0)=" FileMan error, adding HMP EVENT"
"RTN","HMPLOG",47,0)
 . F  S G=$Q(@G) Q:'(G["DIERR")  S J=J+1,^TMP($T(+0),$J,H,"NEW",J)=@G
"RTN","HMPLOG",48,0)
 ; add word-processing text
"RTN","HMPLOG",49,0)
 K HMPERR D WP^DIE(800003,IENS,1,"","HMPWPTXT","HMPERR")
"RTN","HMPLOG",50,0)
  I $D(HMPERR("DIERR")) D  ; save w-p error data, just in case (should not happen)
"RTN","HMPLOG",51,0)
 . S H=$H,J=0,G="HMPERR(""DIERR"")"
"RTN","HMPLOG",52,0)
 . S ^TMP($T(+0),$J,H,"W-P",0)=" FileMan error, adding w-p text"
"RTN","HMPLOG",53,0)
 . F  S G=$Q(@G) Q:'(G["DIERR")  S J=J+1,^TMP($T(+0),$J,H,"W-P",J)=@G
"RTN","HMPLOG",54,0)
 ;
"RTN","HMPLOG",55,0)
 Q HMPLGIEN  ; return new log IEN
"RTN","HMPLOG",56,0)
 ;
"RTN","HMPLOG",57,0)
PRGLOG ; purge HMP EVENT file (#800003) entries older than 61 days
"RTN","HMPLOG",58,0)
 ;
"RTN","HMPLOG",59,0)
 Q:'$L($G(^HMPLOG(800003,0)))  ; file not installed
"RTN","HMPLOG",60,0)
 D DT^DICRW  ; minimal symbol table
"RTN","HMPLOG",61,0)
 ;
"RTN","HMPLOG",62,0)
 N DA,DIK,HMP,HMPRGLOG,J,X,Y
"RTN","HMPLOG",63,0)
 S J=1,HMPRGLOG(J,0)="HMP EVENT log purge started"
"RTN","HMPLOG",64,0)
 S J=J+1,HMPRGLOG(J,0)=" calling routine: PRGLOG^"_$T(+0)
"RTN","HMPLOG",65,0)
 S Y=$NA(^HMPLOG(800003,0))  ; record zero node
"RTN","HMPLOG",66,0)
 S J=J+1,HMPRGLOG(J,0)=" "_Y_"="_$C(34)_$G(^HMPLOG(800003,0))_$C(34)
"RTN","HMPLOG",67,0)
 S Y=$$NWNTRY($$NOW^XLFDT,"I",.HMPRGLOG)  ; log the purge start
"RTN","HMPLOG",68,0)
 ;
"RTN","HMPLOG",69,0)
 S HMP("T-61")=$$HTFM^XLFDT($H-61)  ; 61 days ago, FileMan format
"RTN","HMPLOG",70,0)
 S HMP("DEL")=0  ; deleted count
"RTN","HMPLOG",71,0)
 S HMP("TTL")=0  ; total checked
"RTN","HMPLOG",72,0)
 S DIK="^HMPLOG(800003,"  ; file root
"RTN","HMPLOG",73,0)
 S J=0 F  S J=$O(^HMPLOG(800003,J)) Q:'J  D
"RTN","HMPLOG",74,0)
 . S HMP("TTL")=HMP("TTL")+1,Y=$G(^HMPLOG(800003,J,0)) Q:$P(Y,U,2)>HMP("T-61")
"RTN","HMPLOG",75,0)
 . S DA=J,HMP("DEL")=HMP("DEL")+1
"RTN","HMPLOG",76,0)
 . N J D ^DIK  ; protect J before ^DIK call
"RTN","HMPLOG",77,0)
 ;
"RTN","HMPLOG",78,0)
 K HMPRGLOG S J=1,HMPRGLOG(J,0)="HMP EVENT log purge finished"
"RTN","HMPLOG",79,0)
 S J=J+1,HMPRGLOG(J,0)=" Entries checked: "_HMP("TTL")
"RTN","HMPLOG",80,0)
 S J=J+1,HMPRGLOG(J,0)=" Entries deleted: "_HMP("DEL")
"RTN","HMPLOG",81,0)
 S J=J+1,HMPRGLOG(J,0)=" calling routine: PRGLOG^"_$T(+0)
"RTN","HMPLOG",82,0)
 S Y=$$NWNTRY($$NOW^XLFDT,"I",.HMPRGLOG)  ; log the purge end
"RTN","HMPLOG",83,0)
 Q
"RTN","HMPLOG",84,0)
 ;
"RTN","HMPMETA")
0^25^B193059254
"RTN","HMPMETA",1,0)
HMPMETA ;SLC/PJH,ASM/RRB,CPC-collect domains, uids, & stamptimes ;2016-07-01 13:16Z
"RTN","HMPMETA",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;Sep 01, 2011;Build 24
"RTN","HMPMETA",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMETA",4,0)
 ;
"RTN","HMPMETA",5,0)
 quit  ; no entry from top of routine HMPMETA
"RTN","HMPMETA",6,0)
 ;
"RTN","HMPMETA",7,0)
 ; primary development
"RTN","HMPMETA",8,0)
 ;
"RTN","HMPMETA",9,0)
 ; original author: (pjh)
"RTN","HMPMETA",10,0)
 ; additional author: Ray Blank (rrb)
"RTN","HMPMETA",11,0)
 ; additional author: Frederick D. S. Marshall (toad)
"RTN","HMPMETA",12,0)
 ; additional author: Chris P. Casey (cpc)
"RTN","HMPMETA",13,0)
 ; original org: U.S. Department of Veterans Affairs (va)
"RTN","HMPMETA",14,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMETA",15,0)
 ; other development orgs: VISTA Expertise Network (asmr-ven)
"RTN","HMPMETA",16,0)
 ;
"RTN","HMPMETA",17,0)
 ; 2013-08-14 va-islc/pjh: last update by VA before code transfered
"RTN","HMPMETA",18,0)
 ; to asmr for eHMP contract.
"RTN","HMPMETA",19,0)
 ;
"RTN","HMPMETA",20,0)
 ; 2015-11-04 asmr/rrb: fix first three lines for sac compliance,
"RTN","HMPMETA",21,0)
 ; [DE2818/RRB: SQA findings 1st 3 lines].
"RTN","HMPMETA",22,0)
 ;
"RTN","HMPMETA",23,0)
 ; 2016-03-29/04-13 asmr-ven/toad: change MESNOK to call
"RTN","HMPMETA",24,0)
 ; $$GETSIZE^HMPMONX instead of $$GETSIZE^HMPUTILS; pass user # by
"RTN","HMPMETA",25,0)
 ; reference; fix MESOK likewise, send e-mail to g.HMP IRM GROUP,
"RTN","HMPMETA",26,0)
 ; refactor both, fix org.
"RTN","HMPMETA",27,0)
 ;
"RTN","HMPMETA",28,0)
 ; 2016-04-14 asmr/cpc [DE3759]: avoid multiple edge case in METAOP.
"RTN","HMPMETA",29,0)
 ;
"RTN","HMPMETA",30,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3.
"RTN","HMPMETA",31,0)
 ;
"RTN","HMPMETA",32,0)
 ; 2016-06-30/07-01 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMETA",33,0)
 ; convert variables in MESNOK & MESOK to uppercase; add EOR line;
"RTN","HMPMETA",34,0)
 ; update dev history; add contents; repoint QUINIT from
"RTN","HMPMETA",35,0)
 ; DQINIT^HMPDJFSP to DQINIT^HMPDJFSQ.
"RTN","HMPMETA",36,0)
 ;
"RTN","HMPMETA",37,0)
 ;
"RTN","HMPMETA",38,0)
 ; contents
"RTN","HMPMETA",39,0)
 ;
"RTN","HMPMETA",40,0)
 ; ADD: Build array for metastamp
"RTN","HMPMETA",41,0)
 ; DONE: Check if metastamp compile is complete
"RTN","HMPMETA",42,0)
 ; $$OPD = Check if OPD metastamp is ready to collect
"RTN","HMPMETA",43,0)
 ; INIT: Set metastamp status as in progress
"RTN","HMPMETA",44,0)
 ; UPD: Update metastamp domain as complete
"RTN","HMPMETA",45,0)
 ; MERGE1: US11019 Merge a single domain
"RTN","HMPMETA",46,0)
 ; MERGE: Merge metastamp data into XTMP, mark domain complete
"RTN","HMPMETA",47,0)
 ; METAPT: MetaStamp for patient data
"RTN","HMPMETA",48,0)
 ; METAOP: MetaStamp for operational data
"RTN","HMPMETA",49,0)
 ; STATUS: Set HMP GLOBAL USAGE MONITOR status
"RTN","HMPMETA",50,0)
 ; SET: Flag set/reset, Stamptime set
"RTN","HMPMETA",51,0)
 ; CHECK: Check status, send HMP GLOBAL USAGE MONITOR message
"RTN","HMPMETA",52,0)
 ; MESNOK: e-mail if space limit on ^xtmp breached
"RTN","HMPMETA",53,0)
 ; MESOK: e-mail if space limit on ^xtmp breached
"RTN","HMPMETA",54,0)
 ; EN: Build XTMP for patient
"RTN","HMPMETA",55,0)
 ; QUINIT: Queue the initial extracts for a patient
"RTN","HMPMETA",56,0)
 ; UNSUB: Unsubscribe
"RTN","HMPMETA",57,0)
 ;
"RTN","HMPMETA",58,0)
 ;
"RTN","HMPMETA",59,0)
 ; New routine for US6734
"RTN","HMPMETA",60,0)
 ;
"RTN","HMPMETA",61,0)
 ;
"RTN","HMPMETA",62,0)
 ;
"RTN","HMPMETA",63,0)
ADD(HMPDMNM,HMPUID,HMPSTMP) ; Build array for metastamp - called from HMPDJ0* routines
"RTN","HMPMETA",64,0)
 I ($G(HMPUID)="")!($G(HMPDMNM)="") Q
"RTN","HMPMETA",65,0)
 ;For quick orders the JDS domain is 'qo'
"RTN","HMPMETA",66,0)
 S:HMPDMNM="quick" HMPDMNM="qo"
"RTN","HMPMETA",67,0)
 S ^TMP("HMPMETA",$J,HMPDMNM,HMPUID)=HMPSTMP
"RTN","HMPMETA",68,0)
 ;unit tests use following nodes
"RTN","HMPMETA",69,0)
 S ^TMP("HMPMETA",$J,HMPDMNM)=$G(^TMP("HMPMETA",$J,HMPDMNM))+1
"RTN","HMPMETA",70,0)
 S ^TMP("HMPMETA",$J,"PATIENT")=$G(^TMP("HMPMETA",$J,"PATIENT"))+1
"RTN","HMPMETA",71,0)
 Q
"RTN","HMPMETA",72,0)
 ;
"RTN","HMPMETA",73,0)
 ;
"RTN","HMPMETA",74,0)
DONE(HMPFDFN,HMPBATCH) ; Check if metastamp compile is complete
"RTN","HMPMETA",75,0)
 ;For patients this will always be true since all patient domains compiled by one task
"RTN","HMPMETA",76,0)
 Q:+$G(HMPFDFN) 1
"RTN","HMPMETA",77,0)
 ;For OPD requires to check that all domain compiles are completed
"RTN","HMPMETA",78,0)
 N HMPDOM,HMPCOMP
"RTN","HMPMETA",79,0)
 S HMPDOM="",HMPCOMP=1 F  S HMPDOM=$O(^XTMP(HMPBATCH,0,"MSTA",HMPDOM)) Q:HMPDOM=""  D  Q:'HMPCOMP
"RTN","HMPMETA",80,0)
 .S:$G(^XTMP(HMPBATCH,0,"MSTA",HMPDOM))=0 HMPCOMP=0
"RTN","HMPMETA",81,0)
 Q HMPCOMP
"RTN","HMPMETA",82,0)
 ;
"RTN","HMPMETA",83,0)
 ;
"RTN","HMPMETA",84,0)
OPD(HMPFHMP) ;Check if OPD metastamp is ready to collect
"RTN","HMPMETA",85,0)
 Q $S($$DONE("OPD","HMPFX~"_HMPFHMP_"~OPD"):1,1:0)
"RTN","HMPMETA",86,0)
 ;
"RTN","HMPMETA",87,0)
 ;
"RTN","HMPMETA",88,0)
INIT(HMPBATCH,HMPFDFN,ARGS) ; Set metastamp status as in progress
"RTN","HMPMETA",89,0)
 N DOMAINS
"RTN","HMPMETA",90,0)
 ; set up domains to extract
"RTN","HMPMETA",91,0)
 D @($S(HMPFDFN="OPD":"OPDOMS",1:"PTDOMS")_"^HMPDJFSD(.DOMAINS)")
"RTN","HMPMETA",92,0)
 I $G(ARGS("domains"))'="" D
"RTN","HMPMETA",93,0)
 . S I=""
"RTN","HMPMETA",94,0)
 . F I=1:1 Q:'$D(DOMAINS(I))  D
"RTN","HMPMETA",95,0)
 .. I ARGS("domains")'[DOMAINS(I) K DOMAINS(I)
"RTN","HMPMETA",96,0)
 N HMPDOM,I
"RTN","HMPMETA",97,0)
 F I=1:1 S HMPDOM=$G(DOMAINS(I)) Q:HMPDOM=""  S ^XTMP(HMPBATCH,0,"MSTA",HMPDOM)=0
"RTN","HMPMETA",98,0)
 Q
"RTN","HMPMETA",99,0)
 ;
"RTN","HMPMETA",100,0)
 ;
"RTN","HMPMETA",101,0)
UPD(HMPDOM) ; Update metastamp domain as complete
"RTN","HMPMETA",102,0)
 S ^XTMP(HMPBATCH,0,"MSTA",HMPDOM)=1
"RTN","HMPMETA",103,0)
 Q
"RTN","HMPMETA",104,0)
 ;
"RTN","HMPMETA",105,0)
 ;
"RTN","HMPMETA",106,0)
MERGE1(HMPBATCH,HMPDOM) ; US11019 Merge a single domain
"RTN","HMPMETA",107,0)
 M ^XTMP(HMPBATCH,0,"META",HMPDOM)=^TMP("HMPMETA",$J,HMPDOM)
"RTN","HMPMETA",108,0)
 K ^TMP("HMPMETA",$J,HMPDOM)
"RTN","HMPMETA",109,0)
 Q
"RTN","HMPMETA",110,0)
 ;
"RTN","HMPMETA",111,0)
 ;
"RTN","HMPMETA",112,0)
MERGE(HMPBATCH) ; Merge metastamp data into XTMP and mark domain complete in metastamp
"RTN","HMPMETA",113,0)
 ;Formatting of metastamp into JSON format by HMPMETA goes here when ready
"RTN","HMPMETA",114,0)
 N HMPDOM
"RTN","HMPMETA",115,0)
 S HMPDOM="PATIENT"
"RTN","HMPMETA",116,0)
 F  S HMPDOM=$O(^TMP("HMPMETA",$J,HMPDOM)) Q:HMPDOM=""  D
"RTN","HMPMETA",117,0)
 .M ^XTMP(HMPBATCH,0,"META",HMPDOM)=^TMP("HMPMETA",$J,HMPDOM)
"RTN","HMPMETA",118,0)
 K ^TMP("HMPMETA",$J)
"RTN","HMPMETA",119,0)
 Q
"RTN","HMPMETA",120,0)
 ;
"RTN","HMPMETA",121,0)
 ;
"RTN","HMPMETA",122,0)
METAPT(A,HMPCDOM) ; MetaStamp for patient data (within its own syncStart chunk).;US11019 added second parameter
"RTN","HMPMETA",123,0)
 ; --Input parameter
"RTN","HMPMETA",124,0)
 ; A = "^^HMPFX~hmp-development-box~"<DFN> (e.g. ^^HMPFX~hmp-development-box~3)
"RTN","HMPMETA",125,0)
 ; HMPCDOM = Single domain US11019
"RTN","HMPMETA",126,0)
 ;
"RTN","HMPMETA",127,0)
 ; --Expects
"RTN","HMPMETA",128,0)
 ; DOMSIZE,OFFSET,HMPFCNT ;US11019 comment added not variables
"RTN","HMPMETA",129,0)
 ;
"RTN","HMPMETA",130,0)
 ; --Local variables
"RTN","HMPMETA",131,0)
 ; HMPA = "HMPFX~hmp-development-box~"<DFN>
"RTN","HMPMETA",132,0)
 ; HMPB = ZTASK# --> ^XTMP(HMPA,<ZTASK#>
"RTN","HMPMETA",133,0)
 ; HMPC = Domain (e.g. "allergy") --> ^XTMP(HMPA,HMPB,<Domain>
"RTN","HMPMETA",134,0)
 ; HMPD = Counter (sequential number) --> ^XTMP(HMPA,HMPB,HMPC,<Counter>
"RTN","HMPMETA",135,0)
 ; HMPN = Subscript --> ^XTMP(HMPA,HMPB,HMPC,HMPD,<Subscript>
"RTN","HMPMETA",136,0)
 ; HMPE = ^XTMP(HMPA,HMPB,HMPC,HMPD,HMPN)
"RTN","HMPMETA",137,0)
 ; HMPF = Domain id (e.g. the "C877:3:751" part of "urn:va:allergy:C877:3:751"
"RTN","HMPMETA",138,0)
 ; HMPID = pid --> <site-hash>;DFN (e.g. C877;3)
"RTN","HMPMETA",139,0)
 ; HMPZ1 = DFN
"RTN","HMPMETA",140,0)
 ; HMPP = $$PIDS^HMPDJFS(HMPZ1)  --> JSON construct containing pid, systemId, localId, icn
"RTN","HMPMETA",141,0)
 ; HMPQ = " (double quote literal)
"RTN","HMPMETA",142,0)
 ; HMPT = The "total" node from ^XTMP --> ^XTMP(HMPA,HMPB,HMPC,"total")
"RTN","HMPMETA",143,0)
 ; HMPX = JSON construct for the entire metaStamp
"RTN","HMPMETA",144,0)
 ; HMPW = Event timeStamp
"RTN","HMPMETA",145,0)
 ; HMPY = $$EN^HMPSTMP("NOW")
"RTN","HMPMETA",146,0)
 ; HMPZ = Counter for breaking up the large nodes into sub-nodes in ^TMP
"RTN","HMPMETA",147,0)
 ;
"RTN","HMPMETA",148,0)
 I '$D(U) S U="^"
"RTN","HMPMETA",149,0)
 N HMPA,HMPB,HMPC,HMPC1,HMPD,HMPE,HMPF,HMPID,HMPM,HMPN
"RTN","HMPMETA",150,0)
 N HMPP,HMPQ,HMPT,HMPW,HMPX,HMPY,HMPZ,HMPZ1
"RTN","HMPMETA",151,0)
 S HMPA=$P(A,U,3),HMPB=$O(^XTMP(HMPA,0)),HMPZ1=$P(HMPA,"~",3)
"RTN","HMPMETA",152,0)
 S HMPE="",HMPQ="""",HMPZ=0 ;US11019
"RTN","HMPMETA",153,0)
 S HMPC=$G(HMPCDOM) ;US11019
"RTN","HMPMETA",154,0)
 S HMPP=$$PIDS^HMPDJFS(HMPZ1)
"RTN","HMPMETA",155,0)
 S HMPY=$$EN^HMPSTMP("NOW")
"RTN","HMPMETA",156,0)
 S HMPX=",""metaStamp"":"_"{""icn"":"""_$$GETICN^MPIF001(HMPZ1)_""""_","
"RTN","HMPMETA",157,0)
 S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_",""sourceMetaStamp"":"_"{"
"RTN","HMPMETA",158,0)
 S HMPID=$TR($P($P(HMPP,"pid",2),","),""":")
"RTN","HMPMETA",159,0)
 S HMPX=HMPX_""""_$P(HMPID,";")_""""_":{"
"RTN","HMPMETA",160,0)
 S HMPX=HMPX_"""pid"":"""_HMPID_""""_","
"RTN","HMPMETA",161,0)
 S HMPX=HMPX_"""localId"":"""_$P(HMPID,";",2)_""""_","
"RTN","HMPMETA",162,0)
 S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_","
"RTN","HMPMETA",163,0)
 S HMPX=HMPX_"""domainMetaStamp"""_":"_"{"
"RTN","HMPMETA",164,0)
 ;Scan Domains
"RTN","HMPMETA",165,0)
 D:HMPC'=""  I HMPC="" F  S HMPC=$O(^XTMP(HMPA,0,"META",HMPC)) Q:HMPC']""  D  ;US11019 allow process by single domain
"RTN","HMPMETA",166,0)
 .S HMPX=HMPX_""""_HMPC_""""_":{"
"RTN","HMPMETA",167,0)
 .S HMPX=HMPX_"""domain"":"""_HMPC_""""_","
"RTN","HMPMETA",168,0)
 .S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_","
"RTN","HMPMETA",169,0)
 .S HMPD=0
"RTN","HMPMETA",170,0)
 .S HMPX=HMPX_"""eventMetaStamp"""_":"_"{" ; Patient data
"RTN","HMPMETA",171,0)
 .N HMPU,HMPS S HMPU=""
"RTN","HMPMETA",172,0)
 .I $O(^XTMP(HMPA,0,"META",HMPC,HMPU))="" S HMPX=HMPX_"}" ;US11019 - cater for zero entries
"RTN","HMPMETA",173,0)
 .F  S HMPU=$O(^XTMP(HMPA,0,"META",HMPC,HMPU)) Q:HMPU']""  D
"RTN","HMPMETA",174,0)
 ..N VAR0,VAR1
"RTN","HMPMETA",175,0)
 ..S HMPS=$G(^XTMP(HMPA,0,"META",HMPC,HMPU)),VAR0=$P(HMPU,":",3),VAR1=$P(HMPU,":",4,99)
"RTN","HMPMETA",176,0)
 ..I $L(HMPX)>20000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX,HMPX=""
"RTN","HMPMETA",177,0)
 ..S HMPX=HMPX_"""urn:va:"_VAR0_":"_VAR1_""""_":{"
"RTN","HMPMETA",178,0)
 ..S HMPX=HMPX_"""stampTime"":"""_HMPS_""""_"}"
"RTN","HMPMETA",179,0)
 ..S HMPX=HMPX_$S($O(^XTMP(HMPA,0,"META",HMPC,HMPU))="":"}",1:",")
"RTN","HMPMETA",180,0)
 .S HMPX=HMPX_"},"
"RTN","HMPMETA",181,0)
 .I $L(HMPX)>20000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX,HMPX=""
"RTN","HMPMETA",182,0)
 I HMPZ!($L(HMPX)>0) D  ;DE3759 avoid multiple edge case
"RTN","HMPMETA",183,0)
 .I $L(HMPX)=0 S HMPX=^TMP("HMPF",$J,HMPFCNT,.3,HMPZ),^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=$E(HMPX,1,$L(HMPX)-1),HMPX="" ;DE3759
"RTN","HMPMETA",184,0)
 I $L(HMPX)>0 D
"RTN","HMPMETA",185,0)
 .S HMPZ=HMPZ+1
"RTN","HMPMETA",186,0)
 .S HMPX=$E(HMPX,1,$L(HMPX)-1)_"}}}}" D
"RTN","HMPMETA",187,0)
 ..I $E(HMPX,$L(HMPX))="{" S HMPX=HMPX_"""seq"":"_OFFSET_",""total"":"_DOMSIZE
"RTN","HMPMETA",188,0)
 ..E  S HMPX=HMPX_",""seq"":"_OFFSET_",""total"":"_DOMSIZE
"RTN","HMPMETA",189,0)
 .S HMPX=HMPX_",""object"":"
"RTN","HMPMETA",190,0)
 .S ^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX
"RTN","HMPMETA",191,0)
 Q
"RTN","HMPMETA",192,0)
 ;
"RTN","HMPMETA",193,0)
 ;
"RTN","HMPMETA",194,0)
METAOP(A) ; MetaStamp for operational data (within its own syncStart chunk)
"RTN","HMPMETA",195,0)
 ; A = HMPFX~hmp-development-box~OPD
"RTN","HMPMETA",196,0)
 ; --Local variables
"RTN","HMPMETA",197,0)
 ; HMPA = "HMPFX~hmp-development-box~"<DFN>
"RTN","HMPMETA",198,0)
 ; HMPB = ZTASK# --> ^XTMP(HMPA,<ZTASK#>
"RTN","HMPMETA",199,0)
 ; HMPC = Domain (e.g. "allergy") --> ^XTMP(HMPA,HMPB,<Domain>
"RTN","HMPMETA",200,0)
 ; HMPD = Counter (sequential number) --> ^XTMP(HMPA,HMPB,HMPC,<Counter>
"RTN","HMPMETA",201,0)
 ; HMPN = Subscript --> ^XTMP(HMPA,HMPB,HMPC,HMPD,<Subscript>
"RTN","HMPMETA",202,0)
 ; HMPE = ^XTMP(HMPA,HMPB,HMPC,HMPD,HMPN)
"RTN","HMPMETA",203,0)
 ; HMPF = Domain id (e.g. the "C877:3:751" part of "urn:va:allergy:C877:3:751"
"RTN","HMPMETA",204,0)
 ; HMPID = pid --> <site-hash>;DFN (e.g. C877;3)
"RTN","HMPMETA",205,0)
 ; HMPZ1 = DFN
"RTN","HMPMETA",206,0)
 ; HMPP = $$PIDS^HMPDJFS(HMPZ1)  --> JSON construct containing pid, systemId, localId, icn
"RTN","HMPMETA",207,0)
 ; HMPQ = " (double quote literal)
"RTN","HMPMETA",208,0)
 ; HMPT = The "total" node from ^XTMP --> ^XTMP(HMPA,HMPB,HMPC,"total")
"RTN","HMPMETA",209,0)
 ; HMPX = JSON construct for the entire metaStamp
"RTN","HMPMETA",210,0)
 ; HMPW = Event timeStamp
"RTN","HMPMETA",211,0)
 ; HMPY = $$EN^HMPSTMP("NOW")
"RTN","HMPMETA",212,0)
 ; HMPZ = Counter for breaking up the large nodes into sub-nodes in ^TMP
"RTN","HMPMETA",213,0)
 ;
"RTN","HMPMETA",214,0)
 I '$D(U) S U="^"
"RTN","HMPMETA",215,0)
 N HMPA,HMPJ,HMPQ,HMPSEP,HMPZ,HMPDAT,HMPDAT1,HMPDOM,HMPDOM1,HMPEVT,HMPX,HMPTOT,HMPTSK,HMPMOR,HMPLAS,HMPMOR,HMPLAS
"RTN","HMPMETA",216,0)
 S HMPA=$P(A,U,3),HMPQ="""",HMPZ=0,HMPSEP=","""
"RTN","HMPMETA",217,0)
 S HMPCNT=$G(HMPCNT)+1,HMPJ=$P(HMPA,"~",1,2)_"~OPD"
"RTN","HMPMETA",218,0)
 S HMPSEP=HMPQ
"RTN","HMPMETA",219,0)
 S HMPTSK=$O(^XTMP(A,0)),HMPY=$$EN^HMPSTMP("NOW"),HMPID=$$SYS^HMPUTILS
"RTN","HMPMETA",220,0)
 S HMPX="{""collection"":"""_"OPDsyncStart"_""""_","
"RTN","HMPMETA",221,0)
 S HMPX=HMPX_"""metaStamp"":"_"{"
"RTN","HMPMETA",222,0)
 S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_",""sourceMetaStamp"":"_"{"
"RTN","HMPMETA",223,0)
 S HMPX=HMPX_""""_$P(HMPID,";")_""""_":{"
"RTN","HMPMETA",224,0)
 S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_","
"RTN","HMPMETA",225,0)
 S HMPX=HMPX_"""domainMetaStamp"""_":"_"{"
"RTN","HMPMETA",226,0)
 ;Scan Domains
"RTN","HMPMETA",227,0)
 S HMPC=""
"RTN","HMPMETA",228,0)
 F  S HMPC=$O(^XTMP(HMPA,0,"META",HMPC)) Q:HMPC']""  D
"RTN","HMPMETA",229,0)
 .S HMPX=HMPX_""""_HMPC_""""_":{"
"RTN","HMPMETA",230,0)
 .S HMPX=HMPX_"""domain"":"""_HMPC_""""_","
"RTN","HMPMETA",231,0)
 .S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_","
"RTN","HMPMETA",232,0)
 .S HMPD=0
"RTN","HMPMETA",233,0)
 .S HMPX=HMPX_"""itemMetaStamp"""_":"_"{" ; Patient data
"RTN","HMPMETA",234,0)
 .N HMPU,HMPS S HMPU=""
"RTN","HMPMETA",235,0)
 .F  S HMPU=$O(^XTMP(HMPA,0,"META",HMPC,HMPU)) Q:HMPU']""  D
"RTN","HMPMETA",236,0)
 ..N VAR0,VAR1
"RTN","HMPMETA",237,0)
 ..S HMPS=$G(^XTMP(HMPA,0,"META",HMPC,HMPU)),VAR0=$P(HMPU,":",3),VAR1=$P(HMPU,":",4,99)
"RTN","HMPMETA",238,0)
 ..I $L(HMPX)>20000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX,HMPX=""
"RTN","HMPMETA",239,0)
 ..S HMPX=HMPX_"""urn:va:"_VAR0_":"_VAR1_""""_":{"
"RTN","HMPMETA",240,0)
 ..S HMPX=HMPX_"""stampTime"":"""_HMPS_""""_"}"
"RTN","HMPMETA",241,0)
 ..S HMPX=HMPX_$S($O(^XTMP(HMPA,0,"META",HMPC,HMPU))="":"}",1:",")
"RTN","HMPMETA",242,0)
 .S HMPX=HMPX_"},"
"RTN","HMPMETA",243,0)
 .I $L(HMPX)>20000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX,HMPX=""
"RTN","HMPMETA",244,0)
 I HMPZ!($L(HMPX)>0) D  ;DE3759 avoid multiple edge case
"RTN","HMPMETA",245,0)
 .I $L(HMPX)=0 S HMPX=^TMP("HMPF",$J,HMPFCNT,.3,HMPZ),^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=$E(HMPX,1,$L(HMPX)-1),HMPX="" ;DE3759
"RTN","HMPMETA",246,0)
 .S HMPZ=HMPZ+1
"RTN","HMPMETA",247,0)
 .S HMPX=$E(HMPX,1,$L(HMPX)-1)_"}}}}},{"
"RTN","HMPMETA",248,0)
 .S ^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX
"RTN","HMPMETA",249,0)
 Q
"RTN","HMPMETA",250,0)
 ;
"RTN","HMPMETA",251,0)
 ;
"RTN","HMPMETA",252,0)
STATUS(STOP,HMPFHMP) ; Set HMP GLOBAL USAGE MONITOR status
"RTN","HMPMETA",253,0)
 Q:$G(STOP)=""  Q:$G(HMPFHMP)=""
"RTN","HMPMETA",254,0)
 N HMPFLG,HMPSTMP,HMPSRV
"RTN","HMPMETA",255,0)
 S HMPSRV=$O(^HMP(800000,"B",HMPFHMP,"")) Q:'HMPSRV
"RTN","HMPMETA",256,0)
 S HMPFLG=$P($G(^HMP(800000,HMPSRV,0)),U,5),HMPSTMP=$P($G(^HMP(800000,HMPSRV,0)),U,6)
"RTN","HMPMETA",257,0)
 ;If stopped and already flagged as stopped do nothing
"RTN","HMPMETA",258,0)
 I STOP,HMPFLG Q
"RTN","HMPMETA",259,0)
 ;If stopped but not flagged as stopped set flag and timestamp
"RTN","HMPMETA",260,0)
 I STOP,'HMPFLG D SET(STOP,HMPSRV) Q
"RTN","HMPMETA",261,0)
 ;If running and flagged as stopped flag as running
"RTN","HMPMETA",262,0)
 I 'STOP,HMPFLG D SET(STOP,HMPSRV) Q
"RTN","HMPMETA",263,0)
 ;No action needed if running and not flagged as stop
"RTN","HMPMETA",264,0)
 Q
"RTN","HMPMETA",265,0)
 ;
"RTN","HMPMETA",266,0)
 ;
"RTN","HMPMETA",267,0)
SET(STOP,HMPSRV) ; Flag set/reset, Stamptime set
"RTN","HMPMETA",268,0)
 Q:'$G(HMPSRV)
"RTN","HMPMETA",269,0)
 L +^HMP(800000,HMPSRV,0):5 E  Q
"RTN","HMPMETA",270,0)
 S $P(^HMP(800000,HMPSRV,0),U,5,6)=STOP_U_$$NOW^XLFDT
"RTN","HMPMETA",271,0)
 L -^HMP(800000,HMPSRV,0)
"RTN","HMPMETA",272,0)
 Q
"RTN","HMPMETA",273,0)
 ;
"RTN","HMPMETA",274,0)
 ;
"RTN","HMPMETA",275,0)
CHECK(HMPFHMP) ; Check status and send HMP GLOBAL USAGE MONITOR message if appropriate
"RTN","HMPMETA",276,0)
 ; Input HMPFHMP - server name
"RTN","HMPMETA",277,0)
 Q:$G(HMPFHMP)=""
"RTN","HMPMETA",278,0)
 N HMPFLG,HMPSTMP,HMPDIFF,HMPSRV
"RTN","HMPMETA",279,0)
 S HMPSRV=$O(^HMP(800000,"B",HMPFHMP,"")) Q:'HMPSRV
"RTN","HMPMETA",280,0)
 S HMPFLG=$P($G(^HMP(800000,HMPSRV,0)),U,5)
"RTN","HMPMETA",281,0)
 ;No action required if status is not set
"RTN","HMPMETA",282,0)
 I HMPFLG="" Q
"RTN","HMPMETA",283,0)
 ;Get stamptime
"RTN","HMPMETA",284,0)
 S HMPSTMP=$P($G(^HMP(800000,HMPSRV,0)),U,6) Q:HMPSTMP=""
"RTN","HMPMETA",285,0)
 ;If stamptime < five minutes ago no action
"RTN","HMPMETA",286,0)
 I $$FMDIFF^XLFDT($$NOW^XLFDT,HMPSTMP,2)<300 Q
"RTN","HMPMETA",287,0)
 ;Otherwise send message
"RTN","HMPMETA",288,0)
 D:HMPFLG MESNOK
"RTN","HMPMETA",289,0)
 D:'HMPFLG MESOK
"RTN","HMPMETA",290,0)
 ;Clear DISK USAGE STATUS and DISK USAGE STATUS TIME in subscription file
"RTN","HMPMETA",291,0)
 L +^HMP(800000,HMPSRV,0):5 E  Q
"RTN","HMPMETA",292,0)
 S $P(^HMP(800000,HMPSRV,0),U,5,6)=""
"RTN","HMPMETA",293,0)
 L -^HMP(800000,HMPSRV,0):5
"RTN","HMPMETA",294,0)
 Q
"RTN","HMPMETA",295,0)
 ;
"RTN","HMPMETA",296,0)
 ;
"RTN","HMPMETA",297,0)
MESNOK ; e-mail if space limit on ^xtmp breached
"RTN","HMPMETA",298,0)
 ;islc/pjh,ven/toad;private;procedure;clean;silent;sac
"RTN","HMPMETA",299,0)
 ; called by:
"RTN","HMPMETA",300,0)
 ;   CHECK
"RTN","HMPMETA",301,0)
 ; calls:
"RTN","HMPMETA",302,0)
 ;   $$GETSIZE^HMPMONX = size of ehmp's usage of ^xtmp
"RTN","HMPMETA",303,0)
 ;   $$GETMAX^HMPDJFSP = max size of that usage allowed
"RTN","HMPMETA",304,0)
 ;   $$NOW^XLFDT = current date-time in fileman format
"RTN","HMPMETA",305,0)
 ;   $$FMTE^XLFDT = convert fileman date-time to external
"RTN","HMPMETA",306,0)
 ;   SENDMSG^XMXAPI: send e-mail
"RTN","HMPMETA",307,0)
 ; input:
"RTN","HMPMETA",308,0)
 ;   from the database, within $$GETSIZE & $$GETMAX
"RTN","HMPMETA",309,0)
 ; output:
"RTN","HMPMETA",310,0)
 ;  e-mail created & sent to g.HMP IRM GROUP
"RTN","HMPMETA",311,0)
 ; examples:
"RTN","HMPMETA",312,0)
 ;   [develop examples]
"RTN","HMPMETA",313,0)
 ; to do:
"RTN","HMPMETA",314,0)
 ;   convert this message and the one in MESOK to bulletins
"RTN","HMPMETA",315,0)
 ;
"RTN","HMPMETA",316,0)
 new HMPUSER set HMPUSER=.5 ; send as postmaster
"RTN","HMPMETA",317,0)
 set HMPUSER(0)="@" ; with programmer privileges
"RTN","HMPMETA",318,0)
 new SUBJECT set SUBJECT="HMP GLOBAL USAGE MONITOR"
"RTN","HMPMETA",319,0)
 ;
"RTN","HMPMETA",320,0)
 new TEXT set TEXT="HMPTEXT"
"RTN","HMPMETA",321,0)
 new HMPTEXT
"RTN","HMPMETA",322,0)
 do
"RTN","HMPMETA",323,0)
 . ; estimated usage of ^xtmp:
"RTN","HMPMETA",324,0)
 . new SIZE set SIZE=$justify($piece($$GETSIZE^HMPMONX,",")/1000000,2,2)
"RTN","HMPMETA",325,0)
 . ; maximum usage allowed:
"RTN","HMPMETA",326,0)
 . new MAX set MAX=$justify($$GETMAX^HMPDJFSP/1000000,2,2)
"RTN","HMPMETA",327,0)
 . set HMPTEXT(1)="Alert: eHMP usage of global ^XTMP has exceeded "
"RTN","HMPMETA",328,0)
 . set HMPTEXT(1)=HMPTEXT(1)_MAX_" MB for more than 5 minutes."
"RTN","HMPMETA",329,0)
 . set HMPTEXT(2)=" "
"RTN","HMPMETA",330,0)
 . set HMPTEXT(3)="       eHMP subscribing is paused."
"RTN","HMPMETA",331,0)
 . set HMPTEXT(4)=" "
"RTN","HMPMETA",332,0)
 . set HMPTEXT(5)="       eHMP usage of global ^XTMP is "_SIZE_" MB."
"RTN","HMPMETA",333,0)
 . set HMPTEXT(6)=" "
"RTN","HMPMETA",334,0)
 . set HMPTEXT(7)="       Disk space check at "_$$FMTE^XLFDT($$NOW^XLFDT)
"RTN","HMPMETA",335,0)
 . set HMPTEXT(8)=" "
"RTN","HMPMETA",336,0)
 . quit
"RTN","HMPMETA",337,0)
 ;
"RTN","HMPMETA",338,0)
 new HMPRECIP set HMPRECIP("HMP IRM GROUP")=""
"RTN","HMPMETA",339,0)
 new HMPMSG
"RTN","HMPMETA",340,0)
 ;
"RTN","HMPMETA",341,0)
 do SENDMSG^XMXAPI(.HMPUSER,SUBJECT,TEXT,.HMPRECIP,,.HMPMSG)
"RTN","HMPMETA",342,0)
 ;
"RTN","HMPMETA",343,0)
 quit  ; end of MESNOK
"RTN","HMPMETA",344,0)
 ;
"RTN","HMPMETA",345,0)
 ;
"RTN","HMPMETA",346,0)
MESOK ; e-mail if space limit on ^xtmp breached
"RTN","HMPMETA",347,0)
 ;islc/pjh,ven/toad;private;procedure;clean;silent;sac
"RTN","HMPMETA",348,0)
 ; called by:
"RTN","HMPMETA",349,0)
 ;   CHECK
"RTN","HMPMETA",350,0)
 ; calls:
"RTN","HMPMETA",351,0)
 ;   $$GETMAX^HMPDJFSP = max size of that usage allowed
"RTN","HMPMETA",352,0)
 ;   $$NOW^XLFDT = current date-time in fileman format
"RTN","HMPMETA",353,0)
 ;   $$FMTE^XLFDT = convert fileman date-time to external
"RTN","HMPMETA",354,0)
 ;   SENDMSG^XMXAPI: send e-mail
"RTN","HMPMETA",355,0)
 ; input:
"RTN","HMPMETA",356,0)
 ;   from the database, within $$GETMAX
"RTN","HMPMETA",357,0)
 ; output:
"RTN","HMPMETA",358,0)
 ;  e-mail created & sent to g.HMP IRM GROUP
"RTN","HMPMETA",359,0)
 ; examples:
"RTN","HMPMETA",360,0)
 ;   [develop examples]
"RTN","HMPMETA",361,0)
 ; to do:
"RTN","HMPMETA",362,0)
 ;   convert this message and the one in MESNOK to bulletins
"RTN","HMPMETA",363,0)
 ;
"RTN","HMPMETA",364,0)
 new HMPUSER set HMPUSER=.5 ; send as postmaster
"RTN","HMPMETA",365,0)
 set HMPUSER(0)="@" ; with programmer privileges
"RTN","HMPMETA",366,0)
 new SUBJECT set SUBJECT="HMP GLOBAL USAGE MONITOR"
"RTN","HMPMETA",367,0)
 ;
"RTN","HMPMETA",368,0)
 new TEXT set TEXT="HMPTEXT"
"RTN","HMPMETA",369,0)
 new HMPTEXT
"RTN","HMPMETA",370,0)
 do
"RTN","HMPMETA",371,0)
 . ; maximum usage allowed:
"RTN","HMPMETA",372,0)
 . new MAX set MAX=$justify($$GETMAX^HMPDJFSP/1000000,2,2)
"RTN","HMPMETA",373,0)
 . set HMPTEXT(1)="Alert: eHMP usage of global ^XTMP has been below "
"RTN","HMPMETA",374,0)
 . set HMPTEXT(1)=HMPTEXT(1)_MAX_" MB for more than 5 minutes."
"RTN","HMPMETA",375,0)
 . set HMPTEXT(2)=" "
"RTN","HMPMETA",376,0)
 . set HMPTEXT(3)="       eHMP subscribing is restarted."
"RTN","HMPMETA",377,0)
 . set HMPTEXT(4)=" "
"RTN","HMPMETA",378,0)
 . set HMPTEXT(7)="       Disk space check at "_$$FMTE^XLFDT($$NOW^XLFDT)
"RTN","HMPMETA",379,0)
 . set HMPTEXT(8)=" "
"RTN","HMPMETA",380,0)
 . quit
"RTN","HMPMETA",381,0)
 ;
"RTN","HMPMETA",382,0)
 new HMPRECIP set HMPRECIP("HMP IRM GROUP")=""
"RTN","HMPMETA",383,0)
 new HMPMSG
"RTN","HMPMETA",384,0)
 ;
"RTN","HMPMETA",385,0)
 do SENDMSG^XMXAPI(.HMPUSER,SUBJECT,TEXT,.HMPRECIP,,.HMPMSG)
"RTN","HMPMETA",386,0)
 ;
"RTN","HMPMETA",387,0)
 quit  ; end of MESOK
"RTN","HMPMETA",388,0)
 ;
"RTN","HMPMETA",389,0)
 ;
"RTN","HMPMETA",390,0)
 ;Following tags used by VPRJTT0 unit test routines
"RTN","HMPMETA",391,0)
 ;-------------------------------------------------
"RTN","HMPMETA",392,0)
EN(HMPFDFN) ;Build XTMP for patient
"RTN","HMPMETA",393,0)
 I $G(HMPFDFN)="" D MES^XPDUTL("No patient specified, call as D EN^HMPMETA(DFN)") Q
"RTN","HMPMETA",394,0)
 N ARGS,DOMAINS,HMPSRV,NEWSUB,HMPFERR,HMPBATCH,HMPSTMP,SEQNODE,ZTSK,ZTQUEUED
"RTN","HMPMETA",395,0)
 ;Select domains to compile
"RTN","HMPMETA",396,0)
 ;OPD domains
"RTN","HMPMETA",397,0)
 ;asu-class#asu-rule#category#charttab#displaygroup#doc-def#labgroup#labpanel#location#orderable#page#pt-select#
"RTN","HMPMETA",398,0)
 ;personphoto#pointofcare#quick#roster#route#schedule#team#teamposition#user#usertabprefs#viewdefdef#
"RTN","HMPMETA",399,0)
 ;viewdefdefcoldefconfigtemplate#immunization-list#allergy-list#signssymptoms-list#vitaltypes-list#
"RTN","HMPMETA",400,0)
 ;vitalqualifier-list#vitalcategory-list
"RTN","HMPMETA",401,0)
 ;Patient domains
"RTN","HMPMETA",402,0)
 ;allergy#vital#problem#order#treatment#patient#consult#procedure#obs#visit#appointment#ptf#med#lab#
"RTN","HMPMETA",403,0)
 ;image#surgery#document#mh#
"RTN","HMPMETA",404,0)
 ;Patient PCE domains
"RTN","HMPMETA",405,0)
 ;auxiliary#diagnosis#factor#immunization#task#vital#exam#cpt#education#pov#skin
"RTN","HMPMETA",406,0)
 ;S ARGS("domains")="allergy#asu-class"
"RTN","HMPMETA",407,0)
 ;
"RTN","HMPMETA",408,0)
 ;Modify SEQNODE to extract required patient
"RTN","HMPMETA",409,0)
 S SEQNODE=HMPFDFN_"^syncStart^HMPFX~hmp-development-box~"_HMPFDFN_"^^64671"
"RTN","HMPMETA",410,0)
 S HMPBATCH=$P(SEQNODE,U,3),HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPMETA",411,0)
 S HMPSRV("ien")=$O(^HMP(800000,"B",HMPSRV,0)) Q:'HMPSRV("ien")
"RTN","HMPMETA",412,0)
 ;Unsubscribe patient and clear cache
"RTN","HMPMETA",413,0)
 D UNSUB(HMPFDFN,HMPSRV("ien")) K ^XTMP(HMPBATCH)
"RTN","HMPMETA",414,0)
 ;Clear metastamp array
"RTN","HMPMETA",415,0)
 K ^TMP("HMPMETA",$J)
"RTN","HMPMETA",416,0)
 ; set up domains to extract
"RTN","HMPMETA",417,0)
 D @($S(HMPFDFN="OPD":"OPDOMS",1:"PTDOMS")_"^HMPDJFSD(.DOMAINS)")
"RTN","HMPMETA",418,0)
 ;Clear unwanted domains
"RTN","HMPMETA",419,0)
 I $G(ARGS("domains"))'="" N I F I=1:1 Q:'$D(DOMAINS(I))  K:ARGS("domains")'[DOMAINS(I) DOMAINS(I)
"RTN","HMPMETA",420,0)
 ;
"RTN","HMPMETA",421,0)
 ; see if this is new subscription and task extract if new
"RTN","HMPMETA",422,0)
 D SETPAT^HMPDJFSP(HMPFDFN,HMPSRV,.NEWSUB) Q:$G(HMPFERR) ""
"RTN","HMPMETA",423,0)
 ;For operational data set stamptime as time subscription placed
"RTN","HMPMETA",424,0)
 S:HMPFDFN="OPD" HMPSTMP=$$JSONDT^HMPUTILS($$NOW^XLFDT)
"RTN","HMPMETA",425,0)
 I NEWSUB D  Q:$G(HMPFERR) ""
"RTN","HMPMETA",426,0)
 . I HMPFDFN="OPD" D  ; queue each operational domain
"RTN","HMPMETA",427,0)
 . . S I="" F  S I=$O(DOMAINS(I)) Q:'I  D
"RTN","HMPMETA",428,0)
 . . . N HMPFDOM
"RTN","HMPMETA",429,0)
 . . . S HMPFDOM(1)=DOMAINS(I)
"RTN","HMPMETA",430,0)
 . . . D QUINIT(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPMETA",431,0)
 . E  D  ; queue all domains for patient
"RTN","HMPMETA",432,0)
 . . N HMPFDOM
"RTN","HMPMETA",433,0)
 . . M HMPFDOM=DOMAINS
"RTN","HMPMETA",434,0)
 . . ; if patients extracts are held (version mismatch), put DFN on wait list
"RTN","HMPMETA",435,0)
 . . I $G(^XTMP("HMPFS~"_HMPSRV("ien"),"waiting")) S ^XTMP("HMPFS~"_HMPSRV("ien"),"waiting",HMPFDFN)="" QUIT
"RTN","HMPMETA",436,0)
 . . ; otherwise queue patient
"RTN","HMPMETA",437,0)
 . . D QUINIT(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPMETA",438,0)
 Q
"RTN","HMPMETA",439,0)
 ;
"RTN","HMPMETA",440,0)
 ;
"RTN","HMPMETA",441,0)
QUINIT(HMPBATCH,HMPFDFN,HMPFDOM) ; Queue the initial extracts for a patient
"RTN","HMPMETA",442,0)
 ; HMPBATCH="HMPFX~hmpsrvid~dfn"  example: HMPFX~hmpXYZ~229
"RTN","HMPMETA",443,0)
 ; HMPFDOM(n)="domainName"
"RTN","HMPMETA",444,0)
 ;
"RTN","HMPMETA",445,0)
 ; ^XTMP("HMPFX~hmpsrvid~dfn",0)=expires^created^HMP Patient Extract
"RTN","HMPMETA",446,0)
 ;                           ,0,"status",domain)=0:waiting;1:ready
"RTN","HMPMETA",447,0)
 ;                           ,0,"task",taskIen)=""
"RTN","HMPMETA",448,0)
 ;                           ,taskIen,domain,... (extract data)
"RTN","HMPMETA",449,0)
 ;
"RTN","HMPMETA",450,0)
 ; only done once when beginning the batch, no matter how many tasked jobs
"RTN","HMPMETA",451,0)
 L +^XTMP(HMPBATCH):5 E  D SETERR^HMPDJFS("Cannot lock batch:"_HMPBATCH) QUIT
"RTN","HMPMETA",452,0)
 I '$D(^XTMP(HMPBATCH)) D
"RTN","HMPMETA",453,0)
 . D NEWXTMP^HMPDJFS(HMPBATCH,2,"HMP Patient Extract")
"RTN","HMPMETA",454,0)
 . I $G(ARGS("jobId"))]"" S ^XTMP(HMPBATCH,"JOBID")=ARGS("jobId")  ;US3907
"RTN","HMPMETA",455,0)
 . I $G(ARGS("rootJobId"))]"" S ^XTMP(HMPBATCH,"ROOTJOBID")=ARGS("rootJobId")  ;US3907
"RTN","HMPMETA",456,0)
 . S ^XTMP(HMPBATCH,0,"time")=$H
"RTN","HMPMETA",457,0)
 . D SETMARK^HMPDJFSP("Start",HMPFDFN,HMPBATCH) ; sends full demographics
"RTN","HMPMETA",458,0)
 L -^XTMP(HMPBATCH)
"RTN","HMPMETA",459,0)
 ;
"RTN","HMPMETA",460,0)
 ; set up the domains to be done by this task
"RTN","HMPMETA",461,0)
 N I S I=0 F  S I=$O(HMPFDOM(I)) Q:'I  D SETDOM^HMPDJFSP("status",HMPFDOM(I),0)
"RTN","HMPMETA",462,0)
 ;
"RTN","HMPMETA",463,0)
 ;Call compile in foreground
"RTN","HMPMETA",464,0)
 S ZTSK=$J,^XTMP(HMPBATCH,0,"task",ZTSK)=$H,ZTQUEUED="1" D DQINIT^HMPDJFSQ U 0
"RTN","HMPMETA",465,0)
 Q
"RTN","HMPMETA",466,0)
 ;
"RTN","HMPMETA",467,0)
 ;
"RTN","HMPMETA",468,0)
UNSUB(DFN,SRV) ;Unsubscribe
"RTN","HMPMETA",469,0)
 ;Operational Data subscription
"RTN","HMPMETA",470,0)
 I DFN="OPD" D UPDOPD^HMPDJFSP(SRV,"@") Q
"RTN","HMPMETA",471,0)
 ;Patient subscription
"RTN","HMPMETA",472,0)
 N DA,DIK
"RTN","HMPMETA",473,0)
 S DA=DFN,DA(1)=SRV
"RTN","HMPMETA",474,0)
 S DIK="^HMP(800000,"_DA(1)_",1,"
"RTN","HMPMETA",475,0)
 D ^DIK
"RTN","HMPMETA",476,0)
 Q
"RTN","HMPMETA",477,0)
 ;
"RTN","HMPMETA",478,0)
 ;
"RTN","HMPMETA",479,0)
EOR ; end of routine HMPMETA
"RTN","HMPMON")
0^26^B33479508
"RTN","HMPMON",1,0)
HMPMON ;asmr-ven/zag&toad-option hmpmon dashboard ;Aug 25, 2016 21:17:38
"RTN","HMPMON",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMON",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMON",4,0)
 ;
"RTN","HMPMON",5,0)
 Q  ; no entry from top
"RTN","HMPMON",6,0)
 ;DE6526 - routine refactored, August 25, 2016
"RTN","HMPMON",7,0)
 ;
"RTN","HMPMON",8,0)
 ; HMPMON is the main routine for the eHMP Dashboard
"RTN","HMPMON",9,0)
 ; OPTION^HMPMON is the MenuMan entry point for option HMPMON DASHBOARD. 
"RTN","HMPMON",10,0)
 ; All other HMPMON* routines are invoked directly or indirectly from this routine;
"RTN","HMPMON",11,0)
 ; PROMPT^HMPMONA issues the action prompts throughout the Dashboard.
"RTN","HMPMON",12,0)
 ;
"RTN","HMPMON",13,0)
OPTION ; option eHMP Dashboard [HMPMON DASHBOARD]
"RTN","HMPMON",14,0)
 ;
"RTN","HMPMON",15,0)
 D HOME^%ZIS  ; set IO* variables
"RTN","HMPMON",16,0)
 ;
"RTN","HMPMON",17,0)
 N CALL,HMPACT,HMPNEWP,HMPRATE,HMPROMPT,HMPSRVR,HMPSUB
"RTN","HMPMON",18,0)
 ; line tag/routine to call
"RTN","HMPMON",19,0)
 ; HMPACT - user-selected action
"RTN","HMPMON",20,0)
 ; HMPNEWP - new prompt, indicates changing actions
"RTN","HMPMON",21,0)
 S HMPROMPT="DASH" ; Dashboard Action Prompt
"RTN","HMPMON",22,0)
 S HMPRATE=$$RATE^HMPMONC ; auto-update rate
"RTN","HMPMON",23,0)
 ;
"RTN","HMPMON",24,0)
 S HMPSRVR=$$GETSRVR^HMPMONM ; subscription server
"RTN","HMPMON",25,0)
 ; if there are NO subscriptions, display help and issue end-of-page prompt
"RTN","HMPMON",26,0)
 I 'HMPSRVR D NOSRVR^HMPMONM  Q
"RTN","HMPMON",27,0)
 ;
"RTN","HMPMON",28,0)
 N HMPEOP,USERCALL
"RTN","HMPMON",29,0)
 F  Q:HMPROMPT=U  D  ; option's main loop
"RTN","HMPMON",30,0)
 . S HMPSUB=$$GETSUB^HMPMONM(HMPSRVR) ; zero node from HMP SUBSCRIPTION
"RTN","HMPMON",31,0)
 . ; 1. run prompt's initial action
"RTN","HMPMON",32,0)
 . D  Q:HMPROMPT=U  ; if time-out or ^-escape from end-of-pages
"RTN","HMPMON",33,0)
 ..  S HMPACT=$$FIRST(HMPROMPT) ; get initial action
"RTN","HMPMON",34,0)
 ..  D FORMFEED^HMPMONL ; clear screen for initial action
"RTN","HMPMON",35,0)
 ..  S CALL=$$CALL(HMPACT) ; action's subroutine call
"RTN","HMPMON",36,0)
 ..  D @CALL ; perform initial action
"RTN","HMPMON",37,0)
 . ; 2. prompt user to select action
"RTN","HMPMON",38,0)
 . S HMPACT="" D PROMPT^HMPMONA(.HMPACT,HMPROMPT) ; prompt user for next action
"RTN","HMPMON",39,0)
 . Q:$E(HMPACT)="U"  ; update = initial action
"RTN","HMPMON",40,0)
 . ; 3. if action changes to a new prompt, do it
"RTN","HMPMON",41,0)
 . S HMPNEWP=$$NEWPRMPT(HMPACT) ; changing prompts?
"RTN","HMPMON",42,0)
 . I HMPNEWP'="" S HMPROMPT=HMPNEWP Q  ; change to new prompt and quit
"RTN","HMPMON",43,0)
 . ; 4. otherwise, perform user-selected action
"RTN","HMPMON",44,0)
 . S HMPEOP=1 ; default to prompting for end of page
"RTN","HMPMON",45,0)
 . S USERCALL=$$CALL(HMPACT) ; action's subroutine call
"RTN","HMPMON",46,0)
 . D @USERCALL ; perform user-selected action
"RTN","HMPMON",47,0)
 . ; 5. and prompt for end of page after action
"RTN","HMPMON",48,0)
 . D ENDPAGE^HMPMONL:HMPEOP
"RTN","HMPMON",49,0)
 ;
"RTN","HMPMON",50,0)
 Q
"RTN","HMPMON",51,0)
 ;
"RTN","HMPMON",52,0)
 ;
"RTN","HMPMON",53,0)
CALL(HMPACT) ; function, action's subroutine call
"RTN","HMPMON",54,0)
 ; called by:
"RTN","HMPMON",55,0)
 ;   OPTION
"RTN","HMPMON",56,0)
 ; input:
"RTN","HMPMON",57,0)
 ;   HMPACT = code for action (e.g., "ES")
"RTN","HMPMON",58,0)
 ; output = "" or label (eg "RATE") or entryref (eg "U^HMPMOND")
"RTN","HMPMON",59,0)
 ; examples:
"RTN","HMPMON",60,0)
 ;   $$CALL = ""
"RTN","HMPMON",61,0)
 ;   $$CALL("BD") = ""
"RTN","HMPMON",62,0)
 ;   $$CALL("ES") = "ES^HMPMONS"
"RTN","HMPMON",63,0)
 ;   $$CALL("M") = "DIFSUB"
"RTN","HMPMON",64,0)
 ;   $$CALL("NONSENSE") = ""
"RTN","HMPMON",65,0)
 ;
"RTN","HMPMON",66,0)
 ;A few actions call no subroutines to perform the action, most do. 
"RTN","HMPMON",67,0)
 ;Returns "" if the action does not call a subroutine or a line tag with optional routine.
"RTN","HMPMON",68,0)
 ;
"RTN","HMPMON",69,0)
 S HMPACT=$G(HMPACT,"U")  ; default to Update
"RTN","HMPMON",70,0)
 I $$CALLS'[(U_HMPACT_U) Q ""  ; not a calling action
"RTN","HMPMON",71,0)
 ;
"RTN","HMPMON",72,0)
 N ACTREC S ACTREC=$T(@HMPACT)  ; action's record
"RTN","HMPMON",73,0)
 Q $P(ACTREC,";",5)  ; return action's subroutine call
"RTN","HMPMON",74,0)
 ;
"RTN","HMPMON",75,0)
 ;
"RTN","HMPMON",76,0)
NEWPRMPT(HMPACT) ;function, action's new prompt
"RTN","HMPMON",77,0)
 ; called by:
"RTN","HMPMON",78,0)
 ;   OPTION
"RTN","HMPMON",79,0)
 ; calls: none
"RTN","HMPMON",80,0)
 ; input:
"RTN","HMPMON",81,0)
 ;   HMPACT = code for action (e.g., "ES")
"RTN","HMPMON",82,0)
 ; output = "" or DASH or ERR or HIST or SYNC or ^
"RTN","HMPMON",83,0)
 ; examples:
"RTN","HMPMON",84,0)
 ;   $$NEWPRMPT = ""
"RTN","HMPMON",85,0)
 ;   $$NEWPRMPT("U") = ""
"RTN","HMPMON",86,0)
 ;   $$NEWPRMPT("S") = "SYNC"
"RTN","HMPMON",87,0)
 ;   $$NEWPRMPT("BD") = "DASH"
"RTN","HMPMON",88,0)
 ;   $$NEWPRMPT("Q") = "^"
"RTN","HMPMON",89,0)
 ;   $$NEWPRMPT("NONSENSE") = ""
"RTN","HMPMON",90,0)
 ;
"RTN","HMPMON",91,0)
 ;Most actions leave the user on the same prompt selected, a few change prompts. 
"RTN","HMPMON",92,0)
 ;returns "" if action doesn't change prompts, name of the prompt if it does, or "^" if action exits the dashboard
"RTN","HMPMON",93,0)
 ;
"RTN","HMPMON",94,0)
 S HMPACT=$G(HMPACT,"U") ; default to Update
"RTN","HMPMON",95,0)
 Q:$$CHANGES'[(U_HMPACT_U) ""  ; not a prompt-changing action
"RTN","HMPMON",96,0)
 ;
"RTN","HMPMON",97,0)
 N ACTREC S ACTREC=$T(@HMPACT) ; action's record
"RTN","HMPMON",98,0)
 Q $P(ACTREC,";",4) ; return new prompt
"RTN","HMPMON",99,0)
 ;
"RTN","HMPMON",100,0)
 ;
"RTN","HMPMON",101,0)
FIRST(HMPROMPT) ; prompt's initial action
"RTN","HMPMON",102,0)
 ; called by:
"RTN","HMPMON",103,0)
 ;   OPTION
"RTN","HMPMON",104,0)
 ; calls: none
"RTN","HMPMON",105,0)
 ; input:
"RTN","HMPMON",106,0)
 ;   HMPROMPT = DASH or ERR or HIST or SYNC, default to DASH
"RTN","HMPMON",107,0)
 ; output = code for prompt's initial action
"RTN","HMPMON",108,0)
 ; examples:
"RTN","HMPMON",109,0)
 ;   $$FIRST = "U"
"RTN","HMPMON",110,0)
 ;   $$FIRST("ERR") = "UE"
"RTN","HMPMON",111,0)
 ;   $$FIRST("NONSENSE") = ""
"RTN","HMPMON",112,0)
 ;
"RTN","HMPMON",113,0)
 S HMPROMPT=$G(HMPROMPT,"DASH") ; default to dashboard
"RTN","HMPMON",114,0)
 Q:$$PROMPTS'[(U_HMPROMPT_U) "" ; no action for undefined prompt
"RTN","HMPMON",115,0)
 ;
"RTN","HMPMON",116,0)
 N ACTION,DEFREC,DEFREF
"RTN","HMPMON",117,0)
 S DEFREF=HMPROMPT_"DEF" ; default's reference
"RTN","HMPMON",118,0)
 S DEFREC=$T(@DEFREF) ; default's record
"RTN","HMPMON",119,0)
 S ACTION=$P(DEFREC,";",3) ; default action (& first)
"RTN","HMPMON",120,0)
 ;
"RTN","HMPMON",121,0)
 Q ACTION ; return prompt's initial action ; end of $$FIRST
"RTN","HMPMON",122,0)
 ;
"RTN","HMPMON",123,0)
PROMPTS() ;
"RTN","HMPMON",124,0)
 Q "^DASH^SYNC^ERR^HIST^UNIT^"
"RTN","HMPMON",125,0)
 ;
"RTN","HMPMON",126,0)
ACTIONS() ;
"RTN","HMPMON",127,0)
 Q "^U^V^J^S^E^H^C^M^Q^US^ES^PS^RS^BD^UE^E2^E3^E4^E5^UH^EH^MH^UU^"
"RTN","HMPMON",128,0)
 ;
"RTN","HMPMON",129,0)
CALLS() ;
"RTN","HMPMON",130,0)
 Q "^U^V^J^C^M^US^ES^PS^RS^UE^E2^E3^E4^E5^UH^EH^MH^UU^"
"RTN","HMPMON",131,0)
 ;
"RTN","HMPMON",132,0)
CHANGES() ;
"RTN","HMPMON",133,0)
 Q "^S^E^H^Q^BD^"
"RTN","HMPMON",134,0)
 ;
"RTN","HMPMON",135,0)
DASH ;;HMP MON DASH ACTION;Select Dashboard Action
"RTN","HMPMON",136,0)
DASHHELP ;;^D DASHHELP^HMPMONDH
"RTN","HMPMON",137,0)
DASHDEF ;;U
"RTN","HMPMON",138,0)
DASHCODE ;;9
"RTN","HMPMON",139,0)
U ;;U:Update Dashboard;;U^HMPMOND
"RTN","HMPMON",140,0)
V ;;V:View HMP Nodes;;V^HMPMONV
"RTN","HMPMON",141,0)
J ;;J:Job Listing;;J^HMPMONJ
"RTN","HMPMON",142,0)
S ;;S:Sync Processes;SYNC;
"RTN","HMPMON",143,0)
E ;;E:Errors;ERR;
"RTN","HMPMON",144,0)
H ;;H:History;HIST;
"RTN","HMPMON",145,0)
C ;;C:Change Auto-update Rate;;C^HMPMONC
"RTN","HMPMON",146,0)
M ;;M:Monitor a Different Server;;M^HMPMONM
"RTN","HMPMON",147,0)
Q ;;Q:Quit;^;
"RTN","HMPMON",148,0)
 ;
"RTN","HMPMON",149,0)
SYNC ;;HMP MON SYNC ACTION;Select Sync-process Action
"RTN","HMPMON",150,0)
SYNCHELP ;;^do SYNCHELP^HMPMONSH
"RTN","HMPMON",151,0)
SYNCDEF ;;US
"RTN","HMPMON",152,0)
SYNCCODE ;;5
"RTN","HMPMON",153,0)
US ;;US:Update Sync-process Screen;;US^HMPMONS
"RTN","HMPMON",154,0)
ES ;;ES:Examine Sync Process;;ES^HMPMONS
"RTN","HMPMON",155,0)
PS ;;PS:Park Sync Process;;PS^HMPMONS
"RTN","HMPMON",156,0)
RS ;;RS:Restart Sync Process;;RS^HMPMONS
"RTN","HMPMON",157,0)
BD ;;BD:Back to Dashboard;DASH;
"RTN","HMPMON",158,0)
 ;
"RTN","HMPMON",159,0)
ERR ;;HMP MON ERR ACTION;Select Error Action
"RTN","HMPMON",160,0)
ERRHELP ;;^do ERRHELP^HMPMONEH
"RTN","HMPMON",161,0)
ERRDEF ;;UE
"RTN","HMPMON",162,0)
ERRCODE ;;8
"RTN","HMPMON",163,0)
UE ;;UE:Update Error Screen;;UE^HMPMONE
"RTN","HMPMON",164,0)
E2 ;;E2:Examine XTMP Error Log;;E2^HMPMONE
"RTN","HMPMON",165,0)
E3 ;;E3:Examine HMPERR Error Log;;E3^HMPMONE
"RTN","HMPMON",166,0)
E4 ;;E4:Examine HMPFERR Error Log;;E4^HMPMONE
"RTN","HMPMON",167,0)
E5 ;;E5:Examine HMP ERROR Error Log;;E5^HMPMONE
"RTN","HMPMON",168,0)
 ;;BD:Back to Dashboard;DASH;
"RTN","HMPMON",169,0)
 ;
"RTN","HMPMON",170,0)
 ;ME ;;ME:Manage Error Log;;ME^HMPMONE   ; removed
"RTN","HMPMON",171,0)
 ;
"RTN","HMPMON",172,0)
HIST ;;HMP MON HIST ACTION;Select History Action
"RTN","HMPMON",173,0)
HISTHELP ;;^D HISTHELP^HMPMONHH
"RTN","HMPMON",174,0)
HISTDEF ;;UH
"RTN","HMPMON",175,0)
HISTCODE ;;4
"RTN","HMPMON",176,0)
UH ;;UH:Update History Screen;;UH^HMPMONH
"RTN","HMPMON",177,0)
EH ;;EH:Examine History;;EH^HMPMONH
"RTN","HMPMON",178,0)
MH ;;MH:Manage History;;MH^HMPMONH
"RTN","HMPMON",179,0)
 ;;BD:Back to Dashboard;DASH;
"RTN","HMPMON",180,0)
 ;
"RTN","HMPMONA")
0^62^B32852666
"RTN","HMPMONA",1,0)
HMPMONA ;asmr-ven/toad-dashboard: action prompts ;Aug 25, 2016 21:17:38
"RTN","HMPMONA",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONA",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONA",4,0)
 ;
"RTN","HMPMONA",5,0)
 Q  ; no entry from top
"RTN","HMPMONA",6,0)
 ;DE6526 - routine refactored, August 25, 2016
"RTN","HMPMONA",7,0)
 ;
"RTN","HMPMONA",8,0)
 ; PROMPT^HMPMONA issues the action prompts throughout the eHMP
"RTN","HMPMONA",9,0)
 ; Dashboard. It is invoked by HMPMON, which is the main routine forthe eHMP Dashboard.
"RTN","HMPMONA",10,0)
 ;
"RTN","HMPMONA",11,0)
PROMPT(HMPACT,HMPROMPT) ; general action prompt
"RTN","HMPMONA",12,0)
 ; called by:
"RTN","HMPMONA",13,0)
 ;   OPTION
"RTN","HMPMONA",14,0)
 ; calls:
"RTN","HMPMONA",15,0)
 ;   $$PROMPTS^HMPMON = Dashboard's five main prompts
"RTN","HMPMONA",16,0)
 ;   $$CODES = prompt's set-of-codes definition
"RTN","HMPMONA",17,0)
 ;   $$TEXT = prompt's text
"RTN","HMPMONA",18,0)
 ;   $$DEFAULT = prompt's default action
"RTN","HMPMONA",19,0)
 ;   $$HELP = prompt's extended ?? help
"RTN","HMPMONA",20,0)
 ;   EN^DDIOL: write to screen or output to an array
"RTN","HMPMONA",21,0)
 ;   READ^HMPMONR: input from prompt or array, to issue action prompt
"RTN","HMPMONA",22,0)
 ; input:
"RTN","HMPMONA",23,0)
 ;   HMPROMPT = DASH or ERR or HIST or SYNC, default to DASH
"RTN","HMPMONA",24,0)
 ; output:
"RTN","HMPMONA",25,0)
 ;  HMPACT = Q to exit ehmp dashboard
"RTN","HMPMONA",26,0)
 ;         = U? to update current screen
"RTN","HMPMONA",27,0)
 ;         = S or E or H to switch prompts from dashboard prompt
"RTN","HMPMONA",28,0)
 ;         = BD to return to dashboard prompt
"RTN","HMPMONA",29,0)
 ;         = other action to do & remain at current prompt
"RTN","HMPMONA",30,0)
 ; examples:
"RTN","HMPMONA",31,0)
 ;   PROMPT(.action):
"RTN","HMPMONA",32,0)
 ;      Dashboard Action Prompt issued to user
"RTN","HMPMONA",33,0)
 ;      action = valid dashboard action code user selects (e.g., "U")
"RTN","HMPMONA",34,0)
 ;   PROMPT(.action,"ERR"):
"RTN","HMPMONA",35,0)
 ;      Error Action Prompt issued to user
"RTN","HMPMONA",36,0)
 ;      action = valid error action code user selects (e.g., "E3")
"RTN","HMPMONA",37,0)
 ;   PROMPT(.action,"SYNC"):
"RTN","HMPMONA",38,0)
 ;      Sync-process Action Prompt issued to user
"RTN","HMPMONA",39,0)
 ;      if user enters ^ or ^^
"RTN","HMPMONA",40,0)
 ;      action = "Q"
"RTN","HMPMONA",41,0)
 ;   PROMPT(.action,"HIST"):
"RTN","HMPMONA",42,0)
 ;      History Action Prompt issued to user
"RTN","HMPMONA",43,0)
 ;      if user times out
"RTN","HMPMONA",44,0)
 ;      action = "Q"
"RTN","HMPMONA",45,0)
 ;   PROMPT(.action,"NONSENSE"):
"RTN","HMPMONA",46,0)
 ;      no prompt issued to user
"RTN","HMPMONA",47,0)
 ;      action = "Q"
"RTN","HMPMONA",48,0)
 ;
"RTN","HMPMONA",49,0)
 S HMPACT="Q" ; default to exiting ehmp dashboard
"RTN","HMPMONA",50,0)
 S HMPROMPT=$G(HMPROMPT,"DASH") ; default to dashboard
"RTN","HMPMONA",51,0)
 Q:$$PROMPTS^HMPMON'[(U_HMPROMPT_U)  ; can't issue undefined prompt
"RTN","HMPMONA",52,0)
 ;
"RTN","HMPMONA",53,0)
 N DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HMPMONA",54,0)
 S DIR(0)=$$CODES(HMPROMPT) ; set-of-codes
"RTN","HMPMONA",55,0)
 S DIR("A")=$$TEXT(HMPROMPT) ; prompt text
"RTN","HMPMONA",56,0)
 S DIR("B")=$$DEFAULT(HMPROMPT) ; prompt default (refresh or return)
"RTN","HMPMONA",57,0)
 S X=$$HELP(HMPROMPT) ; prompt extended ?? help specification
"RTN","HMPMONA",58,0)
 S:$L(X) DIR("??")=X  ; only if help set up
"RTN","HMPMONA",59,0)
 S DIR("T")=HMPRATE ; set timeout to control auto-refresh rate
"RTN","HMPMONA",60,0)
 ;
"RTN","HMPMONA",61,0)
 D EN^DDIOL("",,"!") ; blank line for readability
"RTN","HMPMONA",62,0)
 D ^DIR
"RTN","HMPMONA",63,0)
 ;
"RTN","HMPMONA",64,0)
 S:$D(DTOUT) Y=DIR("B")  ; for action prompts, timeout = default, creates auto-update
"RTN","HMPMONA",65,0)
 ;
"RTN","HMPMONA",66,0)
 I $D(DUOUT)!$D(DIROUT) S HMPACT="Q" Q  ; timeout or '^', exit
"RTN","HMPMONA",67,0)
 S HMPACT=Y  ; action selected by user
"RTN","HMPMONA",68,0)
 ;
"RTN","HMPMONA",69,0)
 Q
"RTN","HMPMONA",70,0)
 ;
"RTN","HMPMONA",71,0)
 ;
"RTN","HMPMONA",72,0)
CODES(HMPROMPT) ; prompt's set of codes
"RTN","HMPMONA",73,0)
 ; called by:
"RTN","HMPMONA",74,0)
 ;   PROMPT
"RTN","HMPMONA",75,0)
 ; calls:
"RTN","HMPMONA",76,0)
 ;   $$PROMPTS^HMPMON = Dashboard's five main prompts
"RTN","HMPMONA",77,0)
 ;   $T(@(HMPROMPT_"CODE")^HMPMON) ; prompt record's header line
"RTN","HMPMONA",78,0)
 ;   $$CODE = code definition
"RTN","HMPMONA",79,0)
 ; input:
"RTN","HMPMONA",80,0)
 ;   HMPROMPT = DASH or ERR or HIST or SYNC, default to DASH
"RTN","HMPMONA",81,0)
 ; output = set-of-codes definition for prompt
"RTN","HMPMONA",82,0)
 ; examples:
"RTN","HMPMONA",83,0)
 ;   $$CODES = "SB^U:Update;V:View HMP Nodes;S:Sync Processes;E:E..."
"RTN","HMPMONA",84,0)
 ;   $$CODES("HIST") = "SB^UH:Update History;EH:Examine History;M..."
"RTN","HMPMONA",85,0)
 ;   $$CODES("NONSENSE") = ""
"RTN","HMPMONA",86,0)
 ;
"RTN","HMPMONA",87,0)
 set HMPROMPT=$G(HMPROMPT,"DASH") ; default to dashboard
"RTN","HMPMONA",88,0)
 Q:$$PROMPTS^HMPMON'[(U_HMPROMPT_U) "" ; undefined prompt, no set
"RTN","HMPMONA",89,0)
 ;
"RTN","HMPMONA",90,0)
 new CODETAG set CODETAG=HMPROMPT_"CODE" ; label for code definitions
"RTN","HMPMONA",91,0)
 new HEADER set HEADER=$T(@CODETAG^HMPMON) ; prompt record's header
"RTN","HMPMONA",92,0)
 new TOTAL set TOTAL=$P(HEADER,";;",2) ; # codes
"RTN","HMPMONA",93,0)
 ;
"RTN","HMPMONA",94,0)
 new CODES set CODES=$$CODE(HMPROMPT) ; start w/ first code definition
"RTN","HMPMONA",95,0)
 new COUNT ; count definitions
"RTN","HMPMONA",96,0)
 F COUNT=2:1:TOTAL S CODES=CODES_";"_$$CODE(HMPROMPT,COUNT) ; append each code
"RTN","HMPMONA",97,0)
 ;
"RTN","HMPMONA",98,0)
 Q "SB^"_CODES ; return set of codes
"RTN","HMPMONA",99,0)
 ;
"RTN","HMPMONA",100,0)
 ;
"RTN","HMPMONA",101,0)
CODE(HMPROMPT,IEN) ; code definition
"RTN","HMPMONA",102,0)
 ; called by:
"RTN","HMPMONA",103,0)
 ;   $$CODES
"RTN","HMPMONA",104,0)
 ; calls:
"RTN","HMPMONA",105,0)
 ;   $$PROMPTS^HMPMON = Dashboard's five main prompts
"RTN","HMPMONA",106,0)
 ;   $T(@(HMPROMPT_"CODE")+IEN^HMPMON) = code's subentry
"RTN","HMPMONA",107,0)
 ; input:
"RTN","HMPMONA",108,0)
 ;   HMPROMPT = DASH or ERR or HIST or SYNC, default to DASH
"RTN","HMPMONA",109,0)
 ;   IEN = sequence # of a code definition, defaults to 1
"RTN","HMPMONA",110,0)
 ; output = that code definition
"RTN","HMPMONA",111,0)
 ; examples:
"RTN","HMPMONA",112,0)
 ;   $$CODE = "U:Update"
"RTN","HMPMONA",113,0)
 ;   $$CODE("HIST") = "EH:Examine History"
"RTN","HMPMONA",114,0)
 ;   $$CODE("SYNC",2) = "PS:Park Sync Process"
"RTN","HMPMONA",115,0)
 ;   $$CODE("ERR",42) = ""
"RTN","HMPMONA",116,0)
 ;   $$CODE("NONSENSE") = ""
"RTN","HMPMONA",117,0)
 ;
"RTN","HMPMONA",118,0)
 S HMPROMPT=$G(HMPROMPT,"DASH") ; default to dashboard
"RTN","HMPMONA",119,0)
 Q:$$PROMPTS^HMPMON'[(U_HMPROMPT_U) "" ; unknown prompt, no code
"RTN","HMPMONA",120,0)
 S IEN=$G(IEN,1) ; default to code #1
"RTN","HMPMONA",121,0)
 ;
"RTN","HMPMONA",122,0)
 N CODE,CODETAG,SUBENTRY
"RTN","HMPMONA",123,0)
 S CODETAG=HMPROMPT_"CODE"  ; line tag for code definitions
"RTN","HMPMONA",124,0)
 S SUBENTRY=$T(@CODETAG+IEN^HMPMON)  ; code subentry
"RTN","HMPMONA",125,0)
 S CODE=$P(SUBENTRY,";",3)  ; code definition
"RTN","HMPMONA",126,0)
 ;
"RTN","HMPMONA",127,0)
 Q CODE  ; return code definition
"RTN","HMPMONA",128,0)
 ;
"RTN","HMPMONA",129,0)
 ;
"RTN","HMPMONA",130,0)
TEXT(HMPROMPT) ; prompt text
"RTN","HMPMONA",131,0)
 ; called by:
"RTN","HMPMONA",132,0)
 ;   PROMPT
"RTN","HMPMONA",133,0)
 ; calls:
"RTN","HMPMONA",134,0)
 ;   $$PROMPTS^HMPMON = Dashboard's five main prompts
"RTN","HMPMONA",135,0)
 ;   $T(@HMPROMPT^HMPMON) = prompt record's header line
"RTN","HMPMONA",136,0)
 ; input:
"RTN","HMPMONA",137,0)
 ;   HMPROMPT = DASH or ERR or HIST or SYNC, default to DASH
"RTN","HMPMONA",138,0)
 ; output = text to insert in prompt text
"RTN","HMPMONA",139,0)
 ; examples:
"RTN","HMPMONA",140,0)
 ;   $$TEXT = "Dashboard"
"RTN","HMPMONA",141,0)
 ;   $$TEXT("HIST") = "History"
"RTN","HMPMONA",142,0)
 ;   $$TEXT("NONSENSE") = ""
"RTN","HMPMONA",143,0)
 ;
"RTN","HMPMONA",144,0)
 S HMPROMPT=$G(HMPROMPT,"DASH") ; default to dashboard
"RTN","HMPMONA",145,0)
 Q:$$PROMPTS^HMPMON'[(U_HMPROMPT_U) "" ; undefined prompt, no text
"RTN","HMPMONA",146,0)
 ;
"RTN","HMPMONA",147,0)
 N HEADER,TEXT
"RTN","HMPMONA",148,0)
 S HEADER=$T(@HMPROMPT^HMPMON) ; prompt's header line
"RTN","HMPMONA",149,0)
 S TEXT=$P(HEADER,";",4) ; prompt text
"RTN","HMPMONA",150,0)
 ;
"RTN","HMPMONA",151,0)
 Q TEXT  ; return prompt text
"RTN","HMPMONA",152,0)
 ;
"RTN","HMPMONA",153,0)
 ;
"RTN","HMPMONA",154,0)
DEFAULT(HMPROMPT) ; prompt default
"RTN","HMPMONA",155,0)
 ; called by:
"RTN","HMPMONA",156,0)
 ;   PROMPT
"RTN","HMPMONA",157,0)
 ; calls:
"RTN","HMPMONA",158,0)
 ;   $$PROMPTS^HMPMON = Dashboard's five main prompts
"RTN","HMPMONA",159,0)
 ;   $T(@(HMPROMPT_"DEF")^HMPMON) ; default's pointer record
"RTN","HMPMONA",160,0)
 ;   $T(@DEFTXT^HMPMON) ; default's $text
"RTN","HMPMONA",161,0)
 ; input:
"RTN","HMPMONA",162,0)
 ;   HMPROMPT = DASH or ERR or HIST or SYNC, default to DASH
"RTN","HMPMONA",163,0)
 ; output = text of prompt's default action
"RTN","HMPMONA",164,0)
 ; examples:
"RTN","HMPMONA",165,0)
 ;   $$DEFAULT = "Update Dashboard"
"RTN","HMPMONA",166,0)
 ;   $$DEFAULT("ERR") = "Update Error Screen"
"RTN","HMPMONA",167,0)
 ;   $$DEFAULT("NONSENSE") = ""
"RTN","HMPMONA",168,0)
 ;
"RTN","HMPMONA",169,0)
 S HMPROMPT=$G(HMPROMPT,"DASH") ; default to dashboard
"RTN","HMPMONA",170,0)
 Q:$$PROMPTS^HMPMON'[(U_HMPROMPT_U) "" ; undefined prompt, no def
"RTN","HMPMONA",171,0)
 ;
"RTN","HMPMONA",172,0)
 N DEFPREC,DEFTXT,DFLTAG
"RTN","HMPMONA",173,0)
 S DFLTAG=HMPROMPT_"DEF" ; default's $text reference
"RTN","HMPMONA",174,0)
 S DEFPREC=$T(@DFLTAG^HMPMON) ; default's $text from HMPMONM
"RTN","HMPMONA",175,0)
 S DEFTXT=$P(DEFPREC,";",3) ; default's $text
"RTN","HMPMONA",176,0)
 ;
"RTN","HMPMONA",177,0)
 new DEFREC set DEFREC=$T(@DEFTXT^HMPMON) ; default's record
"RTN","HMPMONA",178,0)
 new DEFDEF set DEFDEF=$P(DEFREC,";",3) ; default's definition
"RTN","HMPMONA",179,0)
 new DEFAULT set DEFAULT=$P(DEFDEF,":",2) ; prompt's default
"RTN","HMPMONA",180,0)
 ;
"RTN","HMPMONA",181,0)
 Q DEFAULT ; return prompt default
"RTN","HMPMONA",182,0)
 ;
"RTN","HMPMONA",183,0)
 ;
"RTN","HMPMONA",184,0)
HELP(HMPROMPT) ; function, prompt for extended ?? help
"RTN","HMPMONA",185,0)
 ; called by:
"RTN","HMPMONA",186,0)
 ;   PROMPT
"RTN","HMPMONA",187,0)
 ; calls:
"RTN","HMPMONA",188,0)
 ;   $$PROMPTS^HMPMON = Dashboard's five main prompts
"RTN","HMPMONA",189,0)
 ;   $T(@(HMPROMPT_"HELP")^HMPMON) ; help's pointer record
"RTN","HMPMONA",190,0)
 ; input:
"RTN","HMPMONA",191,0)
 ;   HMPROMPT = DASH or ERR or HIST or SYNC, default to DASH
"RTN","HMPMONA",192,0)
 ; output = routine extended ?? help
"RTN","HMPMONA",193,0)
 ; examples:
"RTN","HMPMONA",194,0)
 ;   $$TEXT = "^D DASHHELP^HMPMONDH"
"RTN","HMPMONA",195,0)
 ;   $$TEXT("HIST") = ""
"RTN","HMPMONA",196,0)
 ;   $$TEXT("NONSENSE") = ""
"RTN","HMPMONA",197,0)
 ;
"RTN","HMPMONA",198,0)
 S HMPROMPT=$G(HMPROMPT,"DASH") ; default to dashboard
"RTN","HMPMONA",199,0)
 Q:$$PROMPTS^HMPMON'[(U_HMPROMPT_U) ""  ; unknown prompt, no help
"RTN","HMPMONA",200,0)
 ;
"RTN","HMPMONA",201,0)
 N DFLTAG,HELP,HLPLTAG
"RTN","HMPMONA",202,0)
 S DFLTAG=HMPROMPT_"HELP" ; help's default line tag
"RTN","HMPMONA",203,0)
 S HLPLTAG=$T(@DFLTAG^HMPMON)  ; help line tag
"RTN","HMPMONA",204,0)
 S HELP=$P(HLPLTAG,";;",2)  ; ?? help specification
"RTN","HMPMONA",205,0)
 ;
"RTN","HMPMONA",206,0)
 Q HELP ; return prompt for extended "??" help
"RTN","HMPMONA",207,0)
 ;
"RTN","HMPMONC")
0^27^B19385564
"RTN","HMPMONC",1,0)
HMPMONC ;asmr-ven/toad-dashboard: auto-update rate ;2016-06-29 13:57Z
"RTN","HMPMONC",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONC",4,0)
 ;
"RTN","HMPMONC",5,0)
 quit  ; no entry from top of routine HMPMONC
"RTN","HMPMONC",6,0)
 ;
"RTN","HMPMONC",7,0)
 ; primary development
"RTN","HMPMONC",8,0)
 ;
"RTN","HMPMONC",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONC",10,0)
 ; original author: Raymond Hsu (hsu)
"RTN","HMPMONC",11,0)
 ; original org: U.S. Department of Veterans Affairs (va)
"RTN","HMPMONC",12,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONC",13,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONC",14,0)
 ;
"RTN","HMPMONC",15,0)
 ; 2015-11-02/2016-02-29 va/hsu: develop auto-refresh feature, first
"RTN","HMPMONC",16,0)
 ; in routine HMPDJFSM, then in HMPDBMN.
"RTN","HMPMONC",17,0)
 ;
"RTN","HMPMONC",18,0)
 ; 2016-03-18/04-06 asmr-ven/toad: created routine HMPMONC from rate
"RTN","HMPMONC",19,0)
 ; subroutines C, $$RATE, SETSYS, and SETPKG^HMPMOND, which in turn
"RTN","HMPMONC",20,0)
 ; were created from Team Krypton's subroutines in HMPMONDB; change
"RTN","HMPMONC",21,0)
 ; options HMPMON SET SYS DASHBOARD RATE and HMPMON SET PKG
"RTN","HMPMONC",22,0)
 ; DASHBOARD RATE to invoke moved subroutines; fix org & history.
"RTN","HMPMONC",23,0)
 ;
"RTN","HMPMONC",24,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONC",25,0)
 ;
"RTN","HMPMONC",26,0)
 ; 2016-06-28/29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONC",27,0)
 ; convert variables to uppercase; fix "; lookup by prefiX" in SETPKG;
"RTN","HMPMONC",28,0)
 ; restore EOR line; fix old bug in SETPKG's call to TED^XPAREDIT.
"RTN","HMPMONC",29,0)
 ;
"RTN","HMPMONC",30,0)
 ;
"RTN","HMPMONC",31,0)
 ; contents
"RTN","HMPMONC",32,0)
 ;
"RTN","HMPMONC",33,0)
 ; C: dashboard action: change auto-update rate
"RTN","HMPMONC",34,0)
 ; $$RATE = auto-update rate
"RTN","HMPMONC",35,0)
 ; SETSYS: option hmpmon set sys dashboard rate
"RTN","HMPMONC",36,0)
 ; SETPKG: option hmpmon set pkg dashboard rate
"RTN","HMPMONC",37,0)
 ;
"RTN","HMPMONC",38,0)
 ;
"RTN","HMPMONC",39,0)
 ; to do
"RTN","HMPMONC",40,0)
 ;
"RTN","HMPMONC",41,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONC",42,0)
 ; replace writes with new writer that can reroute output to arrays
"RTN","HMPMONC",43,0)
 ; create unit tests
"RTN","HMPMONC",44,0)
 ; change call to top into call to unit tests
"RTN","HMPMONC",45,0)
 ;
"RTN","HMPMONC",46,0)
 ;
"RTN","HMPMONC",47,0)
C ; dashboard action: change auto-update rate
"RTN","HMPMONC",48,0)
 ;ven/toad;private;procedure;clean;dialog;sac
"RTN","HMPMONC",49,0)
 ; called by:
"RTN","HMPMONC",50,0)
 ;   OPTION^HMPMON
"RTN","HMPMONC",51,0)
 ; calls:
"RTN","HMPMONC",52,0)
 ;   TED^XPAREDIT: use template to edit parameter
"RTN","HMPMONC",53,0)
 ;   $$RATE = resulting dashboard auto-update rate
"RTN","HMPMONC",54,0)
 ; input:
"RTN","HMPMONC",55,0)
 ;   input from the current device's user
"RTN","HMPMONC",56,0)
 ; output:
"RTN","HMPMONC",57,0)
 ;   HMPRATE = new auto-update rate [pass-by-symbol-table]
"RTN","HMPMONC",58,0)
 ;   HMPEOP = 0 to suppress end-of-page prompt [p-b-s-t]
"RTN","HMPMONC",59,0)
 ;   issue prompt to current device's user
"RTN","HMPMONC",60,0)
 ; examples:
"RTN","HMPMONC",61,0)
 ;   [develop examples]
"RTN","HMPMONC",62,0)
 ;
"RTN","HMPMONC",63,0)
 new HMPFLAG set HMPFLAG="AB"
"RTN","HMPMONC",64,0)
 new HMPTEMPL set HMPTEMPL="HMPMON DASHBOARD USR"
"RTN","HMPMONC",65,0)
 new HMPNTITY set HMPNTITY=DUZ_";VA(200,"
"RTN","HMPMONC",66,0)
 do TED^XPAREDIT(HMPTEMPL,HMPFLAG,HMPNTITY)
"RTN","HMPMONC",67,0)
 ;
"RTN","HMPMONC",68,0)
 set HMPRATE=$$RATE ; set new auto-update rate
"RTN","HMPMONC",69,0)
 ;
"RTN","HMPMONC",70,0)
 set HMPEOP=0 ; suppress OPTION^HMPMON's end-of-page prompt
"RTN","HMPMONC",71,0)
 ; (because TED^XPAREDIT just did one)
"RTN","HMPMONC",72,0)
 ;
"RTN","HMPMONC",73,0)
 quit  ; end of C
"RTN","HMPMONC",74,0)
 ;
"RTN","HMPMONC",75,0)
 ;
"RTN","HMPMONC",76,0)
RATE() ; auto-update rate
"RTN","HMPMONC",77,0)
 ;ven/toad;private;function;clean;silent;sac
"RTN","HMPMONC",78,0)
 ; called by:
"RTN","HMPMONC",79,0)
 ;   OPTION^HMPMON
"RTN","HMPMONC",80,0)
 ; calls:
"RTN","HMPMONC",81,0)
 ;   $$GET^XPAR = parameter value
"RTN","HMPMONC",82,0)
 ; input: none
"RTN","HMPMONC",83,0)
 ; output = current auto-update rate
"RTN","HMPMONC",84,0)
 ; examples:
"RTN","HMPMONC",85,0)
 ;   [develop examples]
"RTN","HMPMONC",86,0)
 ;
"RTN","HMPMONC",87,0)
 new ENTITY set ENTITY="ALL" ; apply all parameters, prioritized
"RTN","HMPMONC",88,0)
 new PARAM set PARAM="HMPMON DASHBOARD UPDATE" ; param name
"RTN","HMPMONC",89,0)
 new INSTANCE set INSTANCE=1 ; there's only one per entity
"RTN","HMPMONC",90,0)
 new FORMAT set FORMAT="I" ; internal, the only format
"RTN","HMPMONC",91,0)
 new RATE ; auto-update rate
"RTN","HMPMONC",92,0)
 set RATE=$$GET^XPAR(ENTITY,PARAM,INSTANCE,FORMAT) ; get parameter
"RTN","HMPMONC",93,0)
 if RATE="" do  ; if parameter value is missing
"RTN","HMPMONC",94,0)
 . set RATE=DTIME ; default to user time-out rate
"RTN","HMPMONC",95,0)
 . quit
"RTN","HMPMONC",96,0)
 ;
"RTN","HMPMONC",97,0)
 quit RATE ; return auto-update rate
"RTN","HMPMONC",98,0)
 ;
"RTN","HMPMONC",99,0)
 ;
"RTN","HMPMONC",100,0)
SETSYS ; option hmpmon set sys dashboard rate
"RTN","HMPMONC",101,0)
 ;ven/toad;private;procedure;clean;dialog;sac
"RTN","HMPMONC",102,0)
 ; called by:
"RTN","HMPMONC",103,0)
 ;   Menuman
"RTN","HMPMONC",104,0)
 ; calls:
"RTN","HMPMONC",105,0)
 ;   $$GET1^DIQ = get current system ien
"RTN","HMPMONC",106,0)
 ;   TED^XPAREDIT: use template to edit parameter
"RTN","HMPMONC",107,0)
 ; input:
"RTN","HMPMONC",108,0)
 ;   input from the current device's user
"RTN","HMPMONC",109,0)
 ; output:
"RTN","HMPMONC",110,0)
 ;   parameter hmpmon dashboard update updated for system
"RTN","HMPMONC",111,0)
 ;   issue prompt to current device's user
"RTN","HMPMONC",112,0)
 ; examples:
"RTN","HMPMONC",113,0)
 ;   [develop examples]
"RTN","HMPMONC",114,0)
 ;
"RTN","HMPMONC",115,0)
 new HMPSYSN do  ; get current system #
"RTN","HMPMONC",116,0)
 . new HMPFILE set HMPFILE=8989.3 ; kernel system parameters
"RTN","HMPMONC",117,0)
 . new HMPREC set HMPREC="1," ; only one entry in file, always #1
"RTN","HMPMONC",118,0)
 . new HMPFIELD set HMPFIELD=.01 ; domain name
"RTN","HMPMONC",119,0)
 . new HMPFLAG set HMPFLAG="I" ; internal format
"RTN","HMPMONC",120,0)
 . set HMPSYSN=$$GET1^DIQ(HMPFILE,HMPREC,HMPFIELD,HMPFLAG) ; get field
"RTN","HMPMONC",121,0)
 . quit
"RTN","HMPMONC",122,0)
 new HMPSYS set HMPSYS=HMPSYSN_";DIC(4.2," ; entity = system
"RTN","HMPMONC",123,0)
 new HMPTEMPL set HMPTEMPL="HMPMON DASHBOARD SYS"
"RTN","HMPMONC",124,0)
 new HMPFLAG set HMPFLAG="AB"
"RTN","HMPMONC",125,0)
 do TED^XPAREDIT(HMPTEMPL,HMPFLAG,HMPSYS)
"RTN","HMPMONC",126,0)
 ;
"RTN","HMPMONC",127,0)
 quit  ; end of SETSYS
"RTN","HMPMONC",128,0)
 ;
"RTN","HMPMONC",129,0)
 ;
"RTN","HMPMONC",130,0)
SETPKG ; option hmpmon set pkg dashboard rate
"RTN","HMPMONC",131,0)
 ;ven/toad;private;procedure;clean;dialog;sac
"RTN","HMPMONC",132,0)
 ; called by:
"RTN","HMPMONC",133,0)
 ;   Menuman
"RTN","HMPMONC",134,0)
 ; calls:
"RTN","HMPMONC",135,0)
 ;   $$FIND1^DIC = find ien of ehmp application
"RTN","HMPMONC",136,0)
 ;   TED^XPAREDIT: use template to edit parameter
"RTN","HMPMONC",137,0)
 ; input:
"RTN","HMPMONC",138,0)
 ;   input from the current device's user
"RTN","HMPMONC",139,0)
 ; output:
"RTN","HMPMONC",140,0)
 ;   parameter hmpmon dashboard update updated for package
"RTN","HMPMONC",141,0)
 ;   issue prompt to current device's user
"RTN","HMPMONC",142,0)
 ; examples:
"RTN","HMPMONC",143,0)
 ;   [develop examples]
"RTN","HMPMONC",144,0)
 ;
"RTN","HMPMONC",145,0)
 ; this option should only be used by the ehmp primary developers
"RTN","HMPMONC",146,0)
 ;
"RTN","HMPMONC",147,0)
 new HMPKGN do  ; find package # for ehmp
"RTN","HMPMONC",148,0)
 . new HMPFILE set HMPFILE=9.4 ; package
"RTN","HMPMONC",149,0)
 . new HMPREFIX set HMPREFIX="HMP" ; field prefix (1)
"RTN","HMPMONC",150,0)
 . new HMPFLAG set HMPFLAG="QX" ; quick, exact
"RTN","HMPMONC",151,0)
 . new HMPINDEX set HMPINDEX="C" ; lookup by prefix
"RTN","HMPMONC",152,0)
 . set HMPKGN=$$FIND1^DIC(HMPFILE,,HMPFLAG,HMPREFIX,HMPINDEX)
"RTN","HMPMONC",153,0)
 . quit
"RTN","HMPMONC",154,0)
 new HMPKG set HMPKG=HMPKGN_";DIC(9.4," ; entity = package
"RTN","HMPMONC",155,0)
 new HMPTEMPL set HMPTEMPL="HMPMON DASHBOARD PKG"
"RTN","HMPMONC",156,0)
 new HMPFLAG set HMPFLAG="AB"
"RTN","HMPMONC",157,0)
 do TED^XPAREDIT(HMPTEMPL,HMPFLAG,HMPKG)
"RTN","HMPMONC",158,0)
 ;
"RTN","HMPMONC",159,0)
 quit  ; end of SETPKG
"RTN","HMPMONC",160,0)
 ;
"RTN","HMPMONC",161,0)
 ;
"RTN","HMPMONC",162,0)
EOR ; end of routine HMPMONC
"RTN","HMPMOND")
0^28^B73551310
"RTN","HMPMOND",1,0)
HMPMOND ;asmr-ven/toad-dashboard: update, rate ;Aug 25, 2016 21:17:38
"RTN","HMPMOND",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMOND",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMOND",4,0)
 ;
"RTN","HMPMOND",5,0)
 Q  ; no entry from top
"RTN","HMPMOND",6,0)
 ;DE6526 - routine refactored, August 25, 2016
"RTN","HMPMOND",7,0)
 ;
"RTN","HMPMOND",8,0)
U ; dashboard action: update dashboard
"RTN","HMPMOND",9,0)
 ;
"RTN","HMPMOND",10,0)
 ; called by:
"RTN","HMPMOND",11,0)
 ;   OPTION^HMPMON
"RTN","HMPMOND",12,0)
 ; calls:
"RTN","HMPMOND",13,0)
 ;   $$LASTREAM^HMPMONL = last freshness stream
"RTN","HMPMOND",14,0)
 ;   $$UHEAD^HMPMONL = header for dashboard update screen
"RTN","HMPMOND",15,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMOND",16,0)
 ;   $$LNQSTAT = line 1: queue status
"RTN","HMPMOND",17,0)
 ;   $$LNSTRM = line 2: jobs polling in this stream
"RTN","HMPMOND",18,0)
 ;   $$LNLUPDT = line 3: last update & errors count
"RTN","HMPMOND",19,0)
 ;   $$LNEOQ = line 4: end of queue & xtmp size
"RTN","HMPMOND",20,0)
 ;   QUEUE: show last max items in freshness queue
"RTN","HMPMOND",21,0)
 ; input:
"RTN","HMPMOND",22,0)
 ;   HMPSRVR = # of server record in file HMP Subscription (800000)
"RTN","HMPMOND",23,0)
 ;   HMPSUB = subscription record's header node
"RTN","HMPMOND",24,0)
 ;   input from the database
"RTN","HMPMOND",25,0)
 ; throughput: [passed through symbol table]
"RTN","HMPMOND",26,0)
 ;   HMPROMPT = current prompt; ^ to exit option; else leave alone
"RTN","HMPMOND",27,0)
 ;
"RTN","HMPMOND",28,0)
 ;
"RTN","HMPMOND",29,0)
 N STREAM,SYS ; freshness stream subscript into ^xtmp
"RTN","HMPMOND",30,0)
 S STREAM=$$LASTREAM^HMPMONL(HMPSRVR) ; get last freshness stream
"RTN","HMPMOND",31,0)
 S SYS=$$SYS^HMPUTILS
"RTN","HMPMOND",32,0)
 D EN^DDIOL($$UHEAD^HMPMONL(STREAM,"eHMP Dashboard: "_SYS),,"?0") ; header
"RTN","HMPMOND",33,0)
 ;
"RTN","HMPMOND",34,0)
 D EN^DDIOL($$LNQSTAT(STREAM),,"!!") ; line 1: queue status
"RTN","HMPMOND",35,0)
 Q:STREAM=""  ; nothing else to show
"RTN","HMPMOND",36,0)
 ;
"RTN","HMPMOND",37,0)
 D EN^DDIOL($$LNSTRM(STREAM)) ; line 2: jobs polling in this stream
"RTN","HMPMOND",38,0)
 ;
"RTN","HMPMOND",39,0)
 D EN^DDIOL($$LNLUPDT(HMPSUB)) ; line 3: last update, errors
"RTN","HMPMOND",40,0)
 ;
"RTN","HMPMOND",41,0)
 D EN^DDIOL($$LNEOQ(STREAM)) ; line 4: end of queue, xtmp size
"RTN","HMPMOND",42,0)
 ;
"RTN","HMPMOND",43,0)
 D QUEUE(STREAM,10) ; show last max items in freshness queue
"RTN","HMPMOND",44,0)
 ;
"RTN","HMPMOND",45,0)
 Q
"RTN","HMPMOND",46,0)
 ;
"RTN","HMPMOND",47,0)
 ;
"RTN","HMPMOND",48,0)
LNQSTAT(STREAM) ; function, queue status line
"RTN","HMPMOND",49,0)
 ; input:
"RTN","HMPMOND",50,0)
 ;   STREAM = last freshness stream
"RTN","HMPMOND",51,0)
 ; output = line 1 of dashboard screen
"RTN","HMPMOND",52,0)
 ;
"RTN","HMPMOND",53,0)
 Q $$SQUEUE(STREAM) ; queue status
"RTN","HMPMOND",54,0)
 ;
"RTN","HMPMOND",55,0)
 ;
"RTN","HMPMOND",56,0)
LNSTRM(STREAM) ; line 2: jobs polling in this stream
"RTN","HMPMOND",57,0)
 ; called by:
"RTN","HMPMOND",58,0)
 ;   U
"RTN","HMPMOND",59,0)
 ; calls:
"RTN","HMPMOND",60,0)
 ;   ^%ZOSF("JOBPARAM")
"RTN","HMPMOND",61,0)
 ; input:
"RTN","HMPMOND",62,0)
 ;   STREAM = last freshness stream
"RTN","HMPMOND",63,0)
 ;   input from the database
"RTN","HMPMOND",64,0)
 ; output = line 2: jobs polling in this stream
"RTN","HMPMOND",65,0)
 ;   report to current device
"RTN","HMPMOND",66,0)
 ;
"RTN","HMPMOND",67,0)
 N INACTV,JBID,JBLST,LNSTRM,X,Y
"RTN","HMPMOND",68,0)
 S JBLST="",INACTV=0,JBID=""
"RTN","HMPMOND",69,0)
 F  S JBID=$O(^XTMP(STREAM,"job",JBID)) Q:'JBID  D
"RTN","HMPMOND",70,0)
 . S X=JBID X ^%ZOSF("JOBPARAM")  ; check if job active
"RTN","HMPMOND",71,0)
 . S:Y="" INACTV=INACTV+1
"RTN","HMPMOND",72,0)
 . S JBLST=JBLST_$S(JBLST:", ",1:"")_JBID
"RTN","HMPMOND",73,0)
 ;
"RTN","HMPMOND",74,0)
 S LNSTRM="   Polling job#"
"RTN","HMPMOND",75,0)
 S:JBLST LNSTRM=LNSTRM_" "_JBLST
"RTN","HMPMOND",76,0)
 S:INACTV LNSTRM=LNSTRM_" ("_INACTV_" inactive)"
"RTN","HMPMOND",77,0)
 ;
"RTN","HMPMOND",78,0)
 Q LNSTRM ; return line 2: stream's polling jobs
"RTN","HMPMOND",79,0)
 ;
"RTN","HMPMOND",80,0)
 ;
"RTN","HMPMOND",81,0)
LNLUPDT(HMPSUB) ; line 3: last update & errors count
"RTN","HMPMOND",82,0)
 ; called by:
"RTN","HMPMOND",83,0)
 ;   U
"RTN","HMPMOND",84,0)
 ; calls:
"RTN","HMPMOND",85,0)
 ;   $$SLASTUP = screen-field lastupdate
"RTN","HMPMOND",86,0)
 ;   $$LJ^XLFSTR = left justify
"RTN","HMPMOND",87,0)
 ;   $$SERRORS = screen-field errors
"RTN","HMPMOND",88,0)
 ;   SETRIGHT^HMPMONL: set substring at right of line
"RTN","HMPMOND",89,0)
 ; input:
"RTN","HMPMOND",90,0)
 ;   HMPSUB = subscription record's header node
"RTN","HMPMOND",91,0)
 ; output = line 3: last update & errors count
"RTN","HMPMOND",92,0)
 ;
"RTN","HMPMOND",93,0)
 N SLASTUP S SLASTUP=$$SLASTUP(HMPSUB) ; lastupdate
"RTN","HMPMOND",94,0)
 N LNLUPDT S LNLUPDT=$$LJ^XLFSTR(SLASTUP,79) ; left in 79 columns
"RTN","HMPMOND",95,0)
 N SERRORS S SERRORS=$$SERRORS ; screen-field errors
"RTN","HMPMOND",96,0)
 D SETRIGHT^HMPMONL(.LNLUPDT,SERRORS) ; to the right
"RTN","HMPMOND",97,0)
 ;
"RTN","HMPMOND",98,0)
 Q LNLUPDT ; return line 3: last update & errors
"RTN","HMPMOND",99,0)
 ;
"RTN","HMPMOND",100,0)
 ;
"RTN","HMPMOND",101,0)
LNEOQ(STREAM) ; line 4: end of queue & xtmp size
"RTN","HMPMOND",102,0)
 ; called by:
"RTN","HMPMOND",103,0)
 ;   U
"RTN","HMPMOND",104,0)
 ; calls:
"RTN","HMPMOND",105,0)
 ;   $$SXTMPSIZ = screen-field xtmp-size
"RTN","HMPMOND",106,0)
 ;   $$RJ^XLFSTR = right justify
"RTN","HMPMOND",107,0)
 ;   $$SENDQ = screen-field end-of-queue
"RTN","HMPMOND",108,0)
 ;   SETLEFT^HMPMONL: set substring at left of line
"RTN","HMPMOND",109,0)
 ; input:
"RTN","HMPMOND",110,0)
 ;   STREAM = last freshness stream
"RTN","HMPMOND",111,0)
 ; output = line 4: end of queue & xtmp size
"RTN","HMPMOND",112,0)
 ;
"RTN","HMPMOND",113,0)
 N LNEOQ,SENDQ,SXTMPSIZ
"RTN","HMPMOND",114,0)
 S SXTMPSIZ=$$SXTMPSIZ ; screen-field xtmp-size
"RTN","HMPMOND",115,0)
 S LNEOQ=$$RJ^XLFSTR(SXTMPSIZ,79) ; create line 3
"RTN","HMPMOND",116,0)
 S SENDQ=$$SENDQ(STREAM) ; screen-field end-of-queue
"RTN","HMPMOND",117,0)
 D:SENDQ SETLEFT^HMPMONL(.LNEOQ,SENDQ)
"RTN","HMPMOND",118,0)
 ;
"RTN","HMPMOND",119,0)
 Q LNEOQ ; return line 4: end of queue & xtmp size
"RTN","HMPMOND",120,0)
 ;
"RTN","HMPMOND",121,0)
SQUEUE(STREAM) ; screen-field queue status
"RTN","HMPMOND",122,0)
 ; called by:
"RTN","HMPMOND",123,0)
 ;   $$LNQSTAT
"RTN","HMPMOND",124,0)
 ; calls:
"RTN","HMPMOND",125,0)
 ;   CHKXTMP^HMPMONX: calculate queue status
"RTN","HMPMOND",126,0)
 ; input:
"RTN","HMPMOND",127,0)
 ;   STREAM = last freshness stream
"RTN","HMPMOND",128,0)
 ; output = queue status
"RTN","HMPMOND",129,0)
 ;
"RTN","HMPMOND",130,0)
 Q:STREAM="" "No HMP extract stream found."  ; nothing to monitor
"RTN","HMPMOND",131,0)
 ;
"RTN","HMPMOND",132,0)
 N RESULT D CHKXTMP^HMPMONX(.RESULT) ; calculate queue status
"RTN","HMPMOND",133,0)
 Q RESULT(1)  ;return queue status
"RTN","HMPMOND",134,0)
 ;
"RTN","HMPMOND",135,0)
SLASTUP(HMPSUB) ; screen-field last update
"RTN","HMPMOND",136,0)
 ; called by:
"RTN","HMPMOND",137,0)
 ;   $$LNLUPDT
"RTN","HMPMOND",138,0)
 ; input:
"RTN","HMPMOND",139,0)
 ;   HMPSUB = subscription record's header node
"RTN","HMPMOND",140,0)
 ; output = screen-field last update
"RTN","HMPMOND",141,0)
 ;
"RTN","HMPMOND",142,0)
 N SERVER,SLASTUP,UPDATE
"RTN","HMPMOND",143,0)
 S SERVER=$P(HMPSUB,U)  ; ^DD(800000,.01,0)="SERVER"
"RTN","HMPMOND",144,0)
 S UPDATE=$P(HMPSUB,U,2) ; ^DD(800000,.02,0)="LASTUPDATE"
"RTN","HMPMOND",145,0)
 S SLASTUP="   Last Update: "_UPDATE
"RTN","HMPMOND",146,0)
 S:$P(HMPSUB,U,4) SLASTUP=SLASTUP_"  x"_$P(HMPSUB,U,4) ; ^DD(800000,.04,0)="REPEAT POLLS"
"RTN","HMPMOND",147,0)
 ;
"RTN","HMPMOND",148,0)
 Q SLASTUP ; return last-update
"RTN","HMPMOND",149,0)
 ;
"RTN","HMPMOND",150,0)
 ;
"RTN","HMPMOND",151,0)
SERRORS() ; function, screen-field errors
"RTN","HMPMOND",152,0)
 ;
"RTN","HMPMOND",153,0)
 Q "eHMP Errors: "_$FN($$ETOTL^HMPMONE,",")  ;  # ehmp errors in all logs
"RTN","HMPMOND",154,0)
 ;
"RTN","HMPMOND",155,0)
 ;
"RTN","HMPMOND",156,0)
SENDQ(STREAM) ; screen-field end-of-queue
"RTN","HMPMOND",157,0)
 ;
"RTN","HMPMOND",158,0)
 ; called by:
"RTN","HMPMOND",159,0)
 ;   $$LNEOQ
"RTN","HMPMOND",160,0)
 ; calls: none
"RTN","HMPMOND",161,0)
 ; input:
"RTN","HMPMOND",162,0)
 ;   STREAM = last freshness stream
"RTN","HMPMOND",163,0)
 ; output = screen-field end-of-queue
"RTN","HMPMOND",164,0)
 ;
"RTN","HMPMOND",165,0)
 N SENDQ S SENDQ=""
"RTN","HMPMOND",166,0)
 S:$D(^XTMP(STREAM)) SENDQ="  End of Queue: "_$P(STREAM,"~",3)_"-"_$G(^XTMP(STREAM,"last"))
"RTN","HMPMOND",167,0)
 ;
"RTN","HMPMOND",168,0)
 Q SENDQ ; return screen-field end-of-queue
"RTN","HMPMOND",169,0)
 ;
"RTN","HMPMOND",170,0)
 ;
"RTN","HMPMOND",171,0)
SXTMPSIZ(STREAM) ; function, returns screen-field xtmp-size
"RTN","HMPMOND",172,0)
 ; called by:
"RTN","HMPMOND",173,0)
 ;   $$LNEOQ
"RTN","HMPMOND",174,0)
 ;
"RTN","HMPMOND",175,0)
 Q "eHMP's ^XTMP use: "_$$XTMPSIZE^HMPMONX  ; size of eHMP in ^XTMP
"RTN","HMPMOND",176,0)
 ;
"RTN","HMPMOND",177,0)
 ;
"RTN","HMPMOND",178,0)
QUEUE(STREAM,MAX) ; show last max items in freshness queue
"RTN","HMPMOND",179,0)
 ; called by:
"RTN","HMPMOND",180,0)
 ;   U
"RTN","HMPMOND",181,0)
 ; calls:
"RTN","HMPMOND",182,0)
 ;   QLIST: get size and last max items
"RTN","HMPMOND",183,0)
 ;   QDEF: define table F report
"RTN","HMPMOND",184,0)
 ;   QHEAD: show freshness-queue header
"RTN","HMPMOND",185,0)
 ;   $$QROW = each row of the report
"RTN","HMPMOND",186,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMOND",187,0)
 ; input:
"RTN","HMPMOND",188,0)
 ;   STREAM = last freshness stream
"RTN","HMPMOND",189,0)
 ;   MAX = maximum # items to show
"RTN","HMPMOND",190,0)
 ;   input from the database
"RTN","HMPMOND",191,0)
 ; output:
"RTN","HMPMOND",192,0)
 ;   HMPEXIT = whether to exit option report to current device
"RTN","HMPMOND",193,0)
 ;
"RTN","HMPMOND",194,0)
 N LIST ; size of queue, array of last max items
"RTN","HMPMOND",195,0)
 D QLIST(.LIST,STREAM,MAX) ; get size and last max items
"RTN","HMPMOND",196,0)
 ;
"RTN","HMPMOND",197,0)
 N FRESHQ D QDEF(.FRESHQ) ; define table for report
"RTN","HMPMOND",198,0)
 D QHEAD(.FRESHQ,MAX,LIST) ; show freshness-queue report header lines
"RTN","HMPMOND",199,0)
 ;
"RTN","HMPMOND",200,0)
 N ITEM,RECORD,ROW S ITEM=""
"RTN","HMPMOND",201,0)
 F  S ITEM=$O(LIST(ITEM),-1) Q:'ITEM  D  ; traverse items
"RTN","HMPMOND",202,0)
 . S RECORD=LIST(ITEM) Q:RECORD=""
"RTN","HMPMOND",203,0)
 . S ROW=$$QROW(.FRESHQ,ITEM,RECORD)
"RTN","HMPMOND",204,0)
 . D EN^DDIOL(ROW) ; display row of report
"RTN","HMPMOND",205,0)
 ;
"RTN","HMPMOND",206,0)
 Q
"RTN","HMPMOND",207,0)
 ;
"RTN","HMPMOND",208,0)
 ;
"RTN","HMPMOND",209,0)
QLIST(LIST,STREAM,MAX) ; size of freshness queue, get last max items
"RTN","HMPMOND",210,0)
 ; called by:
"RTN","HMPMOND",211,0)
 ;   QUEUE
"RTN","HMPMOND",212,0)
 ; input:
"RTN","HMPMOND",213,0)
 ;   STREAM = last freshness stream
"RTN","HMPMOND",214,0)
 ;   MAX = maximum # items to show
"RTN","HMPMOND",215,0)
 ;   LIST - passed by ref.
"RTN","HMPMOND",216,0)
 ; output:
"RTN","HMPMOND",217,0)
 ;   LIST = total # items in freshness queue
"RTN","HMPMOND",218,0)
 ;   LIST(item #) = record for each of the last max items
"RTN","HMPMOND",219,0)
 ;
"RTN","HMPMOND",220,0)
 K LIST S LIST=0
"RTN","HMPMOND",221,0)
 N ITEM S ITEM=$C(1) ; reverse iteration from first subscript after numerics
"RTN","HMPMOND",222,0)
 F  S ITEM=$O(^XTMP(STREAM,ITEM),-1) Q:'ITEM  D  ; traverse end of freshness list
"RTN","HMPMOND",223,0)
 . S LIST=LIST+1  ; count up to max to show
"RTN","HMPMOND",224,0)
 . Q:LIST>MAX
"RTN","HMPMOND",225,0)
 . S LIST(ITEM)=$G(^XTMP(STREAM,ITEM))  ; record item
"RTN","HMPMOND",226,0)
 ;
"RTN","HMPMOND",227,0)
 Q
"RTN","HMPMOND",228,0)
 ;
"RTN","HMPMOND",229,0)
QDEF(FRESHQ) ; set table definition for report
"RTN","HMPMOND",230,0)
 ; called by:
"RTN","HMPMOND",231,0)
 ;   QUEUE
"RTN","HMPMOND",232,0)
 ; output:
"RTN","HMPMOND",233,0)
 ;  FRESHQ = table definition for report, passed by ref.
"RTN","HMPMOND",234,0)
 ;
"RTN","HMPMOND",235,0)
 S FRESHQ=5 ; table definition for report
"RTN","HMPMOND",236,0)
 S FRESHQ(1,0)="1^8^item^l" ; column 1
"RTN","HMPMOND",237,0)
 S FRESHQ(2,0)="11^21^patient^l" ; column 2
"RTN","HMPMOND",238,0)
 S FRESHQ(3,0)="24^35^transaction^r" ; column 3
"RTN","HMPMOND",239,0)
 S FRESHQ(4,0)="38^64^type^l" ; column 4
"RTN","HMPMOND",240,0)
 S FRESHQ(5,0)="67^79^waiting^r" ; column 5
"RTN","HMPMOND",241,0)
 ;
"RTN","HMPMOND",242,0)
 Q
"RTN","HMPMOND",243,0)
 ;
"RTN","HMPMOND",244,0)
QHEAD(FRESHQ,MAX,COUNT) ; show freshness-queue header
"RTN","HMPMOND",245,0)
 ;
"RTN","HMPMOND",246,0)
 ; called by:
"RTN","HMPMOND",247,0)
 ;   QUEUE
"RTN","HMPMOND",248,0)
 ; calls:
"RTN","HMPMOND",249,0)
 ;   $$QLNQSTAT = freshness queue report line 1: max & count
"RTN","HMPMOND",250,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMOND",251,0)
 ;   $$TABLHEAD^HMPMONL = table header
"RTN","HMPMOND",252,0)
 ;   $$TABLLINE^HMPMONL = table line
"RTN","HMPMOND",253,0)
 ; input:
"RTN","HMPMOND",254,0)
 ;   FRESHQ = table definition for report (see example), passed by ref.
"RTN","HMPMOND",255,0)
 ;   MAX = maximum # items to show
"RTN","HMPMOND",256,0)
 ;   COUNT = total # items in queue
"RTN","HMPMOND",257,0)
 ; output:
"RTN","HMPMOND",258,0)
 ;   report to current device or output array
"RTN","HMPMOND",259,0)
 ; examples:
"RTN","HMPMOND",260,0)
 ;   if:
"RTN","HMPMOND",261,0)
 ;     FRESHQ(1,0) = "1^8^item^l"
"RTN","HMPMOND",262,0)
 ;     FRESHQ(2,0) = "11^21^patient^l"
"RTN","HMPMOND",263,0)
 ;     FRESHQ(3,0) = "24^35^transaction^r"
"RTN","HMPMOND",264,0)
 ;     FRESHQ(4,0) = "38^64^which^l"
"RTN","HMPMOND",265,0)
 ;     FRESHQ(5,0) = "67^79^waiting^r"
"RTN","HMPMOND",266,0)
 ;
"RTN","HMPMOND",267,0)
 N QHEAD,QLINE,QLNQSTAT
"RTN","HMPMOND",268,0)
 S QLNQSTAT=$$QLNQSTAT(MAX,COUNT) ; max & count
"RTN","HMPMOND",269,0)
 D EN^DDIOL(QLNQSTAT,,"!!") ; freshness queue report line 1
"RTN","HMPMOND",270,0)
 ;
"RTN","HMPMOND",271,0)
 S QHEAD=$$TABLHEAD^HMPMONL(.FRESHQ) ; table header
"RTN","HMPMOND",272,0)
 D EN^DDIOL(QHEAD,,"!!") ; freshness queue report line 2
"RTN","HMPMOND",273,0)
 ;
"RTN","HMPMOND",274,0)
 N QLINE S QLINE=$$TABLLINE^HMPMONL(.FRESHQ) ; table line
"RTN","HMPMOND",275,0)
 D EN^DDIOL(QLINE) ; freshness queue report line 3
"RTN","HMPMOND",276,0)
 ;
"RTN","HMPMOND",277,0)
 Q
"RTN","HMPMOND",278,0)
 ;
"RTN","HMPMOND",279,0)
QLNQSTAT(MAX,LIST) ; freshness queue report line 1
"RTN","HMPMOND",280,0)
 ; called by:
"RTN","HMPMOND",281,0)
 ;   QHEAD
"RTN","HMPMOND",282,0)
 ; calls:
"RTN","HMPMOND",283,0)
 ;   $$LJ^XLFSTR = left-justify max items
"RTN","HMPMOND",284,0)
 ;   SETRIGHT^HMPMONL = right-justify total items
"RTN","HMPMOND",285,0)
 ; input:
"RTN","HMPMOND",286,0)
 ;   MAX = maximum # items to show
"RTN","HMPMOND",287,0)
 ;   LIST = total # items in freshness queue
"RTN","HMPMOND",288,0)
 ; output = freshness queue report line 1
"RTN","HMPMOND",289,0)
 ;
"RTN","HMPMOND",290,0)
 N QLINE,QLNQSTAT,QSIZE
"RTN","HMPMOND",291,0)
 ;
"RTN","HMPMOND",292,0)
 S QLNQSTAT=$$LJ^XLFSTR("Freshness Queue (last "_MAX_" items):",79)
"RTN","HMPMOND",293,0)
 S QSIZE="Total items in queue: "_LIST
"RTN","HMPMOND",294,0)
 D SETRIGHT^HMPMONL(.QLNQSTAT,QSIZE)
"RTN","HMPMOND",295,0)
 ;
"RTN","HMPMOND",296,0)
 Q QLNQSTAT ; return freshness queue report line 1
"RTN","HMPMOND",297,0)
 ;
"RTN","HMPMOND",298,0)
 ;
"RTN","HMPMOND",299,0)
QROW(FRESHQ,ITEM,RECORD) ; row of the freshness-queue report
"RTN","HMPMOND",300,0)
 ;
"RTN","HMPMOND",301,0)
 ; called by:
"RTN","HMPMOND",302,0)
 ;   QUEUE
"RTN","HMPMOND",303,0)
 ; calls:
"RTN","HMPMOND",304,0)
 ;   SETCOL^HMPMONL: set a value into its column
"RTN","HMPMOND",305,0)
 ;   $$QWAIT = waiting value for this record
"RTN","HMPMOND",306,0)
 ; input:
"RTN","HMPMOND",307,0)
 ;   FRESHQ = table definition for report (see example), passed by ref.
"RTN","HMPMOND",308,0)
 ;   ITEM = sequence # of item in freshness queue
"RTN","HMPMOND",309,0)
 ;   RECORD = record of item in the queue
"RTN","HMPMOND",310,0)
 ; output: report row for the item
"RTN","HMPMOND",311,0)
 ; example: see QDEF
"RTN","HMPMOND",312,0)
 ;
"RTN","HMPMOND",313,0)
 ;
"RTN","HMPMOND",314,0)
 N PATIENT,ROW,TRANSACT,TYPE,WAITING
"RTN","HMPMOND",315,0)
 S ROW=""
"RTN","HMPMOND",316,0)
 D:$L(RECORD)  ; if no record, no row
"RTN","HMPMOND",317,0)
 . D SETCOL^HMPMONL(.ROW,.FRESHQ,1,ITEM)
"RTN","HMPMOND",318,0)
 . S PATIENT=$P(RECORD,U) ; patient record #
"RTN","HMPMOND",319,0)
 . D SETCOL^HMPMONL(.ROW,.FRESHQ,2,PATIENT)
"RTN","HMPMOND",320,0)
 . S TRANSACT=$P(RECORD,U,2)
"RTN","HMPMOND",321,0)
 . D SETCOL^HMPMONL(.ROW,.FRESHQ,3,TRANSACT)
"RTN","HMPMOND",322,0)
 . S TYPE=$P($P(RECORD,U,3),"#")
"RTN","HMPMOND",323,0)
 . D SETCOL^HMPMONL(.ROW,.FRESHQ,4,TYPE)
"RTN","HMPMOND",324,0)
 . S WAITING=$$QWAIT(RECORD)
"RTN","HMPMOND",325,0)
 . D SETCOL^HMPMONL(.ROW,.FRESHQ,5,WAITING)
"RTN","HMPMOND",326,0)
 ;
"RTN","HMPMOND",327,0)
 Q ROW ; return report row
"RTN","HMPMOND",328,0)
 ;
"RTN","HMPMOND",329,0)
 ;
"RTN","HMPMOND",330,0)
QWAIT(RECORD) ; function, return waiting value
"RTN","HMPMOND",331,0)
 ; input:
"RTN","HMPMOND",332,0)
 ;   RECORD = record of item in the queue
"RTN","HMPMOND",333,0)
 ; output = waiting value
"RTN","HMPMOND",334,0)
 ; examples:
"RTN","HMPMOND",335,0)
 ;   $$QWAIT("3^visit^H4721^^52660^54378") = "done"
"RTN","HMPMOND",336,0)
 ;      if $H = "64003,54378" then:
"RTN","HMPMOND",337,0)
 ;   $$QWAIT("3^visit^H4721^^52660^") = "1,718 s"
"RTN","HMPMOND",338,0)
 ;   $$QWAIT("3^visit^H4721^^") = ""
"RTN","HMPMOND",339,0)
 ;   $$QWAIT("") = ""
"RTN","HMPMOND",340,0)
 ;
"RTN","HMPMOND",341,0)
 Q:$G(RECORD)="" ""  ; return null if no RECORD
"RTN","HMPMOND",342,0)
 ;
"RTN","HMPMOND",343,0)
 N DONE,START,WAITING
"RTN","HMPMOND",344,0)
 S WAITING="",DONE=$P(RECORD,U,6)
"RTN","HMPMOND",345,0)
 S:DONE WAITING="done"
"RTN","HMPMOND",346,0)
 D:'DONE
"RTN","HMPMOND",347,0)
 . S START=$P(RECORD,U,5) Q:'START
"RTN","HMPMOND",348,0)
 . S WAITING=$FN($P($H,",",2)-START,",")_" s" S:WAITING<0 WAITING=86400-WAITING  ; handle midnight
"RTN","HMPMOND",349,0)
 ;
"RTN","HMPMOND",350,0)
 Q WAITING ; return waiting seconds
"RTN","HMPMOND",351,0)
 ;
"RTN","HMPMONDH")
0^29^B9552546
"RTN","HMPMONDH",1,0)
HMPMONDH ;asmr-ven/toad-dashboard: main prompt help ;2016-06-29 15:18Z
"RTN","HMPMONDH",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONDH",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONDH",4,0)
 ;
"RTN","HMPMONDH",5,0)
 quit  ; no entry from top of routine HMPMONDH
"RTN","HMPMONDH",6,0)
 ;
"RTN","HMPMONDH",7,0)
 ; primary development
"RTN","HMPMONDH",8,0)
 ;
"RTN","HMPMONDH",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONDH",10,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONDH",11,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONDH",12,0)
 ;
"RTN","HMPMONDH",13,0)
 ; 2016-03-22/04-06 asmr-ven/toad: created routine HMPMONDH to
"RTN","HMPMONDH",14,0)
 ; provide extended ?? help to main dashboard action prompt, in
"RTN","HMPMONDH",15,0)
 ; dialog or silent mode; fix org.
"RTN","HMPMONDH",16,0)
 ;
"RTN","HMPMONDH",17,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONDH",18,0)
 ;
"RTN","HMPMONDH",19,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONDH",20,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONDH",21,0)
 ;
"RTN","HMPMONDH",22,0)
 ;
"RTN","HMPMONDH",23,0)
 ; contents
"RTN","HMPMONDH",24,0)
 ;
"RTN","HMPMONDH",25,0)
 ; DASHHELP: show extended ?? help for main dashboard action prompt
"RTN","HMPMONDH",26,0)
 ; HELPTEXT: lines of extended help text
"RTN","HMPMONDH",27,0)
 ;
"RTN","HMPMONDH",28,0)
 ;
"RTN","HMPMONDH",29,0)
 ; to do
"RTN","HMPMONDH",30,0)
 ;
"RTN","HMPMONDH",31,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONDH",32,0)
 ; create unit tests
"RTN","HMPMONDH",33,0)
 ; change call to top into call to unit tests
"RTN","HMPMONDH",34,0)
 ;
"RTN","HMPMONDH",35,0)
 ;
"RTN","HMPMONDH",36,0)
DASHHELP() ; show extended ?? help for main dashboard action prompt
"RTN","HMPMONDH",37,0)
 ;ven/toad;private;procedure;clean;report or silent;sac
"RTN","HMPMONDH",38,0)
 ; called by:
"RTN","HMPMONDH",39,0)
 ;   PROMPT^HMPMON
"RTN","HMPMONDH",40,0)
 ; calls:
"RTN","HMPMONDH",41,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONDH",42,0)
 ; input:
"RTN","HMPMONDH",43,0)
 ;   DIQUIET = [optional] =1 for silent mode, else dialog mode
"RTN","HMPMONDH",44,0)
 ; output:
"RTN","HMPMONDH",45,0)
 ;   report to current device, if dialog mode
"RTN","HMPMONDH",46,0)
 ;   ^TMP("DIMSG",$job,line#) = line of help, if silent mode
"RTN","HMPMONDH",47,0)
 ; examples:
"RTN","HMPMONDH",48,0)
 ;   [develop examples]
"RTN","HMPMONDH",49,0)
 ;
"RTN","HMPMONDH",50,0)
 new HELPTEXT
"RTN","HMPMONDH",51,0)
 new LINES set LINES=$piece($text(HELPTEXT),";;",2)
"RTN","HMPMONDH",52,0)
 new LINE
"RTN","HMPMONDH",53,0)
 for LINE=1:1:LINES do
"RTN","HMPMONDH",54,0)
 . set HELPTEXT(LINE)=$piece($text(@("HELPTEXT+"_LINE)),";;",2)
"RTN","HMPMONDH",55,0)
 . quit
"RTN","HMPMONDH",56,0)
 ;
"RTN","HMPMONDH",57,0)
 do EN^DDIOL(.HELPTEXT) ; write or load extended ?? help text
"RTN","HMPMONDH",58,0)
 ;
"RTN","HMPMONDH",59,0)
 quit  ; end of DASHHELP
"RTN","HMPMONDH",60,0)
 ;
"RTN","HMPMONDH",61,0)
 ;
"RTN","HMPMONDH",62,0)
HELPTEXT ;;16
"RTN","HMPMONDH",63,0)
 ;;The available actions at the eHMP Dashboard's main screen include:
"RTN","HMPMONDH",64,0)
 ;;
"RTN","HMPMONDH",65,0)
 ;;U = Update Dashboard, to refresh the main screen. This is the
"RTN","HMPMONDH",66,0)
 ;;    default action at this prompt, which auto-updates frequently.
"RTN","HMPMONDH",67,0)
 ;;V = View HMP Nodes, to inspect the main eHMP data nodes currently
"RTN","HMPMONDH",68,0)
 ;;    stored in the ^XTMP or ^TMP globals.
"RTN","HMPMONDH",69,0)
 ;;J = Job Listing, to inspect the polling jobs and extract batches.
"RTN","HMPMONDH",70,0)
 ;;S = Sync Processes, to switch to the Sync-process Screen.
"RTN","HMPMONDH",71,0)
 ;;E = Errors, to switch to the Errors Screen.
"RTN","HMPMONDH",72,0)
 ;;H = History, to switch to the History Screen.
"RTN","HMPMONDH",73,0)
 ;;C = Change Auto-update Rate, to change the frequency with which
"RTN","HMPMONDH",74,0)
 ;;    the dashboard screens refresh. (This change covers all screens,
"RTN","HMPMONDH",75,0)
 ;;    not just the main screen.)
"RTN","HMPMONDH",76,0)
 ;;M = Monitor a Different Subscription, to change which server in the
"RTN","HMPMONDH",77,0)
 ;;    HMP Subscription file (800000) the dashboard is monitoring.
"RTN","HMPMONDH",78,0)
 ;;Q = Quit, to exit the dashboard.
"RTN","HMPMONDH",79,0)
 ;
"RTN","HMPMONDH",80,0)
 ;
"RTN","HMPMONDH",81,0)
EOR ; end of routine HMPMONDH
"RTN","HMPMONE")
0^30^B15446586
"RTN","HMPMONE",1,0)
HMPMONE ;asmr-ven/zag&toad-dashboard: error actions ;Aug 25, 2016 21:17:38
"RTN","HMPMONE",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONE",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONE",4,0)
 ;
"RTN","HMPMONE",5,0)
 Q  ; no entry from top
"RTN","HMPMONE",6,0)
 ;DE6526 - routine refactored, August 25, 2016
"RTN","HMPMONE",7,0)
 ;
"RTN","HMPMONE",8,0)
UE ; update error screen
"RTN","HMPMONE",9,0)
 ; called by:
"RTN","HMPMONE",10,0)
 ;   OPTION^HMPMON
"RTN","HMPMONE",11,0)
 ; calls:
"RTN","HMPMONE",12,0)
 ;   $$LASTREAM^HMPMONL = get last stream name
"RTN","HMPMONE",13,0)
 ;   $$UHEAD^HMPMONL = calculate header line
"RTN","HMPMONE",14,0)
 ;   $$OBSCNT
"RTN","HMPMONE",15,0)
 ;   $$EXTMP
"RTN","HMPMONE",16,0)
 ;   $$EHMPJB
"RTN","HMPMONE",17,0)
 ;   $$EHMPFERR
"RTN","HMPMONE",18,0)
 ;   $$ETMPJOB
"RTN","HMPMONE",19,0)
 ; input:
"RTN","HMPMONE",20,0)
 ;   HMPSRVR = # of server record in file HMP Subscription (800000)
"RTN","HMPMONE",21,0)
 ;   five different error logs
"RTN","HMPMONE",22,0)
 ; output:
"RTN","HMPMONE",23,0)
 ;   report counts to current device
"RTN","HMPMONE",24,0)
 ; examples:
"RTN","HMPMONE",25,0)
 ;   [develop examples]
"RTN","HMPMONE",26,0)
 ;
"RTN","HMPMONE",27,0)
 N STREAM ; freshness stream subscript into ^xtmp
"RTN","HMPMONE",28,0)
 S STREAM=$$LASTREAM^HMPMONL(HMPSRVR) ; get last freshness stream
"RTN","HMPMONE",29,0)
 write $$UHEAD^HMPMONL(STREAM,"eHMP Errors"),! ; write header line
"RTN","HMPMONE",30,0)
 ;
"RTN","HMPMONE",31,0)
 N ETOTAL S ETOTAL=0 ; total ehmp errors
"RTN","HMPMONE",32,0)
 ;
"RTN","HMPMONE",33,0)
 N EXTMP S EXTMP=$$EXTMP ; ehmp errors in xtmp error log
"RTN","HMPMONE",34,0)
 N ETERR S ETERR=$$EHMPJB ; ehmp errors in hmperr error log
"RTN","HMPMONE",35,0)
 N ETFERR S ETFERR=$$EHMPFERR ; ehmp errors in hmpferr error log
"RTN","HMPMONE",36,0)
 N ETSPACE S ETSPACE=$$ETMPJOB ; ehmp errors in hmp error error log
"RTN","HMPMONE",37,0)
 ;
"RTN","HMPMONE",38,0)
 S ETOTAL=ETOTAL+EXTMP+ETERR+ETFERR+ETSPACE
"RTN","HMPMONE",39,0)
 ;
"RTN","HMPMONE",40,0)
 W !,"                error log   # errors"
"RTN","HMPMONE",41,0)
 W !,"    ---------------------   --------"
"RTN","HMPMONE",42,0)
 W !,"                    Total: "_ETOTAL,!
"RTN","HMPMONE",43,0)
 W !," ^XTMP('HMPXTEMP ERRORS'): "_EXTMP
"RTN","HMPMONE",44,0)
 W !,"      ^TMP('HMPERR',$job): "_ETERR
"RTN","HMPMONE",45,0)
 W !,"  ^TMP('HMPFERR',$job,$h): "_ETFERR
"RTN","HMPMONE",46,0)
 W !,"   ^TMP($job,'HMP ERROR'): "_ETSPACE
"RTN","HMPMONE",47,0)
 ;
"RTN","HMPMONE",48,0)
 Q
"RTN","HMPMONE",49,0)
 ;
"RTN","HMPMONE",50,0)
 ;
"RTN","HMPMONE",51,0)
ETOTL() ; count ehmp errors in all error logs
"RTN","HMPMONE",52,0)
 ; called by:
"RTN","HMPMONE",53,0)
 ;   SHOWSRVR^HMPMON
"RTN","HMPMONE",54,0)
 ; calls:
"RTN","HMPMONE",55,0)
 ;   $$OBSCNT
"RTN","HMPMONE",56,0)
 ;   $$EXTMP
"RTN","HMPMONE",57,0)
 ;   $$EHMPJB
"RTN","HMPMONE",58,0)
 ;   $$EHMPFERR
"RTN","HMPMONE",59,0)
 ;   $$ETMPJOB
"RTN","HMPMONE",60,0)
 ; input: ehmp error logs
"RTN","HMPMONE",61,0)
 ; output = # ehmp errors in all error logs
"RTN","HMPMONE",62,0)
 ;
"RTN","HMPMONE",63,0)
 N ETOTAL S ETOTAL=0 ; total ehmp errors
"RTN","HMPMONE",64,0)
 ;
"RTN","HMPMONE",65,0)
 N EXTMP S EXTMP=$$EXTMP ; ehmp errors in xtmp error log
"RTN","HMPMONE",66,0)
 N ETERR S ETERR=$$EHMPJB ; ehmp errors in hmperr error log
"RTN","HMPMONE",67,0)
 N ETFERR S ETFERR=$$EHMPFERR ; ehmp errors in hmpferr error log
"RTN","HMPMONE",68,0)
 N ETSPACE S ETSPACE=$$ETMPJOB ; ehmp errors in hmp error error log
"RTN","HMPMONE",69,0)
 ;
"RTN","HMPMONE",70,0)
 S ETOTAL=ETOTAL+EXTMP+ETERR+ETFERR+ETSPACE
"RTN","HMPMONE",71,0)
 ;
"RTN","HMPMONE",72,0)
 Q ETOTAL ; return # errors
"RTN","HMPMONE",73,0)
 ;
"RTN","HMPMONE",74,0)
 ;
"RTN","HMPMONE",75,0)
EXTMP() ; count errors in ^XTMP("HMPXTEMP ERRORS")
"RTN","HMPMONE",76,0)
 ; called by:
"RTN","HMPMONE",77,0)
 ;   UE
"RTN","HMPMONE",78,0)
 ;   E2
"RTN","HMPMONE",79,0)
 ; output = # ehmp errors in xtmp error log
"RTN","HMPMONE",80,0)
 ;
"RTN","HMPMONE",81,0)
 Q +$O(^XTMP("HMPXTEMP ERRORS",""),-1)
"RTN","HMPMONE",82,0)
 ;
"RTN","HMPMONE",83,0)
EHMPJB() ; total errors in ^TMP("HMPERR",$J)
"RTN","HMPMONE",84,0)
 ; called by:
"RTN","HMPMONE",85,0)
 ;   UE
"RTN","HMPMONE",86,0)
 ;   E3
"RTN","HMPMONE",87,0)
 ;
"RTN","HMPMONE",88,0)
 N ERRCNT,JB S ERRCNT=0,JB=0
"RTN","HMPMONE",89,0)
 F  S JB=$O(^TMP("HMPERR",JB)) Q:'JB  S ERRCNT=ERRCNT+$O(^TMP("HMPERR",JB,0))
"RTN","HMPMONE",90,0)
 ;
"RTN","HMPMONE",91,0)
 Q ERRCNT
"RTN","HMPMONE",92,0)
 ;
"RTN","HMPMONE",93,0)
 ;
"RTN","HMPMONE",94,0)
EHMPFERR() ; function, count errors in ^TMP("HMPFERR",$J)
"RTN","HMPMONE",95,0)
 ; called by:
"RTN","HMPMONE",96,0)
 ;   UE
"RTN","HMPMONE",97,0)
 ;   E4
"RTN","HMPMONE",98,0)
 ; calls: none
"RTN","HMPMONE",99,0)
 ;
"RTN","HMPMONE",100,0)
 N ERRCNT,JB,HTM
"RTN","HMPMONE",101,0)
 S ERRCNT=0,JB=0
"RTN","HMPMONE",102,0)
 F  S JB=$O(^TMP("HMPFERR",JB)) Q:'JB  D
"RTN","HMPMONE",103,0)
 . S HTM=0 F  S HTM=$O(^TMP("HMPFERR",JB,HTM)) Q:'HTM  S ERRCNT=ERRCNT+1
"RTN","HMPMONE",104,0)
 ;
"RTN","HMPMONE",105,0)
 Q ERRCNT ; return total errors
"RTN","HMPMONE",106,0)
 ;
"RTN","HMPMONE",107,0)
 ;
"RTN","HMPMONE",108,0)
ETMPJOB() ; count errors in  ^TMP($J,"HMP ERROR","# of Errors")
"RTN","HMPMONE",109,0)
 ; called by:
"RTN","HMPMONE",110,0)
 ;   UE
"RTN","HMPMONE",111,0)
 ;   E5
"RTN","HMPMONE",112,0)
 ;
"RTN","HMPMONE",113,0)
 N ERRCNT,JB S ERRCNT=0,JB=0
"RTN","HMPMONE",114,0)
 F  S JB=$O(^TMP(JB))  Q:'JB  S ERRCNT=ERRCNT+$G(^TMP(JB,"HMP ERROR","# of Errors"))
"RTN","HMPMONE",115,0)
 ;
"RTN","HMPMONE",116,0)
 Q ERRCNT ; return # errors
"RTN","HMPMONE",117,0)
 ;
"RTN","HMPMONE",118,0)
 ;
"RTN","HMPMONE",119,0)
E1 ; obsolete error tag
"RTN","HMPMONE",120,0)
 W !,"obsolete" Q
"RTN","HMPMONE",121,0)
 ;
"RTN","HMPMONE",122,0)
E2 ; examine xtmp error log
"RTN","HMPMONE",123,0)
 ; called by:
"RTN","HMPMONE",124,0)
 ;   OPTION^HMPMON
"RTN","HMPMONE",125,0)
 ; calls:
"RTN","HMPMONE",126,0)
 ;   $$EXTMP = count of XTMP errors
"RTN","HMPMONE",127,0)
 ; input: none
"RTN","HMPMONE",128,0)
 ;
"RTN","HMPMONE",129,0)
 ;errors from ^XTMP("HMPXTEMP ERRORS")
"RTN","HMPMONE",130,0)
 ;  errors set in SETERROR^HMPUTILS, called by:
"RTN","HMPMONE",131,0)
 ;    HMPCRPC1
"RTN","HMPMONE",132,0)
 ;    HMPDJ
"RTN","HMPMONE",133,0)
 ;    HMPDJ1
"RTN","HMPMONE",134,0)
 ;    HMPDJ2
"RTN","HMPMONE",135,0)
 ;    HMPEF
"RTN","HMPMONE",136,0)
 ;    HMPPARAM
"RTN","HMPMONE",137,0)
 ;    HMPPXRM
"RTN","HMPMONE",138,0)
 ;    HMPUPD
"RTN","HMPMONE",139,0)
 ;
"RTN","HMPMONE",140,0)
 ;
"RTN","HMPMONE",141,0)
 W !,"Total Errors in "_$NA(^XTMP("HMPXTEMP ERRORS"))_": "_$$EXTMP
"RTN","HMPMONE",142,0)
 Q
"RTN","HMPMONE",143,0)
 ;
"RTN","HMPMONE",144,0)
 ;
"RTN","HMPMONE",145,0)
E3 ; ^TMP("HMPERR",$J) errors
"RTN","HMPMONE",146,0)
 ; called by:
"RTN","HMPMONE",147,0)
 ;   OPTION^HMPMON
"RTN","HMPMONE",148,0)
 ; calls:
"RTN","HMPMONE",149,0)
 ;   $$EHMPJB = count of ^TMP("HMPERR",$J) errors
"RTN","HMPMONE",150,0)
 ;
"RTN","HMPMONE",151,0)
 W !,"Total Errors in "_$NA(^XTMP("HMPERR","job#"))_": "_$$EHMPJB
"RTN","HMPMONE",152,0)
 ;
"RTN","HMPMONE",153,0)
 Q
"RTN","HMPMONE",154,0)
 ;
"RTN","HMPMONE",155,0)
 ;
"RTN","HMPMONE",156,0)
E4 ; ^TMP("HMPFERR",$J) errors
"RTN","HMPMONE",157,0)
 ; called by:
"RTN","HMPMONE",158,0)
 ;   OPTION^HMPMON
"RTN","HMPMONE",159,0)
 ; calls:
"RTN","HMPMONE",160,0)
 ;   $$EHMPFERR = count of HMPFERR errors
"RTN","HMPMONE",161,0)
 ;
"RTN","HMPMONE",162,0)
 ; ^TMP("HMPFERR")
"RTN","HMPMONE",163,0)
 ; ^TMP("HMPFERR",$J,$H)=MSG
"RTN","HMPMONE",164,0)
 ;    set in routine HMPDJFS
"RTN","HMPMONE",165,0)
 ;
"RTN","HMPMONE",166,0)
 ;
"RTN","HMPMONE",167,0)
 W !,"Total Errors in "_$NA(^XTMP("HMPFERR","job#"))_$$EHMPFERR
"RTN","HMPMONE",168,0)
 ;
"RTN","HMPMONE",169,0)
 Q
"RTN","HMPMONE",170,0)
 ;
"RTN","HMPMONE",171,0)
 ;
"RTN","HMPMONE",172,0)
E5 ; examine hmp error error log
"RTN","HMPMONE",173,0)
 ; called by:
"RTN","HMPMONE",174,0)
 ;   OPTION^HMPMON
"RTN","HMPMONE",175,0)
 ; calls:
"RTN","HMPMONE",176,0)
 ;   $$ETMPJOB = count of ^TMP("job#","HMP ERROR") errors
"RTN","HMPMONE",177,0)
 ;
"RTN","HMPMONE",178,0)
 ;^TMP($job,"HMP ERROR")
"RTN","HMPMONE",179,0)
 ;  set in routines:
"RTN","HMPMONE",180,0)
 ;    HMPDERRH
"RTN","HMPMONE",181,0)
 ;    HMPDJ
"RTN","HMPMONE",182,0)
 ;    HMPDJ2
"RTN","HMPMONE",183,0)
 ;    HMPDJX
"RTN","HMPMONE",184,0)
 ;    HMPEF
"RTN","HMPMONE",185,0)
 ;    HMPEF1
"RTN","HMPMONE",186,0)
 ;
"RTN","HMPMONE",187,0)
 ;
"RTN","HMPMONE",188,0)
 W !!,"Total Errors in "_$NA(^TMP("job#","HMP ERROR"))_": "_$$ETMPJOB
"RTN","HMPMONE",189,0)
 ;
"RTN","HMPMONE",190,0)
 Q
"RTN","HMPMONE",191,0)
 ;
"RTN","HMPMONE",192,0)
ME ; obsolete
"RTN","HMPMONE",193,0)
 W !,"obsolete line tag ME in routine ^"_$T(+0) Q
"RTN","HMPMONE",194,0)
 ;
"RTN","HMPMONEH")
0^31^B7976382
"RTN","HMPMONEH",1,0)
HMPMONEH ;asmr-ven/toad-dashboard: main prompt help ;2016-06-29 17:18Z
"RTN","HMPMONEH",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONEH",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONEH",4,0)
 ;
"RTN","HMPMONEH",5,0)
 quit  ; no entry from top of routine HMPMONEH
"RTN","HMPMONEH",6,0)
 ;
"RTN","HMPMONEH",7,0)
 ; primary development
"RTN","HMPMONEH",8,0)
 ;
"RTN","HMPMONEH",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONEH",10,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONEH",11,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONEH",12,0)
 ;
"RTN","HMPMONEH",13,0)
 ; 2016-04-05/06 asmr-ven/toad: created routine HMPMONEH to provide
"RTN","HMPMONEH",14,0)
 ; extended ?? help to error-action prompt, in dialog or silent
"RTN","HMPMONEH",15,0)
 ; mode; fix org.
"RTN","HMPMONEH",16,0)
 ;
"RTN","HMPMONEH",17,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONEH",18,0)
 ;
"RTN","HMPMONEH",19,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONEH",20,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONEH",21,0)
 ;
"RTN","HMPMONEH",22,0)
 ;
"RTN","HMPMONEH",23,0)
 ; contents
"RTN","HMPMONEH",24,0)
 ;
"RTN","HMPMONEH",25,0)
 ; ERRHELP: show extended ?? help for error-action prompt
"RTN","HMPMONEH",26,0)
 ; HELPTEXT: lines of extended help text
"RTN","HMPMONEH",27,0)
 ;
"RTN","HMPMONEH",28,0)
 ;
"RTN","HMPMONEH",29,0)
 ; to do
"RTN","HMPMONEH",30,0)
 ;
"RTN","HMPMONEH",31,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONEH",32,0)
 ; create unit tests
"RTN","HMPMONEH",33,0)
 ; change call to top into call to unit tests
"RTN","HMPMONEH",34,0)
 ;
"RTN","HMPMONEH",35,0)
 ;
"RTN","HMPMONEH",36,0)
ERRHELP() ; show extended ?? help for error-action prompt
"RTN","HMPMONEH",37,0)
 ;ven/toad;private;procedure;clean;report or silent;sac
"RTN","HMPMONEH",38,0)
 ; called by:
"RTN","HMPMONEH",39,0)
 ;   PROMPT^HMPMON
"RTN","HMPMONEH",40,0)
 ; calls:
"RTN","HMPMONEH",41,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONEH",42,0)
 ; input:
"RTN","HMPMONEH",43,0)
 ;   DIQUIET = [optional] = 1 for silent mode, else dialog mode
"RTN","HMPMONEH",44,0)
 ; output:
"RTN","HMPMONEH",45,0)
 ;   report to current device, if dialog mode
"RTN","HMPMONEH",46,0)
 ;   ^TMP("DIMSG",$job,line#) = line of help, if silent mode
"RTN","HMPMONEH",47,0)
 ; examples:
"RTN","HMPMONEH",48,0)
 ;   [develop examples]
"RTN","HMPMONEH",49,0)
 ;
"RTN","HMPMONEH",50,0)
 new HELPTEXT
"RTN","HMPMONEH",51,0)
 new LINES set LINES=$piece($text(HELPTEXT),";;",2)
"RTN","HMPMONEH",52,0)
 new LINE
"RTN","HMPMONEH",53,0)
 for LINE=1:1:LINES do
"RTN","HMPMONEH",54,0)
 . set HELPTEXT(LINE)=$piece($text(@("HELPTEXT+"_LINE)),";;",2)
"RTN","HMPMONEH",55,0)
 . quit
"RTN","HMPMONEH",56,0)
 ;
"RTN","HMPMONEH",57,0)
 do EN^DDIOL(.HELPTEXT) ; write or load extended ?? help text
"RTN","HMPMONEH",58,0)
 ;
"RTN","HMPMONEH",59,0)
 quit  ; end of ERRHELP
"RTN","HMPMONEH",60,0)
 ;
"RTN","HMPMONEH",61,0)
 ;
"RTN","HMPMONEH",62,0)
HELPTEXT ;;14
"RTN","HMPMONEH",63,0)
 ;;The available actions at the eHMP Dashboard's error screen include:
"RTN","HMPMONEH",64,0)
 ;;
"RTN","HMPMONEH",65,0)
 ;;UE = Update Error Screen, to refresh the error screen. This is the
"RTN","HMPMONEH",66,0)
 ;;     default action at this prompt, which auto-updates frequently.
"RTN","HMPMONEH",67,0)
 ;;E1 = Examine Kernel Error Log, to select an eHMP error from the
"RTN","HMPMONEH",68,0)
 ;;     main error log used by Vista and examine its variables.
"RTN","HMPMONEH",69,0)
 ;;BD = Back to Dashboard, to return to dashboard's main screen.
"RTN","HMPMONEH",70,0)
 ;;
"RTN","HMPMONEH",71,0)
 ;;Placeholders for future development include:
"RTN","HMPMONEH",72,0)
 ;;
"RTN","HMPMONEH",73,0)
 ;;E2 = Examine XTMP Error Log, to inspect ^XTMP("HMPXTEMP ERRORS").
"RTN","HMPMONEH",74,0)
 ;;E3 = Examine HMPERR Error Log, to inspect ^TMP("HMPERR",$job).
"RTN","HMPMONEH",75,0)
 ;;E4 = Examine HMPFERR Error Log, to inspect ^TMP("HMPFERR",$job).
"RTN","HMPMONEH",76,0)
 ;;E5 = Examine HMP ERROR Error Log, to inspect ^TMP($job,"HMP ERROR").
"RTN","HMPMONEH",77,0)
 ;
"RTN","HMPMONEH",78,0)
 ;
"RTN","HMPMONEH",79,0)
EOR ; end of routine HMPMONEH
"RTN","HMPMONH")
0^32^B3366095
"RTN","HMPMONH",1,0)
HMPMONH ;asmr-ven/zag&toad-dashboard: history ;2016-06-29 17:24Z
"RTN","HMPMONH",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONH",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONH",4,0)
 ;
"RTN","HMPMONH",5,0)
 quit  ; no entry from top of routine ^HMPMONH
"RTN","HMPMONH",6,0)
 ;
"RTN","HMPMONH",7,0)
 ; primary development
"RTN","HMPMONH",8,0)
 ;
"RTN","HMPMONH",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONH",10,0)
 ; additional authors: Zach Gonzales (zag)
"RTN","HMPMONH",11,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONH",12,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONH",13,0)
 ;
"RTN","HMPMONH",14,0)
 ; 2016-03-07 asmr-ven/zag: created subroutines HISTORY, EH, MH, and
"RTN","HMPMONH",15,0)
 ; SH in new routine HMPMON. EH, MH, and SH are just empty shells
"RTN","HMPMONH",16,0)
 ; for now.
"RTN","HMPMONH",17,0)
 ;
"RTN","HMPMONH",18,0)
 ; 2016-03-09/04-06 asmr-ven/toad: moved EH & MH to new routine
"RTN","HMPMONH",19,0)
 ; HMPMONH, added header comments & selection feedback as temporary
"RTN","HMPMONH",20,0)
 ; logging lines; add UH shell subroutine; show timestamp at top of
"RTN","HMPMONH",21,0)
 ; UH to make testing easier; overhaul header; fix org, to-do, lines
"RTN","HMPMONH",22,0)
 ; 1 & 2.
"RTN","HMPMONH",23,0)
 ;
"RTN","HMPMONH",24,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONH",25,0)
 ;
"RTN","HMPMONH",26,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONH",27,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONH",28,0)
 ;
"RTN","HMPMONH",29,0)
 ;
"RTN","HMPMONH",30,0)
 ; contents
"RTN","HMPMONH",31,0)
 ;
"RTN","HMPMONH",32,0)
 ; UH: update history screen
"RTN","HMPMONH",33,0)
 ; EH: examine history
"RTN","HMPMONH",34,0)
 ; MH: manage history
"RTN","HMPMONH",35,0)
 ;
"RTN","HMPMONH",36,0)
 ;
"RTN","HMPMONH",37,0)
 ; to do
"RTN","HMPMONH",38,0)
 ;
"RTN","HMPMONH",39,0)
 ; develop actions
"RTN","HMPMONH",40,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONH",41,0)
 ; replace writes with new writer that can reroute output to arrays
"RTN","HMPMONH",42,0)
 ; replace reader calls with new reader that can:
"RTN","HMPMONH",43,0)
 ;   1. take pre-answers from arrays
"RTN","HMPMONH",44,0)
 ;   2. write all outputs to arrays
"RTN","HMPMONH",45,0)
 ;   3. with each feature independently adjustable
"RTN","HMPMONH",46,0)
 ; create unit tests
"RTN","HMPMONH",47,0)
 ; change call to top into call to unit tests
"RTN","HMPMONH",48,0)
 ;
"RTN","HMPMONH",49,0)
 ;
"RTN","HMPMONH",50,0)
UH ; update history screen
"RTN","HMPMONH",51,0)
 ;ven/zag&toad;private;procedure;clean;interactive;sac
"RTN","HMPMONH",52,0)
 ; called by:
"RTN","HMPMONH",53,0)
 ; calls:
"RTN","HMPMONH",54,0)
 ;   $$LASTREAM^HMPMONL = get last stream name
"RTN","HMPMONH",55,0)
 ;   $$UHEAD^HMPMONL = calculate header line
"RTN","HMPMONH",56,0)
 ; input:
"RTN","HMPMONH",57,0)
 ;   HMPSRVR = # of server record in file HMP Subscription (800000)
"RTN","HMPMONH",58,0)
 ; output:
"RTN","HMPMONH",59,0)
 ; examples:
"RTN","HMPMONH",60,0)
 ;
"RTN","HMPMONH",61,0)
 new STREAM ; freshness stream subscript into ^xtmp
"RTN","HMPMONH",62,0)
 set STREAM=$$LASTREAM^HMPMONL(HMPSRVR) ; get last freshness stream
"RTN","HMPMONH",63,0)
 write $$UHEAD^HMPMONL(STREAM,"Dashboard History"),! ; header line
"RTN","HMPMONH",64,0)
 ;
"RTN","HMPMONH",65,0)
 quit  ; end of UH
"RTN","HMPMONH",66,0)
 ;
"RTN","HMPMONH",67,0)
 ;
"RTN","HMPMONH",68,0)
EH ; examine history
"RTN","HMPMONH",69,0)
 ;ven/zag&toad;private;procedure;clean;interactive;sac
"RTN","HMPMONH",70,0)
 ; called by:
"RTN","HMPMONH",71,0)
 ; calls: 
"RTN","HMPMONH",72,0)
 ; input:
"RTN","HMPMONH",73,0)
 ; output:
"RTN","HMPMONH",74,0)
 ; examples:
"RTN","HMPMONH",75,0)
 ;
"RTN","HMPMONH",76,0)
 write !!,"You have selected the history-action "
"RTN","HMPMONH",77,0)
 write "Examine History."
"RTN","HMPMONH",78,0)
 ;
"RTN","HMPMONH",79,0)
 quit  ; end of EH
"RTN","HMPMONH",80,0)
 ;
"RTN","HMPMONH",81,0)
 ;
"RTN","HMPMONH",82,0)
MH ; manage history
"RTN","HMPMONH",83,0)
 ;ven/zag&toad;private;procedure;clean;interactive;sac
"RTN","HMPMONH",84,0)
 ; called by:
"RTN","HMPMONH",85,0)
 ; calls: 
"RTN","HMPMONH",86,0)
 ; input:
"RTN","HMPMONH",87,0)
 ; output:
"RTN","HMPMONH",88,0)
 ; examples:
"RTN","HMPMONH",89,0)
 ;
"RTN","HMPMONH",90,0)
 write !!,"You have selected the history-action "
"RTN","HMPMONH",91,0)
 write "Manage History."
"RTN","HMPMONH",92,0)
 ;
"RTN","HMPMONH",93,0)
 quit  ; end of MH
"RTN","HMPMONH",94,0)
 ;
"RTN","HMPMONH",95,0)
 ;
"RTN","HMPMONH",96,0)
EOR ; end of routine HMPMONH
"RTN","HMPMONHH")
0^33^B6882140
"RTN","HMPMONHH",1,0)
HMPMONHH ;asmr-ven/toad-dashboard: history help ;2016-06-29 17:32Z
"RTN","HMPMONHH",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONHH",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONHH",4,0)
 ;
"RTN","HMPMONHH",5,0)
 quit  ; no entry from top of routine HMPMONHH
"RTN","HMPMONHH",6,0)
 ;
"RTN","HMPMONHH",7,0)
 ; primary development
"RTN","HMPMONHH",8,0)
 ;
"RTN","HMPMONHH",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONHH",10,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONHH",11,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONHH",12,0)
 ;
"RTN","HMPMONHH",13,0)
 ; 2016-04-06 asmr-ven/toad: created routine HMPMONHH to provide
"RTN","HMPMONHH",14,0)
 ; extended ?? help to action-action prompt, in dialog or
"RTN","HMPMONHH",15,0)
 ; silent mode; fix org & line 1.
"RTN","HMPMONHH",16,0)
 ;
"RTN","HMPMONHH",17,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONHH",18,0)
 ;
"RTN","HMPMONHH",19,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONHH",20,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONHH",21,0)
 ;
"RTN","HMPMONHH",22,0)
 ;
"RTN","HMPMONHH",23,0)
 ; contents
"RTN","HMPMONHH",24,0)
 ;
"RTN","HMPMONHH",25,0)
 ; HISTHELP: show extended ?? help for history-action prompt
"RTN","HMPMONHH",26,0)
 ; HELPTEXT: lines of extended help text
"RTN","HMPMONHH",27,0)
 ;
"RTN","HMPMONHH",28,0)
 ;
"RTN","HMPMONHH",29,0)
 ; to do
"RTN","HMPMONHH",30,0)
 ;
"RTN","HMPMONHH",31,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONHH",32,0)
 ; create unit tests
"RTN","HMPMONHH",33,0)
 ; change call to top into call to unit tests
"RTN","HMPMONHH",34,0)
 ;
"RTN","HMPMONHH",35,0)
 ;
"RTN","HMPMONHH",36,0)
HISTHELP() ; show extended ?? help for history-action prompt
"RTN","HMPMONHH",37,0)
 ;ven/toad;private;procedure;clean;report or silent;sac
"RTN","HMPMONHH",38,0)
 ; called by:
"RTN","HMPMONHH",39,0)
 ;   PROMPT^HMPMON
"RTN","HMPMONHH",40,0)
 ; calls:
"RTN","HMPMONHH",41,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONHH",42,0)
 ; input:
"RTN","HMPMONHH",43,0)
 ;   DIQUIET = [optional] = 1 for silent mode, else dialog mode
"RTN","HMPMONHH",44,0)
 ; output:
"RTN","HMPMONHH",45,0)
 ;   report to current device, if dialog mode
"RTN","HMPMONHH",46,0)
 ;   ^TMP("DIMSG",$job,line#) = line of help, if silent mode
"RTN","HMPMONHH",47,0)
 ; examples:
"RTN","HMPMONHH",48,0)
 ;   [develop examples]
"RTN","HMPMONHH",49,0)
 ;
"RTN","HMPMONHH",50,0)
 new HELPTEXT
"RTN","HMPMONHH",51,0)
 new LINES set LINES=$piece($text(HELPTEXT),";;",2)
"RTN","HMPMONHH",52,0)
 new LINE
"RTN","HMPMONHH",53,0)
 for LINE=1:1:LINES do
"RTN","HMPMONHH",54,0)
 . set HELPTEXT(LINE)=$piece($text(@("HELPTEXT+"_LINE)),";;",2)
"RTN","HMPMONHH",55,0)
 . quit
"RTN","HMPMONHH",56,0)
 ;
"RTN","HMPMONHH",57,0)
 do EN^DDIOL(.HELPTEXT) ; write or load extended ?? help text
"RTN","HMPMONHH",58,0)
 ;
"RTN","HMPMONHH",59,0)
 quit  ; end of HISTHELP
"RTN","HMPMONHH",60,0)
 ;
"RTN","HMPMONHH",61,0)
 ;
"RTN","HMPMONHH",62,0)
HELPTEXT ;;12
"RTN","HMPMONHH",63,0)
 ;;The available action at eHMP Dashboard's sync-process screen is:
"RTN","HMPMONHH",64,0)
 ;;
"RTN","HMPMONHH",65,0)
 ;;BD = Back to Dashboard, to return to dashboard's main screen.
"RTN","HMPMONHH",66,0)
 ;;
"RTN","HMPMONHH",67,0)
 ;;Placeholders for future development include:
"RTN","HMPMONHH",68,0)
 ;;
"RTN","HMPMONHH",69,0)
 ;;UH = Update History Screen, to refresh the screen. This is the
"RTN","HMPMONHH",70,0)
 ;;     default action at this prompt, which auto-updates frequently.
"RTN","HMPMONHH",71,0)
 ;;EH = Examine History, to display the log of interventions
"RTN","HMPMONHH",72,0)
 ;;     including actions PS, RS, ME, and MH) by Dashboard users.
"RTN","HMPMONHH",73,0)
 ;;MH = Manage History, to clear or otherwise manage the Dashboard
"RTN","HMPMONHH",74,0)
 ;;     history log, to keep it from growing too large over time.
"RTN","HMPMONHH",75,0)
 ;
"RTN","HMPMONHH",76,0)
 ;
"RTN","HMPMONHH",77,0)
EOR ; end of routine HMPMONHH
"RTN","HMPMONJ")
0^34^B21225316
"RTN","HMPMONJ",1,0)
HMPMONJ ;asmr-ven/toad-dashboard: job listing ;Aug 25, 2016 21:17:38
"RTN","HMPMONJ",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONJ",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONJ",4,0)
 ;
"RTN","HMPMONJ",5,0)
 Q  ; no entry from top
"RTN","HMPMONJ",6,0)
 ;DE6526 - routine refactored, August 25, 2016
"RTN","HMPMONJ",7,0)
 ;
"RTN","HMPMONJ",8,0)
 ;
"RTN","HMPMONJ",9,0)
J ; job listing
"RTN","HMPMONJ",10,0)
 ; called by:
"RTN","HMPMONJ",11,0)
 ;   OPTION^HMPMON
"RTN","HMPMONJ",12,0)
 ; calls:
"RTN","HMPMONJ",13,0)
 ;   FORMFEED^HMPMONL: issue form feed to current device or array
"RTN","HMPMONJ",14,0)
 ;   $$LASTREAM^HMPMONL = get last freshness stream
"RTN","HMPMONJ",15,0)
 ;   POLLJOBS: show jobs polling in this stream
"RTN","HMPMONJ",16,0)
 ;   EXTRBATS: show extract batches
"RTN","HMPMONJ",17,0)
 ; input:
"RTN","HMPMONJ",18,0)
 ;   HMPSRVR = # of server record in file HMP Subscription (800000)
"RTN","HMPMONJ",19,0)
 ;   input from the database
"RTN","HMPMONJ",20,0)
 ; symbol table:
"RTN","HMPMONJ",21,0)
 ;   HMPROMPT = current dashboard prompt, ^ = exit now [symbol table]
"RTN","HMPMONJ",22,0)
 ;   HMPEOP = 1 by default, 0 if exiting
"RTN","HMPMONJ",23,0)
 ; output = line 2: jobs polling in this stream
"RTN","HMPMONJ",24,0)
 ;   report to current device
"RTN","HMPMONJ",25,0)
 ;
"RTN","HMPMONJ",26,0)
 D FORMFEED^HMPMONL ; clear screen before report
"RTN","HMPMONJ",27,0)
 N STREAM ; freshness stream subscript into ^xtmp
"RTN","HMPMONJ",28,0)
 S STREAM=$$LASTREAM^HMPMONL(HMPSRVR) ; get last freshness stream
"RTN","HMPMONJ",29,0)
 ;
"RTN","HMPMONJ",30,0)
 D POLLJOBS(STREAM) ; show stream's polling jobs
"RTN","HMPMONJ",31,0)
 D EXTRBATS(HMPSRVR,STREAM,HMPSUB) ; show extract batches
"RTN","HMPMONJ",32,0)
 S:HMPROMPT=U HMPEOP=0  ; dashboard exit flag, suppress dashboard end-of-page if exiting
"RTN","HMPMONJ",33,0)
 ;
"RTN","HMPMONJ",34,0)
 Q
"RTN","HMPMONJ",35,0)
 ;
"RTN","HMPMONJ",36,0)
 ;
"RTN","HMPMONJ",37,0)
POLLJOBS(STREAM) ; show stream's polling jobs
"RTN","HMPMONJ",38,0)
 ; called by:
"RTN","HMPMONJ",39,0)
 ;   J
"RTN","HMPMONJ",40,0)
 ; calls:
"RTN","HMPMONJ",41,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONJ",42,0)
 ;   ^%ZOSF("JOBPARAM")
"RTN","HMPMONJ",43,0)
 ; input:
"RTN","HMPMONJ",44,0)
 ;   STREAM = last freshness stream
"RTN","HMPMONJ",45,0)
 ;   input from the database
"RTN","HMPMONJ",46,0)
 ; output = line 2: jobs polling in this stream
"RTN","HMPMONJ",47,0)
 ;   report to current device
"RTN","HMPMONJ",48,0)
 ;
"RTN","HMPMONJ",49,0)
 D EN^DDIOL("Polling job#:",,"!!")
"RTN","HMPMONJ",50,0)
 ;
"RTN","HMPMONJ",51,0)
 N JOBID,LINE,X,Y
"RTN","HMPMONJ",52,0)
 S JOBID=""
"RTN","HMPMONJ",53,0)
 F  S JOBID=$O(^XTMP(STREAM,"job",JOBID)) Q:'JOBID  D
"RTN","HMPMONJ",54,0)
 . S LINE="   "_JOBID
"RTN","HMPMONJ",55,0)
 . ; check if job is still active
"RTN","HMPMONJ",56,0)
 . S X=JOBID X ^%ZOSF("JOBPARAM") S:Y="" LINE=LINE_" (inactive)"
"RTN","HMPMONJ",57,0)
 . D EN^DDIOL(LINE)
"RTN","HMPMONJ",58,0)
 ;
"RTN","HMPMONJ",59,0)
 Q
"RTN","HMPMONJ",60,0)
 ;
"RTN","HMPMONJ",61,0)
EXTRBATS(HMPSRVR,STREAM,HMPSUB) ; show extract batches
"RTN","HMPMONJ",62,0)
 ;
"RTN","HMPMONJ",63,0)
 ; called by:
"RTN","HMPMONJ",64,0)
 ;   J
"RTN","HMPMONJ",65,0)
 ; calls:
"RTN","HMPMONJ",66,0)
 ;   $$SLOTS^HMPMONL = # free resource slots
"RTN","HMPMONJ",67,0)
 ;   $$RJ^XLFSTR = right justify
"RTN","HMPMONJ",68,0)
 ;   SETLEFT^HMPMONL: set substring at left of line
"RTN","HMPMONJ",69,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONJ",70,0)
 ;   $$FRESHPRE^HMPMONL = ^xtmp freshness prefix
"RTN","HMPMONJ",71,0)
 ;   $$WAIT = # seconds batch has waited
"RTN","HMPMONJ",72,0)
 ;   CHKIOSL^HMPMONL: check for and handle end of page
"RTN","HMPMONJ",73,0)
 ;   $$LASTITEM = last domain retrieved for this batch
"RTN","HMPMONJ",74,0)
 ; input:
"RTN","HMPMONJ",75,0)
 ;   HMPSRVR = # of server record in file HMP Subscription (800000)
"RTN","HMPMONJ",76,0)
 ;   STREAM = last freshness stream
"RTN","HMPMONJ",77,0)
 ;   HMPSUB = subscription record's header node
"RTN","HMPMONJ",78,0)
 ;   input from the database
"RTN","HMPMONJ",79,0)
 ; symbol table:
"RTN","HMPMONJ",80,0)
 ;   HMPROMPT = current dashboard prompt, ^ = exit now
"RTN","HMPMONJ",81,0)
 ; output:
"RTN","HMPMONJ",82,0)
 ;   output to the current device
"RTN","HMPMONJ",83,0)
 ;
"RTN","HMPMONJ",84,0)
 ; loop thru extracts for this server
"RTN","HMPMONJ",85,0)
 ;
"RTN","HMPMONJ",86,0)
 N BATCH,C,EXIT,EXTRACTS,FRESHPRE,PIECE,SLOTS,TASK,TSKLST
"RTN","HMPMONJ",87,0)
 S SLOTS="Slots Open: "_$$SLOTS^HMPMONL ; # free slots, ^DD(3.54,1,0)="AVAILABLE SLOTS"
"RTN","HMPMONJ",88,0)
 S EXTRACTS=$$RJ^XLFSTR(SLOTS,79)  ; extracts summary
"RTN","HMPMONJ",89,0)
 D SETLEFT^HMPMONL(.EXTRACTS,"Extract Batches:")
"RTN","HMPMONJ",90,0)
 D EN^DDIOL(EXTRACTS,,"!!")
"RTN","HMPMONJ",91,0)
 ;
"RTN","HMPMONJ",92,0)
 S EXIT=0,FRESHPRE=$$FRESHPRE^HMPMONL(HMPSUB),BATCH=FRESHPRE
"RTN","HMPMONJ",93,0)
 F  D  Q:HMPROMPT=U!EXIT  ; traverse batches
"RTN","HMPMONJ",94,0)
 . S BATCH=$O(^XTMP(BATCH)) ; get next batch
"RTN","HMPMONJ",95,0)
 . S EXIT=$E(BATCH,1,$L(FRESHPRE))'=FRESHPRE
"RTN","HMPMONJ",96,0)
 . Q:EXIT  ; done if it's a different freshness stream
"RTN","HMPMONJ",97,0)
 . ;
"RTN","HMPMONJ",98,0)
 . W !,$J($P(BATCH,"~",3),12)
"RTN","HMPMONJ",99,0)
 . ;
"RTN","HMPMONJ",100,0)
 . S TASK=0,TSKLST="",C=0  ; C is the count
"RTN","HMPMONJ",101,0)
 . F  S TASK=$O(^XTMP(BATCH,0,"task",TASK)) Q:'TASK  S C=C+1,$P(TSKLST,",",C)=TASK  ; comma-delimited string of tasks
"RTN","HMPMONJ",102,0)
 . W ?14,"Tasks: ",TSKLST W:C>1 !
"RTN","HMPMONJ",103,0)
 . ;
"RTN","HMPMONJ",104,0)
 . I '$D(^XTMP(BATCH,0,"wait")) D  Q
"RTN","HMPMONJ",105,0)
 ..  W ?34,"waiting: "_$$WAIT(BATCH)_" seconds"
"RTN","HMPMONJ",106,0)
 ..  D CHKIOSL^HMPMONL ; check, handle end of page
"RTN","HMPMONJ",107,0)
 . ;
"RTN","HMPMONJ",108,0)
 . I 'TSKLST W ?31,"extracting: no task" D CHKIOSL^HMPMONL ; check for and handle end of page
"RTN","HMPMONJ",109,0)
 . ;
"RTN","HMPMONJ",110,0)
 . ; each comma $piece of the list is a task #
"RTN","HMPMONJ",111,0)
 . F PIECE=1:1:$L(TSKLST,",") D  Q:HMPROMPT=U
"RTN","HMPMONJ",112,0)
 ..  S TASK=$P(TSKLST,",",PIECE)
"RTN","HMPMONJ",113,0)
 ..  W ?31,"extracting: "_$$LASTITEM(BATCH,TASK),! ; last item in batch
"RTN","HMPMONJ",114,0)
 ..  D CHKIOSL^HMPMONL ; check for and handle end of page
"RTN","HMPMONJ",115,0)
 ;
"RTN","HMPMONJ",116,0)
 Q
"RTN","HMPMONJ",117,0)
 ;
"RTN","HMPMONJ",118,0)
WAIT(BATCH) ; # seconds batch has waited
"RTN","HMPMONJ",119,0)
 ; called by:
"RTN","HMPMONJ",120,0)
 ;   EXTRBATS
"RTN","HMPMONJ",121,0)
 ; calls:
"RTN","HMPMONJ",122,0)
 ;   $$HDIFF^XLFDT = difference between two horolog date-times
"RTN","HMPMONJ",123,0)
 ; input:
"RTN","HMPMONJ",124,0)
 ;   BATCH = batch id
"RTN","HMPMONJ",125,0)
 ;   input from the database
"RTN","HMPMONJ",126,0)
 ; output = seconds
"RTN","HMPMONJ",127,0)
 ;
"RTN","HMPMONJ",128,0)
 N START S START=$G(^XTMP(BATCH,0,"time"))
"RTN","HMPMONJ",129,0)
 Q:'START 0  ; default to zero
"RTN","HMPMONJ",130,0)
 Q $$HDIFF^XLFDT($H,START,2)  ; return wait time in seconds
"RTN","HMPMONJ",131,0)
 ;
"RTN","HMPMONJ",132,0)
LASTITEM(BATCH,TASK) ; last domain retrieved for this batch
"RTN","HMPMONJ",133,0)
 ; called by:
"RTN","HMPMONJ",134,0)
 ;   EXTRBATS
"RTN","HMPMONJ",135,0)
 ; calls: none
"RTN","HMPMONJ",136,0)
 ; input:
"RTN","HMPMONJ",137,0)
 ;   BATCH = batch id
"RTN","HMPMONJ",138,0)
 ;   TASK = task #
"RTN","HMPMONJ",139,0)
 ;   input from the database
"RTN","HMPMONJ",140,0)
 ; output = last item in batch
"RTN","HMPMONJ",141,0)
 ;
"RTN","HMPMONJ",142,0)
 Q:'$G(TASK) "no task"
"RTN","HMPMONJ",143,0)
 N DOMAIN,LASTITEM,NUM
"RTN","HMPMONJ",144,0)
 S LASTITEM="",DOMAIN=""
"RTN","HMPMONJ",145,0)
 F  D  Q:DOMAIN=""!$L(LASTITEM)
"RTN","HMPMONJ",146,0)
 . S DOMAIN=$O(^XTMP(BATCH,0,"status",DOMAIN)) Q:'$L(DOMAIN)
"RTN","HMPMONJ",147,0)
 . Q:$G(^XTMP(BATCH,0,"status",DOMAIN))  ; domain complete
"RTN","HMPMONJ",148,0)
 . S NUM=$O(^XTMP(BATCH,TASK,DOMAIN,""),-1)
"RTN","HMPMONJ",149,0)
 . S LASTITEM=DOMAIN_$S(NUM:" #"_NUM,1:"")
"RTN","HMPMONJ",150,0)
 ;
"RTN","HMPMONJ",151,0)
 S:LASTITEM="" LASTITEM="<finished>"
"RTN","HMPMONJ",152,0)
 ;
"RTN","HMPMONJ",153,0)
 Q LASTITEM  ; return last item
"RTN","HMPMONJ",154,0)
 ;
"RTN","HMPMONL")
0^35^B48690614
"RTN","HMPMONL",1,0)
HMPMONL ;asmr-ven/toad&mcglk-dashboard: library ;Aug 25, 2016 21:17:38
"RTN","HMPMONL",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONL",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONL",4,0)
 ;
"RTN","HMPMONL",5,0)
 Q  ; no entry from top
"RTN","HMPMONL",6,0)
 ;DE6526 - routine refactored, August 25, 2016
"RTN","HMPMONL",7,0)
 ;
"RTN","HMPMONL",8,0)
UHEAD(STREAM,TITLE) ; update-screen header line
"RTN","HMPMONL",9,0)
 ; called by:
"RTN","HMPMONL",10,0)
 ;   U^HMPMOND
"RTN","HMPMONL",11,0)
 ;   UE^HMPMONE
"RTN","HMPMONL",12,0)
 ;   UH^HMPMONH
"RTN","HMPMONL",13,0)
 ;   US^HMPMONS
"RTN","HMPMONL",14,0)
 ; calls:
"RTN","HMPMONL",15,0)
 ;   $$CJ^XLFSTR = center-justify
"RTN","HMPMONL",16,0)
 ;   SETLEFT: set a substring into the left of a string
"RTN","HMPMONL",17,0)
 ;   SETRIGHT: set a substring into the right of a string
"RTN","HMPMONL",18,0)
 ;   $$NOW = current date-time in iso format
"RTN","HMPMONL",19,0)
 ; input:
"RTN","HMPMONL",20,0)
 ;   STREAM
"RTN","HMPMONL",21,0)
 ;   TITLE
"RTN","HMPMONL",22,0)
 ; in symbol table:
"RTN","HMPMONL",23,0)
 ;   HMPSRVR = server IEN in HMP SUBSCRIPTION (#800000)
"RTN","HMPMONL",24,0)
 ;   HMPROMPT = current prompt; ^ to exit option; else leave alone
"RTN","HMPMONL",25,0)
 ; output = header line
"RTN","HMPMONL",26,0)
 S TITLE=$G(TITLE,"eHMP Dashboard")
"RTN","HMPMONL",27,0)
 N HEADER,SERVER
"RTN","HMPMONL",28,0)
 S HEADER=$$CJ^XLFSTR(TITLE,79) ; center
"RTN","HMPMONL",29,0)
 ;
"RTN","HMPMONL",30,0)
 S SERVER=$P($G(^HMP(800000,HMPSRVR,0)),U)  ; ^DD(800000,.01,0)="SERVER"
"RTN","HMPMONL",31,0)
 D SETLEFT(.HEADER,SERVER) ; server name on left
"RTN","HMPMONL",32,0)
 D SETRIGHT(.HEADER,$$NOW) ; timestamp on right
"RTN","HMPMONL",33,0)
 ;
"RTN","HMPMONL",34,0)
 Q HEADER ; return update for screen header line
"RTN","HMPMONL",35,0)
 ;
"RTN","HMPMONL",36,0)
 ;
"RTN","HMPMONL",37,0)
LASTREAM(HMPSRVR) ; last freshness stream entry for this server
"RTN","HMPMONL",38,0)
 ; called by:
"RTN","HMPMONL",39,0)
 ;   U^HMPMOND
"RTN","HMPMONL",40,0)
 ;   UE^HMPMONE
"RTN","HMPMONL",41,0)
 ;   UH^HMPMONH
"RTN","HMPMONL",42,0)
 ;   J^HMPMONJ
"RTN","HMPMONL",43,0)
 ;   US^HMPMONS
"RTN","HMPMONL",44,0)
 ;
"RTN","HMPMONL",45,0)
 ; input:
"RTN","HMPMONL",46,0)
 ;   HMPSRVR = # of server in file HMP SUBSCRIPTION (#800000)
"RTN","HMPMONL",47,0)
 ;   field Server (.01) in file HMP Subscription (800000)
"RTN","HMPMONL",48,0)
 ;   ^XTMP(stream)
"RTN","HMPMONL",49,0)
 ;
"RTN","HMPMONL",50,0)
 N HEADER,SERVER,STREAM
"RTN","HMPMONL",51,0)
 S HEADER=$G(^HMP(800000,HMPSRVR,0)) ; subscription hdr
"RTN","HMPMONL",52,0)
 S SERVER=$P(HEADER,U) ; field Server (.01)
"RTN","HMPMONL",53,0)
 S STREAM=$O(^XTMP("HMPFS~"_SERVER_"~99999999"),-1) ; get last freshness stream entry
"RTN","HMPMONL",54,0)
 S:$P(STREAM,"~")'="HMPFS" STREAM=""  ; not a freshness stream, found nothing
"RTN","HMPMONL",55,0)
 S:$P(STREAM,"~",2)'=SERVER STREAM="" ; nothing for this server
"RTN","HMPMONL",56,0)
 ;
"RTN","HMPMONL",57,0)
 Q STREAM  ; return freshness stream
"RTN","HMPMONL",58,0)
 ;
"RTN","HMPMONL",59,0)
 ;
"RTN","HMPMONL",60,0)
SLOTS() ; function, # of available resource device slots
"RTN","HMPMONL",61,0)
 ;
"RTN","HMPMONL",62,0)
 ; called by:
"RTN","HMPMONL",63,0)
 ;   EXTRBATS^HMPMONJ
"RTN","HMPMONL",64,0)
 ;
"RTN","HMPMONL",65,0)
 N HMPOUT
"RTN","HMPMONL",66,0)
 D FIND^DIC(3.54,"",1,"BX","HMP EXTRACT RESOURCE","","","","","HMPOUT")  ; B cross-ref., exact match
"RTN","HMPMONL",67,0)
 Q $G(HMPOUT("DILIST","ID",1,1)) ; Available Slots
"RTN","HMPMONL",68,0)
 ;
"RTN","HMPMONL",69,0)
 ;
"RTN","HMPMONL",70,0)
FRESHPRE(HMPSUB) ; ^xtmp freshness prefix
"RTN","HMPMONL",71,0)
 ; called by:
"RTN","HMPMONL",72,0)
 ;   EXTRBATS^HMPMONL
"RTN","HMPMONL",73,0)
 Q "HMPFX~"_$P(HMPSUB,U)_"~" ; ^XTMP prefix
"RTN","HMPMONL",74,0)
 ;
"RTN","HMPMONL",75,0)
NOW() ;
"RTN","HMPMONL",76,0)
 ; called by:
"RTN","HMPMONL",77,0)
 ;   $$UHEAD
"RTN","HMPMONL",78,0)
 ; calls:
"RTN","HMPMONL",79,0)
 ;   $$FMTHL7^HMPSTMP($$NOW^XLFDT) - 14 character HL7 date
"RTN","HMPMONL",80,0)
 ; outputs now in iso format
"RTN","HMPMONL",81,0)
 N HL7DT S HL7DT=$$FMTHL7^HMPSTMP($$NOW^XLFDT)
"RTN","HMPMONL",82,0)
 ; e.g. 2016-12-20 09:26:51
"RTN","HMPMONL",83,0)
 Q $E(HL7DT,1,4)_"-"_$E(HL7DT,5,6)_"-"_$E(HL7DT,7,8)_" "_$E(HL7DT,9,10)_":"_$E(HL7DT,11,12)_":"_$E(HL7DT,13,14)
"RTN","HMPMONL",84,0)
 ;
"RTN","HMPMONL",85,0)
SETLEFT(STRING,SUBSTR) ; set a substring into the left of a string
"RTN","HMPMONL",86,0)
 ; called by:
"RTN","HMPMONL",87,0)
 ;   $$UHEAD
"RTN","HMPMONL",88,0)
 ;   $$LINE4^HMPMOND
"RTN","HMPMONL",89,0)
 ;   EXTRBATS^HMPMONJ
"RTN","HMPMONL",90,0)
 ; input:
"RTN","HMPMONL",91,0)
 ;   SUBSTR - substring to set into the left of the string
"RTN","HMPMONL",92,0)
 ;   STRING - passed by ref.
"RTN","HMPMONL",93,0)
 ;
"RTN","HMPMONL",94,0)
 S $E(STRING,1,$L(SUBSTR))=SUBSTR Q
"RTN","HMPMONL",95,0)
 ;
"RTN","HMPMONL",96,0)
SETRIGHT(STRING,SUBSTR) ; set a substring into the right of a string
"RTN","HMPMONL",97,0)
 ; called by:
"RTN","HMPMONL",98,0)
 ;   $$UHEAD
"RTN","HMPMONL",99,0)
 ;   $$LINE3^HMPMOND
"RTN","HMPMONL",100,0)
 ;   $$QLINE1^HMPMOND
"RTN","HMPMONL",101,0)
 ;
"RTN","HMPMONL",102,0)
 ; input:
"RTN","HMPMONL",103,0)
 ;   SUBSTR - substring to set into the right of the string
"RTN","HMPMONL",104,0)
 ;   STRING - passed by ref.
"RTN","HMPMONL",105,0)
 ;
"RTN","HMPMONL",106,0)
 S $E(STRING,$L(STRING)-$L(SUBSTR)+1,$L(STRING))=SUBSTR Q
"RTN","HMPMONL",107,0)
 ;
"RTN","HMPMONL",108,0)
TABLHEAD(TABLDEF) ; produce a table header from table definition
"RTN","HMPMONL",109,0)
 ; called by:
"RTN","HMPMONL",110,0)
 ;   QHEAD^HMPMOND
"RTN","HMPMONL",111,0)
 ;   VHEAD^HMPMONV
"RTN","HMPMONL",112,0)
 ; calls:
"RTN","HMPMONL",113,0)
 ;   SETCOL: set a column into row of a table
"RTN","HMPMONL",114,0)
 ; input:
"RTN","HMPMONL",115,0)
 ;  .TABLDEF(column #,0) = definition of that column
"RTN","HMPMONL",116,0)
 ; output = table header, based on definition
"RTN","HMPMONL",117,0)
 ; examples:
"RTN","HMPMONL",118,0)
 ;   if:
"RTN","HMPMONL",119,0)
 ;     freshq(1,0)="1^8^item^l"
"RTN","HMPMONL",120,0)
 ;     freshq(2,0)="11^21^patient^l"
"RTN","HMPMONL",121,0)
 ;     freshq(3,0)="24^35^transaction^r"
"RTN","HMPMONL",122,0)
 ;     freshq(4,0)="38^64^type^l"
"RTN","HMPMONL",123,0)
 ;     freshq(5,0)="67^79^waiting^r"
"RTN","HMPMONL",124,0)
 ;   $$TABLHEAD^HMPMONL(.freshq) =
"RTN","HMPMONL",125,0)
 ;     item      patient    transaction  type         . . . waiting
"RTN","HMPMONL",126,0)
 ;
"RTN","HMPMONL",127,0)
 N COLUMN,TABLHEAD
"RTN","HMPMONL",128,0)
 S TABLHEAD=""  ; header to return
"RTN","HMPMONL",129,0)
 S COLUMN=""  ; each column
"RTN","HMPMONL",130,0)
 F  S COLUMN=$O(TABLDEF(COLUMN)) Q:COLUMN=""  D SETCOL(.TABLHEAD,.TABLDEF,COLUMN)
"RTN","HMPMONL",131,0)
 ;
"RTN","HMPMONL",132,0)
 Q TABLHEAD ; return table header
"RTN","HMPMONL",133,0)
 ;
"RTN","HMPMONL",134,0)
 ;
"RTN","HMPMONL",135,0)
TABLLINE(TABLDEF) ; produce a table line from table definition
"RTN","HMPMONL",136,0)
 ; called by:
"RTN","HMPMONL",137,0)
 ;   QHEAD^HMPMOND
"RTN","HMPMONL",138,0)
 ;   VHEAD^HMPMONV
"RTN","HMPMONL",139,0)
 ; calls:
"RTN","HMPMONL",140,0)
 ;   $$COLLENG = length of a column
"RTN","HMPMONL",141,0)
 ;   $$REPEAT^XLFSTR = repeat a character
"RTN","HMPMONL",142,0)
 ;   SETCOL: set a column into row of a table
"RTN","HMPMONL",143,0)
 ; input:
"RTN","HMPMONL",144,0)
 ;  .TABLDEF(column #,0) = definition of that column
"RTN","HMPMONL",145,0)
 ; output = table line, based on definition
"RTN","HMPMONL",146,0)
 ; examples:
"RTN","HMPMONL",147,0)
 ;   if:
"RTN","HMPMONL",148,0)
 ;     freshq(1,0)="1^8^item^l"
"RTN","HMPMONL",149,0)
 ;     freshq(2,0)="11^21^patient^l"
"RTN","HMPMONL",150,0)
 ;     freshq(3,0)="24^35^transaction^r"
"RTN","HMPMONL",151,0)
 ;     freshq(4,0)="38^64^type^l"
"RTN","HMPMONL",152,0)
 ;     freshq(5,0)="67^79^waiting^r"
"RTN","HMPMONL",153,0)
 ;   $$TABLLINE^HMPMONL(.freshq) =
"RTN","HMPMONL",154,0)
 ;
"RTN","HMPMONL",155,0)
 N COLUMN,LENGTH,LINE,TABLLINE
"RTN","HMPMONL",156,0)
 S TABLLINE="" ; table line to return
"RTN","HMPMONL",157,0)
 S COLUMN="" ; each column
"RTN","HMPMONL",158,0)
 F  S COLUMN=$O(TABLDEF(COLUMN)) Q:COLUMN=""  D
"RTN","HMPMONL",159,0)
 . S LENGTH=$$COLLENG(.TABLDEF,COLUMN)
"RTN","HMPMONL",160,0)
 . S LINE=$$REPEAT^XLFSTR("-",LENGTH)
"RTN","HMPMONL",161,0)
 . D SETCOL(.TABLLINE,.TABLDEF,COLUMN,LINE)
"RTN","HMPMONL",162,0)
 ;
"RTN","HMPMONL",163,0)
 Q TABLLINE  ; return table line
"RTN","HMPMONL",164,0)
 ;
"RTN","HMPMONL",165,0)
 ;
"RTN","HMPMONL",166,0)
SETCOL(ROW,TABLDEF,COLUMN,VALUE) ; set a column into row of a table
"RTN","HMPMONL",167,0)
 ; called by:
"RTN","HMPMONL",168,0)
 ;   $$TABLHEAD
"RTN","HMPMONL",169,0)
 ;   $$TABLLINE
"RTN","HMPMONL",170,0)
 ;   $$QROW^HMPMOND
"RTN","HMPMONL",171,0)
 ;   $$VROW^HMPMONV
"RTN","HMPMONL",172,0)
 ; calls:
"RTN","HMPMONL",173,0)
 ;   $$FIELD = fixed-length field with justified value
"RTN","HMPMONL",174,0)
 ; input:
"RTN","HMPMONL",175,0)
 ;   TABLDEF(column #,0) = definition of that column, passed by ref.
"RTN","HMPMONL",176,0)
 ;   COLUMN = column to set, defaults to 1
"RTN","HMPMONL",177,0)
 ;   VALUE = new value to set into column, defaults to column name
"RTN","HMPMONL",178,0)
 ;   ROW = row to change, passed by ref.
"RTN","HMPMONL",179,0)
 ; examples:
"RTN","HMPMONL",180,0)
 ;   if:
"RTN","HMPMONL",181,0)
 ;     freshq(1,0)="1^8^item^l"
"RTN","HMPMONL",182,0)
 ;     freshq(2,0)="11^21^patient^l"
"RTN","HMPMONL",183,0)
 ;     freshq(3,0)="24^35^transaction^r"
"RTN","HMPMONL",184,0)
 ;     freshq(4,0)="38^64^type^l"
"RTN","HMPMONL",185,0)
 ;     freshq(5,0)="67^79^waiting^r"
"RTN","HMPMONL",186,0)
 ;   and
"RTN","HMPMONL",187,0)
 ;     qhead = "item    "
"RTN","HMPMONL",188,0)
 ;     name = "patient"
"RTN","HMPMONL",189,0)
 ;     column = 2
"RTN","HMPMONL",190,0)
 ;   after do SETCOL^HMPMONL(.qhead,.freshq,column,name)
"RTN","HMPMONL",191,0)
 ;     qhead="item      patient    "
"RTN","HMPMONL",192,0)
 ;
"RTN","HMPMONL",193,0)
 S ROW=$G(ROW) ; initialize row
"RTN","HMPMONL",194,0)
 ;
"RTN","HMPMONL",195,0)
 S COLUMN=$G(COLUMN,1)
"RTN","HMPMONL",196,0)
 Q:COLUMN=""  ; don't change if bad column selection
"RTN","HMPMONL",197,0)
 N COLDEF,FIELD,FROM,JUSTIFY,LENGTH,NAME,TO
"RTN","HMPMONL",198,0)
 S COLDEF=$G(TABLDEF(COLUMN,0)) Q:COLDEF=""  ; don't change if no column definition
"RTN","HMPMONL",199,0)
 S FROM=$P(COLDEF,U)  Q:'FROM  ; don't change if no from attribute
"RTN","HMPMONL",200,0)
 S TO=$P(COLDEF,U,2) Q:'TO  ; don't change if no to attribute
"RTN","HMPMONL",201,0)
 ;
"RTN","HMPMONL",202,0)
 S LENGTH=1+TO-FROM
"RTN","HMPMONL",203,0)
 S JUSTIFY=$P(COLDEF,U,4) S:JUSTIFY="" JUSTIFY="l"
"RTN","HMPMONL",204,0)
 Q:$L(JUSTIFY)'=1  ; single-character code
"RTN","HMPMONL",205,0)
 Q:"lrc"'[JUSTIFY  ; code must be from set
"RTN","HMPMONL",206,0)
 ;
"RTN","HMPMONL",207,0)
 S NAME=$P(COLDEF,U,3)
"RTN","HMPMONL",208,0)
 S:$D(VALUE)[0 VALUE=NAME  ; $d of zero or ten
"RTN","HMPMONL",209,0)
 ;
"RTN","HMPMONL",210,0)
 S FIELD=$$FIELD(VALUE,LENGTH,JUSTIFY)
"RTN","HMPMONL",211,0)
 S $E(ROW,FROM,TO)=FIELD
"RTN","HMPMONL",212,0)
 ;
"RTN","HMPMONL",213,0)
 Q
"RTN","HMPMONL",214,0)
 ;
"RTN","HMPMONL",215,0)
COLLENG(TABLDEF,COLUMN) ; length of column
"RTN","HMPMONL",216,0)
 ; called by:
"RTN","HMPMONL",217,0)
 ;   $$TABLLINE
"RTN","HMPMONL",218,0)
 ; input:
"RTN","HMPMONL",219,0)
 ;  TABLDEF(column #,0) = definition of that column, passed by ref.
"RTN","HMPMONL",220,0)
 ;   column = column to set, defaults to 1
"RTN","HMPMONL",221,0)
 ; output = length of column
"RTN","HMPMONL",222,0)
 ; examples:
"RTN","HMPMONL",223,0)
 ;   if:
"RTN","HMPMONL",224,0)
 ;     freshq(1,0)="1^8^item^l"
"RTN","HMPMONL",225,0)
 ;     freshq(2,0)="11^21^patient^l"
"RTN","HMPMONL",226,0)
 ;     freshq(3,0)="24^35^transaction^r"
"RTN","HMPMONL",227,0)
 ;     freshq(4,0)="38^64^type^l"
"RTN","HMPMONL",228,0)
 ;     freshq(5,0)="67^79^waiting^r"
"RTN","HMPMONL",229,0)
 ;   $$COLLENG^HMPMONL(.freshq,5) = 13
"RTN","HMPMONL",230,0)
 ;   $$COLLENG^HMPMONL(.freshq) = 8
"RTN","HMPMONL",231,0)
 ;   $$COLLENG^HMPMONL(.nonsense,-40) = ""
"RTN","HMPMONL",232,0)
 ;
"RTN","HMPMONL",233,0)
 N COLDEF,FROM,LENGTH,TO S LENGTH=""
"RTN","HMPMONL",234,0)
 D
"RTN","HMPMONL",235,0)
 . S COLUMN=$G(COLUMN,1) Q:COLUMN=""  ; no length if bad column selection
"RTN","HMPMONL",236,0)
 . S COLDEF=$G(TABLDEF(COLUMN,0)) Q:COLDEF=""  ; no length if no column definition
"RTN","HMPMONL",237,0)
 . S FROM=$P(COLDEF,U) Q:'FROM  ; no length if no from attribute
"RTN","HMPMONL",238,0)
 . S TO=$P(COLDEF,U,2) Q:'TO  ; no length if no to attribute
"RTN","HMPMONL",239,0)
 . S LENGTH=1+TO-FROM
"RTN","HMPMONL",240,0)
 ;
"RTN","HMPMONL",241,0)
 Q LENGTH ; return column length
"RTN","HMPMONL",242,0)
 ;
"RTN","HMPMONL",243,0)
 ;
"RTN","HMPMONL",244,0)
FIELD(VALUE,LENGTH,JUSTIFY) ; fixed-length field with justified value
"RTN","HMPMONL",245,0)
 ; called by:
"RTN","HMPMONL",246,0)
 ;   SETCOL
"RTN","HMPMONL",247,0)
 ; calls:
"RTN","HMPMONL",248,0)
 ;   $$LJ^XLFSTR = left-justify
"RTN","HMPMONL",249,0)
 ;   $$RJ^XLFSTR = right-justify
"RTN","HMPMONL",250,0)
 ;   $$CJ^XLFSTR = center-justify
"RTN","HMPMONL",251,0)
 ; input:
"RTN","HMPMONL",252,0)
 ;   VALUE = new value to set into field
"RTN","HMPMONL",253,0)
 ;   LENGTH = length of field
"RTN","HMPMONL",254,0)
 ;   JUSTIFY = which way to justify value within field
"RTN","HMPMONL",255,0)
 ; output = field containing new value
"RTN","HMPMONL",256,0)
 ; examples:
"RTN","HMPMONL",257,0)
 ;   $$FIELD^HMPMONL("item",8,"l") = "item    "
"RTN","HMPMONL",258,0)
 ;   $$FIELD^HMPMONL("waiting",13,"r") = "      waiting"
"RTN","HMPMONL",259,0)
 ;
"RTN","HMPMONL",260,0)
 S VALUE=$G(VALUE),LENGTH=$G(LENGTH),JUSTIFY=$G(JUSTIFY,"l")
"RTN","HMPMONL",261,0)
 ;
"RTN","HMPMONL",262,0)
 N FIELD S FIELD=""
"RTN","HMPMONL",263,0)
 S:JUSTIFY="l" FIELD=$$LJ^XLFSTR(VALUE,LENGTH)
"RTN","HMPMONL",264,0)
 S:JUSTIFY="r" FIELD=$$RJ^XLFSTR(VALUE,LENGTH)
"RTN","HMPMONL",265,0)
 S:JUSTIFY="c" FIELD=$$CJ^XLFSTR(VALUE,LENGTH)
"RTN","HMPMONL",266,0)
 ;
"RTN","HMPMONL",267,0)
 Q FIELD  ; return field with new value
"RTN","HMPMONL",268,0)
 ;
"RTN","HMPMONL",269,0)
CHKIOSL ; check for and handle end of page
"RTN","HMPMONL",270,0)
 ; called by:
"RTN","HMPMONL",271,0)
 ;   EXTRBATS^HMPMONJ
"RTN","HMPMONL",272,0)
 ;   VIEWXTMP^HMPMONV
"RTN","HMPMONL",273,0)
 ;   VIEWTMP^HMPMONV
"RTN","HMPMONL",274,0)
 ;   VSHOWROW^HMPMONV
"RTN","HMPMONL",275,0)
 ; calls:
"RTN","HMPMONL",276,0)
 ;   ENDPAGE: prompt for end-of-page
"RTN","HMPMONL",277,0)
 ;   FORMFEED: issue form feed to current device or output array
"RTN","HMPMONL",278,0)
 ; input:
"RTN","HMPMONL",279,0)
 ;   input from user of current device
"RTN","HMPMONL",280,0)
 ; output:
"RTN","HMPMONL",281,0)
 ;   HMPROMPT = current prompt; ^ to exit; else leave alone
"RTN","HMPMONL",282,0)
 ;   output prompt to user on current device
"RTN","HMPMONL",283,0)
 ;
"RTN","HMPMONL",284,0)
 Q:'((IOSL-4)>$Y)  ; not at bottom, exit
"RTN","HMPMONL",285,0)
 D ENDPAGE  ; prompt for end-of-page
"RTN","HMPMONL",286,0)
 Q:HMPROMPT=U  ; no formfeed if timeout or ^-escape
"RTN","HMPMONL",287,0)
 D FORMFEED  ; clear screen
"RTN","HMPMONL",288,0)
 ;
"RTN","HMPMONL",289,0)
 Q
"RTN","HMPMONL",290,0)
 ;
"RTN","HMPMONL",291,0)
ENDPAGE ; prompt for end-of-page
"RTN","HMPMONL",292,0)
 ; called by:
"RTN","HMPMONL",293,0)
 ;   CHKIOSL
"RTN","HMPMONL",294,0)
 ;   OPTION^HMPMON
"RTN","HMPMONL",295,0)
 ;   NOSRVR^HMPMONM
"RTN","HMPMONL",296,0)
 ; calls:
"RTN","HMPMONL",297,0)
 ;   ^DIR: Fileman Reader Main API, to issue end-of-page prompt
"RTN","HMPMONL",298,0)
 ; input:
"RTN","HMPMONL",299,0)
 ;   input from user of current device
"RTN","HMPMONL",300,0)
 ; output:
"RTN","HMPMONL",301,0)
 ;   output prompt to user on current device
"RTN","HMPMONL",302,0)
 ;
"RTN","HMPMONL",303,0)
 D EN^DDIOL("",,"!")
"RTN","HMPMONL",304,0)
 N DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HMPMONL",305,0)
 ;
"RTN","HMPMONL",306,0)
 S DIR(0)="E" ; end-of-page prompt
"RTN","HMPMONL",307,0)
 D ^DIR  ; prompt user to continue or exit
"RTN","HMPMONL",308,0)
 ; timeout or '^'
"RTN","HMPMONL",309,0)
 I $D(DTOUT)!$D(DUOUT)!$D(DIROUT) S HMPROMPT=U ; exit ehmp dashboard
"RTN","HMPMONL",310,0)
 ;
"RTN","HMPMONL",311,0)
 Q
"RTN","HMPMONL",312,0)
 ;
"RTN","HMPMONL",313,0)
FORMFEED ; issue form feed
"RTN","HMPMONL",314,0)
 ; called by:
"RTN","HMPMONL",315,0)
 ;   CHKIOSL
"RTN","HMPMONL",316,0)
 ;   OPTION^HMPMON
"RTN","HMPMONL",317,0)
 ;   J^HMPMONJ
"RTN","HMPMONL",318,0)
 ;   V^HMPMONV
"RTN","HMPMONL",319,0)
 ; calls: none
"RTN","HMPMONL",320,0)
 ;
"RTN","HMPMONL",321,0)
 W @IOF S $X=0 Q  ; reset cursor and $X
"RTN","HMPMONL",322,0)
 ;
"RTN","HMPMONM")
0^36^B24792706
"RTN","HMPMONM",1,0)
HMPMONM ;asmr-ven/toad-dashboard: update, server ;2016-06-29 18:52Z
"RTN","HMPMONM",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONM",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONM",4,0)
 ;
"RTN","HMPMONM",5,0)
 quit  ; no entry from top of routine HMPMOND
"RTN","HMPMONM",6,0)
 ;
"RTN","HMPMONM",7,0)
 ; primary development
"RTN","HMPMONM",8,0)
 ;
"RTN","HMPMONM",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONM",10,0)
 ; original author: Kevin Meldrum (kcm)
"RTN","HMPMONM",11,0)
 ; additional authors: Raymond Hsu (hsu)
"RTN","HMPMONM",12,0)
 ; original org: U.S. Department of Veterans Affairs (va)
"RTN","HMPMONM",13,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONM",14,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONM",15,0)
 ;
"RTN","HMPMONM",16,0)
 ; 2015-11-02/2016-02-29 va/hsu: refine HMPDJFSM, then develop
"RTN","HMPMONM",17,0)
 ; HMPDBMN.
"RTN","HMPMONM",18,0)
 ;
"RTN","HMPMONM",19,0)
 ; 2016-03-18/04-13 asmr-ven/toad: created routine HMPMONM from
"RTN","HMPMONM",20,0)
 ; subscription subroutines M, $$GETSRVR, NOSRVR^HMPMOND, the first
"RTN","HMPMONM",21,0)
 ; of which was created by Salt Lake's $$GETSRV pseudo-function
"RTN","HMPMONM",22,0)
 ; in HMPDJFSM; adjust selection prompt; move ENDPAGE call to
"RTN","HMPMONM",23,0)
 ; HMPMONL; add $$GETSUB; add throughput hmpsub to dashboard;
"RTN","HMPMONM",24,0)
 ; NOSRVR: convert writes to EN^DDIOL for testing; fix org, history
"RTN","HMPMONM",25,0)
 ; & to-do list & line 1.
"RTN","HMPMONM",26,0)
 ;
"RTN","HMPMONM",27,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONM",28,0)
 ;
"RTN","HMPMONM",29,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONM",30,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONM",31,0)
 ;
"RTN","HMPMONM",32,0)
 ;
"RTN","HMPMONM",33,0)
 ; contents
"RTN","HMPMONM",34,0)
 ;
"RTN","HMPMONM",35,0)
 ; M: dashboard action: monitor a different subscription
"RTN","HMPMONM",36,0)
 ; $$GETSRVR = default server to monitor
"RTN","HMPMONM",37,0)
 ; $$GETSUB = subscription record for server
"RTN","HMPMONM",38,0)
 ; NOSRVR: display help if system has no ehmp subscriptions
"RTN","HMPMONM",39,0)
 ;
"RTN","HMPMONM",40,0)
 ;
"RTN","HMPMONM",41,0)
 ; to do
"RTN","HMPMONM",42,0)
 ;
"RTN","HMPMONM",43,0)
 ; add xref to field Default? (.07) of file HMP Subscription (800000)
"RTN","HMPMONM",44,0)
 ; ...to ensure only one server at a time can be set to YES
"RTN","HMPMONM",45,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONM",46,0)
 ; replace writes with new writer that can reroute output to arrays
"RTN","HMPMONM",47,0)
 ; replace DIC call with reader call & silent lookup that can:
"RTN","HMPMONM",48,0)
 ;   1. take pre-answers from arrays
"RTN","HMPMONM",49,0)
 ;   2. write all outputs to arrays
"RTN","HMPMONM",50,0)
 ;   3. with each feature independently adjustable
"RTN","HMPMONM",51,0)
 ; create unit tests
"RTN","HMPMONM",52,0)
 ; change call to top into call to unit tests
"RTN","HMPMONM",53,0)
 ;
"RTN","HMPMONM",54,0)
 ;
"RTN","HMPMONM",55,0)
M ; dashboard action: monitor a different subscription
"RTN","HMPMONM",56,0)
 ;ven/toad;private;procedure;clean;dialog;sac
"RTN","HMPMONM",57,0)
 ; called by:
"RTN","HMPMONM",58,0)
 ;   OPTION^HMPMON
"RTN","HMPMONM",59,0)
 ; calls:
"RTN","HMPMONM",60,0)
 ;   ^DIC: to select subscription
"RTN","HMPMONM",61,0)
 ; input:
"RTN","HMPMONM",62,0)
 ;   input from the current device's user
"RTN","HMPMONM",63,0)
 ; throughput:
"RTN","HMPMONM",64,0)
 ;   HMPSRVR = ien of server to monitor
"RTN","HMPMONM",65,0)
 ;   HMPSUB = subscription record's header node
"RTN","HMPMONM",66,0)
 ; output:
"RTN","HMPMONM",67,0)
 ;   issue prompt to current device's user
"RTN","HMPMONM",68,0)
 ; examples:
"RTN","HMPMONM",69,0)
 ;   [develop examples]
"RTN","HMPMONM",70,0)
 ;
"RTN","HMPMONM",71,0)
 write !
"RTN","HMPMONM",72,0)
 ;
"RTN","HMPMONM",73,0)
 new DIC set DIC="^HMP(800000," ; file hmp subscription (800000)
"RTN","HMPMONM",74,0)
 set DIC(0)="AEMQ" ; ask, echo choice, multi-index, query bad input
"RTN","HMPMONM",75,0)
 set DIC("A")="Select eHMP Server to Monitor: " ; prompt
"RTN","HMPMONM",76,0)
 set DIC("B")=HMPSRVR ; default to current selection
"RTN","HMPMONM",77,0)
 new DIROUT,DLAYGO,DTOUT,DUOUT,X,Y ; other inputs & outputs
"RTN","HMPMONM",78,0)
 ;
"RTN","HMPMONM",79,0)
 do ^DIC ; classic Fileman lookup
"RTN","HMPMONM",80,0)
 ;
"RTN","HMPMONM",81,0)
 if $data(DTOUT) do  quit  ; time-out
"RTN","HMPMONM",82,0)
 . write "   ** time-out **",$char(7)
"RTN","HMPMONM",83,0)
 . set HMPROMPT=U ; exit ehmp dashboard
"RTN","HMPMONM",84,0)
 . quit
"RTN","HMPMONM",85,0)
 ;
"RTN","HMPMONM",86,0)
 if $data(DUOUT)!$data(DIROUT) do  quit  ; ^-escape
"RTN","HMPMONM",87,0)
 . set HMPROMPT=U ; exit ehmp dashboard
"RTN","HMPMONM",88,0)
 . quit
"RTN","HMPMONM",89,0)
 ;
"RTN","HMPMONM",90,0)
 else  do  ; valid selection
"RTN","HMPMONM",91,0)
 . set HMPSRVR=+Y ; update subscription
"RTN","HMPMONM",92,0)
 . set HMPSUB=$$GETSUB(HMPSRVR) ; and subscription record
"RTN","HMPMONM",93,0)
 . quit
"RTN","HMPMONM",94,0)
 ;
"RTN","HMPMONM",95,0)
 quit  ; end of M
"RTN","HMPMONM",96,0)
 ;
"RTN","HMPMONM",97,0)
 ;
"RTN","HMPMONM",98,0)
GETSRVR() ; default server to monitor
"RTN","HMPMONM",99,0)
 ;ven/toad;private;function;clean;silent;sac
"RTN","HMPMONM",100,0)
 ; called by:
"RTN","HMPMONM",101,0)
 ;   OPTION^HMPMON
"RTN","HMPMONM",102,0)
 ; calls: none
"RTN","HMPMONM",103,0)
 ; input:
"RTN","HMPMONM",104,0)
 ;   file hmp subscription (800000)
"RTN","HMPMONM",105,0)
 ; output = ien of server to monitor
"RTN","HMPMONM",106,0)
 ; examples:
"RTN","HMPMONM",107,0)
 ;   [develop examples]
"RTN","HMPMONM",108,0)
 ;
"RTN","HMPMONM",109,0)
 new SRVR set SRVR=0 ; default server
"RTN","HMPMONM",110,0)
 do
"RTN","HMPMONM",111,0)
 . new FIRST set FIRST=$order(^HMP(800000,0)) ; 1st server's ien
"RTN","HMPMONM",112,0)
 . quit:'FIRST
"RTN","HMPMONM",113,0)
 . new SECOND set SECOND=$order(^HMP(800000,FIRST)) ; 2nd server's ien
"RTN","HMPMONM",114,0)
 . if 'SECOND do  quit  ; if there's only one
"RTN","HMPMONM",115,0)
 . . set SRVR=FIRST ; it's the default
"RTN","HMPMONM",116,0)
 . . quit
"RTN","HMPMONM",117,0)
 . ;
"RTN","HMPMONM",118,0)
 . new DEFAULT1 set DEFAULT1=$order(^HMP(800000,"AD",1,0)) ; default?
"RTN","HMPMONM",119,0)
 . new DEFAULT2 set DEFAULT2=$order(^HMP(800000,"AD",1,DEFAULT1))
"RTN","HMPMONM",120,0)
 . if DEFAULT1,'DEFAULT2 do  quit  ; if only one default
"RTN","HMPMONM",121,0)
 . . set SRVR=DEFAULT1 ; it's the default
"RTN","HMPMONM",122,0)
 . . quit
"RTN","HMPMONM",123,0)
 . ;
"RTN","HMPMONM",124,0)
 . set SRVR=FIRST ; otherwise, give up and default to 1st server
"RTN","HMPMONM",125,0)
 . quit
"RTN","HMPMONM",126,0)
 ;
"RTN","HMPMONM",127,0)
 quit SRVR ; return default server ; end of $$GETSRVR
"RTN","HMPMONM",128,0)
 ;
"RTN","HMPMONM",129,0)
 ;
"RTN","HMPMONM",130,0)
GETSUB(SRVR) ; subscription record for server
"RTN","HMPMONM",131,0)
 ;ven/toad;private;function;clean;silent;sac
"RTN","HMPMONM",132,0)
 ; called by:
"RTN","HMPMONM",133,0)
 ;   OPTION^HMPMON
"RTN","HMPMONM",134,0)
 ; calls: none
"RTN","HMPMONM",135,0)
 ; input:
"RTN","HMPMONM",136,0)
 ;   SRVR = server currently monitoring
"RTN","HMPMONM",137,0)
 ;   file hmp subscription (800000)
"RTN","HMPMONM",138,0)
 ; output = header node for server's subscription
"RTN","HMPMONM",139,0)
 ; examples:
"RTN","HMPMONM",140,0)
 ;   [develop examples]
"RTN","HMPMONM",141,0)
 ;
"RTN","HMPMONM",142,0)
 new SUBHDR set SUBHDR=$get(^HMP(800000,SRVR,0)) ; default server
"RTN","HMPMONM",143,0)
 ;
"RTN","HMPMONM",144,0)
 quit SUBHDR ; return server's header node ; end of $$GETSUB
"RTN","HMPMONM",145,0)
 ;
"RTN","HMPMONM",146,0)
 ;
"RTN","HMPMONM",147,0)
NOSRVR ; display help if system has no ehmp subscriptions
"RTN","HMPMONM",148,0)
 ;ven/toad;private;procedure;clean;dialog;sac
"RTN","HMPMONM",149,0)
 ; called by:
"RTN","HMPMONM",150,0)
 ; calls:
"RTN","HMPMONM",151,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONM",152,0)
 ;   ENDPAGE^HMPMONL ; issue end-of-page prompt before exiting
"RTN","HMPMONM",153,0)
 ; input:
"RTN","HMPMONM",154,0)
 ;   input from the current device's user
"RTN","HMPMONM",155,0)
 ; throughput:
"RTN","HMPMONM",156,0)
 ;   HMPSRVR = ien of server to monitor
"RTN","HMPMONM",157,0)
 ; output:
"RTN","HMPMONM",158,0)
 ;   issue prompt to current device's user
"RTN","HMPMONM",159,0)
 ; examples:
"RTN","HMPMONM",160,0)
 ;   [develop examples]
"RTN","HMPMONM",161,0)
 ;
"RTN","HMPMONM",162,0)
 do EN^DDIOL("You need to set up at least one eHMP subscription",,"!!")
"RTN","HMPMONM",163,0)
 do EN^DDIOL("in file HMP Subscription (800000), before you will")
"RTN","HMPMONM",164,0)
 do EN^DDIOL("have anything to monitor with this dashboard. If you")
"RTN","HMPMONM",165,0)
 do EN^DDIOL("set up subscriptions to more than one server, set")
"RTN","HMPMONM",166,0)
 do EN^DDIOL("field Default? (.07) to YES for your main one, or for")
"RTN","HMPMONM",167,0)
 do EN^DDIOL("the one you want to be the default server to monitor")
"RTN","HMPMONM",168,0)
 do EN^DDIOL("when you first enter the eHMP Dashboard.")
"RTN","HMPMONM",169,0)
 do EN^DDIOL("",,"!")
"RTN","HMPMONM",170,0)
 ;
"RTN","HMPMONM",171,0)
 do ENDPAGE^HMPMONL ; issue end-of-page prompt before exiting
"RTN","HMPMONM",172,0)
 ;
"RTN","HMPMONM",173,0)
 quit  ; end of NOSRVR
"RTN","HMPMONM",174,0)
 ;
"RTN","HMPMONM",175,0)
 ;
"RTN","HMPMONM",176,0)
EOR ; end of routine HMPMONM
"RTN","HMPMONR")
0^72^B2756
"RTN","HMPMONR",1,0)
HMPMONR ;asmr-ven/toad-dashboard: reader ;Aug 25, 2016 15:00:56
"RTN","HMPMONR",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONR",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONR",4,0)
 ;
"RTN","HMPMONR",5,0)
 ; obsolete routine, DE6526, August 25, 2016
"RTN","HMPMONR",6,0)
 ;
"RTN","HMPMONS")
0^37^B5634204
"RTN","HMPMONS",1,0)
HMPMONS ;asmr-ven/zag&toad-dashboard: sync process ;2016-06-29 18:58Z
"RTN","HMPMONS",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONS",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONS",4,0)
 ;
"RTN","HMPMONS",5,0)
 quit  ; no entry from top of routine ^HMPMONS
"RTN","HMPMONS",6,0)
 ;
"RTN","HMPMONS",7,0)
 ; primary development
"RTN","HMPMONS",8,0)
 ;
"RTN","HMPMONS",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONS",10,0)
 ; additional authors: Zach Gonzales (zag)
"RTN","HMPMONS",11,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONS",12,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONS",13,0)
 ;
"RTN","HMPMONS",14,0)
 ; 2016-03-07 asmr-ven/zag: create subroutines HISTORY, EH, MH, and
"RTN","HMPMONS",15,0)
 ; SH in new routine HMPMON. EH, MH, and SH are just empty shells
"RTN","HMPMONS",16,0)
 ; for now.
"RTN","HMPMONS",17,0)
 ;
"RTN","HMPMONS",18,0)
 ; 2016-03-10/04-06 asmr-ven/toad: create routine HMPMONS with
"RTN","HMPMONS",19,0)
 ; subroutines ES, PS, and RS, with header comments & selection
"RTN","HMPMONS",20,0)
 ; feedback as temporary logging lines, based on routines HMPMONE
"RTN","HMPMONS",21,0)
 ; and HMPMONH; add US shell subroutine; show timestamp in US to
"RTN","HMPMONS",22,0)
 ; make testing easier; adjust header; fix org, to-do list, line 2.
"RTN","HMPMONS",23,0)
 ;
"RTN","HMPMONS",24,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONS",25,0)
 ;
"RTN","HMPMONS",26,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONS",27,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONS",28,0)
 ;
"RTN","HMPMONS",29,0)
 ;
"RTN","HMPMONS",30,0)
 ; contents
"RTN","HMPMONS",31,0)
 ;
"RTN","HMPMONS",32,0)
 ; US: update sync-process screen
"RTN","HMPMONS",33,0)
 ; ES: examine sync process
"RTN","HMPMONS",34,0)
 ; PS: park bad sync process
"RTN","HMPMONS",35,0)
 ; RS: restart sync process
"RTN","HMPMONS",36,0)
 ;
"RTN","HMPMONS",37,0)
 ;
"RTN","HMPMONS",38,0)
 ; to do
"RTN","HMPMONS",39,0)
 ;
"RTN","HMPMONS",40,0)
 ; develop actions
"RTN","HMPMONS",41,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONS",42,0)
 ; replace writes with new writer that can reroute output to arrays
"RTN","HMPMONS",43,0)
 ; replace reader calls with new reader that can:
"RTN","HMPMONS",44,0)
 ;   1. take pre-answers from arrays
"RTN","HMPMONS",45,0)
 ;   2. write all outputs to arrays
"RTN","HMPMONS",46,0)
 ;   3. with each feature independently adjustable
"RTN","HMPMONS",47,0)
 ; create unit tests
"RTN","HMPMONS",48,0)
 ; change call to top into call to unit tests
"RTN","HMPMONS",49,0)
 ;
"RTN","HMPMONS",50,0)
 ;
"RTN","HMPMONS",51,0)
US ; update sync-process screen
"RTN","HMPMONS",52,0)
 ;ven/zag&toad;private;procedure;clean;interactive;sac
"RTN","HMPMONS",53,0)
 ; called by:
"RTN","HMPMONS",54,0)
 ; calls:
"RTN","HMPMONS",55,0)
 ;   $$LASTREAM^HMPMONL = get last stream name
"RTN","HMPMONS",56,0)
 ;   $$UHEAD^HMPMONL = calculate header line
"RTN","HMPMONS",57,0)
 ; input:
"RTN","HMPMONS",58,0)
 ;   HMPSRVR = # of server record in file HMP Subscription (800000)
"RTN","HMPMONS",59,0)
 ;      [passed through symbol table]
"RTN","HMPMONS",60,0)
 ; output:
"RTN","HMPMONS",61,0)
 ; examples:
"RTN","HMPMONS",62,0)
 ;
"RTN","HMPMONS",63,0)
 new STREAM ; freshness stream subscript into ^xtmp
"RTN","HMPMONS",64,0)
 set STREAM=$$LASTREAM^HMPMONL(HMPSRVR) ; get last freshness stream
"RTN","HMPMONS",65,0)
 write $$UHEAD^HMPMONL(STREAM,"eHMP Sync Processes"),! ; header line
"RTN","HMPMONS",66,0)
 ;
"RTN","HMPMONS",67,0)
 write !!,"You have selected the sync-process-action "
"RTN","HMPMONS",68,0)
 write "Update Sync-process Screen."
"RTN","HMPMONS",69,0)
 ;
"RTN","HMPMONS",70,0)
 quit  ; end of US
"RTN","HMPMONS",71,0)
 ;
"RTN","HMPMONS",72,0)
 ;
"RTN","HMPMONS",73,0)
ES ; examine sync process
"RTN","HMPMONS",74,0)
 ;ven/zag&toad;private;procedure;clean;interactive;sac
"RTN","HMPMONS",75,0)
 ; called by:
"RTN","HMPMONS",76,0)
 ; calls: 
"RTN","HMPMONS",77,0)
 ; input:
"RTN","HMPMONS",78,0)
 ; output:
"RTN","HMPMONS",79,0)
 ; examples:
"RTN","HMPMONS",80,0)
 ;
"RTN","HMPMONS",81,0)
 write !!,"You have selected the sync-process-action "
"RTN","HMPMONS",82,0)
 write "Examine Sync Process."
"RTN","HMPMONS",83,0)
 ;
"RTN","HMPMONS",84,0)
 quit  ; end of ES
"RTN","HMPMONS",85,0)
 ;
"RTN","HMPMONS",86,0)
 ;
"RTN","HMPMONS",87,0)
PS ; park sync process
"RTN","HMPMONS",88,0)
 ;ven/zag&toad;private;procedure;clean;interactive;sac
"RTN","HMPMONS",89,0)
 ; called by:
"RTN","HMPMONS",90,0)
 ; calls: 
"RTN","HMPMONS",91,0)
 ; input:
"RTN","HMPMONS",92,0)
 ; output:
"RTN","HMPMONS",93,0)
 ; examples:
"RTN","HMPMONS",94,0)
 ;
"RTN","HMPMONS",95,0)
 write !!,"You have selected the sync-process-action "
"RTN","HMPMONS",96,0)
 write "Park Sync Process."
"RTN","HMPMONS",97,0)
 ;
"RTN","HMPMONS",98,0)
 quit  ; end of PS
"RTN","HMPMONS",99,0)
 ;
"RTN","HMPMONS",100,0)
 ;
"RTN","HMPMONS",101,0)
RS ; restart sync process
"RTN","HMPMONS",102,0)
 ;ven/zag&toad;private;procedure;clean;interactive;sac
"RTN","HMPMONS",103,0)
 ; called by:
"RTN","HMPMONS",104,0)
 ; calls: 
"RTN","HMPMONS",105,0)
 ; input:
"RTN","HMPMONS",106,0)
 ; output:
"RTN","HMPMONS",107,0)
 ; examples:
"RTN","HMPMONS",108,0)
 ;
"RTN","HMPMONS",109,0)
 write !!,"You have selected the sync-process-action "
"RTN","HMPMONS",110,0)
 write "Restart Sync Process."
"RTN","HMPMONS",111,0)
 ;
"RTN","HMPMONS",112,0)
 quit  ; end of RS
"RTN","HMPMONS",113,0)
 ;
"RTN","HMPMONS",114,0)
 ;
"RTN","HMPMONS",115,0)
EOR ; end of routine HMPMONS
"RTN","HMPMONSH")
0^38^B8092582
"RTN","HMPMONSH",1,0)
HMPMONSH ;asmr-ven/toad-dashboard: sync-process help ;2016-06-29 19:03Z
"RTN","HMPMONSH",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONSH",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONSH",4,0)
 ;
"RTN","HMPMONSH",5,0)
 quit  ; no entry from top of routine HMPMONSH
"RTN","HMPMONSH",6,0)
 ;
"RTN","HMPMONSH",7,0)
 ; primary development
"RTN","HMPMONSH",8,0)
 ;
"RTN","HMPMONSH",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONSH",10,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONSH",11,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONSH",12,0)
 ;
"RTN","HMPMONSH",13,0)
 ; 2016-04-06 asmr-ven/toad: created routine HMPMONSH to provide
"RTN","HMPMONSH",14,0)
 ; extended ?? help to sync-process-action prompt, in dialog or
"RTN","HMPMONSH",15,0)
 ; silent mode; fix org.
"RTN","HMPMONSH",16,0)
 ;
"RTN","HMPMONSH",17,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONSH",18,0)
 ;
"RTN","HMPMONSH",19,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONSH",20,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONSH",21,0)
 ;
"RTN","HMPMONSH",22,0)
 ;
"RTN","HMPMONSH",23,0)
 ; contents
"RTN","HMPMONSH",24,0)
 ;
"RTN","HMPMONSH",25,0)
 ; SYNCHELP: show extended ?? help for sync-process-action prompt
"RTN","HMPMONSH",26,0)
 ; HELPTEXT: lines of extended help text
"RTN","HMPMONSH",27,0)
 ;
"RTN","HMPMONSH",28,0)
 ;
"RTN","HMPMONSH",29,0)
 ; to do
"RTN","HMPMONSH",30,0)
 ;
"RTN","HMPMONSH",31,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONSH",32,0)
 ; create unit tests
"RTN","HMPMONSH",33,0)
 ; change call to top into call to unit tests
"RTN","HMPMONSH",34,0)
 ;
"RTN","HMPMONSH",35,0)
 ;
"RTN","HMPMONSH",36,0)
SYNCHELP() ; show extended ?? help for sync-process-action prompt
"RTN","HMPMONSH",37,0)
 ;ven/toad;private;procedure;clean;report or silent;sac
"RTN","HMPMONSH",38,0)
 ; called by:
"RTN","HMPMONSH",39,0)
 ;   PROMPT^HMPMON
"RTN","HMPMONSH",40,0)
 ; calls:
"RTN","HMPMONSH",41,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONSH",42,0)
 ; input:
"RTN","HMPMONSH",43,0)
 ;   DIQUIET = [optional] = 1 for silent mode, else dialog mode
"RTN","HMPMONSH",44,0)
 ; output:
"RTN","HMPMONSH",45,0)
 ;   report to current device, if dialog mode
"RTN","HMPMONSH",46,0)
 ;   ^TMP("DIMSG",$job,line#) = line of help, if silent mode
"RTN","HMPMONSH",47,0)
 ; examples:
"RTN","HMPMONSH",48,0)
 ;   [develop examples]
"RTN","HMPMONSH",49,0)
 ;
"RTN","HMPMONSH",50,0)
 new HELPTEXT
"RTN","HMPMONSH",51,0)
 new LINES set LINES=$piece($text(HELPTEXT),";;",2)
"RTN","HMPMONSH",52,0)
 new LINE
"RTN","HMPMONSH",53,0)
 for LINE=1:1:LINES do
"RTN","HMPMONSH",54,0)
 . set HELPTEXT(LINE)=$piece($text(@("HELPTEXT+"_LINE)),";;",2)
"RTN","HMPMONSH",55,0)
 . quit
"RTN","HMPMONSH",56,0)
 ;
"RTN","HMPMONSH",57,0)
 do EN^DDIOL(.HELPTEXT) ; write or load extended ?? help text
"RTN","HMPMONSH",58,0)
 ;
"RTN","HMPMONSH",59,0)
 quit  ; end of SYNCHELP
"RTN","HMPMONSH",60,0)
 ;
"RTN","HMPMONSH",61,0)
 ;
"RTN","HMPMONSH",62,0)
HELPTEXT ;;14
"RTN","HMPMONSH",63,0)
 ;;The available action at eHMP Dashboard's sync-process screen is:
"RTN","HMPMONSH",64,0)
 ;;
"RTN","HMPMONSH",65,0)
 ;;BD = Back to Dashboard, to return to dashboard's main screen.
"RTN","HMPMONSH",66,0)
 ;;
"RTN","HMPMONSH",67,0)
 ;;Placeholders for future development include:
"RTN","HMPMONSH",68,0)
 ;;
"RTN","HMPMONSH",69,0)
 ;;US = Update Sync-process Screen, to refresh the screen. This is the
"RTN","HMPMONSH",70,0)
 ;;     default action at this prompt, which auto-updates frequently.
"RTN","HMPMONSH",71,0)
 ;;ES = Examine Sync Process, to select an active or parked sync
"RTN","HMPMONSH",72,0)
 ;;     process and examine its status information.
"RTN","HMPMONSH",73,0)
 ;;PS = Park Sync Process, to select and examine an active sync
"RTN","HMPMONSH",74,0)
 ;;     process, and confirm selection to place it in a parking lot.
"RTN","HMPMONSH",75,0)
 ;;RS = Restart Sync Process, to select and examine a parked or
"RTN","HMPMONSH",76,0)
 ;;     stalled sync process, confirm selection, and restart it.
"RTN","HMPMONSH",77,0)
 ;
"RTN","HMPMONSH",78,0)
 ;
"RTN","HMPMONSH",79,0)
EOR ; end of routine HMPMONSH
"RTN","HMPMONV")
0^39^B42629686
"RTN","HMPMONV",1,0)
HMPMONV ;asmr-ven/toad-dashboard: view hmp nodes ;2016-06-29 19:23Z
"RTN","HMPMONV",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONV",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONV",4,0)
 ;
"RTN","HMPMONV",5,0)
 quit  ; no entry from top of routine HMPMONV
"RTN","HMPMONV",6,0)
 ;
"RTN","HMPMONV",7,0)
 ; primary development
"RTN","HMPMONV",8,0)
 ;
"RTN","HMPMONV",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONV",10,0)
 ; original author: Kevin Meldrum (kcm)
"RTN","HMPMONV",11,0)
 ; additional authors: Raymond Hsu (hsu)
"RTN","HMPMONV",12,0)
 ; original org: U.S. Department of Veterans Affairs (va)
"RTN","HMPMONV",13,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONV",14,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONV",15,0)
 ;
"RTN","HMPMONV",16,0)
 ; 2015-11-02/2016-02-29 va/hsu: refine HMPDJFSM, then develop
"RTN","HMPMONV",17,0)
 ; HMPDBMN, to include end-of-page checks for long displays, and fix
"RTN","HMPMONV",18,0)
 ; bug in display of HMP nodes.
"RTN","HMPMONV",19,0)
 ;
"RTN","HMPMONV",20,0)
 ; 2016-03-15/04-13 asmr-ven/toad: created routine HMPMONV from Team
"RTN","HMPMONV",21,0)
 ; Krypton's HMPDBMN subroutine SHOWHMPN -> V; create VIEWXTMP,
"RTN","HMPMONV",22,0)
 ; VIEWTMP, & VIEWTMPJ; refactor; move CHKIOSL calls to HMPMONL;
"RTN","HMPMONV",23,0)
 ; passim: check hmprompt=U instead of hmpexit after CHKIOSL,
"RTN","HMPMONV",24,0)
 ; convert writes to EN^DDIOL; add VDEF, $$VHEAD, VSHOWROW, and
"RTN","HMPMONV",25,0)
 ; $$VROW, replace write @IOF with do FORMFEED^HMPMONL in V;
"RTN","HMPMONV",26,0)
 ; updated calls & called-by comments; fix org & history.
"RTN","HMPMONV",27,0)
 ;
"RTN","HMPMONV",28,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONV",29,0)
 ;
"RTN","HMPMONV",30,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONV",31,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONV",32,0)
 ;
"RTN","HMPMONV",33,0)
 ;
"RTN","HMPMONV",34,0)
 ; contents
"RTN","HMPMONV",35,0)
 ;
"RTN","HMPMONV",36,0)
 ; V: action view hmp nodes
"RTN","HMPMONV",37,0)
 ; VDEF: define table for report
"RTN","HMPMONV",38,0)
 ; $$VHEAD = header for view hmp nodes
"RTN","HMPMONV",39,0)
 ; VIEWXTMP: view ^xtmp nodes
"RTN","HMPMONV",40,0)
 ; VIEWTMP: view ^tmp nodes
"RTN","HMPMONV",41,0)
 ; VIEWTMPJ: view ^tmp($job) nodes
"RTN","HMPMONV",42,0)
 ; VSHOWROW: show row for an ehmp global node
"RTN","HMPMONV",43,0)
 ; $$VROW = each row of the report
"RTN","HMPMONV",44,0)
 ;
"RTN","HMPMONV",45,0)
 ;
"RTN","HMPMONV",46,0)
 ; to do
"RTN","HMPMONV",47,0)
 ;
"RTN","HMPMONV",48,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONV",49,0)
 ; create unit tests
"RTN","HMPMONV",50,0)
 ; change call to top into call to unit tests
"RTN","HMPMONV",51,0)
 ;
"RTN","HMPMONV",52,0)
 ;
"RTN","HMPMONV",53,0)
V ; action view hmp nodes
"RTN","HMPMONV",54,0)
 ;ven/toad;private;procedure;clean;interactive;sac
"RTN","HMPMONV",55,0)
 ; called by:
"RTN","HMPMONV",56,0)
 ;   OPTION^HMPMON
"RTN","HMPMONV",57,0)
 ; calls:
"RTN","HMPMONV",58,0)
 ;   VDEF: define table for report
"RTN","HMPMONV",59,0)
 ;   FORMFEED^HMPMONL: form feed to current device or output array
"RTN","HMPMONV",60,0)
 ;   VHEAD: show view-hmp-nodes report header lines
"RTN","HMPMONV",61,0)
 ;   VIEWXTMP: view ^xtmp nodes
"RTN","HMPMONV",62,0)
 ;   VIEWTMP: view ^tmp nodes
"RTN","HMPMONV",63,0)
 ;   VIEWTMPJ: view ^tmp($job) nodes
"RTN","HMPMONV",64,0)
 ; input:
"RTN","HMPMONV",65,0)
 ;   input from the database
"RTN","HMPMONV",66,0)
 ; throughput: [passed through symbol table]
"RTN","HMPMONV",67,0)
 ;   HMPROMPT = current prompt; ^ to exit option; else leave alone
"RTN","HMPMONV",68,0)
 ;   HMPEOP = 1 by default, 0 if exiting
"RTN","HMPMONV",69,0)
 ; output:
"RTN","HMPMONV",70,0)
 ;   output to the current device
"RTN","HMPMONV",71,0)
 ; examples:
"RTN","HMPMONV",72,0)
 ;   [develop examples]
"RTN","HMPMONV",73,0)
 ;
"RTN","HMPMONV",74,0)
 new NODES do VDEF(.NODES) ; define table for report
"RTN","HMPMONV",75,0)
 do FORMFEED^HMPMONL ; clear screen before report
"RTN","HMPMONV",76,0)
 do VHEAD(.NODES) ; show view-hmp-nodes report header lines
"RTN","HMPMONV",77,0)
 ;
"RTN","HMPMONV",78,0)
 do
"RTN","HMPMONV",79,0)
 . do VIEWXTMP ; view ^xtmp nodes
"RTN","HMPMONV",80,0)
 . quit:HMPROMPT=U
"RTN","HMPMONV",81,0)
 . ;
"RTN","HMPMONV",82,0)
 . do VIEWTMP ; view ^tmp nodes
"RTN","HMPMONV",83,0)
 . quit:HMPROMPT=U
"RTN","HMPMONV",84,0)
 . ;
"RTN","HMPMONV",85,0)
 . do VIEWTMPJ ; view ^tmp($job) nodes
"RTN","HMPMONV",86,0)
 . quit
"RTN","HMPMONV",87,0)
 ;
"RTN","HMPMONV",88,0)
 if HMPROMPT=U do  ; dashboard exit flag
"RTN","HMPMONV",89,0)
 . set HMPEOP=0 ; suppress dashboard end-of-page if exiting
"RTN","HMPMONV",90,0)
 . quit
"RTN","HMPMONV",91,0)
 ;
"RTN","HMPMONV",92,0)
 quit  ; end of V
"RTN","HMPMONV",93,0)
 ;
"RTN","HMPMONV",94,0)
 ;
"RTN","HMPMONV",95,0)
VDEF(NODES) ; set table definition for report
"RTN","HMPMONV",96,0)
 ;ven/toad;private;procedure;clean;silent;sac
"RTN","HMPMONV",97,0)
 ; called by:
"RTN","HMPMONV",98,0)
 ;   V
"RTN","HMPMONV",99,0)
 ; calls: none
"RTN","HMPMONV",100,0)
 ; input: none
"RTN","HMPMONV",101,0)
 ; output:
"RTN","HMPMONV",102,0)
 ;  .NODES = table definition for report
"RTN","HMPMONV",103,0)
 ; examples: see below
"RTN","HMPMONV",104,0)
 ;
"RTN","HMPMONV",105,0)
 set NODES=2 ; table definition for nodes report
"RTN","HMPMONV",106,0)
 set NODES(1,0)="1^45^current hmp temporary nodes^l" ; column 1
"RTN","HMPMONV",107,0)
 set NODES(2,0)="50^79^high numeric or last subscript^l" ; column 2
"RTN","HMPMONV",108,0)
 ;
"RTN","HMPMONV",109,0)
 quit  ; end of VDEF
"RTN","HMPMONV",110,0)
 ;
"RTN","HMPMONV",111,0)
 ;
"RTN","HMPMONV",112,0)
VHEAD(NODES) ; show view-hmp-nodes report header lines
"RTN","HMPMONV",113,0)
 ;ven/toad;private;procedure;clean;report;sac
"RTN","HMPMONV",114,0)
 ; called by:
"RTN","HMPMONV",115,0)
 ;   V
"RTN","HMPMONV",116,0)
 ; calls:
"RTN","HMPMONV",117,0)
 ;   $$TABLHEAD^HMPMONL = table header
"RTN","HMPMONV",118,0)
 ;   $$TABLLINE^HMPMONL = table line
"RTN","HMPMONV",119,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONV",120,0)
 ; input:
"RTN","HMPMONV",121,0)
 ;  .NODES = table definition for report (see example)
"RTN","HMPMONV",122,0)
 ; output:
"RTN","HMPMONV",123,0)
 ;   report to current device or output array
"RTN","HMPMONV",124,0)
 ; examples:
"RTN","HMPMONV",125,0)
 ;   if:
"RTN","HMPMONV",126,0)
 ;     nodes(1,0) = "1^45^current hmp temporary nodes^l"
"RTN","HMPMONV",127,0)
 ;     nodes(2,0) = "50^79^high numeric or last subscript^l"
"RTN","HMPMONV",128,0)
 ;   [develop examples]
"RTN","HMPMONV",129,0)
 ;
"RTN","HMPMONV",130,0)
 new VHEAD set VHEAD=$$TABLHEAD^HMPMONL(.NODES) ; table header
"RTN","HMPMONV",131,0)
 do EN^DDIOL(VHEAD,,"!!") ; view-hmp-nodes report line 2
"RTN","HMPMONV",132,0)
 ;
"RTN","HMPMONV",133,0)
 new VLINE set VLINE=$$TABLLINE^HMPMONL(.NODES) ; table line
"RTN","HMPMONV",134,0)
 do EN^DDIOL(VLINE) ; view-hmp-nodes report line 3
"RTN","HMPMONV",135,0)
 ;
"RTN","HMPMONV",136,0)
 quit  ; end of VHEAD
"RTN","HMPMONV",137,0)
 ;
"RTN","HMPMONV",138,0)
 ;
"RTN","HMPMONV",139,0)
VIEWXTMP ; view ^xtmp nodes
"RTN","HMPMONV",140,0)
 ;ven/toad;private;procedure;clean;dialog or silent;sac
"RTN","HMPMONV",141,0)
 ; called by:
"RTN","HMPMONV",142,0)
 ;   V
"RTN","HMPMONV",143,0)
 ; calls:
"RTN","HMPMONV",144,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONV",145,0)
 ;   VSHOWROW: show row for an ehmp global node
"RTN","HMPMONV",146,0)
 ;   CHKIOSL^HMPMONL: check for and handle end of page
"RTN","HMPMONV",147,0)
 ; input:
"RTN","HMPMONV",148,0)
 ;   input from the database
"RTN","HMPMONV",149,0)
 ;   end-of-page prompt input from user on current device
"RTN","HMPMONV",150,0)
 ; throughput: [passed through symbol table]
"RTN","HMPMONV",151,0)
 ;   HMPROMPT = current dashboard prompt, ^ = exit now [symbol table]
"RTN","HMPMONV",152,0)
 ; output:
"RTN","HMPMONV",153,0)
 ;   output to current device or output array
"RTN","HMPMONV",154,0)
 ;   end-of-page prompt to user on current device
"RTN","HMPMONV",155,0)
 ; examples:
"RTN","HMPMONV",156,0)
 ;   [develop examples]
"RTN","HMPMONV",157,0)
 ;
"RTN","HMPMONV",158,0)
 do EN^DDIOL("",,"!")
"RTN","HMPMONV",159,0)
 new DONE set DONE=0 ; not yet done with loop
"RTN","HMPMONV",160,0)
 new TREE set TREE="HMOZ"
"RTN","HMPMONV",161,0)
 for  do  quit:HMPROMPT=U!DONE
"RTN","HMPMONV",162,0)
 . set TREE=$order(^XTMP(TREE))
"RTN","HMPMONV",163,0)
 . if $extract(TREE,1,3)'="HMP" do
"RTN","HMPMONV",164,0)
 . . set DONE=1
"RTN","HMPMONV",165,0)
 . . quit
"RTN","HMPMONV",166,0)
 . quit:DONE
"RTN","HMPMONV",167,0)
 . ;
"RTN","HMPMONV",168,0)
 . do VSHOWROW($name(^XTMP(TREE))) ; output row for node
"RTN","HMPMONV",169,0)
 . quit
"RTN","HMPMONV",170,0)
 quit:HMPROMPT=U
"RTN","HMPMONV",171,0)
 ;
"RTN","HMPMONV",172,0)
 do CHKIOSL^HMPMONL ; check for and handle end of page
"RTN","HMPMONV",173,0)
 ;
"RTN","HMPMONV",174,0)
 quit  ; end of VIEWXTMP
"RTN","HMPMONV",175,0)
 ;
"RTN","HMPMONV",176,0)
 ;
"RTN","HMPMONV",177,0)
VIEWTMP ; view ^tmp nodes
"RTN","HMPMONV",178,0)
 ;ven/toad;private;procedure;clean;dialog or silent;sac
"RTN","HMPMONV",179,0)
 ; called by:
"RTN","HMPMONV",180,0)
 ;   V
"RTN","HMPMONV",181,0)
 ; calls:
"RTN","HMPMONV",182,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONV",183,0)
 ;   VSHOWROW: show row for an ehmp global node
"RTN","HMPMONV",184,0)
 ;   CHKIOSL^HMPMONL: check for and handle end of page
"RTN","HMPMONV",185,0)
 ; input:
"RTN","HMPMONV",186,0)
 ;   input from the database
"RTN","HMPMONV",187,0)
 ;   end-of-page prompt input from user on current device
"RTN","HMPMONV",188,0)
 ; throughput: [passed through symbol table]
"RTN","HMPMONV",189,0)
 ;   HMPROMPT = current dashboard prompt, ^ = exit now [symbol table]
"RTN","HMPMONV",190,0)
 ; output:
"RTN","HMPMONV",191,0)
 ;   output to current device or output array
"RTN","HMPMONV",192,0)
 ;   end-of-page prompt to user on current device
"RTN","HMPMONV",193,0)
 ; examples:
"RTN","HMPMONV",194,0)
 ;   [develop examples]
"RTN","HMPMONV",195,0)
 ;
"RTN","HMPMONV",196,0)
 do EN^DDIOL("",,"!")
"RTN","HMPMONV",197,0)
 new DONE set DONE=0 ; not yet done with loop
"RTN","HMPMONV",198,0)
 new TREE set TREE="HMOZ"
"RTN","HMPMONV",199,0)
 for  do  quit:HMPROMPT=U!DONE
"RTN","HMPMONV",200,0)
 . set TREE=$order(^TMP(TREE))
"RTN","HMPMONV",201,0)
 . if $extract(TREE,1,3)'="HMP" do
"RTN","HMPMONV",202,0)
 . . set DONE=1
"RTN","HMPMONV",203,0)
 . . quit
"RTN","HMPMONV",204,0)
 . quit:DONE
"RTN","HMPMONV",205,0)
 . ;
"RTN","HMPMONV",206,0)
 . new JOB set JOB=0
"RTN","HMPMONV",207,0)
 . for  do  quit:HMPROMPT=U!'JOB
"RTN","HMPMONV",208,0)
 . . set JOB=$order(^TMP(TREE,JOB))
"RTN","HMPMONV",209,0)
 . . quit:'JOB
"RTN","HMPMONV",210,0)
 . . ;
"RTN","HMPMONV",211,0)
 . . do VSHOWROW($name(^TMP(TREE,JOB))) ; output row for node
"RTN","HMPMONV",212,0)
 . . quit
"RTN","HMPMONV",213,0)
 . quit
"RTN","HMPMONV",214,0)
 quit:HMPROMPT=U
"RTN","HMPMONV",215,0)
 ;
"RTN","HMPMONV",216,0)
 do CHKIOSL^HMPMONL ; check for and handle end of page
"RTN","HMPMONV",217,0)
 ;
"RTN","HMPMONV",218,0)
 quit  ; end of VIEWTMP
"RTN","HMPMONV",219,0)
 ;
"RTN","HMPMONV",220,0)
 ;
"RTN","HMPMONV",221,0)
VIEWTMPJ ; view ^tmp($job) nodes
"RTN","HMPMONV",222,0)
 ;ven/toad;private;procedure;clean;dialog or silent;sac
"RTN","HMPMONV",223,0)
 ; called by:
"RTN","HMPMONV",224,0)
 ;   V
"RTN","HMPMONV",225,0)
 ; calls:
"RTN","HMPMONV",226,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONV",227,0)
 ;   VSHOWROW: show row for an ehmp global node
"RTN","HMPMONV",228,0)
 ; input:
"RTN","HMPMONV",229,0)
 ;   input from the database
"RTN","HMPMONV",230,0)
 ;   end-of-page prompt input from user on current device
"RTN","HMPMONV",231,0)
 ; throughput: [passed through symbol table]
"RTN","HMPMONV",232,0)
 ;   HMPROMPT = current dashboard prompt, ^ = exit now [symbol table]
"RTN","HMPMONV",233,0)
 ; output:
"RTN","HMPMONV",234,0)
 ;   output to current device or output array
"RTN","HMPMONV",235,0)
 ;   end-of-page prompt to user on current device
"RTN","HMPMONV",236,0)
 ; examples:
"RTN","HMPMONV",237,0)
 ;   [develop examples]
"RTN","HMPMONV",238,0)
 ;
"RTN","HMPMONV",239,0)
 do EN^DDIOL("",,"!")
"RTN","HMPMONV",240,0)
 new JOB set JOB=0
"RTN","HMPMONV",241,0)
 for  do  quit:HMPROMPT=U!'JOB
"RTN","HMPMONV",242,0)
 . set JOB=$order(^TMP(JOB))
"RTN","HMPMONV",243,0)
 . quit:'JOB
"RTN","HMPMONV",244,0)
 . ;
"RTN","HMPMONV",245,0)
 . new DONE set DONE=0 ; not done with loop yet
"RTN","HMPMONV",246,0)
 . new TREE set TREE="HMOZ"
"RTN","HMPMONV",247,0)
 . for  do  quit:HMPROMPT=U!DONE
"RTN","HMPMONV",248,0)
 . . set TREE=$order(^TMP(JOB,TREE))
"RTN","HMPMONV",249,0)
 . . if $extract(TREE,1,3)'="HMP" do
"RTN","HMPMONV",250,0)
 . . . set DONE=1
"RTN","HMPMONV",251,0)
 . . . quit
"RTN","HMPMONV",252,0)
 . . quit:DONE
"RTN","HMPMONV",253,0)
 . . ;
"RTN","HMPMONV",254,0)
 . . do VSHOWROW($name(^TMP(JOB,TREE))) ; output row for node
"RTN","HMPMONV",255,0)
 . . quit
"RTN","HMPMONV",256,0)
 . quit
"RTN","HMPMONV",257,0)
 ;
"RTN","HMPMONV",258,0)
 quit  ; end of VIEWTMPJ
"RTN","HMPMONV",259,0)
 ;
"RTN","HMPMONV",260,0)
 ;
"RTN","HMPMONV",261,0)
VSHOWROW(NODE) ; show row for an ehmp global node
"RTN","HMPMONV",262,0)
 ;ven/toad;private;procedure;clean;dialog or silent;sac
"RTN","HMPMONV",263,0)
 ; called by:
"RTN","HMPMONV",264,0)
 ;   VIEWXTMP
"RTN","HMPMONV",265,0)
 ;   VIEWTMP
"RTN","HMPMONV",266,0)
 ;   VIEWTMPJ
"RTN","HMPMONV",267,0)
 ; calls:
"RTN","HMPMONV",268,0)
 ;   $$VROW = each row of the report
"RTN","HMPMONV",269,0)
 ;   EN^DDIOL: write output or load into output array
"RTN","HMPMONV",270,0)
 ;   CHKIOSL^HMPMONL: check for and handle end of page
"RTN","HMPMONV",271,0)
 ; input:
"RTN","HMPMONV",272,0)
 ;   NODE = namevalue of global node, e.g., "^XTMP(""THING"")"
"RTN","HMPMONV",273,0)
 ;   input from the database
"RTN","HMPMONV",274,0)
 ;   end-of-page prompt input from user on current device
"RTN","HMPMONV",275,0)
 ;   NODES = table definition for report [passed thru symbol table]
"RTN","HMPMONV",276,0)
 ; throughput: [passed through symbol table]
"RTN","HMPMONV",277,0)
 ;   HMPROMPT = current dashboard prompt, ^ = exit now [symbol table]
"RTN","HMPMONV",278,0)
 ; output:
"RTN","HMPMONV",279,0)
 ;   output row for node to current device or output array
"RTN","HMPMONV",280,0)
 ;   end-of-page prompt to user on current device
"RTN","HMPMONV",281,0)
 ; examples:
"RTN","HMPMONV",282,0)
 ;   [develop examples]
"RTN","HMPMONV",283,0)
 ;
"RTN","HMPMONV",284,0)
 new LAST set LAST=$order(@NODE@(" "),-1)
"RTN","HMPMONV",285,0)
 set:LAST="" LAST=$order(@NODE@(""),-1)
"RTN","HMPMONV",286,0)
 new ROW set ROW=$$VROW(.NODES,NODE,LAST)
"RTN","HMPMONV",287,0)
 do EN^DDIOL(ROW) ; display or load row of report
"RTN","HMPMONV",288,0)
 do CHKIOSL^HMPMONL ; check for and handle end of page
"RTN","HMPMONV",289,0)
 ;
"RTN","HMPMONV",290,0)
 quit  ; end of VSHOWROW
"RTN","HMPMONV",291,0)
 ;
"RTN","HMPMONV",292,0)
 ;
"RTN","HMPMONV",293,0)
VROW(NODES,NODE,LAST) ; row of the view-hmp-nodes report
"RTN","HMPMONV",294,0)
 ;ven/toad;private;function;clean;silent;sac
"RTN","HMPMONV",295,0)
 ; called by:
"RTN","HMPMONV",296,0)
 ;   VIEWXTMP
"RTN","HMPMONV",297,0)
 ;   VIEWTMP
"RTN","HMPMONV",298,0)
 ;   VIEWTMPJ
"RTN","HMPMONV",299,0)
 ; calls:
"RTN","HMPMONV",300,0)
 ;   SETCOL^HMPMONL: set a value into its column
"RTN","HMPMONV",301,0)
 ; input:
"RTN","HMPMONV",302,0)
 ;  .NODES = table definition for report (see example)
"RTN","HMPMONV",303,0)
 ;   NODE = current hmp temporary node
"RTN","HMPMONV",304,0)
 ;   LAST = high numeric or last subscript
"RTN","HMPMONV",305,0)
 ; output = report row for the node
"RTN","HMPMONV",306,0)
 ; examples:
"RTN","HMPMONV",307,0)
 ;   if:
"RTN","HMPMONV",308,0)
 ;     nodes(1,0) = "1^45^current hmp temporary nodes^l"
"RTN","HMPMONV",309,0)
 ;     nodes(2,0) = "50^79^high numeric or last subscript^l"
"RTN","HMPMONV",310,0)
 ;   [develop examples]
"RTN","HMPMONV",311,0)
 ;
"RTN","HMPMONV",312,0)
 new ROW set ROW="" ; initialize row
"RTN","HMPMONV",313,0)
 do SETCOL^HMPMONL(.ROW,.NODES,1,NODE)
"RTN","HMPMONV",314,0)
 do SETCOL^HMPMONL(.ROW,.NODES,2,LAST)
"RTN","HMPMONV",315,0)
 ;
"RTN","HMPMONV",316,0)
 quit ROW ; return row of report ; end of $$VROW
"RTN","HMPMONV",317,0)
 ;
"RTN","HMPMONV",318,0)
 ;
"RTN","HMPMONV",319,0)
EOR ; end of routine HMPMONV
"RTN","HMPMONX")
0^40^B51029601
"RTN","HMPMONX",1,0)
HMPMONX ;asmr-ven/toad-dashboard: xtmp size ;2016-06-29 19:42Z
"RTN","HMPMONX",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;April 14,2016;Build 24
"RTN","HMPMONX",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMONX",4,0)
 ;
"RTN","HMPMONX",5,0)
 quit  ; no entry from top of routine HMPMONX
"RTN","HMPMONX",6,0)
 ;
"RTN","HMPMONX",7,0)
 ; primary development
"RTN","HMPMONX",8,0)
 ;
"RTN","HMPMONX",9,0)
 ; primary developer: Frederick D. S. Marshall (toad)
"RTN","HMPMONX",10,0)
 ; original authors: Melanie Buechler (mkb) & Kevin Meldrum (kcm)
"RTN","HMPMONX",11,0)
 ; other authors: Jamshid Denegarian (jd) & Raymond Hsu (hsu)
"RTN","HMPMONX",12,0)
 ; original org: U.S. Department of Veterans Affairs (va)
"RTN","HMPMONX",13,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPMONX",14,0)
 ; development org: VISTA Expertise Network (ven)
"RTN","HMPMONX",15,0)
 ;
"RTN","HMPMONX",16,0)
 ; 2015-11-02/2016-02-29 va/hsu: refine HMPTOOLS, then develop
"RTN","HMPMONX",17,0)
 ; HMPDBMN1.
"RTN","HMPMONX",18,0)
 ;
"RTN","HMPMONX",19,0)
 ; 2016-03-21/04-14 asmr-ven/toad: create routine HMPMONX from
"RTN","HMPMONX",20,0)
 ; HMPTOOLS; add $$XTMPSIZE to include calculation and units;
"RTN","HMPMONX",21,0)
 ; replace write @IOF with do FORMFEED^HMPMONL; eliminate MON (old
"RTN","HMPMONX",22,0)
 ; XTMP monitor option will be retired), refactor top to bottom,
"RTN","HMPMONX",23,0)
 ; repair $$GETSIZE based on version in HMPUTILS; update comments to
"RTN","HMPMONX",24,0)
 ; capture calls into SIZE and $$GETSIZE; fix org & history.
"RTN","HMPMONX",25,0)
 ;
"RTN","HMPMONX",26,0)
 ; 2016-04-14 asmr/bl HMP*2.0*2: update lines 2 & 3, cut EOR line.
"RTN","HMPMONX",27,0)
 ;
"RTN","HMPMONX",28,0)
 ; 2016-06-29 ven/toad: XINDEX is four years behind 2012 VA SAC;
"RTN","HMPMONX",29,0)
 ; convert variables to uppercase; restore EOR line.
"RTN","HMPMONX",30,0)
 ;
"RTN","HMPMONX",31,0)
 ;
"RTN","HMPMONX",32,0)
 ; contents
"RTN","HMPMONX",33,0)
 ;
"RTN","HMPMONX",34,0)
 ; $$XTMPSIZE = approximate size of ehmp's xtmp use in kb
"RTN","HMPMONX",35,0)
 ; SIZE: remote procedure HMP GLOBAL SIZE: return ^XTMP size
"RTN","HMPMONX",36,0)
 ; $$GETSIZE = size of extracts waiting to send
"RTN","HMPMONX",37,0)
 ; $$WALK = walk domain objects in task to get actual size
"RTN","HMPMONX",38,0)
 ; CHKXTMP: remote procedure HMP CHKXTMP: return ^XTMP state
"RTN","HMPMONX",39,0)
 ;
"RTN","HMPMONX",40,0)
 ;
"RTN","HMPMONX",41,0)
 ; to do
"RTN","HMPMONX",42,0)
 ;
"RTN","HMPMONX",43,0)
 ; convert hard-coded text to Dialog file entries
"RTN","HMPMONX",44,0)
 ; replace writes with new writer that can reroute output to arrays
"RTN","HMPMONX",45,0)
 ; replace reader calls with new reader that can:
"RTN","HMPMONX",46,0)
 ;   1. take pre-answers from arrays
"RTN","HMPMONX",47,0)
 ;   2. write all outputs to arrays
"RTN","HMPMONX",48,0)
 ;   3. with each feature independently adjustable
"RTN","HMPMONX",49,0)
 ; create unit tests
"RTN","HMPMONX",50,0)
 ; change call to top into call to unit tests
"RTN","HMPMONX",51,0)
 ;
"RTN","HMPMONX",52,0)
 ;
"RTN","HMPMONX",53,0)
XTMPSIZE() ; approximate size of ehmp's xtmp use in kb
"RTN","HMPMONX",54,0)
 ;ven/toad;private;function;clean;silent;sac
"RTN","HMPMONX",55,0)
 ; called by:
"RTN","HMPMONX",56,0)
 ;   $$SXTMPSIZ^HMPMOND: screen-field xtmp-size
"RTN","HMPMONX",57,0)
 ; calls:
"RTN","HMPMONX",58,0)
 ;   $$GETSIZE = size of extracts waiting to send
"RTN","HMPMONX",59,0)
 ; input:
"RTN","HMPMONX",60,0)
 ; output = size in kb
"RTN","HMPMONX",61,0)
 ; examples:
"RTN","HMPMONX",62,0)
 ;   [develop examples]
"RTN","HMPMONX",63,0)
 ;
"RTN","HMPMONX",64,0)
 new XTMPKB set XTMPKB=$$GETSIZE("actual")/1000+.5 ; kilobytes
"RTN","HMPMONX",65,0)
 set XTMPKB=XTMPKB_" KB"
"RTN","HMPMONX",66,0)
 ;
"RTN","HMPMONX",67,0)
 quit XTMPKB ; return size of xtmp ; end of $$XTMPSIZE
"RTN","HMPMONX",68,0)
 ;
"RTN","HMPMONX",69,0)
 ;
"RTN","HMPMONX",70,0)
SIZE(RESULT) ; remote procedure HMP GLOBAL SIZE: return ^XTMP size
"RTN","HMPMONX",71,0)
 ;islc/mkb&kcm,ven/toad;private;procedure;clean;silent;sac
"RTN","HMPMONX",72,0)
 ; called by:
"RTN","HMPMONX",73,0)
 ;   remote procedure HMP GLOBAL SIZE
"RTN","HMPMONX",74,0)
 ; calls:
"RTN","HMPMONX",75,0)
 ;   $$GETSIZE = size of extracts waiting to send
"RTN","HMPMONX",76,0)
 ; input:
"RTN","HMPMONX",77,0)
 ;   from the database, within $$GETSIZE
"RTN","HMPMONX",78,0)
 ; output:
"RTN","HMPMONX",79,0)
 ;  .RESULT
"RTN","HMPMONX",80,0)
 ; examples:
"RTN","HMPMONX",81,0)
 ;   [develop examples]
"RTN","HMPMONX",82,0)
 ;
"RTN","HMPMONX",83,0)
 set RESULT(1)=$piece($$GETSIZE("actual"),"^")
"RTN","HMPMONX",84,0)
 ;
"RTN","HMPMONX",85,0)
 quit
"RTN","HMPMONX",86,0)
 ;
"RTN","HMPMONX",87,0)
 ;
"RTN","HMPMONX",88,0)
GETSIZE(MODE,SERVER) ; size of extracts waiting to send
"RTN","HMPMONX",89,0)
 ;islc/mkb&kcm,ven/toad;private;function;clean;silent;sac
"RTN","HMPMONX",90,0)
 ; called by:
"RTN","HMPMONX",91,0)
 ;   $$XTMPSIZE = approximate size of ehmp's xtmp use in kb
"RTN","HMPMONX",92,0)
 ;   SIZE: remote procedure HMP GLOBAL SIZE: return ^XTMP size
"RTN","HMPMONX",93,0)
 ;   $$CHKSIZE^HMPDJFSP: Aggregate extract ^XTMP size strategy
"RTN","HMPMONX",94,0)
 ;   MESNOK^HMPMETA: Mail message if ^XTMP too big
"RTN","HMPMONX",95,0)
 ; calls:
"RTN","HMPMONX",96,0)
 ;   GETLST^XPAR: get typical sizes of ehmp domains
"RTN","HMPMONX",97,0)
 ;   $$WALK = walk domain objects in task to get actual size
"RTN","HMPMONX",98,0)
 ; input:
"RTN","HMPMONX",99,0)
 ;    MODE = "estimate" = use estimated domain average sizes, default
"RTN","HMPMONX",100,0)
 ;           "actual" = walk object nodes to calculate using $length
"RTN","HMPMONX",101,0)
 ;    SERVER = name of ehmp server, defaults to all ehmp servers
"RTN","HMPMONX",102,0)
 ; output = size in bytes ^ object count
"RTN","HMPMONX",103,0)
 ; examples:
"RTN","HMPMONX",104,0)
 ;   [develop examples]
"RTN","HMPMONX",105,0)
 ;
"RTN","HMPMONX",106,0)
 set MODE=$get(MODE,"estimate")
"RTN","HMPMONX",107,0)
 new OBJSIZES
"RTN","HMPMONX",108,0)
 if MODE="estimate" do
"RTN","HMPMONX",109,0)
 . do GETLST^XPAR(.OBJSIZES,"PKG","HMP DOMAIN SIZES","I")
"RTN","HMPMONX",110,0)
 . quit
"RTN","HMPMONX",111,0)
 ;
"RTN","HMPMONX",112,0)
 new SIZE set SIZE=0
"RTN","HMPMONX",113,0)
 new OBJECTS set OBJECTS=0
"RTN","HMPMONX",114,0)
 new DONE set DONE=0
"RTN","HMPMONX",115,0)
 ;
"RTN","HMPMONX",116,0)
 set SERVER=$get(SERVER)
"RTN","HMPMONX",117,0)
 new ROOT set ROOT="HMPFX~" ; root for all servers
"RTN","HMPMONX",118,0)
 if SERVER'="" do  ; if size for just one server
"RTN","HMPMONX",119,0)
 . set ROOT=ROOT_SERVER_"~" ; change root
"RTN","HMPMONX",120,0)
 . quit
"RTN","HMPMONX",121,0)
 new BATCH set BATCH=ROOT
"RTN","HMPMONX",122,0)
 ;
"RTN","HMPMONX",123,0)
 for  do  quit:DONE  ; traverse extracts
"RTN","HMPMONX",124,0)
 . set BATCH=$order(^XTMP(BATCH)) ; get next extract
"RTN","HMPMONX",125,0)
 . set DONE=BATCH="" ; out of ^XTMP nodes?
"RTN","HMPMONX",126,0)
 . quit:DONE
"RTN","HMPMONX",127,0)
 . ;
"RTN","HMPMONX",128,0)
 . set DONE=$extract(BATCH,1,$length(ROOT))'=ROOT
"RTN","HMPMONX",129,0)
 . set DONE=$piece(BATCH,ROOT)'="" ; out of nodes with root prefix?
"RTN","HMPMONX",130,0)
 . quit:DONE
"RTN","HMPMONX",131,0)
 . ;
"RTN","HMPMONX",132,0)
 . new TASK set TASK=0
"RTN","HMPMONX",133,0)
 . for  do  quit:'TASK  ; traverse extract tasks
"RTN","HMPMONX",134,0)
 . . set TASK=$order(^XTMP(BATCH,TASK)) ; get next task
"RTN","HMPMONX",135,0)
 . . quit:'TASK
"RTN","HMPMONX",136,0)
 . . ;
"RTN","HMPMONX",137,0)
 . . new DOMAIN set DOMAIN=""
"RTN","HMPMONX",138,0)
 . . for  do  quit:DOMAIN=""  ; traverse domains
"RTN","HMPMONX",139,0)
 . . . set DOMAIN=$order(^XTMP(BATCH,TASK,DOMAIN)) ; get next domain
"RTN","HMPMONX",140,0)
 . . . quit:DOMAIN=""
"RTN","HMPMONX",141,0)
 . . . ;
"RTN","HMPMONX",142,0)
 . . . new DOMOBJS
"RTN","HMPMONX",143,0)
 . . . set DOMOBJS=+$order(^XTMP(BATCH,TASK,DOMAIN," "),-1)
"RTN","HMPMONX",144,0)
 . . . set OBJECTS=OBJECTS+DOMOBJS
"RTN","HMPMONX",145,0)
 . . . ;
"RTN","HMPMONX",146,0)
 . . . if MODE="actual" do  ; for actual-mode
"RTN","HMPMONX",147,0)
 . . . . set SIZE=SIZE+$$WALK(BATCH,TASK,DOMAIN)
"RTN","HMPMONX",148,0)
 . . . . quit
"RTN","HMPMONX",149,0)
 . . . else  do  ; for estimate-mode
"RTN","HMPMONX",150,0)
 . . . . new DOMNAME set DOMNAME=$piece(DOMAIN,"#")
"RTN","HMPMONX",151,0)
 . . . . new DOMSIZE set DOMSIZE=$get(OBJSIZES(DOMNAME),1000)
"RTN","HMPMONX",152,0)
 . . . . set SIZE=DOMOBJS*DOMSIZE+SIZE
"RTN","HMPMONX",153,0)
 . . . . quit
"RTN","HMPMONX",154,0)
 . . . quit
"RTN","HMPMONX",155,0)
 . . quit
"RTN","HMPMONX",156,0)
 . quit
"RTN","HMPMONX",157,0)
 ;
"RTN","HMPMONX",158,0)
 quit SIZE_"^"_OBJECTS
"RTN","HMPMONX",159,0)
 ;
"RTN","HMPMONX",160,0)
 ;
"RTN","HMPMONX",161,0)
WALK(BATCH,TASK,DOMAIN) ; walk domain objects in task to get actual size
"RTN","HMPMONX",162,0)
 ;islc/mkb&kcm,ven/toad;private;function;clean;silent;sac
"RTN","HMPMONX",163,0)
 ; called by:
"RTN","HMPMONX",164,0)
 ;   $$GETSIZE = size of extracts waiting to send
"RTN","HMPMONX",165,0)
 ; calls: none
"RTN","HMPMONX",166,0)
 ; input:
"RTN","HMPMONX",167,0)
 ;   BATCH = extract-batch id
"RTN","HMPMONX",168,0)
 ;   TASK = extract-batch task #
"RTN","HMPMONX",169,0)
 ;   DOMAIN = extract-batch domain id
"RTN","HMPMONX",170,0)
 ; output = size of domain objects
"RTN","HMPMONX",171,0)
 ; examples:
"RTN","HMPMONX",172,0)
 ;   [develop examples]
"RTN","HMPMONX",173,0)
 ;
"RTN","HMPMONX",174,0)
 new SIZE set SIZE=0
"RTN","HMPMONX",175,0)
 new OBJECT set OBJECT=0
"RTN","HMPMONX",176,0)
 for  do  quit:'OBJECT
"RTN","HMPMONX",177,0)
 . set OBJECT=$order(^XTMP(BATCH,TASK,DOMAIN,OBJECT))
"RTN","HMPMONX",178,0)
 . quit:'OBJECT
"RTN","HMPMONX",179,0)
 . new NODE set NODE=0
"RTN","HMPMONX",180,0)
 . for  do  quit:'NODE
"RTN","HMPMONX",181,0)
 . . set NODE=$order(^XTMP(BATCH,TASK,DOMAIN,OBJECT,NODE))
"RTN","HMPMONX",182,0)
 . . quit:'NODE
"RTN","HMPMONX",183,0)
 . . set SIZE=SIZE+$length($get(^XTMP(BATCH,TASK,DOMAIN,OBJECT,NODE)))
"RTN","HMPMONX",184,0)
 . . quit
"RTN","HMPMONX",185,0)
 . quit
"RTN","HMPMONX",186,0)
 ;
"RTN","HMPMONX",187,0)
 quit SIZE ; return size of domain objects ; end of $$WALK
"RTN","HMPMONX",188,0)
 ;
"RTN","HMPMONX",189,0)
 ;
"RTN","HMPMONX",190,0)
CHKXTMP(RESULT) ; remote procedure HMP CHKXTMP: return ^XTMP state
"RTN","HMPMONX",191,0)
 ;islc/mkb&kcm,ven/toad;private;function;clean;silent;sac
"RTN","HMPMONX",192,0)
 ; called by:
"RTN","HMPMONX",193,0)
 ;   remote procedure HMP CHKXTMP
"RTN","HMPMONX",194,0)
 ;   $$SQUEUE^HMPMOND: screen-field queue status
"RTN","HMPMONX",195,0)
 ; calls: none
"RTN","HMPMONX",196,0)
 ; input:
"RTN","HMPMONX",197,0)
 ; output:
"RTN","HMPMONX",198,0)
 ;  .RESULT = return erray
"RTN","HMPMONX",199,0)
 ;        "There are a total of xxx patients in queue.  yyy Complete"
"RTN","HMPMONX",200,0)
 ;        "zzz Staging", where xxx,yyy, and zzz are zero or greater.
"RTN","HMPMONX",201,0)
 ;        note: if xxx is zero, the sentence after "queue." will not
"RTN","HMPMONX",202,0)
 ;        be displayed
"RTN","HMPMONX",203,0)
 ; examples:
"RTN","HMPMONX",204,0)
 ;   [develop examples]
"RTN","HMPMONX",205,0)
 ;
"RTN","HMPMONX",206,0)
 ; Goes through ^XTMP and figures out the total number of patients, how many
"RTN","HMPMONX",207,0)
 ; have completed data staging, and how many are still staging.
"RTN","HMPMONX",208,0)
 ; There is code to allow a bit more information than requested to be stored
"RTN","HMPMONX",209,0)
 ; in a global (^TMP("FINDSTATUS",$J)) for future needs (e.g. Complete/staging
"RTN","HMPMONX",210,0)
 ; is broken down by domain).  *** This currently commented out ***.
"RTN","HMPMONX",211,0)
 ;
"RTN","HMPMONX",212,0)
 ; ^XTMP("HMPFX~<server id>~DFN",0,"status",<domain>) = status, where
"RTN","HMPMONX",213,0)
 ; status = 1 means data is completely staged and 0 means data is being
"RTN","HMPMONX",214,0)
 ; staged but not complete yet.
"RTN","HMPMONX",215,0)
 ;
"RTN","HMPMONX",216,0)
 ; GLB      = ^TMP("FINDSTATUS",$job)  (FUTURE USE)
"RTN","HMPMONX",217,0)
 ; BATCH    = "HMPFX~<sever id>~DFN"
"RTN","HMPMONX",218,0)
 ; PATDONE  = Number of patients who have completed staging
"RTN","HMPMONX",219,0)
 ; DOMDONE  = Number of domains that have completed staging for a patient
"RTN","HMPMONX",220,0)
 ; DOMSTAT  = Domain status (1 = complete; 0 = staging)
"RTN","HMPMONX",221,0)
 ; PATIENT  = Patient IEN
"RTN","HMPMONX",222,0)
 ; DOMAIN   = Patient domain (e.g. lab, med, allergy, etc.)
"RTN","HMPMONX",223,0)
 ; PATSTAGE = Number of patients who are still in the staging state
"RTN","HMPMONX",224,0)
 ; DOMSTAGE = Number of domains that are still staging for a patient
"RTN","HMPMONX",225,0)
 ; TOTAL    = PATDONE+PATSTAGE
"RTN","HMPMONX",226,0)
 ;
"RTN","HMPMONX",227,0)
 ; new GLB set GLB=$name(^TMP("FINDSTATUS",$job))
"RTN","HMPMONX",228,0)
 ; kill @GLB
"RTN","HMPMONX",229,0)
 new PATDONE set PATDONE=0
"RTN","HMPMONX",230,0)
 new PATSTAGE set PATSTAGE=0
"RTN","HMPMONX",231,0)
 new EXIT set EXIT=0
"RTN","HMPMONX",232,0)
 new BATCH set BATCH="HMPFX"
"RTN","HMPMONX",233,0)
 for  do  quit:EXIT
"RTN","HMPMONX",234,0)
 . set BATCH=$order(^XTMP(BATCH))
"RTN","HMPMONX",235,0)
 . set EXIT=BATCH="" ; out of ^xtmp nodes
"RTN","HMPMONX",236,0)
 . quit:EXIT
"RTN","HMPMONX",237,0)
 . ;
"RTN","HMPMONX",238,0)
 . set EXIT=$piece(BATCH,"HMPFX")'=""
"RTN","HMPMONX",239,0)
 . quit:EXIT
"RTN","HMPMONX",240,0)
 . ;
"RTN","HMPMONX",241,0)
 . new PATIENT set PATIENT=$piece(BATCH,"~",3)
"RTN","HMPMONX",242,0)
 . new DOMDONE set DOMDONE=0
"RTN","HMPMONX",243,0)
 . new DOMSTAGE set DOMSTAGE=0
"RTN","HMPMONX",244,0)
 . quit:PATIENT'=+PATIENT  ; patients only
"RTN","HMPMONX",245,0)
 . ;
"RTN","HMPMONX",246,0)
 . new DOMAIN set DOMAIN=""
"RTN","HMPMONX",247,0)
 . for  do  quit:DOMAIN=""
"RTN","HMPMONX",248,0)
 . . set DOMAIN=$order(^XTMP(BATCH,0,"status",DOMAIN))
"RTN","HMPMONX",249,0)
 . . quit:DOMAIN=""
"RTN","HMPMONX",250,0)
 . . new DOMSTAT set DOMSTAT=^XTMP(BATCH,0,"status",DOMAIN)
"RTN","HMPMONX",251,0)
 . . if DOMSTAT=1 do
"RTN","HMPMONX",252,0)
 . . . set DOMDONE=DOMDONE+1
"RTN","HMPMONX",253,0)
 . . . ; set @GLB@(PATIENT,DOMAIN)="Complete"
"RTN","HMPMONX",254,0)
 . . . quit
"RTN","HMPMONX",255,0)
 . . if DOMSTAT'=1 do
"RTN","HMPMONX",256,0)
 . . . set DOMSTAGE=DOMSTAGE+1
"RTN","HMPMONX",257,0)
 . . . ; set @GLB@(PATIENT,DOMAIN)="Staging"
"RTN","HMPMONX",258,0)
 . . . quit
"RTN","HMPMONX",259,0)
 . . quit
"RTN","HMPMONX",260,0)
 . ;
"RTN","HMPMONX",261,0)
 . if DOMSTAGE>0 do
"RTN","HMPMONX",262,0)
 . . set PATSTAGE=PATSTAGE+1
"RTN","HMPMONX",263,0)
 . . ; set @GLB@(PATIENT)="Staging"
"RTN","HMPMONX",264,0)
 . . quit
"RTN","HMPMONX",265,0)
 . if DOMSTAGE'>0 do
"RTN","HMPMONX",266,0)
 . . set PATDONE=PATDONE+1
"RTN","HMPMONX",267,0)
 . . ; set @GLB@(PATIENT)="Complete"
"RTN","HMPMONX",268,0)
 . . quit
"RTN","HMPMONX",269,0)
 . quit
"RTN","HMPMONX",270,0)
 ;
"RTN","HMPMONX",271,0)
 new TOTAL set TOTAL=PATDONE+PATSTAGE
"RTN","HMPMONX",272,0)
 ;
"RTN","HMPMONX",273,0)
 kill RESULT
"RTN","HMPMONX",274,0)
 set RESULT(1)="There are a total of "_TOTAL_" patient"
"RTN","HMPMONX",275,0)
 set RESULT(1)=RESULT(1)_$select(TOTAL=1:"",1:"s")_" in queue."
"RTN","HMPMONX",276,0)
 if PATDONE>0 do
"RTN","HMPMONX",277,0)
 . set RESULT(1)=RESULT(1)_"  "_PATDONE_" Complete"
"RTN","HMPMONX",278,0)
 . quit
"RTN","HMPMONX",279,0)
 if PATSTAGE>0 do
"RTN","HMPMONX",280,0)
 . set RESULT(1)=RESULT(1)_"  "_PATSTAGE_" Staging"
"RTN","HMPMONX",281,0)
 . quit
"RTN","HMPMONX",282,0)
 ;
"RTN","HMPMONX",283,0)
 quit
"RTN","HMPMONX",284,0)
 ;
"RTN","HMPMONX",285,0)
 ;
"RTN","HMPMONX",286,0)
EOR ; end of routine HMPMONX
"RTN","HMPOR")
0^41^B51019081
"RTN","HMPOR",1,0)
HMPOR ;ASMR/CK,hrubovcak - Order file support;Feb 01, 2016 14:28:49
"RTN","HMPOR",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Build 4;Build 24
"RTN","HMPOR",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPOR",4,0)
 ;
"RTN","HMPOR",5,0)
 ; routine created for US11894, December 17, 2015
"RTN","HMPOR",6,0)
 Q
"RTN","HMPOR",7,0)
 ;
"RTN","HMPOR",8,0)
ADDFLAG(HMRSLT,HMVALS,HMORIFN,HMDFN,HMORLVL) ; LAYGO flag action into HMP SUBSCRIPTION file (#800000)
"RTN","HMPOR",9,0)
 ; HMRSLT - result, passed-by-ref.,  1 on success else "-1^error message"
"RTN","HMPOR",10,0)
 ;parameters below required
"RTN","HMPOR",11,0)
 ; HMVALS - array of values, subscripted by field #, passed-by-ref.
"RTN","HMPOR",12,0)
 ; HMORIFN - Order IFN
"RTN","HMPOR",13,0)
 ; HMDFN - patient DFN
"RTN","HMPOR",14,0)
 ; HMORLVL = ^OR(100,HMORIFN,8,level) OPTIONAL, used from within OE/RR
"RTN","HMPOR",15,0)
 ;
"RTN","HMPOR",16,0)
 S HMRSLT="-1^parameter missing"  ; initialize return
"RTN","HMPOR",17,0)
 Q:'($G(HMORIFN)>0)!'($G(HMDFN)>0)  ; must have Order IFN and patient DFN
"RTN","HMPOR",18,0)
 Q:'$G(HMVALS(.01))  ; must have date/time at minimum
"RTN","HMPOR",19,0)
 ;
"RTN","HMPOR",20,0)
 N FMSG,HMFDA,HMIENS,HMSRVR,J,SUB,X
"RTN","HMPOR",21,0)
 S HMSRVR=$$SRVRNO(HMDFN)
"RTN","HMPOR",22,0)
 I '(HMSRVR>0) S HMRSLT="-1^HMP server not found to add flag data." Q
"RTN","HMPOR",23,0)
 ;
"RTN","HMPOR",24,0)
 S X=$$GET1^DIQ(100,HMORIFN_",",.02,"I")  ; (#.02) OBJECT OF ORDER
"RTN","HMPOR",25,0)
 I '($P(X,";",2)="DPT(") S HMRSLT="-1^Order DFN not found" Q  ; not a patient
"RTN","HMPOR",26,0)
 S HMDFN=+X I '$D(^HMP(800000,HMSRVR,1,HMDFN,0)) S HMRSLT="-1^DFN "_HMDFN_" not subscribed." Q  ; not subscribed
"RTN","HMPOR",27,0)
 ;
"RTN","HMPOR",28,0)
 ; If Order not in HMP sub-file then LAYGO it in
"RTN","HMPOR",29,0)
 I '$D(^HMP(800000,HMSRVR,1,HMDFN,1,HMORIFN,0)) D
"RTN","HMPOR",30,0)
 . N HMVALS,RSLT,VALS  ; protect the values in HMVALS
"RTN","HMPOR",31,0)
 . S VALS(.15)=$$NOW^XLFDT  ; Order Action Date/Time
"RTN","HMPOR",32,0)
 . D ADDORDR(.RSLT,.VALS,HMORIFN,HMDFN,HMORLVL)  ; DE3584 Jan 27, 2016
"RTN","HMPOR",33,0)
 ;
"RTN","HMPOR",34,0)
 S SUB="+1,"_HMORIFN_","_HMDFN_","_HMSRVR_","
"RTN","HMPOR",35,0)
 F J=.01,.02,.03,.04 S:$G(HMVALS(J))]"" HMFDA(800000.142,SUB,J)=HMVALS(J)
"RTN","HMPOR",36,0)
 D UPDATE^DIE("","HMFDA","HMIENS","FMSG") ; HMIENS coming back from call
"RTN","HMPOR",37,0)
 ;
"RTN","HMPOR",38,0)
 D  ; update date and time for lastUpdateTime in HMPSTMP
"RTN","HMPOR",39,0)
 . N HMVALS,RSLT,VALS  ; protect the values in HMVALS
"RTN","HMPOR",40,0)
 . S VALS(.15)=$$NOW^XLFDT  ; Order Action Date/Time
"RTN","HMPOR",41,0)
 . D UPDTORDR(.RSLT,.VALS,HMORIFN,HMDFN)
"RTN","HMPOR",42,0)
 ;
"RTN","HMPOR",43,0)
 S HMRSLT=$S($D(FMSG):"-^FM error in ADDFLAG",1:1)
"RTN","HMPOR",44,0)
 ;
"RTN","HMPOR",45,0)
 Q
"RTN","HMPOR",46,0)
 ;
"RTN","HMPOR",47,0)
ADDORDR(HMRSLT,HMVALS,HMORIFN,HMDFN,HMORLVL) ; LAYGO order into HMP SUBSCRIPTION file (#800000), sub-file 800000.14
"RTN","HMPOR",48,0)
 ; HMRSLT - return value passed-by-ref., 1 on success else "-1^error message"
"RTN","HMPOR",49,0)
 ;parameters below required
"RTN","HMPOR",50,0)
 ; HMVALS - array of values, subscripted by field #, passed-by-ref.
"RTN","HMPOR",51,0)
 ;   note: HMVALS(.01) not needed, it's the DINUM value below
"RTN","HMPOR",52,0)
 ; HMORIFN - Order IFN
"RTN","HMPOR",53,0)
 ; HMDFN - patient's DFN
"RTN","HMPOR",54,0)
 ; HMORLVL = ^OR(100,HMORIFN,8,level) OPTIONAL, used from within OE/RR
"RTN","HMPOR",55,0)
 ;
"RTN","HMPOR",56,0)
 S HMRSLT="-1^parameter missing"  ; initialize return
"RTN","HMPOR",57,0)
 Q:'($G(HMORIFN)>0)!'($G(HMDFN)>0)  ; must have Order IFN and DFN
"RTN","HMPOR",58,0)
 Q:'$O(HMVALS(0))  ; must have FileMan data array
"RTN","HMPOR",59,0)
 ;
"RTN","HMPOR",60,0)
 N A,FMSG,HMFDA,HMIENS,HMSRVR,J,L,SUB
"RTN","HMPOR",61,0)
 S HMSRVR=$$SRVRNO(HMDFN)  ; server number subscribed to
"RTN","HMPOR",62,0)
 I '(HMSRVR>0) S HMRSLT="-1^HMP server not found for DFN "_HMDFN Q  ; not subscribed
"RTN","HMPOR",63,0)
 I $D(^HMP(800000,HMSRVR,1,HMDFN,1,"B",HMORIFN)) S HMRSLT="-1^ORDER "_HMORIFN_" already tracked." Q  ; duplicate Order creation
"RTN","HMPOR",64,0)
 ;
"RTN","HMPOR",65,0)
 S HMIENS(1)=HMORIFN  ; new IEN assignment, DINUM relationship
"RTN","HMPOR",66,0)
 S SUB="+1,"_HMDFN_","_HMSRVR_","  ; IENS subscript
"RTN","HMPOR",67,0)
 S HMFDA(800000.14,SUB,.01)=HMORIFN
"RTN","HMPOR",68,0)
 ; loop below starts after .01 because of line above
"RTN","HMPOR",69,0)
 S J=.01 F  S J=$O(HMVALS(J)) Q:'J  S HMFDA(800000.14,SUB,J)=HMVALS(J)
"RTN","HMPOR",70,0)
 S HMFDA(800000.14,SUB,1.01)=$$NOW^XLFDT  ; (#1.01) TRACKING START, Jan 26, 2016 - DE3584
"RTN","HMPOR",71,0)
 D UPDATE^DIE("","HMFDA","HMIENS","FMSG")
"RTN","HMPOR",72,0)
 ; if duplicate IEN FileMan returns error
"RTN","HMPOR",73,0)
 S HMRSLT=$S($D(FMSG):"-1^FM error in ADDORDR",1:1)
"RTN","HMPOR",74,0)
 ;DE3584 Jan 27, 2016
"RTN","HMPOR",75,0)
 S L=+$G(HMORLVL)  ; if >zero then call is from OE/RR (OPTIONAL)
"RTN","HMPOR",76,0)
 S A=$P($G(HMORLVL),";",2)  ; second ; piece is FLAG/UNFLAG (OPTIONAL)
"RTN","HMPOR",77,0)
 ;
"RTN","HMPOR",78,0)
 ; Jan 27, 2016 - DE3584 begin
"RTN","HMPOR",79,0)
 D  ; add any flag/unflag activity
"RTN","HMPOR",80,0)
 . N RSLT,VALS,Y
"RTN","HMPOR",81,0)
 . S J=0 F  S J=$O(^OR(100,HMORIFN,8,J)) Q:'J  D
"RTN","HMPOR",82,0)
 ..  S Y=$G(^OR(100,HMORIFN,8,J,3))  ; flag/unflag actions
"RTN","HMPOR",83,0)
 ..  I $P(Y,U,3) D  ; always check for flag action first
"RTN","HMPOR",84,0)
 ...   I L=J,A="F" Q  ; call from OE/RR, Flag will be added there
"RTN","HMPOR",85,0)
 ...   ; (#33) DATE/TIME FLAGGED [3D] ^ (#34) FLAGGED BY [4P:200] ^(#35) REASON FOR FLAG [5F]
"RTN","HMPOR",86,0)
 ...   K RSLT,VALS S VALS(.01)=$P(Y,U,3),VALS(.02)="F",VALS(.03)=$P(Y,U,4),VALS(.04)=$P(Y,U,5)
"RTN","HMPOR",87,0)
 ...   D ADDFLAG(.RSLT,.VALS,HMORIFN,HMDFN)
"RTN","HMPOR",88,0)
 ..  I $P(Y,U,6) D  ; check for unflag action
"RTN","HMPOR",89,0)
 ...   ; (#36) DATE/TIME UNFLAGGED [6D] ^ (#37) UNFLAGGED BY [7P:200] ^ (#38) REASON FOR UNFLAG [8F]
"RTN","HMPOR",90,0)
 ...   I L=J,A="U" Q  ; call from OE/RR, Unflag will be added there
"RTN","HMPOR",91,0)
 ...   K RSLT,VALS S VALS(.01)=$P(Y,U,6),VALS(.02)="U",VALS(.03)=$P(Y,U,7),VALS(.04)=$P(Y,U,8)
"RTN","HMPOR",92,0)
 ...   D ADDFLAG(.RSLT,.VALS,HMORIFN,HMDFN)
"RTN","HMPOR",93,0)
 ; Jan 27, 2016 - DE3584 end
"RTN","HMPOR",94,0)
 Q
"RTN","HMPOR",95,0)
 ;
"RTN","HMPOR",96,0)
DELORDR(HMPDFN,HMIFN) ; delete entry in ORDERS sub-file
"RTN","HMPOR",97,0)
 ;
"RTN","HMPOR",98,0)
 N DA,DIK,SRVNM
"RTN","HMPOR",99,0)
 S SRVNM=$$SRVRNO(+$G(HMPDFN)) Q:'(SRVNM>0)  ; get server number, quit if not found
"RTN","HMPOR",100,0)
 S DIK="^HMP(800000,"_SRVNM_",1,"_(+$G(HMPDFN))_",1,"  ; needs server IEN and patient IEN
"RTN","HMPOR",101,0)
 S DA=+$G(HMIFN),DA(1)=+$G(HMPDFN),DA(2)=SRVNM
"RTN","HMPOR",102,0)
 D ^DIK
"RTN","HMPOR",103,0)
 Q
"RTN","HMPOR",104,0)
 ;
"RTN","HMPOR",105,0)
ORDRCHK(HMORIFN,HMDFN) ; Boolean function, does ORDER number HMPORIFN exist in ^HMP(800000) for patient HMDFN
"RTN","HMPOR",106,0)
 ; DE3504 - Jan 19, 2016
"RTN","HMPOR",107,0)
 N RSLT,SRVNM
"RTN","HMPOR",108,0)
 S RSLT=0  ; default to zero
"RTN","HMPOR",109,0)
 S SRVNM=$$SRVRNO(+$G(HMDFN)) Q:'(SRVNM>0) RSLT  ; server not found, return zero ; Jan 26, 2016 - DE3584
"RTN","HMPOR",110,0)
 S:$D(^HMP(800000,SRVNM,1,+$G(HMDFN),1,+$G(HMORIFN),0)) RSLT=1  ; order exists in ^HMP(800000)
"RTN","HMPOR",111,0)
 Q RSLT
"RTN","HMPOR",112,0)
 ;
"RTN","HMPOR",113,0)
ORDRVALS(HMFLDS,HMORIFN) ; map ORDER ACTIONS (#100.008) to ORDERS sub-file (#800000.14) Feb 1, 2016
"RTN","HMPOR",114,0)
 ; HMFLDS returned by reference
"RTN","HMPOR",115,0)
 ; HMORIFN order IFN (Required)
"RTN","HMPOR",116,0)
 ;
"RTN","HMPOR",117,0)
 N FLD,HMERR,HMIENS,HMORVALS,IEN,ORENTDT,SUBFL
"RTN","HMPOR",118,0)
 K HMFLDS  ; returned by reference
"RTN","HMPOR",119,0)
 I '($G(HMORIFN)>0) S HMFLDS("ERR")="ORDER IEN required in routine "_$T(+0) Q
"RTN","HMPOR",120,0)
 ;
"RTN","HMPOR",121,0)
 S HMIENS=(+HMORIFN)_","  ; IENS for Fileman
"RTN","HMPOR",122,0)
 S ORENTDT=$$GET1^DIQ(100,HMIENS,4,"I")  ; WHEN ENTERED, from ORDER file
"RTN","HMPOR",123,0)
 D GETS^DIQ(100,HMIENS,".8*","IN","HMORVALS","HMERR")  ; internal values, ignore null values
"RTN","HMPOR",124,0)
 I $D(HMERR) M HMFLDS("ERR")=HMERR Q  ; error returned from GETS^DIQ
"RTN","HMPOR",125,0)
 ; map HMFLDS (fields from ^OR(100)) to HMFLDS (fields in ^HMP(800000))
"RTN","HMPOR",126,0)
 S SUBFL=100.008,IEN=""
"RTN","HMPOR",127,0)
 S:ORENTDT HMFLDS(.02)=ORENTDT  ; value stored outside of sub-file
"RTN","HMPOR",128,0)
 F  S IEN=$O(HMORVALS(SUBFL,IEN)) Q:'IEN  D
"RTN","HMPOR",129,0)
 . S FLD=0 F  S FLD=$O(HMORVALS(SUBFL,IEN,FLD)) Q:'FLD  S Y=HMORVALS(SUBFL,IEN,FLD,"I") D
"RTN","HMPOR",130,0)
 .. S:FLD=5 HMFLDS(.03)=Y  ; signed by
"RTN","HMPOR",131,0)
 .. S:FLD=6 HMFLDS(.04)=Y  ; signed date/time
"RTN","HMPOR",132,0)
 .. S:FLD=8 HMFLDS(.05)=Y  ; verifying nurse
"RTN","HMPOR",133,0)
 .. S:FLD=9 HMFLDS(.06)=Y  ; nurse verify date/time
"RTN","HMPOR",134,0)
 .. S:FLD=10 HMFLDS(.07)=Y  ; verifying clerk
"RTN","HMPOR",135,0)
 .. S:FLD=11 HMFLDS(.08)=Y  ; clerk verify date/time
"RTN","HMPOR",136,0)
 .. S:FLD=18 HMFLDS(.09)=Y  ; reviewed by
"RTN","HMPOR",137,0)
 .. S:FLD=19 HMFLDS(.1)=Y  ; reviewed date/time
"RTN","HMPOR",138,0)
 .. S:FLD=17 HMFLDS(.11)=Y  ; released by
"RTN","HMPOR",139,0)
 .. S:FLD=16 HMFLDS(.12)=Y  ; released by date/time
"RTN","HMPOR",140,0)
 .. S:FLD=2 HMFLDS(.14)=Y  ; order action
"RTN","HMPOR",141,0)
 .. S:FLD=.01 HMFLDS(.15)=Y ; action date/time
"RTN","HMPOR",142,0)
 ;
"RTN","HMPOR",143,0)
 Q
"RTN","HMPOR",144,0)
 ;
"RTN","HMPOR",145,0)
SRVRNO(DFN4SRVR) ; function, return server number for patient DFN4SRVR, zero if not subscribed
"RTN","HMPOR",146,0)
 N SRVNM
"RTN","HMPOR",147,0)
 S SRVNM=$O(^HMP(800000,"AITEM",+$G(DFN4SRVR),""))  ; server name
"RTN","HMPOR",148,0)
 Q:SRVNM="" 0  ; patient not found
"RTN","HMPOR",149,0)
 Q +$O(^HMP(800000,"B",SRVNM,0))  ; server IEN or zero
"RTN","HMPOR",150,0)
 ;
"RTN","HMPOR",151,0)
UPDTORDR(HMRSLT,HMVALS,HMORIFN,HMDFN) ; update order in HMP SUBSCRIPTION file (#800000), sub-file 800000.14
"RTN","HMPOR",152,0)
 ; HMRSLT - return value passed-by-ref., 1 on success else "-1^error message"
"RTN","HMPOR",153,0)
 ;all 3 parameters below required
"RTN","HMPOR",154,0)
 ; HMORIFN - Order IFN
"RTN","HMPOR",155,0)
 ; HMDFN - patient's DFN
"RTN","HMPOR",156,0)
 ; HMVALS - array of values, subscripted by field #, passed-by-ref.
"RTN","HMPOR",157,0)
 ;   note: HMVALS(.01) not needed, it's the DINUM value below
"RTN","HMPOR",158,0)
 ;
"RTN","HMPOR",159,0)
 S HMRSLT="-1^parameter missing"  ; initialize return
"RTN","HMPOR",160,0)
 Q:'($G(HMORIFN)>0)!'($G(HMDFN)>0)  ; must have Order IFN and DFN
"RTN","HMPOR",161,0)
 Q:'$O(HMVALS(0))  ; must have FileMan data
"RTN","HMPOR",162,0)
 ;
"RTN","HMPOR",163,0)
 N FMSG,HMFDA,HMSRVR,J,SUB
"RTN","HMPOR",164,0)
 S HMSRVR=$$SRVRNO(HMDFN)  ; server number subscribed to
"RTN","HMPOR",165,0)
 I '(HMSRVR>0) S HMRSLT="-1^HMP server not found for DFN "_HMDFN Q  ; not subscribed
"RTN","HMPOR",166,0)
 I '$D(^HMP(800000,HMSRVR,1,HMDFN,1,"B",HMORIFN)) S HMRSLT="-1^ORDER "_HMORIFN_" not found." Q  ; Order must exist
"RTN","HMPOR",167,0)
 ;
"RTN","HMPOR",168,0)
 S SUB=HMORIFN_","_HMDFN_","_HMSRVR_","  ; IENS subscript
"RTN","HMPOR",169,0)
 ; loop below starts after .01 because order already exists
"RTN","HMPOR",170,0)
 S J=.01 F  S J=$O(HMVALS(J)) Q:'J  S HMFDA(800000.14,SUB,J)=HMVALS(J)
"RTN","HMPOR",171,0)
 D FILE^DIE("","HMFDA","FMSG")
"RTN","HMPOR",172,0)
 ; return minus 1 if FileMan returns error
"RTN","HMPOR",173,0)
 S HMRSLT=$S($D(FMSG):"-1^FM error in UPDTORDR",1:1)
"RTN","HMPOR",174,0)
 ;
"RTN","HMPOR",175,0)
 Q
"RTN","HMPOR",176,0)
 ;
"RTN","HMPORRPC")
0^64^B2194584
"RTN","HMPORRPC",1,0)
HMPORRPC ;ASMR/MBS -- Orders RPCs ;01/06/2015  16:42
"RTN","HMPORRPC",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Dec 22, 2015;Build 24
"RTN","HMPORRPC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPORRPC",4,0)
 ; External References          DBIA#
"RTN","HMPORRPC",5,0)
 ; -------------------          -----
"RTN","HMPORRPC",6,0)
 ; ^OR(100                       5771
"RTN","HMPORRPC",7,0)
 ; DIQ                           2056
"RTN","HMPORRPC",8,0)
 Q
"RTN","HMPORRPC",9,0)
RELATED(RET,IEN) ;
"RTN","HMPORRPC",10,0)
 N RESULT,I,HMPSIBS,HMPKIDS,PARENT
"RTN","HMPORRPC",11,0)
 S RESULT=$NA(^TMP($J,"HMPORRPC")) K @RESULT
"RTN","HMPORRPC",12,0)
 I '+$G(IEN) S @RESULT@("error")="No order selected" G JSONIFY
"RTN","HMPORRPC",13,0)
 I '+$$GET1^DIQ(100,IEN_",",".01","I") S @RESULT@("error")="Nonexisting order" G JSONIFY
"RTN","HMPORRPC",14,0)
 ;See if we have a parent
"RTN","HMPORRPC",15,0)
 S PARENT=$$GET1^DIQ(100,IEN_",",36,"I")
"RTN","HMPORRPC",16,0)
 I +PARENT D
"RTN","HMPORRPC",17,0)
 . S @RESULT@("parent")=PARENT
"RTN","HMPORRPC",18,0)
 . ;Check for siblings
"RTN","HMPORRPC",19,0)
 . D LIST^DIC(100.002,","_PARENT_",","@;.01","I",,,,,,,"HMPSIBS")
"RTN","HMPORRPC",20,0)
 . F I=1:1:+$G(HMPSIBS("DILIST",0)) D
"RTN","HMPORRPC",21,0)
 . . Q:$G(HMPSIBS("DILIST",2,I))=IEN
"RTN","HMPORRPC",22,0)
 . . S @RESULT@("siblings",I)=$G(HMPSIBS("DILIST",2,I))
"RTN","HMPORRPC",23,0)
 ;Get children
"RTN","HMPORRPC",24,0)
 D LIST^DIC(100.002,","_IEN_",","@;.01","I",,,,,,,"HMPKIDS")
"RTN","HMPORRPC",25,0)
 F I=1:1:+$G(HMPKIDS("DILIST",0)) D
"RTN","HMPORRPC",26,0)
 . S @RESULT@("children",I)=$G(HMPKIDS("DILIST",2,I))
"RTN","HMPORRPC",27,0)
 ;US11945 - If we're calling this from HMPDJ01, don't convert to JSON yet
"RTN","HMPORRPC",28,0)
 I $G(HMPNOJS)=1 S RET=RESULT Q
"RTN","HMPORRPC",29,0)
JSONIFY ;
"RTN","HMPORRPC",30,0)
 D ENCODE^HMPJSON(RESULT,"RET")
"RTN","HMPORRPC",31,0)
 Q
"RTN","HMPPTRPC")
0^70^B11913363
"RTN","HMPPTRPC",1,0)
HMPPTRPC ;ASMR/MBS,CK - Patient Select RPC;May 15, 2016 14:15
"RTN","HMPPTRPC",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPPTRPC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPPTRPC",4,0)
 ; ROUTINE          IA#
"RTN","HMPPTRPC",5,0)
 ; XLFSTR          10104
"RTN","HMPPTRPC",6,0)
 ; XLFSTR          10104
"RTN","HMPPTRPC",7,0)
 ; VADPT           10061
"RTN","HMPPTRPC",8,0)
 ; MPIF001          2701
"RTN","HMPPTRPC",9,0)
 ; ORQPT2
"RTN","HMPPTRPC",10,0)
 ; XLFDT
"RTN","HMPPTRPC",11,0)
 ; DIC
"RTN","HMPPTRPC",12,0)
 ;
"RTN","HMPPTRPC",13,0)
 Q
"RTN","HMPPTRPC",14,0)
SELECT(RET,CRIT,SEARCH) ; Returns patient information based on search
"RTN","HMPPTRPC",15,0)
 N I,DFN,DFNS,HMPCNT,ICN,PID,CRITFND
"RTN","HMPPTRPC",16,0)
 S RET(1)="" ; Default to empty string return
"RTN","HMPPTRPC",17,0)
 I $G(SEARCH)="" S RET(1)="-1^No patient specified." Q
"RTN","HMPPTRPC",18,0)
 I $G(CRIT)="" S RET(1)="-1^No search critera specified." Q
"RTN","HMPPTRPC",19,0)
 S CRIT=$$UP^XLFSTR(CRIT),CRITFND=0 ; CRITFND will be 1 if we matched the CRIT to a criteria
"RTN","HMPPTRPC",20,0)
 I CRIT="LAST5" D SRLAST5(SEARCH) S CRITFND=1 ; Search by last5
"RTN","HMPPTRPC",21,0)
 I CRIT="NAME" D SRNAME(SEARCH) S CRITFND=1 ; Search by (partial) name
"RTN","HMPPTRPC",22,0)
 I CRIT="ICN" S DFNS(1)=$$GETDFN^MPIF001(SEARCH),ICN=SEARCH,CRITFND=1 ; ICN
"RTN","HMPPTRPC",23,0)
 I CRIT="PID" S DFNS(1)=$P(SEARCH,";",2),PID=SEARCH,CRITFND=1 ; PID - assume 2nd piece is DFN for *this* server
"RTN","HMPPTRPC",24,0)
 I $G(PID)]"",$P(PID,";")'=$$SYS^HMPUTILS S RET(1)="-1^Can only resolve pid for local site." Q
"RTN","HMPPTRPC",25,0)
 ;If we couldn't match a search criteria, return an error
"RTN","HMPPTRPC",26,0)
 I 'CRITFND S RET(1)="-1^Invalid search criteria requested" Q
"RTN","HMPPTRPC",27,0)
 I +$G(DFNS(1))=-1 S RET(1)="" Q
"RTN","HMPPTRPC",28,0)
 S HMPCNT="" F  S HMPCNT=$O(DFNS(HMPCNT)) Q:HMPCNT=""  S DFN=DFNS(HMPCNT) D
"RTN","HMPPTRPC",29,0)
 . N ICN,SENS,SSN,DOB,FULLNAME,FAMNAME,DISPNAME,SUMMARY,GNDRCODE,LAST4,LAST5,PID,GNDRNAME,VADM,GVNNAME
"RTN","HMPPTRPC",30,0)
 . I $$GET1^DIQ(2,DFN,".01")="" Q  ; Skip entries that don't match a valid DFN (mostly useful if CRIT was "PID")
"RTN","HMPPTRPC",31,0)
 . D DEM^VADPT
"RTN","HMPPTRPC",32,0)
 . ;DE3160 If no icn for patient then set ICN="" so that an extra field in return data does not get returned.
"RTN","HMPPTRPC",33,0)
 . S ICN=$$GETICN^MPIF001(DFN) I ICN<0 S ICN=""
"RTN","HMPPTRPC",34,0)
 . S SENS=$S($$EN1^ORQPT2(DFN)=1:"true",1:"false")
"RTN","HMPPTRPC",35,0)
 . S DOB=$TR($$FMTE^XLFDT(+$P($P($G(VADM(3)),U),"."),"7DZ"),"/","")
"RTN","HMPPTRPC",36,0)
 . S FULLNAME=$G(VADM(1))
"RTN","HMPPTRPC",37,0)
 . S FAMNAME=$P(FULLNAME,",",1),GVNNAME=$P(FULLNAME,",",2,99)
"RTN","HMPPTRPC",38,0)
 . S DISPNAME=$$FRSTCPS(FULLNAME),SUMMARY=DISPNAME
"RTN","HMPPTRPC",39,0)
 . S GNDRCODE="urn:va:pat-gender:"_$P($G(VADM(5)),U),GNDRNAME=$P($G(VADM(5)),U,2)
"RTN","HMPPTRPC",40,0)
 . S LAST4=$P($P($G(VADM(2)),U,2),"-",3),LAST5=$E(FAMNAME,1)_LAST4,SSN="*****"_LAST4
"RTN","HMPPTRPC",41,0)
 . S PID=$$SYS^HMPUTILS_";"_DFN
"RTN","HMPPTRPC",42,0)
 . S RET(HMPCNT)=FULLNAME_U_FAMNAME_U_GVNNAME_U_DISPNAME_U_GNDRCODE_U_GNDRNAME_U_SSN_U_LAST4_U_LAST5_U_DOB_U_SENS_U_DFN
"RTN","HMPPTRPC",43,0)
 . S RET(HMPCNT)=RET(HMPCNT)_U_PID_U_ICN_U_SUMMARY
"RTN","HMPPTRPC",44,0)
 Q
"RTN","HMPPTRPC",45,0)
SRLAST5(SEARCH) ; Search for patients by last5
"RTN","HMPPTRPC",46,0)
 D FIND(SEARCH,"BS5")
"RTN","HMPPTRPC",47,0)
 Q
"RTN","HMPPTRPC",48,0)
SRNAME(SEARCH) ; Search for patients by name
"RTN","HMPPTRPC",49,0)
 D FIND(SEARCH,"")
"RTN","HMPPTRPC",50,0)
 Q
"RTN","HMPPTRPC",51,0)
FIND(SEARCH,XREF) ; Find patients that match search term in x-ref
"RTN","HMPPTRPC",52,0)
 N HMPFIND,HMPERR
"RTN","HMPPTRPC",53,0)
 D FIND^DIC(2,,"@","P",SEARCH,,XREF,,,"HMPFIND","HMPERR")
"RTN","HMPPTRPC",54,0)
 F I=1:1:+$G(HMPFIND("DILIST",0)) S DFNS(I)=HMPFIND("DILIST",I,0)
"RTN","HMPPTRPC",55,0)
 Q
"RTN","HMPPTRPC",56,0)
FRSTCPS(IN) ; Formats patient's name to begin each word with a capital and the rest lowercase
"RTN","HMPPTRPC",57,0)
 N FRSTCHAR,OUT
"RTN","HMPPTRPC",58,0)
 S FRSTCHAR=1,OUT=""
"RTN","HMPPTRPC",59,0)
 F I=1:1:$L(IN) D
"RTN","HMPPTRPC",60,0)
 . N CHAR S CHAR=$E($E(IN,I))
"RTN","HMPPTRPC",61,0)
 . I $$ISALPHA(CHAR) D  Q
"RTN","HMPPTRPC",62,0)
 . . I FRSTCHAR S OUT=OUT_CHAR,FRSTCHAR=0 Q
"RTN","HMPPTRPC",63,0)
 . . S OUT=OUT_$$LOW^XLFSTR(CHAR)
"RTN","HMPPTRPC",64,0)
 . ;otherwise, non-alphabetic character
"RTN","HMPPTRPC",65,0)
 . S OUT=OUT_CHAR,FRSTCHAR=1
"RTN","HMPPTRPC",66,0)
 Q OUT
"RTN","HMPPTRPC",67,0)
ISALPHA(CHAR) ;
"RTN","HMPPTRPC",68,0)
 Q CHAR?1A
"RTN","HMPPTRPC",69,0)
 ;
"RTN","HMPSTMP")
0^7^B101713428
"RTN","HMPSTMP",1,0)
HMPSTMP ;ASMR/JD,BL,ASF,CK,CPC - MetaStamp ;Jun 22, 2016 17:23:52
"RTN","HMPSTMP",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPSTMP",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPSTMP",4,0)
 ;
"RTN","HMPSTMP",5,0)
 ; Returns the most recent date/time
"RTN","HMPSTMP",6,0)
 ; JD - 6/5/15 - Added code to the DOC section to consider the attachment date
"RTN","HMPSTMP",7,0)
 ;               as one of the dates if it exists
"RTN","HMPSTMP",8,0)
 ; JD - 2/1/16 - Added code to the FINDNEW section to skip over the imprecise dates. DE3548
"RTN","HMPSTMP",9,0)
 ; JD - 2/7/16 - Modified FINDNEW section to default to NOW if no other dates exist. DE3728
"RTN","HMPSTMP",10,0)
 Q
"RTN","HMPSTMP",11,0)
 ;
"RTN","HMPSTMP",12,0)
EN(A) ; extrinsic function, used to create "stampTime" or "lastUpdateTime" subscript in arrays
"RTN","HMPSTMP",13,0)
 K B
"RTN","HMPSTMP",14,0)
 N C
"RTN","HMPSTMP",15,0)
 ; A is either "now" or a domain name (per PTDOMS^HMPDJFSD)
"RTN","HMPSTMP",16,0)
 ; B is the return value (stampTime)
"RTN","HMPSTMP",17,0)
 S C=$$UP^XLFSTR(A)
"RTN","HMPSTMP",18,0)
 I C="NOW" G NOW
"RTN","HMPSTMP",19,0)
 I C="ADM" G ADM
"RTN","HMPSTMP",20,0)
 I C="ALLERGY" G ALL
"RTN","HMPSTMP",21,0)
 I C="AUXILIARY" G AUX
"RTN","HMPSTMP",22,0)
 I C="APPOINTMENT" G APP
"RTN","HMPSTMP",23,0)
 I C="DIAGNOSIS" G DIA
"RTN","HMPSTMP",24,0)
 I C="DOCUMENT" G DOC
"RTN","HMPSTMP",25,0)
 I C="FACTOR" G FAC
"RTN","HMPSTMP",26,0)
 I C="IMMUNIZATION" G IMM
"RTN","HMPSTMP",27,0)
 I C="LAB" G LAB
"RTN","HMPSTMP",28,0)
 I C="MED" G MED
"RTN","HMPSTMP",29,0)
 I C="OBS" G OBS
"RTN","HMPSTMP",30,0)
 I C="ORDER" G ORD
"RTN","HMPSTMP",31,0)
 I C="PROBLEM" G PRO
"RTN","HMPSTMP",32,0)
 I C="PROCEDURE" G PRC
"RTN","HMPSTMP",33,0)
 I C="CONSULT" G CON
"RTN","HMPSTMP",34,0)
 I C="IMAGE" G IMA
"RTN","HMPSTMP",35,0)
 I C="SURGERY" G SUR
"RTN","HMPSTMP",36,0)
 I C="TASK" G TAS
"RTN","HMPSTMP",37,0)
 I C="VISIT" G VIS
"RTN","HMPSTMP",38,0)
 I C="VITAL" G VIT
"RTN","HMPSTMP",39,0)
 I C="PTF" G PTF
"RTN","HMPSTMP",40,0)
 I C="EXAM" G EXA
"RTN","HMPSTMP",41,0)
 I C="CPT" G CPT
"RTN","HMPSTMP",42,0)
 I C="EDUCATION" G EDU
"RTN","HMPSTMP",43,0)
 I C="POV" G POV
"RTN","HMPSTMP",44,0)
 I C="SKIN" G SKI
"RTN","HMPSTMP",45,0)
 I C="TREATMENT" G TRE
"RTN","HMPSTMP",46,0)
 I C="MH" G MH
"RTN","HMPSTMP",47,0)
 Q ""  ; DE3504 changed B to "" to prevent error if code falls through
"RTN","HMPSTMP",48,0)
 ;
"RTN","HMPSTMP",49,0)
NOW ;
"RTN","HMPSTMP",50,0)
 ; Set stamp time in YYYYMMDDHHMMSS format
"RTN","HMPSTMP",51,0)
 S B=$$FMTHL7($$NOW^XLFDT)  ; DE5016
"RTN","HMPSTMP",52,0)
 S B=$E(B_"000000",1,14)  ; Need padding to force YYYYMMDDHHMMSS precision
"RTN","HMPSTMP",53,0)
 Q B
"RTN","HMPSTMP",54,0)
 ;
"RTN","HMPSTMP",55,0)
ADM ; Admissions (these are visits whose ID starts with an "H").  JD - January 26, 2015
"RTN","HMPSTMP",56,0)
 K DATA
"RTN","HMPSTMP",57,0)
 S DATE(1)=$G(ADM("dateTime"))
"RTN","HMPSTMP",58,0)
 S DATE(2)=$G(ADM("stay","dischargeDateTime"))
"RTN","HMPSTMP",59,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",60,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",61,0)
ALL ; Allergy ; rhl 20141231
"RTN","HMPSTMP",62,0)
 K DATE
"RTN","HMPSTMP",63,0)
 S DATE(1)=$G(REAC("entered"))
"RTN","HMPSTMP",64,0)
 S DATE(2)=$G(REAC("verified"))
"RTN","HMPSTMP",65,0)
 ;  dates in observations array
"RTN","HMPSTMP",66,0)
 N I,J
"RTN","HMPSTMP",67,0)
 S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",68,0)
 S I=0
"RTN","HMPSTMP",69,0)
 F  S I=$O(REAC("observations",I)) Q:I=""  D
"RTN","HMPSTMP",70,0)
 . I $G(REAC("observations",I,"date"))]"" S J=J+1,DATE(J)=REAC("observations",I,"date")
"RTN","HMPSTMP",71,0)
 ;  dates in comment array
"RTN","HMPSTMP",72,0)
 N I,J
"RTN","HMPSTMP",73,0)
 S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",74,0)
 S I=0
"RTN","HMPSTMP",75,0)
 F  S I=$O(REAC("comments",I)) Q:I=""  D
"RTN","HMPSTMP",76,0)
 . I $G(REAC("comments",I,"entered"))]"" S J=J+1,DATE(J)=REAC("comments",I,"entered")
"RTN","HMPSTMP",77,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",78,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",79,0)
AUX ; Auxiliary
"RTN","HMPSTMP",80,0)
 Q ""
"RTN","HMPSTMP",81,0)
 K DATE
"RTN","HMPSTMP",82,0)
 ;S DATE(1)=$G(
"RTN","HMPSTMP",83,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",84,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",85,0)
APP ; Appointment
"RTN","HMPSTMP",86,0)
 K DATE
"RTN","HMPSTMP",87,0)
 S DATE(1)=$G(APPT("dateTime"))
"RTN","HMPSTMP",88,0)
 S DATE(2)=$G(APPT("checkIn"))
"RTN","HMPSTMP",89,0)
 S DATE(3)=$G(APPT("checkOut"))
"RTN","HMPSTMP",90,0)
 ;if freshness item get timestamp from stream get last update from freshness stream
"RTN","HMPSTMP",91,0)
 I $G(FILTER("freshnessDateTime")) S DATE(4)=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime")) ;DE4859
"RTN","HMPSTMP",92,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",93,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",94,0)
DIA ; Diagnosis
"RTN","HMPSTMP",95,0)
 Q ""
"RTN","HMPSTMP",96,0)
 K DATE
"RTN","HMPSTMP",97,0)
 ;S DATE(1)=$G(
"RTN","HMPSTMP",98,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",99,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",100,0)
DOC ; Document
"RTN","HMPSTMP",101,0)
 N AUDDT
"RTN","HMPSTMP",102,0)
 S AUDDT=""  ; Audit trail date/time
"RTN","HMPSTMP",103,0)
 K DATE
"RTN","HMPSTMP",104,0)
 S DATE(1)=$G(DOC("referenceDateTime"))
"RTN","HMPSTMP",105,0)
 S DATE(2)=$G(DOC("entered"))
"RTN","HMPSTMP",106,0)
 ;DE2818, ^TIU(8925.5) references - ICR 6279
"RTN","HMPSTMP",107,0)
 ; Find the most recent audit trail entry for the document
"RTN","HMPSTMP",108,0)
 S:$G(DOC("localId")) AUDDT=$O(^TIU(8925.5,"B",DOC("localId"),""),-1)
"RTN","HMPSTMP",109,0)
 ; Get the audit trail date/time
"RTN","HMPSTMP",110,0)
 S:AUDDT AUDDT=$P($G(^TIU(8925.5,AUDDT,3)),"^",2)
"RTN","HMPSTMP",111,0)
 S:AUDDT DATE(3)=$$JSONDT^HMPUTILS(AUDDT)
"RTN","HMPSTMP",112,0)
 ;go through HMPDJ array
"RTN","HMPSTMP",113,0)
 N I,II,J
"RTN","HMPSTMP",114,0)
 S J=""
"RTN","HMPSTMP",115,0)
 S J=$O(DATE(J),-1)
"RTN","HMPSTMP",116,0)
 S I=0
"RTN","HMPSTMP",117,0)
 F  S I=$O(DOC("text",I)) Q:I=""  D
"RTN","HMPSTMP",118,0)
 . I $G(DOC("text",I,"dateTime"))]"" S J=J+1,DATE(J)=DOC("text",I,"dateTime")
"RTN","HMPSTMP",119,0)
 . S II=0 F  S II=$O(DOC("text",I,"clinicians",II)) Q:II=""  D
"RTN","HMPSTMP",120,0)
 . . I $G(DOC("text",I,"clinicians",II,"signedDateTime"))]"" S J=J+1,DATE(J)=DOC("text",I,"clinicians",II,"signedDateTime")
"RTN","HMPSTMP",121,0)
 ;DE4148 use freshness datetime if available
"RTN","HMPSTMP",122,0)
 I $G(FILTER("freshnessDateTime")) S J=J+1,DATE(J)=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime"))
"RTN","HMPSTMP",123,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",124,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",125,0)
FAC ; Factor
"RTN","HMPSTMP",126,0)
 K DATE
"RTN","HMPSTMP",127,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",128,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",129,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",130,0)
IMM ; Immunization
"RTN","HMPSTMP",131,0)
 K DATE
"RTN","HMPSTMP",132,0)
 N T
"RTN","HMPSTMP",133,0)
 S DATE(1)=$G(PCE("administeredDateTime"))
"RTN","HMPSTMP",134,0)
 ;DE4013 use freshness datetime if available
"RTN","HMPSTMP",135,0)
 S T=$G(FILTER("freshnessDateTime"))
"RTN","HMPSTMP",136,0)
 I T S DATE(2)=$$JSONDT^HMPUTILS(T)
"RTN","HMPSTMP",137,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",138,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",139,0)
LAB ; Lab
"RTN","HMPSTMP",140,0)
 K DATE
"RTN","HMPSTMP",141,0)
 S DATE(1)=$G(LAB("observed"))
"RTN","HMPSTMP",142,0)
 S DATE(2)=$G(LAB("resulted"))
"RTN","HMPSTMP",143,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",144,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",145,0)
MED ; Med
"RTN","HMPSTMP",146,0)
 K DATE
"RTN","HMPSTMP",147,0)
 S DATE(1)=$G(MED("orders",1,"ordered"))
"RTN","HMPSTMP",148,0)
 S DATE(2)=$G(MED("overallStart"))
"RTN","HMPSTMP",149,0)
 S DATE(3)=$G(MED("overallStop"))
"RTN","HMPSTMP",150,0)
 S DATE(4)=$G(MED("stopped"))
"RTN","HMPSTMP",151,0)
 S DATE(5)=$G(MED("lastFilled"))
"RTN","HMPSTMP",152,0)
 S DATE(6)=$G(MED("prescriptionFinished")) ; DE5723
"RTN","HMPSTMP",153,0)
 ;go through value array
"RTN","HMPSTMP",154,0)
 N I,J
"RTN","HMPSTMP",155,0)
 S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",156,0)
 S I=0
"RTN","HMPSTMP",157,0)
 F  S I=$O(MED("dosages",I)) Q:I=""  D
"RTN","HMPSTMP",158,0)
 . I $G(MED("dosages",I,"start"))]"" S J=J+1,DATE(J)=MED("dosages",I,"start")
"RTN","HMPSTMP",159,0)
 . I $G(MED("dosages",I,"stop"))]"" S J=J+1,DATE(J)=MED("dosages",I,"stop")
"RTN","HMPSTMP",160,0)
 S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",161,0)
 S I=0
"RTN","HMPSTMP",162,0)
 F  S I=$O(MED("fills",I)) Q:I=""  D
"RTN","HMPSTMP",163,0)
 . I $G(MED("fills",I,"dispenseDate"))]"" S J=J+1,DATE(J)=MED("fills",I,"dispenseDate")
"RTN","HMPSTMP",164,0)
 . I $G(MED("fills",I,"releaseDate"))]"" S J=J+1,DATE(J)=MED("fills",I,"releaseDate")
"RTN","HMPSTMP",165,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",166,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",167,0)
OBS ; Obs ; rhl 20141231
"RTN","HMPSTMP",168,0)
 K DATE
"RTN","HMPSTMP",169,0)
 S DATE(1)=$G(CLIO("entered"))
"RTN","HMPSTMP",170,0)
 S DATE(2)=$G(CLIO("observed"))
"RTN","HMPSTMP",171,0)
 S DATE(3)=$G(CLIO("setStart"))
"RTN","HMPSTMP",172,0)
 S DATE(4)=$G(CLIO("setStop"))
"RTN","HMPSTMP",173,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",174,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",175,0)
 ;
"RTN","HMPSTMP",176,0)
ORD ; Order ; RHL 20141231
"RTN","HMPSTMP",177,0)
 N D,DATE,I,J,ND,XDT,SRVRNUM
"RTN","HMPSTMP",178,0)
 S DATE(1)=$G(ORDER("entered")),SRVRNUM=$$SRVRNO^HMPOR(DFN)  ; need server number for patient
"RTN","HMPSTMP",179,0)
 ; DE3504 - Jan 18, 2016, added the code below for US10045
"RTN","HMPSTMP",180,0)
 ; US10045 - PB check if patient and order in the HMP SUBSCRIPTION, if found get date/time stamps with seconds from there
"RTN","HMPSTMP",181,0)
 I $D(^HMP(800000,SRVRNUM,1,DFN,1,ID,0)) D
"RTN","HMPSTMP",182,0)
 . S ND=$G(^HMP(800000,SRVRNUM,1,DFN,1,ID,0))
"RTN","HMPSTMP",183,0)
 . S XDT(2)=$P(ND,U,15),XDT(1)=$P(ND,U,2)  ; FileMan format date/time
"RTN","HMPSTMP",184,0)
 . S D=XDT(1) S:XDT(2)>D D=XDT(2)  ; get later date in D
"RTN","HMPSTMP",185,0)
 . S DATE(1)=$$JSONDT^HMPUTILS(D)
"RTN","HMPSTMP",186,0)
 ; these are signature /verification dates
"RTN","HMPSTMP",187,0)
 ;DE3337 Feb 3, 2016 ;US10045 - PB Oct 28, 2015 flag set in HMPDJ01 to indicate there is date in the array ORDER("clinicians",I,"signedDateTime") where I is the incremental variable
"RTN","HMPSTMP",188,0)
 S J=1,I=0  ; evaluate this array every time DE3337
"RTN","HMPSTMP",189,0)
 F  S I=$O(ORDER("clinicians",I)) Q:'I  D
"RTN","HMPSTMP",190,0)
 . I $G(ORDER("clinicians",I,"signedDateTime"))]"" S J=J+1,DATE(J)=ORDER("clinicians",I,"signedDateTime")
"RTN","HMPSTMP",191,0)
 ;
"RTN","HMPSTMP",192,0)
 I $G(ORDER("stop")) S J=J+1,DATE(J)=ORDER("stop")
"RTN","HMPSTMP",193,0)
 Q $$FINDNEW(.DATE)  ; determine newest date
"RTN","HMPSTMP",194,0)
 ;
"RTN","HMPSTMP",195,0)
PRO ; Problem
"RTN","HMPSTMP",196,0)
 K DATE N I,J,T
"RTN","HMPSTMP",197,0)
 S DATE(1)=$G(PROB("entered"))
"RTN","HMPSTMP",198,0)
 S DATE(2)=$G(PROB("updated"))
"RTN","HMPSTMP",199,0)
 S DATE(3)=$G(PROB("onset"))
"RTN","HMPSTMP",200,0)
 S DATE(4)=$G(PROB("resolved"))
"RTN","HMPSTMP",201,0)
 ; there may be dates in comments
"RTN","HMPSTMP",202,0)
 S I=0,J=4  ; J starts at 4 because of the logic above
"RTN","HMPSTMP",203,0)
 F  S I=$O(PROB("comments",I)) Q:I=""  S T=$G(PROB("comments",I,"entered")) S:T J=J+1,DATE(J)=T
"RTN","HMPSTMP",204,0)
 ; ASF - DE3691, get lastUpdateTime, Feb 29, 2016
"RTN","HMPSTMP",205,0)
 D 
"RTN","HMPSTMP",206,0)
 . ;if freshness item get timestamp from stream get last update from freshness stream
"RTN","HMPSTMP",207,0)
 . S T=$G(FILTER("freshnessDateTime"))
"RTN","HMPSTMP",208,0)
 . I T S J=J+1,DATE(J)=$$JSONDT^HMPUTILS(T) Q
"RTN","HMPSTMP",209,0)
 . ;else get from audit file
"RTN","HMPSTMP",210,0)
 . S T=$O(^GMPL(125.8,"AD",ID,0))  ; PROBLEM LIST AUDIT, ICR 2974, last changed date/time with seconds
"RTN","HMPSTMP",211,0)
 . I T S J=J+1,DATE(J)=$$JSONDT^HMPUTILS(9999999-T)  ; got an edited date/time (inverse order)
"RTN","HMPSTMP",212,0)
 ;
"RTN","HMPSTMP",213,0)
 Q $$FINDNEW(.DATE)  ; determine newest date
"RTN","HMPSTMP",214,0)
 ;
"RTN","HMPSTMP",215,0)
PRC ; Procedure
"RTN","HMPSTMP",216,0)
 K DATE
"RTN","HMPSTMP",217,0)
 S DATE(1)=$G(PROC("dateTime"))
"RTN","HMPSTMP",218,0)
 S DATE(2)=$G(PROC("requested"))
"RTN","HMPSTMP",219,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",220,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",221,0)
CON ; Consult
"RTN","HMPSTMP",222,0)
 K DATE
"RTN","HMPSTMP",223,0)
 S DATE(1)=$G(CONS("dateTime"))
"RTN","HMPSTMP",224,0)
 S DATE(2)=$G(CONS("earliestDate"))
"RTN","HMPSTMP",225,0)
 S DATE(3)=$G(ACT("entered"))
"RTN","HMPSTMP",226,0)
 S DATE(4)=$G(ACT("dateTime"))
"RTN","HMPSTMP",227,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",228,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",229,0)
IMA ; Image ; RHL 20150102
"RTN","HMPSTMP",230,0)
 K DATE
"RTN","HMPSTMP",231,0)
 S DATE(1)=$G(EXAM("dateTime"))
"RTN","HMPSTMP",232,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",233,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",234,0)
SUR ; Surgery ; RHL 20150102
"RTN","HMPSTMP",235,0)
 K DATE
"RTN","HMPSTMP",236,0)
 S DATE(1)=$G(SURG("dateTime"))
"RTN","HMPSTMP",237,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",238,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",239,0)
TAS ; Task
"RTN","HMPSTMP",240,0)
 Q ""
"RTN","HMPSTMP",241,0)
 K DATE
"RTN","HMPSTMP",242,0)
 ;S DATE(1)=$G(
"RTN","HMPSTMP",243,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",244,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",245,0)
VIS ; Visit
"RTN","HMPSTMP",246,0)
 K DATE
"RTN","HMPSTMP",247,0)
 S DATE(1)=$G(VST("dateTime"))
"RTN","HMPSTMP",248,0)
 S DATE(2)=$G(VST("checkOut"))
"RTN","HMPSTMP",249,0)
 ;DE4049 use freshness datetime if available
"RTN","HMPSTMP",250,0)
 I $G(FILTER("freshnessDateTime")) S DATE(3)=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime"))
"RTN","HMPSTMP",251,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",252,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",253,0)
VIT ; Vital
"RTN","HMPSTMP",254,0)
 K DATE
"RTN","HMPSTMP",255,0)
 S DATE(1)=$G(VIT("observed"))
"RTN","HMPSTMP",256,0)
 S DATE(2)=$G(VIT("resulted"))
"RTN","HMPSTMP",257,0)
 S DATE(3)=$G(VIT("dateEnteredInError")) ; r1.3 - fix for including vital EIE date
"RTN","HMPSTMP",258,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",259,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",260,0)
PTF ; Ptf ; RHL 20150102
"RTN","HMPSTMP",261,0)
 K DATE
"RTN","HMPSTMP",262,0)
 S DATE(1)=$G(PTF("arrivalDateTime"))
"RTN","HMPSTMP",263,0)
 S DATE(2)=$G(PTF("dischargeDateTime"))
"RTN","HMPSTMP",264,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",265,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",266,0)
EXA ; Exam
"RTN","HMPSTMP",267,0)
 K DATE
"RTN","HMPSTMP",268,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",269,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",270,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",271,0)
CPT ; CPT
"RTN","HMPSTMP",272,0)
 K DATE
"RTN","HMPSTMP",273,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",274,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",275,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",276,0)
EDU ; Education
"RTN","HMPSTMP",277,0)
 K DATE
"RTN","HMPSTMP",278,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",279,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",280,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",281,0)
POV ; Pov
"RTN","HMPSTMP",282,0)
 K DATE
"RTN","HMPSTMP",283,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",284,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",285,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",286,0)
SKI ; Skin
"RTN","HMPSTMP",287,0)
 K DATE
"RTN","HMPSTMP",288,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",289,0)
 S DATE(2)=$G(PCE("dateRead"))
"RTN","HMPSTMP",290,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",291,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",292,0)
TRE ; Treatment ; RHL 20150102
"RTN","HMPSTMP",293,0)
 K DATE
"RTN","HMPSTMP",294,0)
 S DATE(1)=$G(NTX("entered"))
"RTN","HMPSTMP",295,0)
 S DATE(2)=$G(NTX("start"))
"RTN","HMPSTMP",296,0)
 S DATE(3)=$G(NTX("stop"))
"RTN","HMPSTMP",297,0)
 ;these are dates in signature/verification dates; is this used for NTX orders
"RTN","HMPSTMP",298,0)
 I $G(NTX("clinicians")) D
"RTN","HMPSTMP",299,0)
 . N I,J
"RTN","HMPSTMP",300,0)
 . S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",301,0)
 . S I=0
"RTN","HMPSTMP",302,0)
 . F  S I=$O(NTX("clinicians",I)) Q:I=""  D
"RTN","HMPSTMP",303,0)
 . . I $G(NTX("clinicians",I,"signedDateTime"))]"" S J=J+1,DATE(J)=NTX("clinicians",I,"signedDateTime")
"RTN","HMPSTMP",304,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",305,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",306,0)
MH ; Mh   ; RHL 20150103
"RTN","HMPSTMP",307,0)
 K DATE
"RTN","HMPSTMP",308,0)
 S DATE(1)=$G(MH("administeredDateTime"))
"RTN","HMPSTMP",309,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",310,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",311,0)
 ;
"RTN","HMPSTMP",312,0)
FINDNEW(DATE)  ; function, find the latest date from DATE array
"RTN","HMPSTMP",313,0)
 ;DATE array has following format DATE(1)=DATE DATE(2)=DATE
"RTN","HMPSTMP",314,0)
 N ADATE,COMDATE,NDATE,X
"RTN","HMPSTMP",315,0)
 ; Jan 28, 2016, DE3519;bl set date for comparison, now plus 60 seconds padded with zeroes, no time zone offset
"RTN","HMPSTMP",316,0)
 S NDATE=$E($$FMTHL7($$FMADD^XLFDT($$NOW^XLFDT,0,0,0,60))_"000000",1,14)  ; DE5016
"RTN","HMPSTMP",317,0)
 S X=0,COMDATE=0  ; initialize starting date to zero
"RTN","HMPSTMP",318,0)
 F  S X=$O(DATE(X)) Q:'X  D:$E(DATE(X),7,8)  ; evaluate only if precise date. DE3548
"RTN","HMPSTMP",319,0)
 . S ADATE=$E(DATE(X)_"000000",1,14) ; Need padding down to the second (YYYYMMDDHHMM). JD-1/23/15
"RTN","HMPSTMP",320,0)
 . I ADATE>NDATE Q  ; DE3519;bl prevent future date/times in lastUpdateTime
"RTN","HMPSTMP",321,0)
 . I ADATE>COMDATE S COMDATE=ADATE
"RTN","HMPSTMP",322,0)
 ;Defaut to NOW if there are no other dates.  JD - 2/7/16. DE3728
"RTN","HMPSTMP",323,0)
 I 'COMDATE S COMDATE=$E($$FMTHL7($$NOW^XLFDT)_"000000",1,14)  ; DE5016
"RTN","HMPSTMP",324,0)
 Q COMDATE
"RTN","HMPSTMP",325,0)
 ;
"RTN","HMPSTMP",326,0)
 ; DE5016 - May 26, 2016 - hrubovcak
"RTN","HMPSTMP",327,0)
FMTHL7(HMPFMDTM) ; function, return HL7 date/time from FileMan date/time, strip time zone offset
"RTN","HMPSTMP",328,0)
 Q $P($TR($$FMTHL7^XLFDT(HMPFMDTM),"-+","^^"),"^")  ; translate plus or minus sign to '^', return first piece
"RTN","HMPSTMP",329,0)
 ;
"RTN","HMPTFU2")
0^71^B40570794
"RTN","HMPTFU2",1,0)
HMPTFU2 ;ASMR/JCH,CK - Utilities for the Treating Facility file 391.91 ;Apr 27, 2016 10:35:07
"RTN","HMPTFU2",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPTFU2",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPTFU2",4,0)
 ;
"RTN","HMPTFU2",5,0)
 ; Reference to ^DGCN(391.91 is NOT currently supported; see ICR #2911 for an existing Private ICR between 
"RTN","HMPTFU2",6,0)
 ;  Registration and CIRN that would meet the needs of this routine, or provide an example for a new ICR.
"RTN","HMPTFU2",7,0)
 ;
"RTN","HMPTFU2",8,0)
 Q
"RTN","HMPTFU2",9,0)
 ;
"RTN","HMPTFU2",10,0)
TFL(LIST,PT) ;for this PT [patient] (either DFN, ICN or EDIPI) return the list of treating facilities
"RTN","HMPTFU2",11,0)
 ; CALLED FROM RPC HMP LOCAL GET CORRESPONDINGIDS
"RTN","HMPTFU2",12,0)
 ; PT values :   Source ID^Source ID Type^Assigning Authority^Assigning Facility
"RTN","HMPTFU2",13,0)
 ;  ICN example:   1008520438V882204^NI^USVHA^200M
"RTN","HMPTFU2",14,0)
 ;  DFN example:   100000511^PI^USVHA^500
"RTN","HMPTFU2",15,0)
 ;  EDIPI example: 852043888^NI^USDOD^200DOD
"RTN","HMPTFU2",16,0)
 ;
"RTN","HMPTFU2",17,0)
 ; SOURCE ID:      SOURCE ID is the unique system assigned identifier at the identified facility for the
"RTN","HMPTFU2",18,0)
 ;                 patient record.  The value of SOURCE ID varies, depending on the source facility. 
"RTN","HMPTFU2",19,0)
 ;                 If SOURCE ID is from the Master Patient Index, the value is the Integration 
"RTN","HMPTFU2",20,0)
 ;                 Control Number (ICN).  If SOURCE ID is from the Department of Defense (DOD), the
"RTN","HMPTFU2",21,0)
 ;                 value is the Electronic Data Interchange Personal Identifier (EDIPI), which is 
"RTN","HMPTFU2",22,0)
 ;                 their equivalent of an ICN. In the future, SOURCE ID may come from other sources 
"RTN","HMPTFU2",23,0)
 ;                 due to additional initiatives.
"RTN","HMPTFU2",24,0)
 ;
"RTN","HMPTFU2",25,0)
 ; SOURCE ID TYPE: SOURCE ID TYPE defines the data source for the TREATING FACILITY LIST file (#391.91) entry.
"RTN","HMPTFU2",26,0)
 ;                 The source ID type is a reference to the HL7 Table 0203, Identifier Type, and the VA
"RTN","HMPTFU2",27,0)
 ;                 Identity Management user defined values: NI (National Identifier), PI (Patient Identifier)
"RTN","HMPTFU2",28,0)
 ; 
"RTN","HMPTFU2",29,0)
 ; Return:
"RTN","HMPTFU2",30,0)
 ; This will return the ICN and the list of treating facilities in the following format:
"RTN","HMPTFU2",31,0)
 ;   RESULT(n)=Id^IdType^AssigningFacility^AssigningAuthority^IdStatus
"RTN","HMPTFU2",32,0)
 ;     Examples:
"RTN","HMPTFU2",33,0)
 ;      RESULT(1)="1011232151V598646^NI^200M^A"
"RTN","HMPTFU2",34,0)
 ;      RESULT(2)="7168937^PI^91E3^USVHA^A"
"RTN","HMPTFU2",35,0)
 ;      RESULT(3)="852043888^NI^200DOD^USDOD^A"
"RTN","HMPTFU2",36,0)
 ;
"RTN","HMPTFU2",37,0)
 ; ID STATUS:      ID STATUS supports joint VA/DoD medical centers, Veteran's Record Management (VRM), and Virtual 
"RTN","HMPTFU2",38,0)
 ;                 Lifetime Electronic Record (VLER) initiatives.  This field allows the capture of resolved 
"RTN","HMPTFU2",39,0)
 ;                 duplicate events and exposes the related identifier and identifier status to the consuming 
"RTN","HMPTFU2",40,0)
 ;                 applications. A value of ""A"" indicates that the patient record is an active record on 
"RTN","HMPTFU2",41,0)
 ;                 the identifying system (e.g., VAMC or DoD). A value of "H" indicates that the patient 
"RTN","HMPTFU2",42,0)
 ;                 record was identified as part of a duplicate pair, has been merged, and is no longer active 
"RTN","HMPTFU2",43,0)
 ;                 on the identifying system (e.g., VAMC or DoD).
"RTN","HMPTFU2",44,0)
 ;
"RTN","HMPTFU2",45,0)
 N X,ICN,DFN,EDIPI,ASSIGN,ID,SITE,TYPE,SITEIEN,TFIEN
"RTN","HMPTFU2",46,0)
 ;
"RTN","HMPTFU2",47,0)
 ; Master Patient Index (MPI) must be installed to continue
"RTN","HMPTFU2",48,0)
 S X="MPIF001" X ^%ZOSF("TEST") I '$T S LIST(1)="-1^MPI Not Installed" Q
"RTN","HMPTFU2",49,0)
 ;
"RTN","HMPTFU2",50,0)
 K LIST ; Clear "return" variable
"RTN","HMPTFU2",51,0)
 ;
"RTN","HMPTFU2",52,0)
 ; what do we have
"RTN","HMPTFU2",53,0)
 S TYPE=$P(PT,"^",2) ; SOURCE ID TYPE
"RTN","HMPTFU2",54,0)
 S SITE=$P(PT,"^",4) ; 
"RTN","HMPTFU2",55,0)
 S ID=$P(PT,"^")
"RTN","HMPTFU2",56,0)
 S ASSIGN=$P(PT,"^",3)
"RTN","HMPTFU2",57,0)
 ; check input data
"RTN","HMPTFU2",58,0)
 I ID']"" S LIST(1)="-1^Id is not defined." Q
"RTN","HMPTFU2",59,0)
 I TYPE'="NI",TYPE'="PI" S LIST(1)="-1^Invalid Id Type." Q
"RTN","HMPTFU2",60,0)
 I ASSIGN'="USVHA",ASSIGN'="USDOD" S LIST(1)="-1^Invalid Assigning Authority." Q
"RTN","HMPTFU2",61,0)
 I SITE']"" S LIST(1)="-1^Missing Assigning Facility." Q
"RTN","HMPTFU2",62,0)
 ; find the ien for the station number
"RTN","HMPTFU2",63,0)
 S SITEIEN=$O(^DIC(4,"D",SITE,0))
"RTN","HMPTFU2",64,0)
 I 'SITEIEN S LIST(1)="-1^Assigning Facility is not defined in database." Q
"RTN","HMPTFU2",65,0)
 ;
"RTN","HMPTFU2",66,0)
 I TYPE="PI",ASSIGN="USVHA" S DFN=ID
"RTN","HMPTFU2",67,0)
 I TYPE="NI",ASSIGN="USVHA",SITE="200M" S ICN=ID
"RTN","HMPTFU2",68,0)
 I TYPE="NI",ASSIGN="USDOD",SITE="200DOD" S EDIPI=ID
"RTN","HMPTFU2",69,0)
 I $D(ICN) S DFN=$$GETDFN^MPIF001(ICN) D  Q:$D(LIST(1))
"RTN","HMPTFU2",70,0)
 . I +DFN<0 S LIST(1)="-1^ICN is not known" Q
"RTN","HMPTFU2",71,0)
 . S SITEIEN=$$IEN^XUAF4($P($$SITE^VASITE,"^",3))
"RTN","HMPTFU2",72,0)
 ;
"RTN","HMPTFU2",73,0)
 I $D(DFN) S ICN=$$GETICN^MPIF001(DFN)
"RTN","HMPTFU2",74,0)
 ; DFN should be defined, but ICN may not.
"RTN","HMPTFU2",75,0)
 ;Use new xref AISS appropriately to retrieve DFN from EDIPI
"RTN","HMPTFU2",76,0)
 I $D(EDIPI)=""!(ASSIGN="")!(TYPE="")!(SITEIEN="") S LIST(1)="-1^Insufficient data" Q
"RTN","HMPTFU2",77,0)
 I $D(EDIPI),'$D(^DGCN(391.91,"AISS",EDIPI,ASSIGN,TYPE,SITEIEN)) D  Q
"RTN","HMPTFU2",78,0)
 . S LIST(1)="-1^EDIPI Record is unknown at this facility"
"RTN","HMPTFU2",79,0)
 I $D(EDIPI),$D(^DGCN(391.91,"AISS",EDIPI,ASSIGN,TYPE,SITEIEN)) D
"RTN","HMPTFU2",80,0)
 .S EN=$O(^DGCN(391.91,"AISS",EDIPI,ASSIGN,TYPE,SITEIEN,0))
"RTN","HMPTFU2",81,0)
 .S DFN=$P($G(^DGCN(391.91,EN,0)),"^")
"RTN","HMPTFU2",82,0)
 ;
"RTN","HMPTFU2",83,0)
 ; if ICN is not defined, it is OK, but DFN should be defined
"RTN","HMPTFU2",84,0)
 ; bad input, such as Id^NI^USVHA^123
"RTN","HMPTFU2",85,0)
 I '$G(DFN) S LIST(1)="-1^Invalid input" Q
"RTN","HMPTFU2",86,0)
 ; check DFN and Site to be matching an entry in file #391.91
"RTN","HMPTFU2",87,0)
 I '$O(^DGCN(391.91,"APAT",DFN,SITEIEN,0)) D  Q
"RTN","HMPTFU2",88,0)
 . S LIST(1)="-1^Id as '"_ID_"'"_" is not in database"
"RTN","HMPTFU2",89,0)
 ; DFN should be defined, but ICN may not.
"RTN","HMPTFU2",90,0)
 S X=$$QUERYTF($P($G(ICN),"V"),"LIST")
"RTN","HMPTFU2",91,0)
 I $P(X,U)="1" S LIST(1)="-1"_U_$P(X,U,2) Q
"RTN","HMPTFU2",92,0)
 Q
"RTN","HMPTFU2",93,0)
 ;
"RTN","HMPTFU2",94,0)
GETICN(EDIPI) ;return the ICN when EDIPI is passed
"RTN","HMPTFU2",95,0)
 N EN,DFN,ICN,IEN
"RTN","HMPTFU2",96,0)
 S IEN=$$IEN^XUAF4("200DOD")
"RTN","HMPTFU2",97,0)
 I 'IEN Q "-1^Unknown Assigning Facility."
"RTN","HMPTFU2",98,0)
 I '$D(^DGCN(391.91,"ASCR",EDIPI,IEN)) Q "-1^EDIPI Record is unknown at this facility"
"RTN","HMPTFU2",99,0)
 I $D(^DGCN(391.91,"ASCR",EDIPI,IEN)) D
"RTN","HMPTFU2",100,0)
 .S EN=$O(^DGCN(391.91,"ASCR",EDIPI,$$IEN^XUAF4("200DOD"),""))
"RTN","HMPTFU2",101,0)
 .S DFN=$P($G(^DGCN(391.91,EN,0)),"^")
"RTN","HMPTFU2",102,0)
 .I DFN'="" S ICN=$$GETICN^MPIF001(DFN)
"RTN","HMPTFU2",103,0)
 .I DFN="" S ICN="-1^No Site Record associated with this entry"
"RTN","HMPTFU2",104,0)
 Q ICN
"RTN","HMPTFU2",105,0)
 ;
"RTN","HMPTFU2",106,0)
QUERYTF(PAT,ARY) ;a query for Treating Facility.
"RTN","HMPTFU2",107,0)
 ;INPUT   PAT - The patient's ICN
"RTN","HMPTFU2",108,0)
 ;        ARY - The array in which to return the Treating facility info.
"RTN","HMPTFU2",109,0)
 ;OUTPUT  A list of the Treating Facilities in the array provided from
"RTN","HMPTFU2",110,0)
 ;        the parameter.  It will be in the structure of x(1), x(2) etc.
"RTN","HMPTFU2",111,0)
 ;  Ex  X(1)=<ID> ^ <ID TYPE> ^ <Assigning Authority> ^ <Assigning Facility> ^ <ID Status>
"RTN","HMPTFU2",112,0)
 ;
"RTN","HMPTFU2",113,0)
 ; This is also a function call.  If there is an error then "1^error description" will be returned. 
"RTN","HMPTFU2",114,0)
 ; If no data is found the array will not be populated and "1^error description" will be returned.
"RTN","HMPTFU2",115,0)
 ;
"RTN","HMPTFU2",116,0)
 N PDFN,HMPER,LP,CTR
"RTN","HMPTFU2",117,0)
 ;
"RTN","HMPTFU2",118,0)
 ; ICN is not required
"RTN","HMPTFU2",119,0)
 I ('$D(ARY)) S HMPER="1^Parameter missing." G QUERYTFQ
"RTN","HMPTFU2",120,0)
 S HMPER=0,CTR=1
"RTN","HMPTFU2",121,0)
 S X="MPIF001" X ^%ZOSF("TEST") I '$T G QUERYTFQ
"RTN","HMPTFU2",122,0)
 S PDFN=$G(DFN)
"RTN","HMPTFU2",123,0)
 I '$G(PDFN) S HMPER="1^DFN is not defined." G QUERYTFQ
"RTN","HMPTFU2",124,0)
 ;SET FIRST ENTRY TO BE THE ICN - FULL ICN - PAT IS NOT THE ICN
"RTN","HMPTFU2",125,0)
 S @ARY@(CTR)=$$GETICN^MPIF001(PDFN)_"^NI^200M^USVHA^A"
"RTN","HMPTFU2",126,0)
 ;**856 - MVI 1371 (ckn)
"RTN","HMPTFU2",127,0)
 ;Loop through all TFIENs for site
"RTN","HMPTFU2",128,0)
 ;F LP=0:0 S LP=$O(^DGCN(391.91,"APAT",PDFN,LP)) Q:'LP  S TFIEN=$O(^(LP,"")) D SET(TFIEN,ARY,.CTR)
"RTN","HMPTFU2",129,0)
 F LP=0:0 S LP=$O(^DGCN(391.91,"APAT",PDFN,LP)) Q:'LP  D
"RTN","HMPTFU2",130,0)
 .S TFIEN=0 F  S TFIEN=$O(^DGCN(391.91,"APAT",PDFN,LP,TFIEN)) Q:'TFIEN  D
"RTN","HMPTFU2",131,0)
 ..D SET(TFIEN,ARY,.CTR)
"RTN","HMPTFU2",132,0)
 I $D(@ARY)'>9 S HMPER="1^Could not find Treating Facilities"
"RTN","HMPTFU2",133,0)
QUERYTFQ Q HMPER
"RTN","HMPTFU2",134,0)
 ;
"RTN","HMPTFU2",135,0)
SET(TFIEN,ARY,CTR) ;This sets the array with the treating facility list.
"RTN","HMPTFU2",136,0)
 ;  Ex  ARY(1)=<ID> ^ <ID TYPE> ^ <Assigning Facility> ^ <Assigning Authority> ^ <ID Status>
"RTN","HMPTFU2",137,0)
 N DGCN,INSTIEN,SOURCE,EN,SDFN,STATUS,SITEN,ID,IDTYPE,SITE,ASSAUTH,FOUND,NODE,NODE0,NODE2,STNNUM
"RTN","HMPTFU2",138,0)
 S DGCN(0)=$G(^DGCN(391.91,TFIEN,0)),SITEN=""
"RTN","HMPTFU2",139,0)
 ;
"RTN","HMPTFU2",140,0)
 S INSTIEN=$P($G(DGCN(0)),"^",2) ;            TREATING FACILITY LIST (#391.91) INSTITUTION field (#.02)
"RTN","HMPTFU2",141,0)
 I INSTIEN'="" S SITEN=$$STA^XUAF4(INSTIEN) ; STATION from Institution IEN
"RTN","HMPTFU2",142,0)
 S ID=$P(DGCN(0),"^") ;                       ID=Patient DFN field (#.01)
"RTN","HMPTFU2",143,0)
 S STNNUM=SITEN
"RTN","HMPTFU2",144,0)
 ;
"RTN","HMPTFU2",145,0)
 S NODE2=$G(^DGCN(391.91,TFIEN,2))
"RTN","HMPTFU2",146,0)
 S SDFN=$P(NODE2,"^",2) ; SDFN="SOURCE ID"
"RTN","HMPTFU2",147,0)
 S STATUS=$P(NODE2,"^",3) ; STATUS="IDENTIFIER STATUS"
"RTN","HMPTFU2",148,0)
 S ASSAUTH=$P(NODE2,"^") ; Assigning Authority
"RTN","HMPTFU2",149,0)
 ;
"RTN","HMPTFU2",150,0)
 S NODE0=$G(^DGCN(391.91,TFIEN,0))
"RTN","HMPTFU2",151,0)
 S IDTYPE=$P(NODE0,"^",9) ; SOURCE ID TYPE
"RTN","HMPTFU2",152,0)
 ;
"RTN","HMPTFU2",153,0)
 I SITEN="200DOD"!(SITEN["200N") S IDTYPE="NI"
"RTN","HMPTFU2",154,0)
 I SITEN="200DOD" S ASSAUTH="USDOD"
"RTN","HMPTFU2",155,0)
 I IDTYPE="" S IDTYPE="PI"
"RTN","HMPTFU2",156,0)
 I ASSAUTH="" S ASSAUTH="USVHA"
"RTN","HMPTFU2",157,0)
 I SITEN["200N"&(IDTYPE="NI")&(ASSAUTH="USVHA") S ASSAUTH=""
"RTN","HMPTFU2",158,0)
 I IDTYPE="PI" S SITEN=$$TF2SITEN(TFIEN) Q:(SITEN=""&(STNNUM'="742V1"))
"RTN","HMPTFU2",159,0)
 ;
"RTN","HMPTFU2",160,0)
 ; If VA Internal Patient ID, get site hash from domain associated with Treating Facility
"RTN","HMPTFU2",161,0)
 S NODE0=$G(^DGCN(391.91,TFIEN,0))
"RTN","HMPTFU2",162,0)
 S NODE2=$G(^DGCN(391.91,TFIEN,2))
"RTN","HMPTFU2",163,0)
 S SDFN=$P(NODE2,"^",2),STATUS=$P(NODE2,"^",3),IDTYPE=$P(NODE0,"^",9)
"RTN","HMPTFU2",164,0)
 ; DE2345 - MBS 9/15/2015; Only return active entries
"RTN","HMPTFU2",165,0)
 I STATUS'="A" Q
"RTN","HMPTFU2",166,0)
 S ASSAUTH=$P(NODE2,"^")
"RTN","HMPTFU2",167,0)
 I SITEN="200DOD"!(SITEN["200N") S IDTYPE="NI"
"RTN","HMPTFU2",168,0)
 I SITEN="200DOD" S ASSAUTH="USDOD"
"RTN","HMPTFU2",169,0)
 I IDTYPE="" S IDTYPE="PI"
"RTN","HMPTFU2",170,0)
 I ASSAUTH="" S ASSAUTH="USVHA"
"RTN","HMPTFU2",171,0)
 I SITEN["200N"&(IDTYPE="NI")&(ASSAUTH="USVHA") S ASSAUTH=""
"RTN","HMPTFU2",172,0)
 I SDFN'="" S CTR=CTR+1,@ARY@(CTR)=SDFN_"^"_IDTYPE_"^"_SITEN_"^"_ASSAUTH_"^"_STATUS_"^"_STNNUM,FOUND=1
"RTN","HMPTFU2",173,0)
 Q
"RTN","HMPTFU2",174,0)
TF2SITEN(TFIEN) ;Find the DOMAIN associated with the TREATING FACILITY and return the station number.
"RTN","HMPTFU2",175,0)
 ;Currently, our test systems' station numbers are not set up for local DOMAINs. This would result in these
"RTN","HMPTFU2",176,0)
 ;entries failing all the time, thus breaking existing behavior. For the time being, we will default to
"RTN","HMPTFU2",177,0)
 ;the old behavior if we cannot locate a station number as a temporary measure. In the future, we need to
"RTN","HMPTFU2",178,0)
 ;fix the test systems to set up the station numbers correctly, and then change this code to return
"RTN","HMPTFU2",179,0)
 ;an empty string if the DOMAIN could not be resolved.
"RTN","HMPTFU2",180,0)
 S SITEN=""
"RTN","HMPTFU2",181,0)
 Q:'+$G(TFIEN) ""
"RTN","HMPTFU2",182,0)
 Q:'$D(^DGCN(391.91,TFIEN)) ""
"RTN","HMPTFU2",183,0)
 ;Get station number from Institution file (pointed to from Treating Facility List)
"RTN","HMPTFU2",184,0)
 N INSTNUM,STNNUM,DONE,I
"RTN","HMPTFU2",185,0)
 S INSTNUM=$P($G(^DGCN(391.91,TFIEN,0)),U,2) Q:'+INSTNUM SITEN
"RTN","HMPTFU2",186,0)
 S STNNUM=$P($G(^DIC(4,INSTNUM,99)),U) Q:'+STNNUM SITEN
"RTN","HMPTFU2",187,0)
 ;DE2345 - MBS 9/15/2015; Do not return entries with station numbers=+200
"RTN","HMPTFU2",188,0)
 I STNNUM?1"200".A Q ""
"RTN","HMPTFU2",189,0)
 ;Domain file doesn't have an x-ref on station number, so we have to brute-force it
"RTN","HMPTFU2",190,0)
 S (I,DONE)=0 F  S I=$O(^DIC(4.2,I)) Q:'+I  D  Q:DONE
"RTN","HMPTFU2",191,0)
 . I $P(^DIC(4.2,I,0),U,13)=STNNUM S SITEN=$$SYS^HMPUTILS($P(^DIC(4.2,I,0),U)),DONE=1
"RTN","HMPTFU2",192,0)
 Q SITEN
"RTN","HMPTFU2",193,0)
 ;
"RTN","HMPTIUL")
0^73^B4400616
"RTN","HMPTIUL",1,0)
HMPTIUL ;ASMR/HM/CK - RPC to display long list of titles;Mar 29, 2016 11:34:29
"RTN","HMPTIUL",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPTIUL",3,0)
 ;PER VA Directive 6402, this routine should not be modified
"RTN","HMPTIUL",4,0)
 ;
"RTN","HMPTIUL",5,0)
 ; External References          DBIA#
"RTN","HMPTIUL",6,0)
 ; -------------------          -----
"RTN","HMPTIUL",7,0)
 ; TIU NATIONAL TITLE LINK      5677
"RTN","HMPTIUL",8,0)
 Q
"RTN","HMPTIUL",9,0)
 ;
"RTN","HMPTIUL",10,0)
LONGLIST(Y) ;long list of titles
"RTN","HMPTIUL",11,0)
 ; .Y = Return list contains the IEN and NAME of the Document Class hierarchy
"RTN","HMPTIUL",12,0)
 ;        TITLE, DOCUMENT CLASS, CLASS - DE3566 added document class and class
"RTN","HMPTIUL",13,0)
 ; it will return all titles with restrictions with inactive titles removed 
"RTN","HMPTIUL",14,0)
 ;  e.g 622^ATTENDING  <CARDIOLOGY ATTENDING CONSULT>^618^CARDIOLOGY^3^PROGRESS NOTES^38^CLINICAL DOCUMENTS
"RTN","HMPTIUL",15,0)
 ;
"RTN","HMPTIUL",16,0)
 N CLASS,DA,DOCCLASS,I,PARNTDOC,PARENT,SN,STATUS,TITLE,X
"RTN","HMPTIUL",17,0)
 K Y  ; Y is the returned value
"RTN","HMPTIUL",18,0)
 S I=0,CLASS=0,TITLE=""
"RTN","HMPTIUL",19,0)
 F  S CLASS=$O(^TIU(8925.1,"ACL",CLASS)) Q:+CLASS'>0  D  ;ICR 5677 TIU NATIONAL TITLE LINK
"RTN","HMPTIUL",20,0)
 . F  S TITLE=$O(^TIU(8925.1,"ACL",CLASS,TITLE)) Q:TITLE=""  D
"RTN","HMPTIUL",21,0)
 . . S DA=0
"RTN","HMPTIUL",22,0)
 . . F  S DA=$O(^TIU(8925.1,"ACL",CLASS,TITLE,DA)) Q:+DA'>0  D
"RTN","HMPTIUL",23,0)
 . . . S SN=$G(^TIU(8925.1,DA,0)),STATUS=$P(SN,"^",7)
"RTN","HMPTIUL",24,0)
 . . . Q:STATUS'=11  ; return Active Titles only
"RTN","HMPTIUL",25,0)
 . . . ; DE3566 March 28, 2016 CK- return the Document Class hierarchy
"RTN","HMPTIUL",26,0)
 . . . ; get DOCUMENT CLASS - DE3566
"RTN","HMPTIUL",27,0)
 . . . S DOCCLASS("IEN")=+$$DOCCLASS^TIULC1(+DA)  ;ICR 3548
"RTN","HMPTIUL",28,0)
 . . . S DOCCLASS("NAM")=$P(^TIU(8925.1,DOCCLASS("IEN"),0),U)
"RTN","HMPTIUL",29,0)
 . . . ; get Parent of DOCUMENT CLASS - DE3566
"RTN","HMPTIUL",30,0)
 . . . S PARNTDOC("IEN")=+$$CLINDOC^TIULC1(+DA)
"RTN","HMPTIUL",31,0)
 . . . S PARNTDOC("NAM")=$P(^TIU(8925.1,PARNTDOC("IEN"),0),U)
"RTN","HMPTIUL",32,0)
 . . . ; get Parent Class of above - DE3566
"RTN","HMPTIUL",33,0)
 . . . S PARENT("IEN")=38
"RTN","HMPTIUL",34,0)
 . . . S PARENT("NAM")=$P(^TIU(8925.1,PARENT("IEN"),0),U)
"RTN","HMPTIUL",35,0)
 . . . ; Populate list of TIU Long List of Titles
"RTN","HMPTIUL",36,0)
 . . . S I=I+1,Y(I)=DA_U_TITLE_U_DOCCLASS("IEN")_U_DOCCLASS("NAM")_U_PARNTDOC("IEN")_U
"RTN","HMPTIUL",37,0)
 . . . S Y(I)=Y(I)_PARNTDOC("NAM")_U_PARENT("IEN")_U_PARENT("NAM")
"RTN","HMPTIUL",38,0)
 . . . ;DE3566 end of changes
"RTN","HMPTIUL",39,0)
 Q
"RTN","HMPTIUL",40,0)
 ;
"RTN","HMPTOOLS")
0^60^B13771837
"RTN","HMPTOOLS",1,0)
HMPTOOLS ;ASMR/JD - More HMP utilities ; 9/25/15 10:59am
"RTN","HMPTOOLS",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPTOOLS",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPTOOLS",4,0)
 ;
"RTN","HMPTOOLS",5,0)
 Q
"RTN","HMPTOOLS",6,0)
 ;
"RTN","HMPTOOLS",7,0)
CHKXTMP(RSLT) ; RPC(HMP CHKXTMP) to return the state of ^XTMP data
"RTN","HMPTOOLS",8,0)
 ; RSLT - Return array:
"RTN","HMPTOOLS",9,0)
 ;        "There are a total of xxx patients in queue.  yyy Complete  zzz Staging"
"RTN","HMPTOOLS",10,0)
 ;        Where xxx,yyy, and zzz are zero or greater.
"RTN","HMPTOOLS",11,0)
 ;        NOTE: If xxx is zero, then the sentence after "queue." will NOT be displayed
"RTN","HMPTOOLS",12,0)
 ;
"RTN","HMPTOOLS",13,0)
 ; Goes through ^XTMP and figures out the total number of patients, how many
"RTN","HMPTOOLS",14,0)
 ; have completed data staging, and how many are still staging.
"RTN","HMPTOOLS",15,0)
 ; There is code to allow a bit more information than requested to be stored
"RTN","HMPTOOLS",16,0)
 ; in a global (^TMP("FINDSTATUS",$J)) for future needs (e.g. Complete/staging
"RTN","HMPTOOLS",17,0)
 ; is broken down by domain).  *** This currently commented out ***.
"RTN","HMPTOOLS",18,0)
 ;
"RTN","HMPTOOLS",19,0)
 ; ^XTMP("HMPFX~<server id>~DFN",0,"status",<domain>)=STATUS, where STATUS=1 means
"RTN","HMPTOOLS",20,0)
 ; data is completely staged and 0 means data is being staged but not complete yet.
"RTN","HMPTOOLS",21,0)
 ;
"RTN","HMPTOOLS",22,0)
 ; GLB    = ^TMP("FINDSTATUS",$J)  (FUTURE USE)
"RTN","HMPTOOLS",23,0)
 ; HMPBAT = "HMPFX~<sever id>~DFN"
"RTN","HMPTOOLS",24,0)
 ; HMPCM  = Number of patients who have completed staging
"RTN","HMPTOOLS",25,0)
 ; HMPCMP = Number of domains that have completed staging for a patient
"RTN","HMPTOOLS",26,0)
 ; HMPCNT = Domain status (1 = complete; 0 = staging)
"RTN","HMPTOOLS",27,0)
 ; HMPDFN = Patient IEN
"RTN","HMPTOOLS",28,0)
 ; HMPDOM = Patient domain (e.g. lab, med, allergy, etc.)
"RTN","HMPTOOLS",29,0)
 ; HMPST  = Number of patients who are still in the staging state
"RTN","HMPTOOLS",30,0)
 ; HMPSTG = Number of domains that are still staging for a patient
"RTN","HMPTOOLS",31,0)
 ; HMPT   = HMPCM+HMPST
"RTN","HMPTOOLS",32,0)
 ;
"RTN","HMPTOOLS",33,0)
 N GLB,HMPBAT,HMPCM,HMPCMP,HMPCNT,HMPDFN,HMPDOM,HMPST,HMPSTG,HMPT
"RTN","HMPTOOLS",34,0)
 ;S GLB=$NA(^TMP("FINDSTATUS",$J))
"RTN","HMPTOOLS",35,0)
 ;K @GLB
"RTN","HMPTOOLS",36,0)
 S HMPBAT="HMPFX",(HMPCM,HMPST)=0
"RTN","HMPTOOLS",37,0)
 F  S HMPBAT=$O(^XTMP(HMPBAT)) Q:$E(HMPBAT,1,5)'="HMPFX"  D
"RTN","HMPTOOLS",38,0)
 .S HMPDOM="",HMPDFN=$P(HMPBAT,"~",3),(HMPCMP,HMPSTG)=0
"RTN","HMPTOOLS",39,0)
 .I HMPDFN'=+HMPDFN Q  ; Patients ONLY!
"RTN","HMPTOOLS",40,0)
 .F  S HMPDOM=$O(^XTMP(HMPBAT,0,"status",HMPDOM)) Q:HMPDOM']""  D
"RTN","HMPTOOLS",41,0)
 ..S HMPCNT=^XTMP(HMPBAT,0,"status",HMPDOM)
"RTN","HMPTOOLS",42,0)
 ..I HMPCNT=1 D
"RTN","HMPTOOLS",43,0)
 ...S HMPCMP=HMPCMP+1
"RTN","HMPTOOLS",44,0)
 ...;S @GLB@(HMPDFN,HMPDOM)="Complete"
"RTN","HMPTOOLS",45,0)
 ..I HMPCNT'=1 D
"RTN","HMPTOOLS",46,0)
 ...S HMPSTG=HMPSTG+1
"RTN","HMPTOOLS",47,0)
 ...;S @GLB@(HMPDFN,HMPDOM)="Staging"
"RTN","HMPTOOLS",48,0)
 .I HMPSTG>0 D
"RTN","HMPTOOLS",49,0)
 ..S HMPST=HMPST+1
"RTN","HMPTOOLS",50,0)
 ..;S @GLB@(HMPDFN)="Staging"
"RTN","HMPTOOLS",51,0)
 .I HMPSTG'>0 D
"RTN","HMPTOOLS",52,0)
 ..S HMPCM=HMPCM+1
"RTN","HMPTOOLS",53,0)
 ..;S @GLB@(HMPDFN)="Complete"
"RTN","HMPTOOLS",54,0)
 S HMPT=HMPCM+HMPST
"RTN","HMPTOOLS",55,0)
 K RSLT
"RTN","HMPTOOLS",56,0)
 S RSLT(1)="There are a total of "_HMPT_" patient"_$S(HMPT=1:"",1:"s")_" in queue."
"RTN","HMPTOOLS",57,0)
 I HMPCM>0 S RSLT(1)=RSLT(1)_"  "_HMPCM_" Complete"
"RTN","HMPTOOLS",58,0)
 I HMPST>0 S RSLT(1)=RSLT(1)_"  "_HMPST_" Staging"
"RTN","HMPTOOLS",59,0)
 Q
"RTN","HMPTOOLS",60,0)
 ;
"RTN","HMPTOOLS",61,0)
MON ; Monitor the progress of ^XTMP growth.  JD - 6/11/15
"RTN","HMPTOOLS",62,0)
 N DONE,SIZE,RES
"RTN","HMPTOOLS",63,0)
 D HOME^%ZIS
"RTN","HMPTOOLS",64,0)
 S DONE=-1
"RTN","HMPTOOLS",65,0)
 F  Q:DONE'=-1  D
"RTN","HMPTOOLS",66,0)
 .S SIZE=+$P($P($$GETSIZE(),U)/1000+.5,".")
"RTN","HMPTOOLS",67,0)
 .W @IOF,"eHMP usage of ^XTMP = "_SIZE_"  kilo byte(s)"
"RTN","HMPTOOLS",68,0)
 .D CHKXTMP(.RES)
"RTN","HMPTOOLS",69,0)
 .W !!,RES(1)
"RTN","HMPTOOLS",70,0)
 .W !!,"Hit any key to exit the monitor"
"RTN","HMPTOOLS",71,0)
 .X "R *DONE:2"
"RTN","HMPTOOLS",72,0)
 Q
"RTN","HMPTOOLS",73,0)
 ;
"RTN","HMPTOOLS",74,0)
SIZE(RSLT) ; calculate the size of XTMP global
"RTN","HMPTOOLS",75,0)
 S RSLT(1)=$P($$GETSIZE(),"^")
"RTN","HMPTOOLS",76,0)
 Q
"RTN","HMPTOOLS",77,0)
 ;
"RTN","HMPTOOLS",78,0)
GETSIZE(HMPMODE,HMPSRVN) ; -- return current aggregate extract size for extracts waiting to be sent to HMP servers
"RTN","HMPTOOLS",79,0)
 ; input: HMPMODE := [ estimate - use estimated domain average sizes (default) |
"RTN","HMPTOOLS",80,0)
 ;                     actual - walk though object nodes to calculate using $LENGTH ]
"RTN","HMPTOOLS",81,0)
 ;        HMPSRVN := name of HMP server [optional - defaults to all HMP servers]
"RTN","HMPTOOLS",82,0)
 ; returns: total size in bytes ^ object count
"RTN","HMPTOOLS",83,0)
 ;
"RTN","HMPTOOLS",84,0)
 ; -- loop thru extracts for server(s) 
"RTN","HMPTOOLS",85,0)
 N ROOT,BATCH,TASK,DOMAIN,OBJS,OBJCNT,OBJSIZES,TOTAL
"RTN","HMPTOOLS",86,0)
 S (OBJCNT,TOTAL)=0
"RTN","HMPTOOLS",87,0)
 S ROOT="HMPFX~"_$S($G(HMPSRVN)]"":HMPSRVN_"~",1:"")
"RTN","HMPTOOLS",88,0)
 S BATCH=ROOT
"RTN","HMPTOOLS",89,0)
 F  S BATCH=$O(^XTMP(BATCH)) Q:$E(BATCH,1,$L(ROOT))'=ROOT  D
"RTN","HMPTOOLS",90,0)
 . S TASK=0 F  S TASK=$O(^XTMP(BATCH,TASK)) Q:'TASK  D
"RTN","HMPTOOLS",91,0)
 . . S DOMAIN="" F  S DOMAIN=$O(^XTMP(BATCH,TASK,DOMAIN)) Q:DOMAIN=""  D
"RTN","HMPTOOLS",92,0)
 . . . S OBJS=+$O(^XTMP(BATCH,TASK,DOMAIN," "),-1)
"RTN","HMPTOOLS",93,0)
 . . . S OBJCNT=OBJCNT+OBJS
"RTN","HMPTOOLS",94,0)
 . . . S TOTAL=TOTAL+$$WALK(BATCH,TASK,DOMAIN) Q
"RTN","HMPTOOLS",95,0)
 . . . S TOTAL=TOTAL+(OBJS*$G(OBJSIZES($P(DOMAIN,"#")),1000))
"RTN","HMPTOOLS",96,0)
 Q TOTAL_"^"_OBJCNT
"RTN","HMPTOOLS",97,0)
 ;
"RTN","HMPTOOLS",98,0)
WALK(BATCH,TASK,DOMAIN) ; -- walk through domain objectS in task to get actual size
"RTN","HMPTOOLS",99,0)
 N OBJ,SIZE,NODE
"RTN","HMPTOOLS",100,0)
 S (OBJ,SIZE)=0
"RTN","HMPTOOLS",101,0)
 F  S OBJ=$O(^XTMP(BATCH,TASK,DOMAIN,OBJ)) Q:'OBJ  D
"RTN","HMPTOOLS",102,0)
 . S NODE=0 F  S NODE=$O(^XTMP(BATCH,TASK,DOMAIN,OBJ,NODE)) Q:'NODE  S SIZE=SIZE+$L($G(^(NODE)))
"RTN","HMPTOOLS",103,0)
 Q SIZE
"RTN","HMPTOOLS",104,0)
 ;
"RTN","HMPTOOLS",105,0)
MSG(M,Q,V) ;
"RTN","HMPTOOLS",106,0)
 ;Create a message (M) in JSON format with a qualifier (Q)
"RTN","HMPTOOLS",107,0)
 ;Returns RSLT(1)
"RTN","HMPTOOLS",108,0)
 ; M - Message text  - The paramater is message being reported for instance "DFN" could the message
"RTN","HMPTOOLS",109,0)
 ; Q - Qualifier:    - The quailifier is reporting where the JSON message is Required or Invalid.
"RTN","HMPTOOLS",110,0)
 ;        1 - Required
"RTN","HMPTOOLS",111,0)
 ;        2 - Invalid
"RTN","HMPTOOLS",112,0)
 ; V - If Q=1, then V is ignored (or not passed in)  
"RTN","HMPTOOLS",113,0)
 ;     If Q=2, then V=<the invalid value>
"RTN","HMPTOOLS",114,0)
 N TEXT,ERRMSG,JSONERR
"RTN","HMPTOOLS",115,0)
 K ERRMSG,RSLT,JSONERR
"RTN","HMPTOOLS",116,0)
 S M=$G(M),Q=$G(Q),V=$G(V)
"RTN","HMPTOOLS",117,0)
 S TEXT=M
"RTN","HMPTOOLS",118,0)
 I Q=1 S TEXT=M_" is required"
"RTN","HMPTOOLS",119,0)
 I Q=2 S TEXT="Invalid "_M_": "_V
"RTN","HMPTOOLS",120,0)
 S ERRMSG("Message")=TEXT D ENCODE^HMPJSON("ERRMSG","RSLT","JSONERR")
"RTN","HMPTOOLS",121,0)
 I $G(JSONERR) S RSLT(1)=JSONERR
"RTN","HMPTOOLS",122,0)
 Q
"RTN","HMPUPD")
0^43^B25103187
"RTN","HMPUPD",1,0)
HMPUPD ;SLC/MKB,ASMR/RRB,CK - Update local data ;Jun 22, 2016 17:23:52
"RTN","HMPUPD",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;May 15, 2016;Build 24
"RTN","HMPUPD",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPUPD",4,0)
 ;
"RTN","HMPUPD",5,0)
 Q
"RTN","HMPUPD",6,0)
 ;
"RTN","HMPUPD",7,0)
PHONE(HMP,JSON) ; RPC = HMP PUT PHONE
"RTN","HMPUPD",8,0)
 Q
"RTN","HMPUPD",9,0)
PUT(HMP,DFN,CMD,JSON) ; -- update phone numbers
"RTN","HMPUPD",10,0)
 ; RPC = HMP PUT DEMOGRAPHICS
"RTN","HMPUPD",11,0)
 ;
"RTN","HMPUPD",12,0)
 N ARRAY,HMPERR,ERR,HOME,CELL,WORK,NOK,ECON,X,OK,HMPSYS
"RTN","HMPUPD",13,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPUPD",14,0)
 D DECODE^HMPJSON("JSON","ARRAY","HMPERR")
"RTN","HMPUPD",15,0)
 I $D(HMPERR) D  G PQ
"RTN","HMPUPD",16,0)
 . K ARRAY N HMPTMP,HMPTXT
"RTN","HMPUPD",17,0)
 . S HMPTXT(1)="Problem decoding json input."
"RTN","HMPUPD",18,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.JSON)
"RTN","HMPUPD",19,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","ARRAY","HMPERR")
"RTN","HMPUPD",20,0)
 . S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPUPD",21,0)
 . M HMP(1)=ARRAY
"RTN","HMPUPD",22,0)
 . S HMP(2)="}}"
"RTN","HMPUPD",23,0)
 ;
"RTN","HMPUPD",24,0)
 S DFN=+$G(DFN) I DFN<1 S ERR=$$ERR(1,DFN) G PHQ
"RTN","HMPUPD",25,0)
 S CMD=$G(CMD) ;can only update phone#
"RTN","HMPUPD",26,0)
 N HMPX,HMPDR,I,J S (HMPDR,HOME,CELL,WORK,NOK,ECON)=""
"RTN","HMPUPD",27,0)
 D VAL("old")
"RTN","HMPUPD",28,0)
 S I="" F  S I=$O(ARRAY("telecom",I)) Q:I<1  D
"RTN","HMPUPD",29,0)
 . I $G(ARRAY("telecom",I,"use"))="H" D  Q
"RTN","HMPUPD",30,0)
 .. S HOME=$G(ARRAY("telecom",I,"value"))
"RTN","HMPUPD",31,0)
 .. I HOME=HOME("old") S HOME="" Q           ;no change
"RTN","HMPUPD",32,0)
 .. I "@"[HOME S:$L(HOME("old")) HOME="@" Q  ;delete
"RTN","HMPUPD",33,0)
 .. S HOME=$$FORMAT(HOME),ARRAY("telecom",I,"value")=HOME
"RTN","HMPUPD",34,0)
 . I $G(ARRAY("telecom",I,"use"))="MC" D  Q
"RTN","HMPUPD",35,0)
 .. S CELL=$G(ARRAY("telecom",I,"value"))
"RTN","HMPUPD",36,0)
 .. I CELL=CELL("old") S CELL="" Q           ;no change
"RTN","HMPUPD",37,0)
 .. I "@"[CELL S:$L(CELL("old")) CELL="@" Q  ;delete
"RTN","HMPUPD",38,0)
 .. S CELL=$$FORMAT(CELL),ARRAY("telecom",I,"value")=CELL
"RTN","HMPUPD",39,0)
 . I $G(ARRAY("telecom",I,"use"))="WP" D  Q
"RTN","HMPUPD",40,0)
 .. S WORK=$G(ARRAY("telecom",I,"value"))
"RTN","HMPUPD",41,0)
 .. I WORK=WORK("old") S WORK="" Q           ;no change
"RTN","HMPUPD",42,0)
 .. I "@"[WORK S:$L(WORK("old")) WORK="@" Q  ;delete
"RTN","HMPUPD",43,0)
 .. S WORK=$$FORMAT(WORK),ARRAY("telecom",I,"value")=WORK
"RTN","HMPUPD",44,0)
 S I="" F  S I=$O(ARRAY("contact",I)) Q:I<1  D
"RTN","HMPUPD",45,0)
 . S X=$P($G(ARRAY("contact",I,"typeCode")),":",4) Q:X=""  ;NOK or ECON
"RTN","HMPUPD",46,0)
 . S J="" F  S J=$O(ARRAY("contact",I,"telecom",J)) Q:J<1  D
"RTN","HMPUPD",47,0)
 .. Q:$G(ARRAY("contact",I,"telecom",J,"use"))'="H"
"RTN","HMPUPD",48,0)
 .. S @X=$G(ARRAY("contact",I,"telecom",J,"value"))
"RTN","HMPUPD",49,0)
 .. I @X=@X@("old") S @X="" Q           ;no change
"RTN","HMPUPD",50,0)
 .. I "@"[@X S:$L(@X@("old")) @X="@" Q  ;delete
"RTN","HMPUPD",51,0)
 .. S @X=$$FORMAT(@X),ARRAY("contact",I,"telecom",J,"value")=@X
"RTN","HMPUPD",52,0)
 .. ; X="NOK" S NOK=$$FORMAT(NOK),ARRAY("contact",I,"telecom",J,"value")=NOK
"RTN","HMPUPD",53,0)
 ;
"RTN","HMPUPD",54,0)
 S:$L(HOME) HMPX(.131)=HOME,HMPDR=".131"
"RTN","HMPUPD",55,0)
 S:$L(CELL) HMPX(.134)=CELL,HMPDR=HMPDR_$S($L(HMPDR):";",1:"")_".134"
"RTN","HMPUPD",56,0)
 S:$L(WORK) HMPX(.132)=WORK,HMPDR=HMPDR_$S($L(HMPDR):";",1:"")_".132"
"RTN","HMPUPD",57,0)
 S:$L(ECON) HMPX(.339)=ECON,HMPDR=HMPDR_$S($L(HMPDR):";",1:"")_".339"
"RTN","HMPUPD",58,0)
 S:$L(NOK) HMPX(.219)=NOK,HMPDR=HMPDR_$S($L(HMPDR):";",1:"")_".219"
"RTN","HMPUPD",59,0)
 I '$O(HMPX(0)) S ERR=$$ERR(3) G PHQ
"RTN","HMPUPD",60,0)
 D EDIT^VAFCPTED(DFN,"HMPX",HMPDR)
"RTN","HMPUPD",61,0)
 S X=$G(^DPT(DFN,.13)),OK=1 D  ;check global ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",62,0)
 . I $L(HOME),$S(HOME="@":$L($P(X,U)),1:(HMPX(.131)'=$P(X,U))) S OK=0
"RTN","HMPUPD",63,0)
 . I $L(CELL),$S(CELL="@":$L($P(X,U,4)),1:(HMPX(.134)'=$P(X,U,4))) S OK=0
"RTN","HMPUPD",64,0)
 . I $L(WORK),$S(WORK="@":$L($P(X,U,2)),1:(HMPX(.132)'=$P(X,U,2))) S OK=0
"RTN","HMPUPD",65,0)
 . I $L(ECON) S X=$G(^DPT(DFN,.33)) I $S(ECON="@":$L($P(X,U,9)),1:(HMPX(.339)'=$P(X,U,9))) S OK=0 ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",66,0)
 . I $L(NOK) S X=$G(^DPT(DFN,.21)) I $S(NOK="@":$L($P(X,U,9)),1:(HMPX(.219)'=$P(X,U,9))) S OK=0 ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",67,0)
 S:'OK ERR=$$ERR(5)
"RTN","HMPUPD",68,0)
 ;
"RTN","HMPUPD",69,0)
PHQ ; add item count and terminating characters
"RTN","HMPUPD",70,0)
 I $D(ERR) S HMP(1)="{""apiVersion"":""1.01"",""error"":{""message"":"""_ERR_"""},""success"":false}" G PQ
"RTN","HMPUPD",71,0)
 ; HMP="{""apiVersion"":""1.01"",""data"":{""updated"":"_""""_$$HL7NOW_""""_",""localId"":"""_DFN_"""},""success"":true}"
"RTN","HMPUPD",72,0)
 D POSTX^HMPEVNT("patient",DFN)
"RTN","HMPUPD",73,0)
 D ENCODE^HMPJSON("ARRAY","HMP","HMPERR")
"RTN","HMPUPD",74,0)
 I $D(HMPERR) D  G PQ
"RTN","HMPUPD",75,0)
 . K HMP N HMPTMP,HMPTXT
"RTN","HMPUPD",76,0)
 . S HMPTXT(1)="Problem encoding json output."
"RTN","HMPUPD",77,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.ARRAY)
"RTN","HMPUPD",78,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","HMP","HMPERR")
"RTN","HMPUPD",79,0)
 . S HMP(.5)="{""apiVersion"":""1.01"",""error"":{",HMP(99)="}}"
"RTN","HMPUPD",80,0)
 S HMP(.5)="{""apiVersion"":""1.01"",""params"":{"_$$SYS^HMPDJ_"},""success"":true,"
"RTN","HMPUPD",81,0)
 S HMP(.6)="""data"":{""updated"":"""_$$HL7NOW^HMPDJ_""",""totalItems"":1,""items"":["
"RTN","HMPUPD",82,0)
 S HMP(99)="]}}"
"RTN","HMPUPD",83,0)
PQ ; exit
"RTN","HMPUPD",84,0)
 K ^TMP($J,"HMP")
"RTN","HMPUPD",85,0)
 M ^TMP($J,"HMP")=HMP
"RTN","HMPUPD",86,0)
 K HMP S HMP=$NA(^TMP($J,"HMP"))
"RTN","HMPUPD",87,0)
 Q
"RTN","HMPUPD",88,0)
 ;
"RTN","HMPUPD",89,0)
FORMAT(X) ; -- enforce (xxx)xxx-xxxx phone format
"RTN","HMPUPD",90,0)
 S X=$G(X) I X?1"("3N1")"3N1"-"4N.E Q X
"RTN","HMPUPD",91,0)
 N P,N,I,Y S P=""
"RTN","HMPUPD",92,0)
 F I=1:1:$L(X) S N=$E(X,I) I N=+N S P=P_N
"RTN","HMPUPD",93,0)
 S:$L(P)<10 P=$E("0000000000",1,10-$L(P))_P
"RTN","HMPUPD",94,0)
 S Y=$S(P:"("_$E(P,1,3)_")"_$E(P,4,6)_"-"_$E(P,7,10),1:"")
"RTN","HMPUPD",95,0)
 Q Y
"RTN","HMPUPD",96,0)
 ;
"RTN","HMPUPD",97,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPUPD",98,0)
 Q $$FMTHL7^HMPSTMP($$NOW^XLFDT)  ; DE5016
"RTN","HMPUPD",99,0)
 ;
"RTN","HMPUPD",100,0)
ERR(X,VAL) ; -- return error message
"RTN","HMPUPD",101,0)
 N MSG  S MSG="Error"
"RTN","HMPUPD",102,0)
 I X=1  S MSG="Patient with dfn '"_$G(VAL)_"' not found"
"RTN","HMPUPD",103,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPUPD",104,0)
 I X=3  S MSG="Data not changed"
"RTN","HMPUPD",105,0)
 I X=4  S MSG="Unable to create new object"
"RTN","HMPUPD",106,0)
 I X=5  S MSG="Update failed"
"RTN","HMPUPD",107,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPUPD",108,0)
 Q MSG
"RTN","HMPUPD",109,0)
 ;
"RTN","HMPUPD",110,0)
VAL(SUB) ; -- pull values from ^DPT
"RTN","HMPUPD",111,0)
 N X S X=$G(^DPT(DFN,.13)) ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",112,0)
 S HOME(SUB)=$P(X,U),CELL(SUB)=$P(X,U,4),WORK(SUB)=$P(X,U,2)
"RTN","HMPUPD",113,0)
 S X=$G(^DPT(DFN,.33)),ECON(SUB)=$P(X,U,9) ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",114,0)
 S X=$G(^DPT(DFN,.21)),NOK(SUB)=$P(X,U,9) ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",115,0)
 Q
"RTN","HMPUTIL2")
0^61^B22837890
"RTN","HMPUTIL2",1,0)
HMPUTIL2 ; Agilex/hrubovcak -- HMP utilities routine ;Jun 10, 2015@15:13:03
"RTN","HMPUTIL2",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPUTIL2",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPUTIL2",4,0)
 ;
"RTN","HMPUTIL2",5,0)
ADHOC(HMPDMN,HMPFCNT,DFN,UID,STMPTM,DLTFLG) ; Add syncStart metastamp and syncStatus to unsolicited updates
"RTN","HMPUTIL2",6,0)
 ; HMPDMN,HMPFCNT,DFN,UID,STMPTM  - all required
"RTN","HMPUTIL2",7,0)
 ; DLTFLG - boolean 1 to delete, zero otherwise (optional)
"RTN","HMPUTIL2",8,0)
 ; requires HMPFSTRM and ARGS in symbol table
"RTN","HMPUTIL2",9,0)
 Q:($G(HMPDMN)="")!($G(DFN)="")!($G(UID)="")!($G(STMPTM)="")
"RTN","HMPUTIL2",10,0)
 ; set error trap
"RTN","HMPUTIL2",11,0)
 N $ES,$ET,ERRPAT
"RTN","HMPUTIL2",12,0)
 S $EC="",$ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPUTIL2",13,0)
 ;
"RTN","HMPUTIL2",14,0)
 S DLTFLG=+$G(DLTFLG)  ; optional parameter
"RTN","HMPUTIL2",15,0)
 ;Build SyncStart
"RTN","HMPUTIL2",16,0)
 N H,HMPDAT,HMPID,HMPJSN,HMPSUB,HMPTOT,HMPVAR,HMPX,HMPZ,JSNERR,STS,STSJSON,X,Y
"RTN","HMPUTIL2",17,0)
 S HMPSUB=$O(^TMP("HMP",$J,0)) Q:'HMPSUB
"RTN","HMPUTIL2",18,0)
 S HMPID=$$SYS^HMPUTILS
"RTN","HMPUTIL2",19,0)
 S HMPZ=0,HMPFCNT=$G(HMPFCNT)+1
"RTN","HMPUTIL2",20,0)
 D  ; start of JSON, based on DFN
"RTN","HMPUTIL2",21,0)
 .I DFN'="OPD" S HMPJSN="{""collection"":"""_"syncStart"_$C(34)_$$PIDS^HMPDJFS(DFN)_"," Q
"RTN","HMPUTIL2",22,0)
 .;operational data synch
"RTN","HMPUTIL2",23,0)
 .S HMPJSN="{""collection"":"""_"OPDsyncStart"_$C(34)_","""_"systemId"":"""_$P(HMPID,";")_$C(34)_","
"RTN","HMPUTIL2",24,0)
 .Q:'DLTFLG  ; deletion logic follows
"RTN","HMPUTIL2",25,0)
 .S H=$$FMTH^XLFDT($P($G(HMPFSTRM),"~",3))  ; days in $H format
"RTN","HMPUTIL2",26,0)
 .S X=$$HTFM^XLFDT($P(H,",")_","_(+$G(ARGS("hmp-fst"))))  ; add $H seconds or zero, get FileMan date
"RTN","HMPUTIL2",27,0)
 .S HMPVAR("JSON DEL DATE/TIME")=$$JSONDT^HMPUTILS(X)  ; delete date/time into JSON format
"RTN","HMPUTIL2",28,0)
 .S X=$P($G(UID),":",4)_";"_$P(UID,":",5)  ; UID pieces needed below
"RTN","HMPUTIL2",29,0)
 .S HMPVAR("REMOVED JSON")="{""pid"":"""_X_""",""removed"":""true"",""stampTime"":"_HMPVAR("JSON DEL DATE/TIME")_",""uid"":"""_UID_"""}"
"RTN","HMPUTIL2",30,0)
 ;
"RTN","HMPUTIL2",31,0)
 S:HMPFCNT>1 HMPJSN="},"_HMPJSN
"RTN","HMPUTIL2",32,0)
 S HMPJSN=HMPJSN_"""metaStamp"":"_"{"
"RTN","HMPUTIL2",33,0)
 I DFN'="OPD" S HMPJSN=HMPJSN_$E($$PIDS^HMPDJFS(DFN),2,$L($$PIDS^HMPDJFS(DFN)))_","
"RTN","HMPUTIL2",34,0)
 S HMPJSN=HMPJSN_"""stampTime"":"""_STMPTM_$C(34)_",""sourceMetaStamp"":"_"{"
"RTN","HMPUTIL2",35,0)
 S HMPJSN=HMPJSN_$C(34)_$P(HMPID,";")_$C(34)_":{"
"RTN","HMPUTIL2",36,0)
 I DFN'="OPD" S HMPJSN=HMPJSN_$E($$PIDS^HMPDJFS(DFN),2,$L($$PIDS^HMPDJFS(DFN)))_","
"RTN","HMPUTIL2",37,0)
 S HMPJSN=HMPJSN_"""stampTime"":"""_STMPTM_$C(34)_","
"RTN","HMPUTIL2",38,0)
 S HMPJSN=HMPJSN_"""domainMetaStamp"""_":"_"{"
"RTN","HMPUTIL2",39,0)
 ; transform the domain name for quick orders to match the uid
"RTN","HMPUTIL2",40,0)
 S HMPVAR("DOMAIN")=HMPDMN S:HMPVAR("DOMAIN")="quick" HMPVAR("DOMAIN")="qo"
"RTN","HMPUTIL2",41,0)
 S HMPTOT=1
"RTN","HMPUTIL2",42,0)
 S HMPJSN=HMPJSN_$C(34)_HMPVAR("DOMAIN")_$C(34)_":{"
"RTN","HMPUTIL2",43,0)
 S HMPJSN=HMPJSN_"""domain"":"""_HMPVAR("DOMAIN")_$C(34)_","
"RTN","HMPUTIL2",44,0)
 S HMPJSN=HMPJSN_"""stampTime"":"""_STMPTM_$C(34)_","
"RTN","HMPUTIL2",45,0)
 I DFN="OPD" S HMPJSN=HMPJSN_"""itemMetaStamp"""_":"_"{"
"RTN","HMPUTIL2",46,0)
 E  S HMPJSN=HMPJSN_"""eventMetaStamp"""_":"_"{"
"RTN","HMPUTIL2",47,0)
 ;
"RTN","HMPUTIL2",48,0)
 I $L(HMPJSN)>1000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPJSN,HMPJSN=""
"RTN","HMPUTIL2",49,0)
 S HMPVAR("DATETIME")=$P(UID,":",4,99)
"RTN","HMPUTIL2",50,0)
 ;I DLTFLG S HMPVAR("DATETIME")=$P(UID,":",4,99))
"RTN","HMPUTIL2",51,0)
 S HMPJSN=HMPJSN_$C(34)_UID_":"_HMPVAR("DOMAIN")_":"_HMPVAR("DATETIME")_$C(34)_":{"
"RTN","HMPUTIL2",52,0)
 ; determine date/time to use
"RTN","HMPUTIL2",53,0)
 S Y=STMPTM S:$G(HMPVAR("JSON DEL DATE/TIME")) Y=HMPVAR("JSON DEL DATE/TIME")
"RTN","HMPUTIL2",54,0)
 S HMPJSN=HMPJSN_"""stampTime"":"""_Y_$C(34)_"}}},"  ; put date/time into JSON array
"RTN","HMPUTIL2",55,0)
 ;
"RTN","HMPUTIL2",56,0)
 I $L(HMPJSN)>1000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPJSN,HMPJSN=""
"RTN","HMPUTIL2",57,0)
 S HMPZ=HMPZ+1
"RTN","HMPUTIL2",58,0)
 S HMPJSN=$E(HMPJSN,1,$L(HMPJSN)-1)_"}}}}},"
"RTN","HMPUTIL2",59,0)
 ;Save syncStart
"RTN","HMPUTIL2",60,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPJSN
"RTN","HMPUTIL2",61,0)
 ;Merge in data section from FRESHITM^HMPDJFSG
"RTN","HMPUTIL2",62,0)
 S HMPSUB=""
"RTN","HMPUTIL2",63,0)
 F  S HMPSUB=$O(^TMP("HMP",$J,HMPSUB)) Q:'HMPSUB  D
"RTN","HMPUTIL2",64,0)
 .S HMPFCNT=HMPFCNT+1
"RTN","HMPUTIL2",65,0)
 .I DFN'="OPD" S ^TMP("HMPF",$J,HMPFCNT,.3)="{""collection"":"""_HMPVAR("DOMAIN")_$C(34)_$$PIDS^HMPDJFS(DFN)_",""seq"":1,""total"":1,""object"":"
"RTN","HMPUTIL2",66,0)
 .I DFN="OPD",DLTFLG S ^TMP("HMPF",$J,HMPFCNT,.3)="{""collection"":"""_HMPVAR("DOMAIN")_""",""seq"":1,""total"":1,""object"":"_HMPVAR("REMOVED JSON") ;;US5647
"RTN","HMPUTIL2",67,0)
 .I DFN="OPD",'DLTFLG  D  ;US5859
"RTN","HMPUTIL2",68,0)
 ..S ^TMP("HMPF",$J,HMPFCNT,.3)="{""collection"":"""_HMPVAR("DOMAIN")_""",""seq"":1,""total"":1,""object"":"
"RTN","HMPUTIL2",69,0)
 ..S HMPX="""stampTime"":"_$C(34)_STMPTM_$C(34)_","
"RTN","HMPUTIL2",70,0)
 ..S HMPDAT=$G(^TMP("HMP",$J,HMPSUB,1))
"RTN","HMPUTIL2",71,0)
 ..S ^TMP("HMP",$J,HMPSUB,1)="{"_HMPX_$P(HMPDAT,"{",2,999)  ; add stamp time to start of data
"RTN","HMPUTIL2",72,0)
 .; merge into "HMPF" subscript
"RTN","HMPUTIL2",73,0)
 .M ^TMP("HMPF",$J,HMPFCNT,1)=^TMP("HMP",$J,HMPSUB,1)
"RTN","HMPUTIL2",74,0)
 ;
"RTN","HMPUTIL2",75,0)
 ; Build and add syncStatus
"RTN","HMPUTIL2",76,0)
 S STS("uid")="urn:va:syncStatus:"_HMPVAR("DATETIME"),STS("initialized")="true"
"RTN","HMPUTIL2",77,0)
 S STS("domainTotals",HMPVAR("DOMAIN"))=1
"RTN","HMPUTIL2",78,0)
 D ENCODE^HMPJSON("STS","STSJSON","JSNERR")
"RTN","HMPUTIL2",79,0)
 I $D(JSNERR) S $EC=",JSON encode error in routine "_$T(+0)_"," Q
"RTN","HMPUTIL2",80,0)
 S HMPFCNT=HMPFCNT+1
"RTN","HMPUTIL2",81,0)
 M ^TMP("HMPF",$J,HMPFCNT)=STSJSON
"RTN","HMPUTIL2",82,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAP("syncStatus",$$PIDS^HMPDJFS(DFN),1,1)
"RTN","HMPUTIL2",83,0)
 ;
"RTN","HMPUTIL2",84,0)
 Q
"RTN","HMPUTIL2",85,0)
 ;
"RTN","HMPUTIL2",86,0)
WRAP(DOMAIN,PIDS,OFFSET,DOMSIZE) ; function, JSON wrapper
"RTN","HMPUTIL2",87,0)
 N X S X=""
"RTN","HMPUTIL2",88,0)
 S:$G(DOMAIN)'="syncStart" X="},{""collection"":"""_$P(DOMAIN,"#")_$C(34)_PIDS
"RTN","HMPUTIL2",89,0)
 S X=X_","
"RTN","HMPUTIL2",90,0)
 S:$G(OFFSET)>-1 X=X_"""seq"":"_OFFSET_","
"RTN","HMPUTIL2",91,0)
 S:$G(DOMSIZE)>-1 X=X_"""total"":"_DOMSIZE_","
"RTN","HMPUTIL2",92,0)
 S:$G(OFFSET)>-1 X=X_"""object"":"
"RTN","HMPUTIL2",93,0)
 Q X
"RTN","HMPUTIL2",94,0)
 ;
"RTN","HMPUTILS")
0^42^B55237151
"RTN","HMPUTILS",1,0)
HMPUTILS ;SLC/AGP,ASMR/ASF,JC-HMP utilities ;2016-06-30 20:24Z
"RTN","HMPUTILS",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,2**;Sep 01, 2011;Build 24
"RTN","HMPUTILS",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPUTILS",4,0)
 ;
"RTN","HMPUTILS",5,0)
 quit  ; no entry from top of routine HMPUTILS
"RTN","HMPUTILS",6,0)
 ;
"RTN","HMPUTILS",7,0)
 ; primary development
"RTN","HMPUTILS",8,0)
 ;
"RTN","HMPUTILS",9,0)
 ; original author: (agp)
"RTN","HMPUTILS",10,0)
 ; additional author: Jamshid Denegarian (jd)
"RTN","HMPUTILS",11,0)
 ; additional author: Ray Blank (rrb)
"RTN","HMPUTILS",12,0)
 ; additional author: Frederick D. S. Marshall (toad)
"RTN","HMPUTILS",13,0)
 ; additional author: Allan S. Finkelstein (asf)
"RTN","HMPUTILS",14,0)
 ; additional author: JC Hrobocvek (jc)
"RTN","HMPUTILS",15,0)
 ; additional author: Christine Kampe (ck)
"RTN","HMPUTILS",16,0)
 ; original org: U.S. Department of Veterans Affairs (va)
"RTN","HMPUTILS",17,0)
 ; prime contractor ASM Research (asmr)
"RTN","HMPUTILS",18,0)
 ; other development orgs: VISTA Expertise Network (asmr-ven)
"RTN","HMPUTILS",19,0)
 ;
"RTN","HMPUTILS",20,0)
 ; 2013-08-14 va-islc/agp: last update by VA before code transfered
"RTN","HMPUTILS",21,0)
 ; to asmr for eHMP contract.
"RTN","HMPUTILS",22,0)
 ;
"RTN","HMPUTILS",23,0)
 ; 2015-02-23 asmr/jd: $$NODATA = Is there any patient data
"RTN","HMPUTILS",24,0)
 ;
"RTN","HMPUTILS",25,0)
 ; 2015-11-04 asmr/rrb: fix first three lines for sac compliance,
"RTN","HMPUTILS",26,0)
 ; [DE2818/RRB: SQA findings 1st 3 lines].
"RTN","HMPUTILS",27,0)
 ;
"RTN","HMPUTILS",28,0)
 ; 2016-03-29/04-13 asmr-ven/toad: delete $$GETSIZE & $$WALK, change
"RTN","HMPUTILS",29,0)
 ; calls from MESNOK^HMPMETA and $$CHKSIZE^HMPDJFSP to
"RTN","HMPUTILS",30,0)
 ; $$GETSIZE^HMPMONX, fix org.
"RTN","HMPUTILS",31,0)
 ;
"RTN","HMPUTILS",32,0)
 ; 2016-04-09/12 asmr/asf&jc [DE3116]: $$JSONDT updated to handle
"RTN","HMPUTILS",33,0)
 ; fileman date problems; allow for hrs >24 and mins >60.
"RTN","HMPUTILS",34,0)
 ;
"RTN","HMPUTILS",35,0)
 ; 2016-04-22 asmr/ck [DE4463]: changed HMP routines to all call
"RTN","HMPUTILS",36,0)
 ; $$SYS^HMPUTILS, returns a 4 digit hashed site, padded with leading
"RTN","HMPUTILS",37,0)
 ; zeros.
"RTN","HMPUTILS",38,0)
 ;
"RTN","HMPUTILS",39,0)
 ; 2016-06-30 asmr-ven/toad: update primary development, add contents
"RTN","HMPUTILS",40,0)
 ; and white space.
"RTN","HMPUTILS",41,0)
 ;
"RTN","HMPUTILS",42,0)
 ;
"RTN","HMPUTILS",43,0)
 ; contents
"RTN","HMPUTILS",44,0)
 ;
"RTN","HMPUTILS",45,0)
 ; CHKSP: ^XTMP check before patient subscription starts to cache
"RTN","HMPUTILS",46,0)
 ; SETERROR: error text for JSON
"RTN","HMPUTILS",47,0)
 ; SETERRTX
"RTN","HMPUTILS",48,0)
 ; SETTEXT: format word processing
"RTN","HMPUTILS",49,0)
 ; SPLITVAL: split a value into a list
"RTN","HMPUTILS",50,0)
 ; SETPROV: providers
"RTN","HMPUTILS",51,0)
 ; $$SETUID = create uid string
"RTN","HMPUTILS",52,0)
 ; SETFCURN: create facility urn
"RTN","HMPUTILS",53,0)
 ; $$SETVURN = create VA urn
"RTN","HMPUTILS",54,0)
 ; $$SYS = hashed system name
"RTN","HMPUTILS",55,0)
 ; $$SETNCS = create national codeset urn
"RTN","HMPUTILS",56,0)
 ; $$JSONDT = convert FileMan DT to HL7 DT for JSON
"RTN","HMPUTILS",57,0)
 ; FACILITY: add facility info to array for JSON
"RTN","HMPUTILS",58,0)
 ; $$VERSRV = server version of option name
"RTN","HMPUTILS",59,0)
 ; $$VERCMP = 1 if CUR<VAL, -1 if CUR>VAL, 0 if equal
"RTN","HMPUTILS",60,0)
 ; $$WDWH = What kind of data exists?
"RTN","HMPUTILS",61,0)
 ; $$NODATA = Is there any patient data
"RTN","HMPUTILS",62,0)
 ;
"RTN","HMPUTILS",63,0)
 ;
"RTN","HMPUTILS",64,0)
 ; integration agreements:
"RTN","HMPUTILS",65,0)
 ;
"RTN","HMPUTILS",66,0)
 ; External References          DBIA#
"RTN","HMPUTILS",67,0)
 ; -------------------          -----
"RTN","HMPUTILS",68,0)
 ; XLFCRC                        3156
"RTN","HMPUTILS",69,0)
 ; XLFDT                        10103
"RTN","HMPUTILS",70,0)
 ; XLFUTL                        2622
"RTN","HMPUTILS",71,0)
 ; XUPARAM                       2541
"RTN","HMPUTILS",72,0)
 ;
"RTN","HMPUTILS",73,0)
 ;
"RTN","HMPUTILS",74,0)
 ;
"RTN","HMPUTILS",75,0)
CHKSP(HMPFHMP) ; -- ^XTMP check before patient subscription starts to cache   *BEGIN*S68-PJH
"RTN","HMPUTILS",76,0)
 ; Input HMPFHMP - server name
"RTN","HMPUTILS",77,0)
 N HMPOK
"RTN","HMPUTILS",78,0)
 S HMPOK=0
"RTN","HMPUTILS",79,0)
 F  D  Q:HMPOK
"RTN","HMPUTILS",80,0)
 . ; -- if ok to run, reset DISK USAGE STATUS to 'WITHIN LIMIT' and continue ; US8228
"RTN","HMPUTILS",81,0)
 . I $$OKTORUN^HMPDJFSP("subscribe") S HMPOK=1 D STATUS^HMPMETA(HMPOK,HMPFHMP) Q  ; US8228
"RTN","HMPUTILS",82,0)
 . ; -- otherwise make sure DISK USAGE STATUS is 'EXCEEDED LIMIT' and wait ; US8228
"RTN","HMPUTILS",83,0)
 . D STATUS^HMPMETA(HMPOK,HMPFHMP) H $$GETSECS^HMPDJFSP  ; US8228
"RTN","HMPUTILS",84,0)
 Q  ;  *END*S68-PJH
"RTN","HMPUTILS",85,0)
 ;
"RTN","HMPUTILS",86,0)
 ;
"RTN","HMPUTILS",87,0)
SETERROR(RESULT,ERROR,EXTERROR,DATA) ; -- error text for JSON
"RTN","HMPUTILS",88,0)
 N CNT,TEMP,HMPTEMP,XCNT
"RTN","HMPUTILS",89,0)
 S HMPTEMP="HMPXTEMP ERRORS"
"RTN","HMPUTILS",90,0)
 I '$D(^XTMP(HMPTEMP,0)) S ^XTMP(HMPTEMP,0)=$$FMADD^XLFDT(DT,7)_U_DT_U_"HMP ERROR GLOBAL"
"RTN","HMPUTILS",91,0)
 S RESULT("success")="false"
"RTN","HMPUTILS",92,0)
 I $D(DATA) S XCNT=$O(^XTMP(HMPTEMP,""),-1)+1 M ^XTMP(HMPTEMP,XCNT,"ERROR")=DATA
"RTN","HMPUTILS",93,0)
 I $D(ERROR) D SETERRTX(.TEMP,.ERROR) S RESULT("error","code")=TEMP
"RTN","HMPUTILS",94,0)
 I +$G(XCNT)>0 S RESULT("error","code")=$G(RESULT("error","code"))_" See ^XTMP("_HMPTEMP_","_XCNT_",DATA) for data"
"RTN","HMPUTILS",95,0)
 I $D(EXTERROR) D SETERRTX(.TEMP,.EXTERROR) I TEMP'="" S RESULT("error","message")=TEMP
"RTN","HMPUTILS",96,0)
 ;
"RTN","HMPUTILS",97,0)
 Q
"RTN","HMPUTILS",98,0)
 ;
"RTN","HMPUTILS",99,0)
 ;
"RTN","HMPUTILS",100,0)
SETERRTX(TEMP,ERROR) ;
"RTN","HMPUTILS",101,0)
 S TEMP=""
"RTN","HMPUTILS",102,0)
 S CNT=0 F  S CNT=$O(ERROR(CNT)) Q:CNT'>0  D
"RTN","HMPUTILS",103,0)
 .S TEMP=$S(TEMP'="":TEMP=TEMP_$C(13,10)_ERROR(CNT),1:ERROR(CNT))
"RTN","HMPUTILS",104,0)
 Q
"RTN","HMPUTILS",105,0)
 ;
"RTN","HMPUTILS",106,0)
 ;
"RTN","HMPUTILS",107,0)
SETTEXT(X,VALUE) ; -- format word processing
"RTN","HMPUTILS",108,0)
 N FIRST,I,LINE
"RTN","HMPUTILS",109,0)
 S FIRST=1
"RTN","HMPUTILS",110,0)
 S I=0 F  S I=$O(@X@(I)) Q:I<1  D
"RTN","HMPUTILS",111,0)
 .S LINE=$S($D(@X@(I,0)):@X@(I,0),1:@X@(I))
"RTN","HMPUTILS",112,0)
 .; FIRST=1 S @VALUE@(I)=LINE,FIRST=0 Q
"RTN","HMPUTILS",113,0)
 .S @VALUE@(I)=LINE_$C(13)_$C(10)
"RTN","HMPUTILS",114,0)
 Q
"RTN","HMPUTILS",115,0)
 ;
"RTN","HMPUTILS",116,0)
 ;
"RTN","HMPUTILS",117,0)
SPLITVAL(NODE,ARRAY) ; -- split a value into a list
"RTN","HMPUTILS",118,0)
 N CNT,NAME,VALUE,FIELD
"RTN","HMPUTILS",119,0)
 S NAME="" F  S NAME=$O(ARRAY(NAME)) Q:NAME=""  D
"RTN","HMPUTILS",120,0)
 .S CNT=+ARRAY(NAME)
"RTN","HMPUTILS",121,0)
 .S VALUE=$P($G(NODE),U,CNT)
"RTN","HMPUTILS",122,0)
 .I NAME="Code" S FIELD=$P(ARRAY(NAME),U,2) S VALUE=$$SETVURN(FIELD,VALUE)
"RTN","HMPUTILS",123,0)
 .S ARRAY(NAME)=VALUE
"RTN","HMPUTILS",124,0)
 Q
"RTN","HMPUTILS",125,0)
 ;
"RTN","HMPUTILS",126,0)
 ;
"RTN","HMPUTILS",127,0)
SETPROV(NODE,PROV) ; -- providers
"RTN","HMPUTILS",128,0)
 S PROV("providerUid")=$$SETUID("user",,+NODE)
"RTN","HMPUTILS",129,0)
 S PROV("providerName")=$P(NODE,U,2)
"RTN","HMPUTILS",130,0)
 Q
"RTN","HMPUTILS",131,0)
 ;
"RTN","HMPUTILS",132,0)
 ;
"RTN","HMPUTILS",133,0)
SETUID(DOMAIN,PAT,ID,ADDDATA) ; -- create uid string
"RTN","HMPUTILS",134,0)
 N RESULT,SYS
"RTN","HMPUTILS",135,0)
 S SYS=$S($D(HMPSYS):HMPSYS,1:$$SYS^HMPUTILS)
"RTN","HMPUTILS",136,0)
 S RESULT="urn:va:"_DOMAIN_":"_SYS_":"_$S($G(PAT):PAT_":",1:"")_ID
"RTN","HMPUTILS",137,0)
 I $L($G(ADDDATA)) S RESULT=RESULT_":"_ADDDATA
"RTN","HMPUTILS",138,0)
 Q RESULT
"RTN","HMPUTILS",139,0)
 ;
"RTN","HMPUTILS",140,0)
 ;
"RTN","HMPUTILS",141,0)
SETFCURN(DOMAIN,FACILITY,VALUE) ; -- create facility urn
"RTN","HMPUTILS",142,0)
 Q "urn:va:"_DOMAIN_":"_FACILITY_":"_VALUE
"RTN","HMPUTILS",143,0)
 ;
"RTN","HMPUTILS",144,0)
 ;
"RTN","HMPUTILS",145,0)
SETVURN(DOMAIN,VALUE) ; -- create VA urn
"RTN","HMPUTILS",146,0)
 N RESULT S RESULT=""
"RTN","HMPUTILS",147,0)
 S RESULT="urn:va:"_DOMAIN_":"_VALUE
"RTN","HMPUTILS",148,0)
 Q RESULT
"RTN","HMPUTILS",149,0)
 ;
"RTN","HMPUTILS",150,0)
 ;
"RTN","HMPUTILS",151,0)
SYS(NAME) ; -- return hashed system name from HMP SYSTEM NAME parameter, or calculate from NAME parameter if it exists
"RTN","HMPUTILS",152,0)
 ; DE4463 4/22/2016 CK - changed HMP routines to all call this function
"RTN","HMPUTILS",153,0)
 ;  SYS^HMPUTILS returns a 4 digit hashed site, padded with leading zeros
"RTN","HMPUTILS",154,0)
 N SYS
"RTN","HMPUTILS",155,0)
 S SYS=$$GET^XPAR("SYS","HMP SYSTEM NAME")
"RTN","HMPUTILS",156,0)
 I '$L($G(NAME)),'$L(SYS) Q $$SYS($$KSP^XUPARAM("WHERE"))       ; r2.0 install workaround: if no parameter AND no HMP SYSTEM NAME, then calculate and return using domain name
"RTN","HMPUTILS",157,0)
 I '$L($G(NAME)) Q SYS                                        ; else return HMP SYSTEM NAME parameter
"RTN","HMPUTILS",158,0)
 Q $TR($J($$BASE^XLFUTL($$CRC16^XLFCRC(NAME),10,16),4)," ",0) ; else calculate from parameter
"RTN","HMPUTILS",159,0)
 ;
"RTN","HMPUTILS",160,0)
 ;
"RTN","HMPUTILS",161,0)
SETNCS(CODESET,VALUE) ; -- create national codeset urn
"RTN","HMPUTILS",162,0)
 Q "urn:"_CODESET_":"_VALUE
"RTN","HMPUTILS",163,0)
 ;
"RTN","HMPUTILS",164,0)
 ;
"RTN","HMPUTILS",165,0)
JSONDT(X) ; -- convert FileMan DT to HL7 DT for JSON
"RTN","HMPUTILS",166,0)
 N HL7DT,T,Y
"RTN","HMPUTILS",167,0)
 ;DE3116 4/12/16 ASF,JC function updated to handle FM date problems
"RTN","HMPUTILS",168,0)
 ; T indicates that a time was included
"RTN","HMPUTILS",169,0)
 S T=0 I $E(X,8)=".",$E(X,6,7) S T=1  ; if there's a time it must be a precise date
"RTN","HMPUTILS",170,0)
 S Y=$S(T:X,1:X\1)  ; strip time if imprecise date
"RTN","HMPUTILS",171,0)
 I T,($E(Y,9,10)>23)!($E(Y,11,12)>59)!($E(Y,13,14)>59) S Y=$$FMADD^XLFDT(Y,0,0,0,0) ;DE3116 ASF 04/09/16 allows for hrs >24 and mins >60
"RTN","HMPUTILS",172,0)
 S HL7DT=$$FMTHL7^HMPSTMP(Y)  ; DE5016
"RTN","HMPUTILS",173,0)
 S:T HL7DT=$E(HL7DT_"000000",1,14)  ; if time passed, result must be 14 chars.
"RTN","HMPUTILS",174,0)
 Q HL7DT
"RTN","HMPUTILS",175,0)
 ;
"RTN","HMPUTILS",176,0)
 ;
"RTN","HMPUTILS",177,0)
FACILITY(X,Y) ; -- add facility info to array for JSON
"RTN","HMPUTILS",178,0)
 ;  X=STATION NUMBER^STATION NAME
"RTN","HMPUTILS",179,0)
 ;  Y=Variable array name
"RTN","HMPUTILS",180,0)
 ; >D FACILITY^HMPUTILS("500^CAMP MASTER","LAB")
"RTN","HMPUTILS",181,0)
 ;
"RTN","HMPUTILS",182,0)
 S @Y@("facilityCode")=$P(X,"^")
"RTN","HMPUTILS",183,0)
 S @Y@("facilityName")=$P(X,"^",2)
"RTN","HMPUTILS",184,0)
 Q
"RTN","HMPUTILS",185,0)
 ;
"RTN","HMPUTILS",186,0)
 ;
"RTN","HMPUTILS",187,0)
VERSRV()   ; Return server version of option name
"RTN","HMPUTILS",188,0)
 N HMPLST,VAL
"RTN","HMPUTILS",189,0)
 D FIND^DIC(19,"",1,"X","HMP UI CONTEXT",1,,,,"HMPLST")
"RTN","HMPUTILS",190,0)
 S VAL=$G(HMPLST("DILIST","ID",1,1))
"RTN","HMPUTILS",191,0)
 Q $$UP^XLFSTR($P(VAL,"version ",2))
"RTN","HMPUTILS",192,0)
 ;
"RTN","HMPUTILS",193,0)
 ;
"RTN","HMPUTILS",194,0)
VERCMP(CUR,VAL) ; Returns 1 if CUR<VAL, -1 if CUR>VAL, 0 if equal
"RTN","HMPUTILS",195,0)
 N CURMAJOR,CURMINOR,CURSNAP,VALMAJOR,VALMINOR,VALSNAP
"RTN","HMPUTILS",196,0)
 S CURMAJOR=$P(CUR,"-"),CURMINOR=$P(CUR,"-",2),CURSNAP=$E($P(CUR,"-",3),1,4)="SNAP"
"RTN","HMPUTILS",197,0)
 S VALMAJOR=$P(VAL,"-"),VALMINOR=$P(VAL,"-",2),VALSNAP=$E($P(VAL,"-",3),1,4)="SNAP"
"RTN","HMPUTILS",198,0)
 I $E(VALMINOR)="P" S VALMINOR=$E(VALMINOR,2,99)     ; "P"ilot versions (old)
"RTN","HMPUTILS",199,0)
 I $E(CURMINOR)="P" S CURMINOR=$E(VALMINOR,2,99)
"RTN","HMPUTILS",200,0)
 I $E(VALMINOR)="S" S VALMINOR=$E(VALMINOR,2,99)*10  ; "S"print versions
"RTN","HMPUTILS",201,0)
 I $E(CURMINOR)="S" S CURMINOR=$E(CURMINOR,2,99)*10
"RTN","HMPUTILS",202,0)
 Q:VALMAJOR>CURMAJOR 1   Q:VALMAJOR<CURMAJOR -1  ; compare major versions
"RTN","HMPUTILS",203,0)
 Q:VALMINOR>CURMINOR 1   Q:VALMINOR<CURMINOR -1  ; compare minor versions
"RTN","HMPUTILS",204,0)
 Q:(CURSNAP&'VALSNAP) 1  Q:(VALSNAP&'CURSNAP) -1 ; "SNAPSHOT" < released
"RTN","HMPUTILS",205,0)
 Q 0
"RTN","HMPUTILS",206,0)
 ;
"RTN","HMPUTILS",207,0)
 ;
"RTN","HMPUTILS",208,0)
WDWH() ; What kind of data exists?
"RTN","HMPUTILS",209,0)
 ; HMPA   = loop counter
"RTN","HMPUTILS",210,0)
 ; HMPB   = dummy variable
"RTN","HMPUTILS",211,0)
 ; HMPOPD = 1 if operational data exists
"RTN","HMPUTILS",212,0)
 ;         "" otherwise
"RTN","HMPUTILS",213,0)
 ; HMPPAT = 1 if patient data exists
"RTN","HMPUTILS",214,0)
 ;         "" otherwise
"RTN","HMPUTILS",215,0)
 ; HMPRET = return variable - 0 if no data exists
"RTN","HMPUTILS",216,0)
 ;                            1 if ONLY patient data exists
"RTN","HMPUTILS",217,0)
 ;                            2 if ONLY operational data exists
"RTN","HMPUTILS",218,0)
 ;                            3 if BOTH patient and operational data exist
"RTN","HMPUTILS",219,0)
 N HMPA,HMPOPD,HMPPAT,HMPRET
"RTN","HMPUTILS",220,0)
 S (HMPOPD,HMPPAT)="",HMPA="HMPFX",HMPRET=0
"RTN","HMPUTILS",221,0)
 ; iterate through HMP data only
"RTN","HMPUTILS",222,0)
 F  S HMPA=$O(^XTMP(HMPA)) Q:'($E(HMPA,1,3)="HMP")  D  Q:HMPOD&HMPPAT  ; no need to continue if both flags set
"RTN","HMPUTILS",223,0)
 .S HMPB=$P(HMPA,"~",3)
"RTN","HMPUTILS",224,0)
 .I HMPB="OPD" S HMPOPD=1 Q
"RTN","HMPUTILS",225,0)
 .I HMPB=+HMPB S HMPPAT=1
"RTN","HMPUTILS",226,0)
 I HMPPAT,'HMPOPD S HMPRET=1
"RTN","HMPUTILS",227,0)
 I 'HMPPAT,HMPOPD S HMPRET=2
"RTN","HMPUTILS",228,0)
 I HMPPAT,HMPOPD S HMPRET=3
"RTN","HMPUTILS",229,0)
 Q HMPRET
"RTN","HMPUTILS",230,0)
 ;
"RTN","HMPUTILS",231,0)
 ;
"RTN","HMPUTILS",232,0)
NODATA(A) ; Is there any patient data; JD - 2/23/15
"RTN","HMPUTILS",233,0)
 ; Returns 1 if there is no patient data
"RTN","HMPUTILS",234,0)
 ;          0 Otherwise
"RTN","HMPUTILS",235,0)
 ; HMPA = Loop counter
"RTN","HMPUTILS",236,0)
 ; HMPF = Dummy variable
"RTN","HMPUTILS",237,0)
 N HMPA,HMPF
"RTN","HMPUTILS",238,0)
 S HMPF=0,HMPA=""
"RTN","HMPUTILS",239,0)
 F  S HMPA=$O(^XTMP(A,0,"count",HMPA)) Q:HMPF!(HMPA']"")  D
"RTN","HMPUTILS",240,0)
 .I +$G(^XTMP(A,0,"count",HMPA))>0 S HMPF=1 Q
"RTN","HMPUTILS",241,0)
 Q $S(HMPF:0,1:1)
"RTN","HMPUTILS",242,0)
 ;
"RTN","HMPUTILS",243,0)
 ;
"RTN","HMPUTILS",244,0)
EOR ; end of routine HMPUTILS
"RTN","HMPWB")
0^44^B1427046
"RTN","HMPWB",1,0)
HMPWB ;;ASMR/EJK - COMMON ENTRY POINT FOR ALL WRITEBACK ACTIVITY; 12/14/2014
"RTN","HMPWB",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;DEC 11 2014;Build 24
"RTN","HMPWB",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWB",4,0)
 ;
"RTN","HMPWB",5,0)
 ; INPUT PARAMETERS
"RTN","HMPWB",6,0)
 ;   IEN - existing allergy IEN or 0 if this is a new allergen. 
"RTN","HMPWB",7,0)
 ;   DFN - patient identifier
"RTN","HMPWB",8,0)
 ;   DATA(list) - array of related data
"RTN","HMPWB",9,0)
 ;      domain - used for determining the type of writeback data this is. 
"RTN","HMPWB",10,0)
 ;
"RTN","HMPWB",11,0)
 Q
"RTN","HMPWB",12,0)
 ;
"RTN","HMPWB",13,0)
API(RSLT,IEN,DFN,DATA) ; MAIN ENTRY POINT FROM RPC HMP PUT OPERATIONAL DATA
"RTN","HMPWB",14,0)
 M ^TMP("ZZHMPWB",$J,"DATA")=DATA
"RTN","HMPWB",15,0)
 S ^TMP("ZZHMPWB",$J,"DFN")=$G(DFN)
"RTN","HMPWB",16,0)
 S ^TMP("ZZHMPWB",$J,"IEN")=$G(IEN)
"RTN","HMPWB",17,0)
 N HMPAPI
"RTN","HMPWB",18,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPWB",19,0)
 S HMPAPI=$G(DATA("domain"))
"RTN","HMPWB",20,0)
 I HMPAPI="allergy" D ALLERGY^HMPWB1(.RSLT,IEN,DFN,.DATA)
"RTN","HMPWB",21,0)
 I HMPAPI="demographics" D DEMOG^HMPWB2(.RSLT,IEN,OL,.DATA)
"RTN","HMPWB",22,0)
 I HMPAPI="vitals" D VMADD^HMPWB2(.RSLT,IEN,DFN,.DATA)
"RTN","HMPWB",23,0)
 I HMPAPI="vitals error" D VMERR^HMPWB2(.RSLT,IEN,DFN,.DATA)
"RTN","HMPWB",24,0)
 ;I HMPAPI="meds" D NVAMED^HMPWB3(.RSLT,IEN,DFN,.DATA)
"RTN","HMPWB",25,0)
 Q
"RTN","HMPWB1")
0^45^B43200310
"RTN","HMPWB1",1,0)
HMPWB1 ; Agilex/EJK/JD - WRITE BACK ACTIVITY;Nov 5, 2015@16:15:08
"RTN","HMPWB1",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPWB1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWB1",4,0)
 ;
"RTN","HMPWB1",5,0)
 Q
"RTN","HMPWB1",6,0)
 ; allergy write back from eHMP-UI to VistA
"RTN","HMPWB1",7,0)
ALLERGY(RSLT,IEN,DFN,DATA) ;file allergy data
"RTN","HMPWB1",8,0)
 ; RSLT - result, passed by reference
"RTN","HMPWB1",9,0)
 ; IEN - zero for new allergy, or IEN for edit
"RTN","HMPWB1",10,0)
 ; DFN - patient identifier
"RTN","HMPWB1",11,0)
 ; DATA - array of allergy data. Subscript names are required. 
"RTN","HMPWB1",12,0)
 ;  ("GMRACHT",0)=1 - Chart Marked indicator
"RTN","HMPWB1",13,0)
 ;  ("GMRACHT",1)=3150603.0905 - Date/Time Chart Marked
"RTN","HMPWB1",14,0)
 ;  ("GMRAGNT")="DIGITOXIN^9;PSNDF(50.6," - Allergy and Pointer to Allergen File
"RTN","HMPWB1",15,0)
 ;  ("GMRAOBHX")="o^OBSERVED" - (O)bserved or (H)istorical
"RTN","HMPWB1",16,0)
 ;  ("GMRAORIG")=10000000224 - Pointer to VA DRUG CLASS File (50.605)
"RTN","HMPWB1",17,0)
 ;  ("GMRAORDT")=3150603.0805 - Allergy assessmant date and time. 
"RTN","HMPWB1",18,0)
 ;  ("GMRASEVR")=2 - Severity of Allergy. 1=Mild, 2=Moderate, 3=Severe
"RTN","HMPWB1",19,0)
 ;  ("GMRATYPE")="D^Drug" - Type of Allergen (F)ood or (D)rug
"RTN","HMPWB1",20,0)
 ;  ("GMRANATR")="A^Allergy" - Mechanism of Allergy (A)llergy, (P)harmacologic, (U)nknown.
"RTN","HMPWB1",21,0)
 ;  ("GMRASYMP",0)=2 - Number of Symptoms
"RTN","HMPWB1",22,0)
 ;  ("GMRASYMP",1)="2^ITCHING,WATERING EYES" - IEN and Description of Symptom 1
"RTN","HMPWB1",23,0)
 ;  ("GMRASYMP",2)="133^RASH" - IEN and Description of Symptom 2
"RTN","HMPWB1",24,0)
 ;
"RTN","HMPWB1",25,0)
 I $G(DFN)'>0 D MSG^HMPTOOLS("DFN",1) Q
"RTN","HMPWB1",26,0)
 I '$D(DATA) D MSG^HMPTOOLS("DATA Array",1) Q
"RTN","HMPWB1",27,0)
 N CMMT,FILTER,GMR0,GMRA,GMR0,GMRIEN,HMPALRGY,HMPDATA,HMPDFN,HMPSITE,I,ORY,REAC,STMPTM,USER,VPRI,X,XWBOS,Y
"RTN","HMPWB1",28,0)
 N HMPIDX,HMPSTOP,HMPDFN
"RTN","HMPWB1",29,0)
 S HMPSTOP=0
"RTN","HMPWB1",30,0)
 ;
"RTN","HMPWB1",31,0)
 N $ES,$ET,ERRPAT,ERRMSG,D0
"RTN","HMPWB1",32,0)
 S HMPDFN=DFN
"RTN","HMPWB1",33,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPWB1",34,0)
 S ERRMSG="A problem occurred in the allergy domain, routine: "_$T(+0)
"RTN","HMPWB1",35,0)
 S XWBOS=$$NOW^XLFDT  ; indicate that we're in the RPC broker, prevent interactive calls
"RTN","HMPWB1",36,0)
 L +^GMR(120.8,0):5
"RTN","HMPWB1",37,0)
 D EDITSAVE^ORWDAL32(.ORY,IEN,DFN,.DATA)  ; update ADVERSE REACTION ASSESSMENT (#120.86)
"RTN","HMPWB1",38,0)
 ; ejk US3232 if failure to file, send error message as result. 
"RTN","HMPWB1",39,0)
 I $P(ORY,"^",1)=-1 D MSG^HMPTOOLS($P(ORY,"^",2)) D ERROR Q
"RTN","HMPWB1",40,0)
 I $P(ORY,U,1)=0,'$D(D0) D
"RTN","HMPWB1",41,0)
 . S HMPSTOP=0,HMPIDX=""
"RTN","HMPWB1",42,0)
 . F  S HMPIDX=$O(^GMR(120.8,"B",DFN,HMPIDX),-1) Q:HMPIDX=""!(HMPSTOP=1)  D
"RTN","HMPWB1",43,0)
 .. S GMR0=$G(^GMR(120.8,HMPIDX,0))
"RTN","HMPWB1",44,0)
 .. I $P(GMR0,U,1)=HMPDFN,$P(GMR0,U,2)=$P(DATA("GMRAGNT"),U,1) S D0=HMPIDX,DFN=HMPDFN,HMPSTOP=1
"RTN","HMPWB1",45,0)
 .. Q
"RTN","HMPWB1",46,0)
 . Q
"RTN","HMPWB1",47,0)
 I HMPSTOP S D0=HMPIDX,DFN=HMPDFN
"RTN","HMPWB1",48,0)
 ; return value in RSLT
"RTN","HMPWB1",49,0)
 L +^GMR(120.8,0):5
"RTN","HMPWB1",50,0)
 I $P(DATA("GMRAGNT"),U,2)?.E1"""".E S DATA("GMRAGNT")=$E(DATA("GMRAGNT"),1,$L(DATA("GMRAGNT"))-4) ;DE4763 ASF 5/25/16 CORRECT SAVED VARIABLE POINTER
"RTN","HMPWB1",51,0)
 S HMP=$NA(^TMP("HMP",$J)) K @HMP
"RTN","HMPWB1",52,0)
 S FILTER("id")=D0 ;ien for the entry into the allergy file
"RTN","HMPWB1",53,0)
 S FILTER("patientId")=DFN ;patient identifier
"RTN","HMPWB1",54,0)
 S FILTER("domain")="allergy" ;domain name for write back and freshness stream staging
"RTN","HMPWB1",55,0)
 S FILTER("noHead")=1 ;no header record required.
"RTN","HMPWB1",56,0)
 D GET^HMPDJ(.RSLT,.FILTER) ;build the JSON array in the ^TMP global
"RTN","HMPWB1",57,0)
 K ^TMP("ALLERGY",$J)
"RTN","HMPWB1",58,0)
 M ^TMP("ALLERGY",$J)=@RSLT
"RTN","HMPWB1",59,0)
 S RSLT=$NA(^TMP("ALLERGY",$J))
"RTN","HMPWB1",60,0)
 S HMPFCNT=0
"RTN","HMPWB1",61,0)
 S HMPUID=$$SETUID^HMPUTILS("allergy",DFN,D0)
"RTN","HMPWB1",62,0)
 S HMPE=^TMP("ALLERGY",$J,1,1)
"RTN","HMPWB1",63,0)
 S STMPTM=$TR($P($P(HMPE,"lastUpdateTime",2),","),""":")
"RTN","HMPWB1",64,0)
 D ADHOC^HMPUTIL2("allergy",HMPFCNT,DFN,HMPUID,STMPTM)
"RTN","HMPWB1",65,0)
 K RSLT
"RTN","HMPWB1",66,0)
 S RSLT=$$EXTRACT(HMP)
"RTN","HMPWB1",67,0)
 M ^TMP("HMPALL",$J)=RSLT
"RTN","HMPWB1",68,0)
 K RSLT
"RTN","HMPWB1",69,0)
 S RSLT=$NA(^TMP("HMPALL",$J))
"RTN","HMPWB1",70,0)
 ;Clear work files
"RTN","HMPWB1",71,0)
 K @HMP
"RTN","HMPWB1",72,0)
 Q
"RTN","HMPWB1",73,0)
 ;
"RTN","HMPWB1",74,0)
ALLEIE(RSLT,DATA) ;file allergy entered in error
"RTN","HMPWB1",75,0)
 ;Since DFN is not relevant as an input parameter, we removed it from the DATA string
"RTN","HMPWB1",76,0)
 ;Once we know the allergy IEN, DFN will also be known.  JD - 11/5/15.
"RTN","HMPWB1",77,0)
 ; RSLT - result, passed by reference
"RTN","HMPWB1",78,0)
 ; DATA - contains all information needed to mark a Allergy as Entered in Error
"RTN","HMPWB1",79,0)
 ;   IEN^GMRAERR^GMRAERRBY^GMRAERRDT^GMRACMTS,0)^GMRACMTS,1)
"RTN","HMPWB1",80,0)
 ;      IEN = Pointer to the Allergy to be marked as Entered in Error
"RTN","HMPWB1",81,0)
 ;      GMRAERR = YES (must be YES. Any other value will cause the EIE to fail.)
"RTN","HMPWB1",82,0)
 ;      GMRAERRBY = Pointer to the New Person file. 
"RTN","HMPWB1",83,0)
 ;      GMRAERRDT = Fileman date.time (3150812.143206)
"RTN","HMPWB1",84,0)
 ;      GMRACMTS,0) = Total number of comments
"RTN","HMPWB1",85,0)
 ;      GMRACMTS,N) = Free text field for each comment
"RTN","HMPWB1",86,0)
 ;
"RTN","HMPWB1",87,0)
 N HMPSTOP,HMPIEN,HMPDFN
"RTN","HMPWB1",88,0)
 S HMPIEN=$P(DATA,U,1)
"RTN","HMPWB1",89,0)
 D CHECKREQ
"RTN","HMPWB1",90,0)
 Q:HMPSTOP=1
"RTN","HMPWB1",91,0)
 D PARSE
"RTN","HMPWB1",92,0)
 I '$D(^GMR(120.8,HMPIEN)) D MSG^HMPTOOLS("Allergy "_HMPIEN_" does not exist",2) D ERROR Q
"RTN","HMPWB1",93,0)
 D EDITSAVE^ORWDAL32(.RSLT,HMPIEN,HMPDFN,.DATA)
"RTN","HMPWB1",94,0)
 S HMP=$NA(^TMP("HMP",$J)) K @HMP
"RTN","HMPWB1",95,0)
 S FILTER("id")=HMPIEN ;ien for the entry into the allergy file
"RTN","HMPWB1",96,0)
 S FILTER("patientId")=HMPDFN ;patient identifier
"RTN","HMPWB1",97,0)
 S FILTER("domain")="allergy" ;domain name for write back and freshness stream staging
"RTN","HMPWB1",98,0)
 S FILTER("noHead")=1 ;no header record required.
"RTN","HMPWB1",99,0)
 D GET^HMPDJ(.RSLT,.FILTER) ;build the JSON array in the ^TMP global
"RTN","HMPWB1",100,0)
 K ^TMP("ALLERGY",$J)
"RTN","HMPWB1",101,0)
 M ^TMP("ALLERGY",$J)=@RSLT
"RTN","HMPWB1",102,0)
 S RSLT=$NA(^TMP("ALLERGY",$J))
"RTN","HMPWB1",103,0)
 S HMPFCNT=0
"RTN","HMPWB1",104,0)
 S HMPUID=$$SETUID^HMPUTILS("allergy",HMPDFN,HMPIEN)
"RTN","HMPWB1",105,0)
 S HMPE=^TMP("ALLERGY",$J,1,1)
"RTN","HMPWB1",106,0)
 S STMPTM=$TR($P($P(HMPE,"lastUpdateTime",2),","),""":")
"RTN","HMPWB1",107,0)
 D ADHOC^HMPUTIL2("allergy",HMPFCNT,HMPDFN,HMPUID,STMPTM)
"RTN","HMPWB1",108,0)
 K RSLT
"RTN","HMPWB1",109,0)
 S RSLT=$$EXTRACT(HMP)
"RTN","HMPWB1",110,0)
 M ^TMP("HMPALL",$J)=RSLT
"RTN","HMPWB1",111,0)
 K RSLT
"RTN","HMPWB1",112,0)
 S RSLT=$NA(^TMP("HMPALL",$J))
"RTN","HMPWB1",113,0)
 ;Clear work files
"RTN","HMPWB1",114,0)
 K @HMP
"RTN","HMPWB1",115,0)
 Q
"RTN","HMPWB1",116,0)
 ;
"RTN","HMPWB1",117,0)
CHECKREQ ; check for required fields
"RTN","HMPWB1",118,0)
 ;Removed DFN from the input parameter DATA but for integrity purposes (and not to modify
"RTN","HMPWB1",119,0)
 ;too much code), we need to keep the number of pieces in DATA the same.
"RTN","HMPWB1",120,0)
 I HMPIEN'=+HMPIEN D MSG^HMPTOOLS("Allergy identifier is invalid/null: "_HMPIEN) D ERROR Q
"RTN","HMPWB1",121,0)
 I '$D(^GMR(120.8,HMPIEN)) D MSG^HMPTOOLS("Allergy identifier "_HMPIEN_" does not exist.") D ERROR Q
"RTN","HMPWB1",122,0)
 S DATA=$P(DATA,U)_U_$P($G(^GMR(120.8,HMPIEN,0)),U)_U_$P(DATA,U,2,999)
"RTN","HMPWB1",123,0)
 S HMPSTOP=0
"RTN","HMPWB1",124,0)
 I $P(DATA,U,1)'?1N.N D MSG^HMPTOOLS("Allergy Identifier must be numeric",1) D ERROR Q
"RTN","HMPWB1",125,0)
 I $P(DATA,U,2)'?1N.N D MSG^HMPTOOLS("Patient Identifier ",2,"must be numeric") D ERROR Q
"RTN","HMPWB1",126,0)
 I $P(DATA,U,3)'="YES" D MSG^HMPTOOLS("EIE indicator",2,"must be set to YES") D ERROR Q
"RTN","HMPWB1",127,0)
 I $D(^GMR(120.8,HMPIEN,"ER"))>0 D MSG^HMPTOOLS("Allergy already entered in error: "_HMPIEN) D ERROR Q
"RTN","HMPWB1",128,0)
 Q
"RTN","HMPWB1",129,0)
 ;
"RTN","HMPWB1",130,0)
CHKDATE ;CHECK DATES FOR PROPER FORMAT OF DATE.
"RTN","HMPWB1",131,0)
 N HMPDT
"RTN","HMPWB1",132,0)
 S HMPSTOP=0
"RTN","HMPWB1",133,0)
 S HMPDT=$P($G(DATA("GMRACHT",1)),".",1)
"RTN","HMPWB1",134,0)
 I $L(HMPDT)'=7 D MSG^HMPTOOLS("Date "_HMPDT_" not formatted correctly",2) D ERROR Q
"RTN","HMPWB1",135,0)
 S HMPDT=$P($G(DATA("GMRAORDT")),".",1)
"RTN","HMPWB1",136,0)
 I $L(HMPDT)'=7 D MSG^HMPTOOLS("Date "_HMPDT_" not formatted correctly",2) D ERROR Q
"RTN","HMPWB1",137,0)
 S HMPDT=$P($G(GMRAERRDT),".",1)
"RTN","HMPWB1",138,0)
 I $L(HMPDT)'=7 D MSG^HMPTOOLS("Date "_HMPDT_" not formatted correctly",2) D ERROR Q
"RTN","HMPWB1",139,0)
 Q
"RTN","HMPWB1",140,0)
 ;
"RTN","HMPWB1",141,0)
PARSE ;Parse data string into data elements for EDITSAVE^ORWDAL32
"RTN","HMPWB1",142,0)
 S HMPDFN=$P(DATA,U,2)
"RTN","HMPWB1",143,0)
 S DATA("GMRAERR")=$P(DATA,U,3)
"RTN","HMPWB1",144,0)
 S DATA("GMRAERRBY")=$P(DATA,U,4)
"RTN","HMPWB1",145,0)
 S DATA("GMRAERRDT")=$P(DATA,U,5)
"RTN","HMPWB1",146,0)
 S DATA("GMRAERRCMTS",0)=$P(DATA,U,6)
"RTN","HMPWB1",147,0)
 S DATA("GMRAERRCMTS",1)=$P(DATA,U,7)
"RTN","HMPWB1",148,0)
 Q
"RTN","HMPWB1",149,0)
 ;
"RTN","HMPWB1",150,0)
ERROR ;handle errors generated by MSG^HMPTOOLS
"RTN","HMPWB1",151,0)
 S HMPSTOP=1
"RTN","HMPWB1",152,0)
 S ^TMP("HMP",$J,1,1)=RSLT(1)
"RTN","HMPWB1",153,0)
 S RSLT=$NA(^TMP("HMP",$J))
"RTN","HMPWB1",154,0)
 K RSLT(1)
"RTN","HMPWB1",155,0)
 Q
"RTN","HMPWB1",156,0)
 ;
"RTN","HMPWB1",157,0)
EXTRACT(GLOB) ; Move ^TMP("HMPF",$J) into string format
"RTN","HMPWB1",158,0)
 N HMPSTOP,HMPFND
"RTN","HMPWB1",159,0)
 S RSLT="",X=0,HMPSTOP=0,HMPFND=0
"RTN","HMPWB1",160,0)
 S (I,J)=0
"RTN","HMPWB1",161,0)
 F  S I=$O(^TMP("HMPF",$J,I)) Q:I=""!(HMPSTOP)  D
"RTN","HMPWB1",162,0)
 . F  S J=$O(^TMP("HMPF",$J,I,J)) Q:J=""  D
"RTN","HMPWB1",163,0)
 .. I $G(^TMP("HMPF",$J,I,J))["syncStatus" D
"RTN","HMPWB1",164,0)
 ... Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWB1",165,0)
 ... S RSLT(X)=RSLT(X)_$P(^TMP("HMPF",$J,I,J),",",1)
"RTN","HMPWB1",166,0)
 ... S HMPSTOP=1
"RTN","HMPWB1",167,0)
 ... Q
"RTN","HMPWB1",168,0)
 .. Q:$G(^TMP("HMPF",$J,I,J))=""
"RTN","HMPWB1",169,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),",",1)'["allergy"
"RTN","HMPWB1",170,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),",",4)'["localId"
"RTN","HMPWB1",171,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWB1",172,0)
 .. S X=X+1
"RTN","HMPWB1",173,0)
 .. S RSLT(X)=$G(^TMP("HMPF",$J,I,J))
"RTN","HMPWB1",174,0)
 .. F  S J=$O(^TMP("HMPF",$J,I,J)) Q:J=""  D
"RTN","HMPWB1",175,0)
 ... Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWB1",176,0)
 ... S X=X+1
"RTN","HMPWB1",177,0)
 ... S RSLT(X)=$G(^TMP("HMPF",$J,I,J))
"RTN","HMPWB1",178,0)
 ... S HMPFND=1
"RTN","HMPWB1",179,0)
 ... Q
"RTN","HMPWB1",180,0)
 .. S I=$O(^TMP("HMPF",$J,I))
"RTN","HMPWB1",181,0)
 .. Q
"RTN","HMPWB1",182,0)
 . Q
"RTN","HMPWB1",183,0)
 Q RSLT
"RTN","HMPWB2")
0^46^B43784847
"RTN","HMPWB2",1,0)
HMPWB2 ;;ASMR/PJH/JD - WRITEBACK DEMOGRAPHICS/VITALS TO VISTA;Nov 13, 2015@16:42:53
"RTN","HMPWB2",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Dec 11, 2014;Build 24
"RTN","HMPWB2",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWB2",4,0)
 ;
"RTN","HMPWB2",5,0)
 Q
"RTN","HMPWB2",6,0)
 ;
"RTN","HMPWB2",7,0)
DEMOG(RSLT,IEN,DFN,DATA) ;File demographic data - WIP not part of PSI 6
"RTN","HMPWB2",8,0)
 ;
"RTN","HMPWB2",9,0)
 ;Output
"RTN","HMPWB2",10,0)
 ; RSLT = JSON format string for demographics
"RTN","HMPWB2",11,0)
 ;Input
"RTN","HMPWB2",12,0)
 ; IEN  = record to be updated (not used)
"RTN","HMPWB2",13,0)
 ; DFN  = patient IEN
"RTN","HMPWB2",14,0)
 ; DATA("data") - input format - string
"RTN","HMPWB2",15,0)
 ;   Piece 1: DFN
"RTN","HMPWB2",16,0)
 ;   Piece 2: Home Phone Number - ^DD(2,.131 - ^DPT(DFN,.13) piece 1
"RTN","HMPWB2",17,0)
 ;   Piece 3: Cell Phone Number - ^DD(2,.134 - ^DPT(DFN,.13) piece 4
"RTN","HMPWB2",18,0)
 ;   Piece 4: Work Phone Number - ^DD(2,.132 - ^DPT(DFN,.13) piece 2
"RTN","HMPWB2",19,0)
 ;   Piece 5: Emergency Phone Number - ^DD(2,.339 - ^DPT(DFN,.33) piece 9
"RTN","HMPWB2",20,0)
 ;   Piece 6: NOK Phone Number - ^DD(2,.219 - ^DPT(DFN,.21) piece 9
"RTN","HMPWB2",21,0)
 ;
"RTN","HMPWB2",22,0)
 ; If a piece contains -1, it means DELETE it
"RTN","HMPWB2",23,0)
 ; If a piece is null, it means LEAVE it ALONE
"RTN","HMPWB2",24,0)
 ; If a piece is not -1 and not null, it means UPDATE it
"RTN","HMPWB2",25,0)
 ;
"RTN","HMPWB2",26,0)
 ;Update Demographics Logic
"RTN","HMPWB2",27,0)
 ;-------------------------
"RTN","HMPWB2",28,0)
 ;Quit if DFN is not defined - IEN is not used
"RTN","HMPWB2",29,0)
 S RSLT="ERROR" Q:'$G(DFN)
"RTN","HMPWB2",30,0)
 ;Assume input is presented as a string with DFN in piece1
"RTN","HMPWB2",31,0)
 N HMP,HMPI,INVAR,OUTVAR
"RTN","HMPWB2",32,0)
 S INVAR=$G(DATA("data")) Q:$P(INVAR,U)'=DFN
"RTN","HMPWB2",33,0)
 ;Call existing HMPPTDEM api
"RTN","HMPWB2",34,0)
 D FILE^HMPPTDEM(.OUTVAR,INVAR) I $G(OUTVAR(0))'=1 M RSLT=OUTVAR Q
"RTN","HMPWB2",35,0)
 ;Build JSON in ^TMP("HMP",$J) from VistA - expects DFN to be defined
"RTN","HMPWB2",36,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPWB2",37,0)
 D DPT1^HMPDJ00
"RTN","HMPWB2",38,0)
 ;Call $$EXTRACT to pass JSON back as RSLT string
"RTN","HMPWB2",39,0)
 S RSLT=$$EXTRACT(HMP)
"RTN","HMPWB2",40,0)
 ;Clear work files
"RTN","HMPWB2",41,0)
 K @HMP
"RTN","HMPWB2",42,0)
 Q
"RTN","HMPWB2",43,0)
 ;
"RTN","HMPWB2",44,0)
VMADD(RSLT,IEN,DFN,DATA) ;Add vital measurement
"RTN","HMPWB2",45,0)
 ;
"RTN","HMPWB2",46,0)
 ;
"RTN","HMPWB2",47,0)
 ; Note: Original GMVDCSAV routine supports the following IAs:
"RTN","HMPWB2",48,0)
 ; #3996 - GMV ADD VM RPC called at EN1  (private)
"RTN","HMPWB2",49,0)
 ;
"RTN","HMPWB2",50,0)
 ;Output
"RTN","HMPWB2",51,0)
 ; RSLT = JSON format string for vital added
"RTN","HMPWB2",52,0)
 ;Input
"RTN","HMPWB2",53,0)
 ; IEN  = record to be updated (not used)
"RTN","HMPWB2",54,0)
 ; DFN  = patient IEN (not used, DFN is sent in $P(DATA,"^",2)
"RTN","HMPWB2",55,0)
 ; DATA - input format - string
"RTN","HMPWB2",56,0)
 ;   piece1 = date/time in FileMan internal format
"RTN","HMPWB2",57,0)
 ;   piece2 = patient number from FILE 2 (i.e., DFN)
"RTN","HMPWB2",58,0)
 ;   piece3 = vital type, a semi-colon, the reading, a semi-colon, and
"RTN","HMPWB2",59,0)
 ;            oxygen flow rate and percentage values [optional] (e.g.,
"RTN","HMPWB2",60,0)
 ;            21;99;1 l/min 90%)
"RTN","HMPWB2",61,0)
 ;   piece4 = hospital location (FILE 44) pointer value
"RTN","HMPWB2",62,0)
 ;   piece5 = FILE 200 user number (i.e., DUZ), an asterisk, and the 
"RTN","HMPWB2",63,0)
 ;            qualifier (File 120.52) internal entry numbers separated by
"RTN","HMPWB2",64,0)
 ;            colons (e.g., 547*50:65)
"RTN","HMPWB2",65,0)
 ; Example:
"RTN","HMPWB2",66,0)
 ;            "3051011.1635^134^1;120/80;^67^87*2:38:50:75"
"RTN","HMPWB2",67,0)
 ;
"RTN","HMPWB2",68,0)
 ;Add Vital Logic
"RTN","HMPWB2",69,0)
 ;---------------
"RTN","HMPWB2",70,0)
 N HMPDFN,VMADD,HMPVEIE
"RTN","HMPWB2",71,0)
 S VMADD=1,HMPVEIE=0
"RTN","HMPWB2",72,0)
 ;Quit if DFN is null or IEN is not zero
"RTN","HMPWB2",73,0)
 S RSLT="ERROR" Q:$G(IEN)'=0
"RTN","HMPWB2",74,0)
 ;Assume input is presented as a string with DFN in second piece
"RTN","HMPWB2",75,0)
 N HMP,HMPI,INVAR,OUTVAR,GMRIEN,SEQ,TOT,HMPODT,HMP
"RTN","HMPWB2",76,0)
 S HMPODT=$P(DATA,"^",1),HMPODT=17000000+$P(HMPODT,".",1)_$P(HMPODT,".",2)
"RTN","HMPWB2",77,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPWB2",78,0)
 S INVAR=$G(DATA) I $P(INVAR,U,2)'?1N.N S RSLT="DFN NOT PRESENT IN DATA STRING" Q
"RTN","HMPWB2",79,0)
 S HMPDFN=$P(INVAR,U,2)
"RTN","HMPWB2",80,0)
 ;Add vital record to file #120.5
"RTN","HMPWB2",81,0)
 D EN1^GMVDCSAV(.OUTVAR,INVAR) I $G(OUTVAR(0))="ERROR" S RSLT="ERROR ADDING VITAL TO FILE 120.5" Q
"RTN","HMPWB2",82,0)
 ;Check if added record exist in VistA
"RTN","HMPWB2",83,0)
 S GMRIEN=$$FINDVM(HMPDFN) I 'GMRIEN S RSLT="RECORD DOES NOT EXIST IN VISTA" Q
"RTN","HMPWB2",84,0)
 ;Determine total count and sequence
"RTN","HMPWB2",85,0)
 S TOT=$$COUNTVM(HMPDFN,GMRIEN,.SEQ)
"RTN","HMPWB2",86,0)
 ;Build JSON in ^TMP("HMP",$J) from VistA data in file #120.5
"RTN","HMPWB2",87,0)
 D GMV1(HMPDFN,GMRIEN,SEQ,TOT)
"RTN","HMPWB2",88,0)
 ;Call $$EXTRACT to pass JSON back as RSLT string
"RTN","HMPWB2",89,0)
 K RSLT
"RTN","HMPWB2",90,0)
 S RSLT=$$EXTRACT(HMP)
"RTN","HMPWB2",91,0)
 M ^TMP("HMPVIT",$J)=RSLT
"RTN","HMPWB2",92,0)
 K RSLT
"RTN","HMPWB2",93,0)
 S RSLT=$NA(^TMP("HMPVIT",$J))
"RTN","HMPWB2",94,0)
 ;Clear work files
"RTN","HMPWB2",95,0)
 K @HMP
"RTN","HMPWB2",96,0)
 Q
"RTN","HMPWB2",97,0)
 ;
"RTN","HMPWB2",98,0)
VMERR(RSLT,DATA) ;Mark vital measurement entered in error
"RTN","HMPWB2",99,0)
 ;
"RTN","HMPWB2",100,0)
 ; Note: Original GMRVUTL1 routine supports the following IAs:
"RTN","HMPWB2",101,0)
 ; #4414 - GMV MARK ERROR RPC is called at ERROR (private)
"RTN","HMPWB2",102,0)
 ;
"RTN","HMPWB2",103,0)
 ;DE2983 - Since DFN is not relevant as an input parameter, we removed it from the DATA string.
"RTN","HMPWB2",104,0)
 ;Once we know the vital IEN, DFN will also be known.  JD - 11/9/15.
"RTN","HMPWB2",105,0)
 ;
"RTN","HMPWB2",106,0)
 ;Output
"RTN","HMPWB2",107,0)
 ; RSLT = JSON format string for vital added
"RTN","HMPWB2",108,0)
 ;Input
"RTN","HMPWB2",109,0)
 ; DATA - Input format - string 
"RTN","HMPWB2",110,0)
 ;    piece1 = FILE #120.5 IEN
"RTN","HMPWB2",111,0)
 ;    piece2 
"RTN","HMPWB2",112,0)
 ;      1 = INCORRECT DATE/TIME
"RTN","HMPWB2",113,0)
 ;      2 = INCORRECT READING
"RTN","HMPWB2",114,0)
 ;      3 = INCORRECT PATIENT
"RTN","HMPWB2",115,0)
 ;      4 = INVALID RECORD
"RTN","HMPWB2",116,0)
 ; Example:
"RTN","HMPWB2",117,0)
 ;            "24048^3^2"
"RTN","HMPWB2",118,0)
 ;
"RTN","HMPWB2",119,0)
 ;Mark in error logic
"RTN","HMPWB2",120,0)
 ;-------------------
"RTN","HMPWB2",121,0)
 ;Assume input is presented as a string with 120.5 ien in piece 1
"RTN","HMPWB2",122,0)
 N HMP,HMPI,HMPSTOP,HMPVEIE,INVAR,OUTVAR,GMRIEN,GMRRSN,VMERR
"RTN","HMPWB2",123,0)
 S VMERR=1
"RTN","HMPWB2",124,0)
 S HMPSTOP=0,HMPVEIE=1
"RTN","HMPWB2",125,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPWB2",126,0)
 D CHECK
"RTN","HMPWB2",127,0)
 S INVAR=$G(DATA)
"RTN","HMPWB2",128,0)
 I $D(RSLT(1)) D
"RTN","HMPWB2",129,0)
 . S ^TMP("HMP",$J,1,1)=RSLT(1)
"RTN","HMPWB2",130,0)
 . S RSLT=$NA(^TMP("HMP",$J))
"RTN","HMPWB2",131,0)
 . K RSLT(1)
"RTN","HMPWB2",132,0)
 I HMPSTOP Q
"RTN","HMPWB2",133,0)
 ;Call existing GMVUTL1 api - seq logic
"RTN","HMPWB2",134,0)
 D ERROR^GMVUTL1(.OUTVAR,INVAR) I OUTVAR'="OK" D 
"RTN","HMPWB2",135,0)
 . D MSG^HMPTOOLS("Invalid input parameters",2,INVAR)
"RTN","HMPWB2",136,0)
 . S HMPSTOP=1
"RTN","HMPWB2",137,0)
 . S ^TMP("HMP",$J,1,1)=RSLT(1)
"RTN","HMPWB2",138,0)
 . S RSLT=$NA(^TMP("HMP",$J))
"RTN","HMPWB2",139,0)
 . K RSLT(1)
"RTN","HMPWB2",140,0)
 . Q
"RTN","HMPWB2",141,0)
 I HMPSTOP Q
"RTN","HMPWB2",142,0)
 ;Determine total count and sequence
"RTN","HMPWB2",143,0)
 S TOT=$$COUNTVM(DFN,GMRIEN,.SEQ)
"RTN","HMPWB2",144,0)
 ;Build JSON in ^TMP("HMP",$J) from VistA data in file #120.5
"RTN","HMPWB2",145,0)
 D GMV1(DFN,GMRIEN,.SEQ,TOT)
"RTN","HMPWB2",146,0)
 ;Call $$EXTRACT to pass JSON back as RSLT string
"RTN","HMPWB2",147,0)
 K RSLT
"RTN","HMPWB2",148,0)
 S RSLT=$$EXTRACT(HMP)
"RTN","HMPWB2",149,0)
 M ^TMP("HMPVIT",$J)=RSLT
"RTN","HMPWB2",150,0)
 K RSLT
"RTN","HMPWB2",151,0)
 S RSLT=$NA(^TMP("HMPVIT",$J))
"RTN","HMPWB2",152,0)
 ;Clear work files
"RTN","HMPWB2",153,0)
 K @HMP
"RTN","HMPWB2",154,0)
 Q
"RTN","HMPWB2",155,0)
 ;
"RTN","HMPWB2",156,0)
GMV1(DFN,ID,SEQ,TOT) ; -- vital/measurement ^UTILITY($J,"GMRVD",HMPIDT,HMPTYP,ID)
"RTN","HMPWB2",157,0)
 ; Note: this code is a copy of GMV1^HMPDJ02 with addition of header 
"RTN","HMPWB2",158,0)
 N HMPY,X0,TYPE,LOC,FAC,X,Y,MRES,MUNT,HIGH,LOW,I,ARRAY,VIT,FILTER,HMPE,HMPFCNT,HMPUID,J,STMPTM
"RTN","HMPWB2",159,0)
 S FILTER("id")=ID
"RTN","HMPWB2",160,0)
 S FILTER("noHead")=1
"RTN","HMPWB2",161,0)
 S FILTER("domain")="vital"
"RTN","HMPWB2",162,0)
 S FILTER("patientId")=DFN
"RTN","HMPWB2",163,0)
 D GET^HMPDJ(.RSLT,.FILTER)
"RTN","HMPWB2",164,0)
 K ^TMP("VITAL",$J)
"RTN","HMPWB2",165,0)
 M ^TMP("VITAL",$J)=@RSLT
"RTN","HMPWB2",166,0)
 S RSLT=$NA(^TMP("VITAL",$J))
"RTN","HMPWB2",167,0)
 ;I $G(HMPERR)'="" S RSLT=HMPERR Q
"RTN","HMPWB2",168,0)
 S HMPFCNT=0
"RTN","HMPWB2",169,0)
 S HMPUID=$$SETUID^HMPUTILS("vital",DFN,GMRIEN)
"RTN","HMPWB2",170,0)
 S HMPE=^TMP("VITAL",$J,1,1)
"RTN","HMPWB2",171,0)
 S STMPTM=$TR($P($P(HMPE,"lastUpdateTime",2),","),""":")
"RTN","HMPWB2",172,0)
 D ADHOC^HMPUTIL2("vital",HMPFCNT,DFN,HMPUID,STMPTM)
"RTN","HMPWB2",173,0)
 K RSLT
"RTN","HMPWB2",174,0)
 M RSLT=^TMP("HMPF",$J)
"RTN","HMPWB2",175,0)
 Q
"RTN","HMPWB2",176,0)
 ;
"RTN","HMPWB2",177,0)
FINDVM(DFN) ;Get most recent vital measurement for this patient
"RTN","HMPWB2",178,0)
 Q $O(^GMR(120.5,"C",DFN,"A"),-1)
"RTN","HMPWB2",179,0)
 ;
"RTN","HMPWB2",180,0)
COUNTVM(DFN,IEN,SEQ) ;Count vitals for this patient
"RTN","HMPWB2",181,0)
 N SUB,TOT S SUB=0,SEQ=0,TOT=0
"RTN","HMPWB2",182,0)
 F  S SUB=$O(^GMR(120.5,"C",DFN,SUB)) Q:'SUB  D
"RTN","HMPWB2",183,0)
 .;Ignore entered in error for ADDs
"RTN","HMPWB2",184,0)
 .I $G(VMADD)=1 Q:$P($G(^GMR(120.5,SUB,2)),U)=1
"RTN","HMPWB2",185,0)
 .;Save SEQ if this is the entry
"RTN","HMPWB2",186,0)
 .S TOT=TOT+1 S:SUB=IEN SEQ=TOT
"RTN","HMPWB2",187,0)
 ;Return count of vitals for this patient (plus sequence in SEQ)
"RTN","HMPWB2",188,0)
 Q TOT
"RTN","HMPWB2",189,0)
 ;
"RTN","HMPWB2",190,0)
CHECK ;Check for valid parameters
"RTN","HMPWB2",191,0)
 S DATA=$G(DATA)
"RTN","HMPWB2",192,0)
 S GMRIEN=$P(DATA,U)
"RTN","HMPWB2",193,0)
 I GMRIEN'=+GMRIEN D MSG^HMPTOOLS("Vital identifier is invalid/null: "_GMRIEN) S HMPSTOP=1 Q
"RTN","HMPWB2",194,0)
 ;Removed DFN from the input parameter DATA but for integrity purposes (and not to modify
"RTN","HMPWB2",195,0)
 ;too much code), we need to keep the number of pieces in DATA the same.
"RTN","HMPWB2",196,0)
 S DATA=GMRIEN_U_$P($G(^GMR(120.5,GMRIEN,0)),U,2)_U_$P(DATA,U,2,999)
"RTN","HMPWB2",197,0)
 S DFN=$P(DATA,U,2),GMRRSN=$P(DATA,U,3)
"RTN","HMPWB2",198,0)
 I '$D(^GMR(120.5,GMRIEN)) D MSG^HMPTOOLS("The vital identifier "_GMRIEN_" does not exist.") S HMPSTOP=1 Q
"RTN","HMPWB2",199,0)
 I $G(GMRRSN)<1!($G(GMRRSN)>4) D MSG^HMPTOOLS("The Entered in Error reason must be 1, 2, 3 or 4: "_GMRRSN) S HMPSTOP=1 Q
"RTN","HMPWB2",200,0)
 I $D(^GMR(120.5,GMRIEN,2))>0 D MSG^HMPTOOLS("Vital already entered in error: "_GMRIEN) S HMPSTOP=1 Q
"RTN","HMPWB2",201,0)
 Q
"RTN","HMPWB2",202,0)
EXTRACT(GLOB) ; Move ^TMP("HMPF",$J) into string format
"RTN","HMPWB2",203,0)
 N HMPSTOP,HMPFND,L,PCE
"RTN","HMPWB2",204,0)
 S RSLT="",X=0,HMPSTOP=0,HMPFND=0
"RTN","HMPWB2",205,0)
 S (I,J)=0
"RTN","HMPWB2",206,0)
 F  S I=$O(^TMP("HMPF",$J,I)) Q:I=""!(HMPSTOP)  D
"RTN","HMPWB2",207,0)
 . F  S J=$O(^TMP("HMPF",$J,I,J)) Q:J=""  D
"RTN","HMPWB2",208,0)
 .. I $G(^TMP("HMPF",$J,I,J))["syncStatus" D
"RTN","HMPWB2",209,0)
 ... Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWB2",210,0)
 ... S RSLT(X)=RSLT(X)_$P(^TMP("HMPF",$J,I,J),",",1)
"RTN","HMPWB2",211,0)
 ... S HMPSTOP=1
"RTN","HMPWB2",212,0)
 ... Q
"RTN","HMPWB2",213,0)
 .. Q:$G(^TMP("HMPF",$J,I,J))=""
"RTN","HMPWB2",214,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),",",1)'["vital"
"RTN","HMPWB2",215,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),",",4)'["localId"
"RTN","HMPWB2",216,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWB2",217,0)
 .. S X=X+1
"RTN","HMPWB2",218,0)
 .. S RSLT(X)=$G(^TMP("HMPF",$J,I,J))
"RTN","HMPWB2",219,0)
 .. F  S J=$O(^TMP("HMPF",$J,I,J)) Q:J=""  D
"RTN","HMPWB2",220,0)
 ... Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWB2",221,0)
 ... S X=X+1
"RTN","HMPWB2",222,0)
 ... S RSLT(X)=$G(^TMP("HMPF",$J,I,J))
"RTN","HMPWB2",223,0)
 ... S HMPFND=1
"RTN","HMPWB2",224,0)
 ... Q
"RTN","HMPWB2",225,0)
 .. S I=$O(^TMP("HMPF",$J,I))
"RTN","HMPWB2",226,0)
 .. Q
"RTN","HMPWB2",227,0)
 . Q
"RTN","HMPWB2",228,0)
 Q RSLT
"RTN","HMPWB5")
0^47^B28193400
"RTN","HMPWB5",1,0)
HMPWB5 ;JD/CNP - Write back entry points for Notes, and Encounters;Jul 8, 2015@08:31:16
"RTN","HMPWB5",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPWB5",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWB5",4,0)
 ;
"RTN","HMPWB5",5,0)
 Q
"RTN","HMPWB5",6,0)
 ;
"RTN","HMPWB5",7,0)
ENC(RSLT,IEN,DFN,DATA) ; Encounters
"RTN","HMPWB5",8,0)
 ;
"RTN","HMPWB5",9,0)
 ;RPC: HMP WRITEBACK ENCOUNTERS
"RTN","HMPWB5",10,0)
 ;Output
"RTN","HMPWB5",11,0)
 ; RSLT = JSON format string for encounters
"RTN","HMPWB5",12,0)
 ;Input
"RTN","HMPWB5",13,0)
 ; IEN  = record to be updated
"RTN","HMPWB5",14,0)
 ; DFN  = patient IEN
"RTN","HMPWB5",15,0)
 ; DATA(0) - input format - string - Main delimiter is "^"; Subdelimiter is ";"
"RTN","HMPWB5",16,0)
 ;   Piece 1: DFN - Patient IEN
"RTN","HMPWB5",17,0)
 ;   Piece 2: Inpatient flag - 1 = inpatient, 0 = otherwise
"RTN","HMPWB5",18,0)
 ;   Piece 3: Hospital location IEN
"RTN","HMPWB5",19,0)
 ;   Piece 4: Visit/episode date
"RTN","HMPWB5",20,0)
 ;   Piece 5: Service category
"RTN","HMPWB5",21,0)
 ;   Piece 6: Author/dictator IEN (i.e. Provider)
"RTN","HMPWB5",22,0)
 ;   Piece 7: Encounter type - A 2- or 3-character string as follows:
"RTN","HMPWB5",23,0)
 ;               CPT for CPT (^AUPNVCPT; #9000010.18)
"RTN","HMPWB5",24,0)
 ;               HF      Health Factor (^AUPNVHF; #9000010.23)
"RTN","HMPWB5",25,0)
 ;               IMM     Immunization (^AUPNVIMM; #9000010.11)
"RTN","HMPWB5",26,0)
 ;               PED     Patient Education (^AUPNVPED; #9000010.16)
"RTN","HMPWB5",27,0)
 ;               POV     POV - Purpose of Visit; a.k.a Diagnosis - (^AUPNVPOV; #9000010.07)
"RTN","HMPWB5",28,0)
 ;               SK      Skin (^AUPNVSK; #9000010.12)
"RTN","HMPWB5",29,0)
 ;               XAM     Exam (^AUPNVXAM; #9000010.13)
"RTN","HMPWB5",30,0)
 ; DATA(n) - Encounter data - Main delimiter is "^"; Subdelimeter is ";"
"RTN","HMPWB5",31,0)
 ;  n is an integer>0.  Encounter data varies with the type of encounter (piece 7 above)
"RTN","HMPWB5",32,0)
 ;  as follows:
"RTN","HMPWB5",33,0)
 ;   CPT: CPT code^Modifier1 code;Modifier2 code;...^Quantity^Provider name^Comment
"RTN","HMPWB5",34,0)
 ;    HF: Health factor name^Level/severity code^Comment
"RTN","HMPWB5",35,0)
 ;   IMM: ***N/A***  Immunization RPC will be invoked
"RTN","HMPWB5",36,0)
 ;   PED: Education name^Level of understanding code^Comment
"RTN","HMPWB5",37,0)
 ;   POV: Diag. code^Search term^EXACT "problem list items" text^Add to problem list^Comment
"RTN","HMPWB5",38,0)
 ;    SK: Skin test name^Result code^Reading^Comment
"RTN","HMPWB5",39,0)
 ;   XAM: Exam name^Result code^Comment
"RTN","HMPWB5",40,0)
 ;
"RTN","HMPWB5",41,0)
 N ENC,ENCNM,ENCTL,ENCTYP,ENCGLB,ERR,GLB,HMP,HMPA,HMPFCNT,HMPE,HMPTMP
"RTN","HMPWB5",42,0)
 N HMPUID,INFO,NOTE,NOTEIEN,OK,ORLOC,PCELIST,PRVNM,STMPTM,VISIT,X,Y,X0,X1,X2
"RTN","HMPWB5",43,0)
 S U="^",HMPTMP="HMPENC",ERR="",IEN=$G(IEN)
"RTN","HMPWB5",44,0)
 I '$G(DFN) D MSG("DFN",1) Q  ; DFN is required
"RTN","HMPWB5",45,0)
 ;S INFO=$G(DATA(0))  ;1
"RTN","HMPWB5",46,0)
 S INFO=$G(DATA)     ;2
"RTN","HMPWB5",47,0)
 ;Check for required fields
"RTN","HMPWB5",48,0)
 ; DFN
"RTN","HMPWB5",49,0)
 S HMP="DFN"
"RTN","HMPWB5",50,0)
 I '$P(INFO,U) D MSG(HMP,1) Q
"RTN","HMPWB5",51,0)
 I $D(^DPT($P(INFO,U)))'>0 D MSG(HMP,2,$P(INFO,U)) Q
"RTN","HMPWB5",52,0)
 ; Location
"RTN","HMPWB5",53,0)
 S HMP="Location IEN"
"RTN","HMPWB5",54,0)
 I '$P(INFO,U,3) D MSG(HMP,1) Q
"RTN","HMPWB5",55,0)
 I $D(^SC($P(INFO,U,3)))'>0 D MSG(HMP,2,$P(INFO,U,3)) Q
"RTN","HMPWB5",56,0)
 ; Visit Date
"RTN","HMPWB5",57,0)
 I '$P(INFO,U,4) D MSG("Visit Date",1) Q
"RTN","HMPWB5",58,0)
 ;;Service Category
"RTN","HMPWB5",59,0)
 I $L($P(INFO,U,5))=0 D MSG("Service category",1) Q
"RTN","HMPWB5",60,0)
 ; Encouter Type
"RTN","HMPWB5",61,0)
 I $L($P(INFO,U,7))=0 D MSG("Encounter type",1) Q
"RTN","HMPWB5",62,0)
 ;
"RTN","HMPWB5",63,0)
 ;If the encounter is immunization then call the immunization RPC.
"RTN","HMPWB5",64,0)
 I $P(INFO,U,7)="IMM" D  Q
"RTN","HMPWB5",65,0)
 .;S DATA=DATA(0)_U_DATA(1)  ;1
"RTN","HMPWB5",66,0)
 .D IMMUN^HMPWBIM1(.RSLT,IEN,DFN,.DATA)
"RTN","HMPWB5",67,0)
 ;
"RTN","HMPWB5",68,0)
 S DFN=$P(INFO,U),OK="",NOTEIEN=0,ORLOC=$P(INFO,U,3)
"RTN","HMPWB5",69,0)
 S ENCTYP=$$UP^XLFSTR($P(INFO,U,7))
"RTN","HMPWB5",70,0)
 S ENCGLB=$S(ENCTYP="CPT":"^ICPT",ENCTYP="POV":"^ICD9",1:"MORE")
"RTN","HMPWB5",71,0)
 I ENCGLB="MORE" S ENCGLB=$S(ENCTYP="PED":"^AUTTEDT",ENCTYP="XAM":"^AUTTEXAM",1:"MORE")
"RTN","HMPWB5",72,0)
 I ENCGLB="MORE" S ENCGLB="^AUTT"_ENCTYP
"RTN","HMPWB5",73,0)
 I $D(@ENCGLB)'>0 D MSG("Encounter type",2,ENCTYP) Q  ; Invalid encounter type
"RTN","HMPWB5",74,0)
 ;S ENCNM=$P($G(@ENCGLB@($P(INFO,U,8),0)),U)  ; Encounter name
"RTN","HMPWB5",75,0)
 S PRVNM=$P($G(^VA(200,$P(INFO,U,6),0)),U)   ; Provider name
"RTN","HMPWB5",76,0)
 ;Prepare the encounter array for the RPC
"RTN","HMPWB5",77,0)
 S PCELIST(1)="HDR^"_$P(INFO,U,2)_"^^"_$P(INFO,U,3)_";"_$P(INFO,U,4)_";"_$P(INFO,U,5)
"RTN","HMPWB5",78,0)
 S PCELIST(2)="VST^DT^"_$P(INFO,U,4)
"RTN","HMPWB5",79,0)
 S PCELIST(3)="VST^PT^"_$P(INFO,U)
"RTN","HMPWB5",80,0)
 S PCELIST(4)="VST^HL^"_$P(INFO,U,3)
"RTN","HMPWB5",81,0)
 S PCELIST(5)="VST^VC^"_$P(INFO,U,5)
"RTN","HMPWB5",82,0)
 S PCELIST(6)="PRV^"_$P(INFO,U,6)_"^^^"_PRVNM_"^1"
"RTN","HMPWB5",83,0)
 S ERR=""
"RTN","HMPWB5",84,0)
 S DATA(1)=$P(INFO,U,8,999)  ;2
"RTN","HMPWB5",85,0)
 D PCELST^HMPWB5A(ENCTYP,.DATA,.PCELIST,.ERR)
"RTN","HMPWB5",86,0)
 I $G(ERR)]"" D MSG(ERR) Q
"RTN","HMPWB5",87,0)
 ;Invoke the already existing RPC (ORWPCE SAVE)
"RTN","HMPWB5",88,0)
 ;D SAVE^ORWPCE(.OK,.PCELIST,NOTEIEN,ORLOC)
"RTN","HMPWB5",89,0)
 D DQSAVE^ORWPCE1
"RTN","HMPWB5",90,0)
 ;S VISIT=$O(^AUPNVSIT("B",$P(INFO,U,4),""))
"RTN","HMPWB5",91,0)
 S HMP=""
"RTN","HMPWB5",92,0)
 F  S HMP=$O(^AUPNVSIT("B",$P(INFO,U,4),HMP)) Q:HMP=""  Q:DFN=$P(^AUPNVSIT(HMP,0),"^",5)
"RTN","HMPWB5",93,0)
 S VISIT=HMP
"RTN","HMPWB5",94,0)
 I VISIT>0 D
"RTN","HMPWB5",95,0)
 .K FILTER
"RTN","HMPWB5",96,0)
 .S FILTER("noHead")=1
"RTN","HMPWB5",97,0)
 .S FILTER("patientId")=DFN
"RTN","HMPWB5",98,0)
 .S FILTER("domain")="visit"
"RTN","HMPWB5",99,0)
 .S FILTER("id")=VISIT
"RTN","HMPWB5",100,0)
 .D GET^HMPDJ(.HMP,.FILTER)
"RTN","HMPWB5",101,0)
 .S NOTE=$O(^TIU(8925,"V",VISIT,""))
"RTN","HMPWB5",102,0)
 .I NOTE>0 D
"RTN","HMPWB5",103,0)
 ..K FILTER
"RTN","HMPWB5",104,0)
 ..S FILTER("noHead")=1
"RTN","HMPWB5",105,0)
 ..S FILTER("patientId")=DFN
"RTN","HMPWB5",106,0)
 ..S FILTER("domain")="document"
"RTN","HMPWB5",107,0)
 ..S FILTER("id")=OK
"RTN","HMPWB5",108,0)
 ..D GET^HMPDJ(.HMP,.FILTER)
"RTN","HMPWB5",109,0)
 .S GLB="^AUPNV"_ENCTYP
"RTN","HMPWB5",110,0)
 .S ENC=$O(@GLB@("AD",VISIT,""))
"RTN","HMPWB5",111,0)
 .I ENC>0 D
"RTN","HMPWB5",112,0)
 ..; Get the full domain name so it matches the tags in HMPDJ0
"RTN","HMPWB5",113,0)
 ..S ENCTL=$S(ENCTYP="CPT":"cpt",ENCTYP="HF":"factor",ENCTYP="IMM":"immuniza",1:"MORE")
"RTN","HMPWB5",114,0)
 ..I ENCTL="MORE" S ENCTL=$S(ENCTYP="PED":"educatio",ENCTYP="POV":"pov",1:"MORE")
"RTN","HMPWB5",115,0)
 ..I ENCTL="MORE" S ENCTL=$S(ENCTYP="SK":"skin",ENCTYP="XAM":"exam",1:"")
"RTN","HMPWB5",116,0)
 ..K FILTER
"RTN","HMPWB5",117,0)
 ..S FILTER("noHead")=1
"RTN","HMPWB5",118,0)
 ..S FILTER("patientId")=DFN
"RTN","HMPWB5",119,0)
 ..S FILTER("domain")=ENCTL
"RTN","HMPWB5",120,0)
 ..S FILTER("id")=ENC
"RTN","HMPWB5",121,0)
 ..D GET^HMPDJ(.HMP,.FILTER)
"RTN","HMPWB5",122,0)
 ..;Build Metastamp and Syncstatus
"RTN","HMPWB5",123,0)
 ..S HMPFCNT=$G(^TMP("HMPF",$J,"total"))
"RTN","HMPWB5",124,0)
 ..S HMPUID=$$SETUID^HMPUTILS(ENCTL,DFN,ENC)
"RTN","HMPWB5",125,0)
 ..S HMPE=$G(^TMP("HMP",$J,1,1))
"RTN","HMPWB5",126,0)
 ..S STMPTM=$TR($P($P(HMPE,"stampTime",2),","),""":")
"RTN","HMPWB5",127,0)
 ..D ADHOC^HMPUTIL2(ENCTL,HMPFCNT,DFN,HMPUID,STMPTM)
"RTN","HMPWB5",128,0)
 ..K ^TMP(HMPTMP,$J)
"RTN","HMPWB5",129,0)
 ..;=== Add a } to the end of data
"RTN","HMPWB5",130,0)
 ..; Find the 'data' section in ^TMP("HMPF"
"RTN","HMPWB5",131,0)
 ..S X0=0
"RTN","HMPWB5",132,0)
 ..F  S X0=$O(^TMP("HMPF",$J,X0)) Q:X0'=+X0  D
"RTN","HMPWB5",133,0)
 ...S X1=0
"RTN","HMPWB5",134,0)
 ...F  S X1=$O(^TMP("HMPF",$J,X0,X1)) Q:X1'=+X1  D
"RTN","HMPWB5",135,0)
 ....S X2=$G(^TMP("HMPF",$J,X0,X1))
"RTN","HMPWB5",136,0)
 ....I X2[("""collection"""_":"_""""_ENCTL_"""") M ^TMP(HMPTMP,$J,X0)=^TMP("HMPF",$J,X0)
"RTN","HMPWB5",137,0)
 ..; Add } to the end
"RTN","HMPWB5",138,0)
 ..S X0=0
"RTN","HMPWB5",139,0)
 ..F  S X0=$O(^TMP(HMPTMP,$J,X0)) Q:X0'=+X0  D
"RTN","HMPWB5",140,0)
 ...S X1=$O(^TMP(HMPTMP,$J,X0,""),-1)
"RTN","HMPWB5",141,0)
 ...S ^TMP(HMPTMP,$J,X0,X1)=^TMP(HMPTMP,$J,X0,X1)_"}"
"RTN","HMPWB5",142,0)
 ..;===
"RTN","HMPWB5",143,0)
 ..K RSLT
"RTN","HMPWB5",144,0)
 ..S RSLT=$NA(^TMP(HMPTMP,$J))
"RTN","HMPWB5",145,0)
 .I ENC'>0 D MSG("Encounter was not created")
"RTN","HMPWB5",146,0)
 Q
"RTN","HMPWB5",147,0)
 ;
"RTN","HMPWB5",148,0)
MSG(M,Q,V) ;
"RTN","HMPWB5",149,0)
 ;Create a message (M) in JSON format with a qualifier (Q)
"RTN","HMPWB5",150,0)
 ; M - Message text
"RTN","HMPWB5",151,0)
 ; Q - Qualifier:
"RTN","HMPWB5",152,0)
 ;        1 - Required
"RTN","HMPWB5",153,0)
 ;        2 - Invalid
"RTN","HMPWB5",154,0)
 ; V - If Q=1, then V is ignored (or not passed in)
"RTN","HMPWB5",155,0)
 ;     If Q=2, then V=<the invalid value>
"RTN","HMPWB5",156,0)
 S M=$G(M),Q=$G(Q),V=$G(V)
"RTN","HMPWB5",157,0)
 D MSG^HMPTOOLS(M,Q,V)  ; Returns RSLT(1)
"RTN","HMPWB5",158,0)
 K ^TMP(HMPTMP,$J)
"RTN","HMPWB5",159,0)
 M ^TMP(HMPTMP,$J)=RSLT(1)
"RTN","HMPWB5",160,0)
 K RSLT
"RTN","HMPWB5",161,0)
 S RSLT=$NA(^TMP(HMPTMP,$J))
"RTN","HMPWB5",162,0)
 Q
"RTN","HMPWB5A")
0^48^B30522775
"RTN","HMPWB5A",1,0)
HMPWB5A ;JD/CNP - Write back entry points for Notes, and Encounters;Sep 2, 2015@08:44:47
"RTN","HMPWB5A",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPWB5A",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWB5A",4,0)
 ;Continued from HMPWB5.
"RTN","HMPWB5A",5,0)
 ;
"RTN","HMPWB5A",6,0)
 Q
"RTN","HMPWB5A",7,0)
 ;
"RTN","HMPWB5A",8,0)
PCELST(TYPE,INPUT,OUTPUT,ERR) ;
"RTN","HMPWB5A",9,0)
 ;TYPE   = Encounter Type (e.g. CPT)
"RTN","HMPWB5A",10,0)
 ;INPUT  = Input array containing data for TYPE (the content varies based on what TYPE is)
"RTN","HMPWB5A",11,0)
 ;OUTPUT = Output array
"RTN","HMPWB5A",12,0)
 N CNT,HMP1,HMP2,HMPC,HMPD,HMPE,HMPF,HMPN,HMPP,HMPR,HMPS,HMPT,I,J,K,L
"RTN","HMPWB5A",13,0)
 S CNT=6,HMP1=0
"RTN","HMPWB5A",14,0)
 F  S HMP1=$O(INPUT(HMP1)) Q:HMP1'=+HMP1!($G(ERR)]"")  D
"RTN","HMPWB5A",15,0)
 .S HMP2=INPUT(HMP1),CNT=CNT+1,ERR="",HMPT=""
"RTN","HMPWB5A",16,0)
 .I TYPE="CPT" D
"RTN","HMPWB5A",17,0)
 ..;HMP2=CPT code^Modifier1 code;Modifier2 code;...^Quantity^Provider name^Comment
"RTN","HMPWB5A",18,0)
 ..S HMPN=$$UP^XLFSTR($P(HMP2,U))
"RTN","HMPWB5A",19,0)
 ..S HMPD=$O(^ICPT("B",HMPN,""))
"RTN","HMPWB5A",20,0)
 ..I HMPD'=+HMPD S ERR="Invalid CPT code: "_$P(HMP2,U) Q
"RTN","HMPWB5A",21,0)
 ..S HMPP=$$UP^XLFSTR($P(HMP2,U,4))
"RTN","HMPWB5A",22,0)
 ..S HMPP=$O(^VA(200,"B",HMPP,""))
"RTN","HMPWB5A",23,0)
 ..I HMPP'=+HMPP S ERR="Invalid provider name: "_$P(HMP2,U,4) Q
"RTN","HMPWB5A",24,0)
 ..S HMPC=$P(HMP2,U,2),L=0
"RTN","HMPWB5A",25,0)
 ..F I=1:1:$L(HMPC,";") S J=$P(HMPC,";",I) I J]"" D  Q:$G(ERR)]""
"RTN","HMPWB5A",26,0)
 ...S K=$O(^DIC(81.3,"B",J,""))
"RTN","HMPWB5A",27,0)
 ...I K'=+K S ERR="Invalid CPT modifier code: "_J Q
"RTN","HMPWB5A",28,0)
 ...S L=L+1,HMPT=HMPT_";"_J_"/"_K
"RTN","HMPWB5A",29,0)
 ..I $G(ERR)]"" Q
"RTN","HMPWB5A",30,0)
 ..I $G(HMPT)]"" S HMPT=L_HMPT
"RTN","HMPWB5A",31,0)
 ..S HMPE=$P(HMP2,U,5),I=$P($G(^ICPT(HMPD,0)),U,2)
"RTN","HMPWB5A",32,0)
 ..S OUTPUT(CNT)="CPT+^"_HMPN_"^^"_I_U_$P(HMP2,U,3)_U_HMPP_"^^^"_HMPT_U_HMP1_U
"RTN","HMPWB5A",33,0)
 ..S CNT=CNT+1
"RTN","HMPWB5A",34,0)
 ..S OUTPUT(CNT)="COM^"_HMP1_U_$S(HMPE]"":HMPE,1:"@")
"RTN","HMPWB5A",35,0)
 .I TYPE="HF" D
"RTN","HMPWB5A",36,0)
 ..;HMP2=Health factor name^Level/severity code^Comment
"RTN","HMPWB5A",37,0)
 ..S HMPN=$$UP^XLFSTR($P(HMP2,U))
"RTN","HMPWB5A",38,0)
 ..S HMPD=$O(^AUTTHF("B",HMPN,""))
"RTN","HMPWB5A",39,0)
 ..I HMPD'=+HMPD S ERR="Invalid health factor name: "_$P(HMP2,U) Q
"RTN","HMPWB5A",40,0)
 ..S HMPR=$$UP^XLFSTR($P(HMP2,U,2))
"RTN","HMPWB5A",41,0)
 ..I (",H,M,MO,")'[(","_HMPR_",") S ERR="Invalid health factor level code: "_$P(HMP2,U,2) Q
"RTN","HMPWB5A",42,0)
 ..S HMPE=$P(HMP2,U,3)
"RTN","HMPWB5A",43,0)
 ..S OUTPUT(CNT)="HF+^"_HMPD_"^^"_HMPN_U_HMPR_"^^^^^"_HMP1
"RTN","HMPWB5A",44,0)
 ..S CNT=CNT+1
"RTN","HMPWB5A",45,0)
 ..S OUTPUT(CNT)="COM^"_HMP1_U_$S(HMPE]"":HMPE,1:"@")
"RTN","HMPWB5A",46,0)
 .I TYPE="PED" D
"RTN","HMPWB5A",47,0)
 ..;HMP2=Education name^Level of understanding code^Comment
"RTN","HMPWB5A",48,0)
 ..S HMPN=$$UP^XLFSTR($P(HMP2,U))
"RTN","HMPWB5A",49,0)
 ..S HMPD=$O(^AUTTEDT("B",HMPN,""))
"RTN","HMPWB5A",50,0)
 ..I HMPD'=+HMPD S ERR="Invalid education name: "_$P(HMP2,U) Q
"RTN","HMPWB5A",51,0)
 ..S HMPR=$P(HMP2,U,2)
"RTN","HMPWB5A",52,0)
 ..I (",1,2,3,4,5,")'[(","_HMPR_",") S ERR="Invalid education level code: "_$P(HMP2,U,2) Q
"RTN","HMPWB5A",53,0)
 ..S HMPE=$P(HMP2,U,3)
"RTN","HMPWB5A",54,0)
 ..S OUTPUT(CNT)="PED+^"_HMPD_"^^"_HMPN_U_HMPR_"^^^^^"_HMP1
"RTN","HMPWB5A",55,0)
 ..S CNT=CNT+1
"RTN","HMPWB5A",56,0)
 ..S OUTPUT(CNT)="COM^"_HMP1_U_$S(HMPE]"":HMPE,1:"@")
"RTN","HMPWB5A",57,0)
 .I TYPE="POV" D
"RTN","HMPWB5A",58,0)
 ..;HMP2=Diag. code^Search term^EXACT "problem list items" text^Add to problem list^Comment
"RTN","HMPWB5A",59,0)
 ..S HMPF=$S(HMP1=1:1,1:0)  ;Primary diagnosis flag
"RTN","HMPWB5A",60,0)
 ..S HMPE=$P(HMP2,U,5)      ;Comment
"RTN","HMPWB5A",61,0)
 ..S HMPC=$P(HMP2,U)
"RTN","HMPWB5A",62,0)
 ..S HMPD=$O(^ICD9("AB",HMPC_" ",""))
"RTN","HMPWB5A",63,0)
 ..I HMPD'=+HMPD S ERR="Invalid diagnosis code: "_HMPC
"RTN","HMPWB5A",64,0)
 ..I $P(HMP2,U,2)']"",$P(HMP2,U,3)']"" D  Q:$G(ERR)]""
"RTN","HMPWB5A",65,0)
 ...S ERR="For POV, either 'search term' or 'problem list items' needs to be present" Q
"RTN","HMPWB5A",66,0)
 ..S HMPD=$P(HMP2,U,2)
"RTN","HMPWB5A",67,0)
 ..I HMPD]"" D  Q:$G(ERR)]""   ;Search term
"RTN","HMPWB5A",68,0)
 ...K HMPP
"RTN","HMPWB5A",69,0)
 ...;Invoke the existing RPC: ORWLEX GETFREQ; to make sure we are not returning
"RTN","HMPWB5A",70,0)
 ...;too many search results.
"RTN","HMPWB5A",71,0)
 ...D GETFREQ^ORWLEX(.HMPP,HMPD)
"RTN","HMPWB5A",72,0)
 ...I HMPP>5000 S ERR="Your search '"_HMPD_"' matched "_HMPP_" records, that's too many!" Q
"RTN","HMPWB5A",73,0)
 ...I HMPP=0 S ERR="No matches found for your search term: "_HMPD Q
"RTN","HMPWB5A",74,0)
 ...;Invoke the existing RPC: ORWPCE4 LEX; to get more info
"RTN","HMPWB5A",75,0)
 ...D LEX^ORWPCE4(.HMPP,HMPD,"ICD",$$NOW^XLFDT,0,1)
"RTN","HMPWB5A",76,0)
 ...I +$G(HMPP(1))=-1 S ERR="No matches found for your search term: "_HMPD Q
"RTN","HMPWB5A",77,0)
 ...S HMPN=0,HMPR=""
"RTN","HMPWB5A",78,0)
 ...F  S HMPN=$O(HMPP(HMPN)) Q:HMPN'=+HMPN  D  Q:$G(HMPR)]""
"RTN","HMPWB5A",79,0)
 ....I $P(HMPP(HMPN),U,6)=HMPC S HMPR=1 Q  ; Found a matching diagnosis code
"RTN","HMPWB5A",80,0)
 ...I HMPR']"" S ERR="Diagnosis code "_HMPC_" doesn't match the search term: "_HMPD Q
"RTN","HMPWB5A",81,0)
 ...S HMPS=HMPP(HMPN),HMPS=$P(HMPS,U,2)_" ("_$P(HMPS,U,3)_" "_$P(HMPS,U,4)_")"
"RTN","HMPWB5A",82,0)
 ...S HMPT=$S($P(HMP2,U,4)=1:$P(OUTPUT(6),U,2),1:"")  ;Encounter provider IEN
"RTN","HMPWB5A",83,0)
 ...S OUTPUT(CNT)="POV+^"_HMPC_"^^"_HMPS_U_HMPF_U_HMPT_U_+$P(HMP2,U,4)_"^^^"_HMP1
"RTN","HMPWB5A",84,0)
 ...S CNT=CNT+1
"RTN","HMPWB5A",85,0)
 ...S OUTPUT(CNT)="COM^"_HMP1_U_$S(HMPE]"":HMPE,1:"@")
"RTN","HMPWB5A",86,0)
 ..I HMPD']"" S HMPD=$P(HMP2,U,3) D  Q:$G(ERR)]""   ;Problem list item
"RTN","HMPWB5A",87,0)
 ...S OUTPUT(CNT)="POV+^"_HMPC_"^Problem List Items^"_HMPD_U_HMPF_"^^0^^^"_HMP1
"RTN","HMPWB5A",88,0)
 ...S CNT=CNT+1
"RTN","HMPWB5A",89,0)
 ...S OUTPUT(CNT)="COM^"_HMP1_U_$S(HMPE]"":HMPE,1:"@")
"RTN","HMPWB5A",90,0)
 .I TYPE="SK" D  ;Skin Tests
"RTN","HMPWB5A",91,0)
 ..;HMP2=Skin test name^Result code^Reading^Comment
"RTN","HMPWB5A",92,0)
 ..S HMPN=$$UP^XLFSTR($P(HMP2,U))
"RTN","HMPWB5A",93,0)
 ..S HMPD=$O(^AUTTSK("B",HMPN,""))
"RTN","HMPWB5A",94,0)
 ..I HMPD'=+HMPD S ERR="Invalid skin test name: "_$P(HMP2,U) Q
"RTN","HMPWB5A",95,0)
 ..S HMPR=$$UP^XLFSTR($P(HMP2,U,2))
"RTN","HMPWB5A",96,0)
 ..I (",D,N,O,P,")'[(","_HMPR_",") S ERR="Invalid skin test result code: "_$P(HMP2,U,2) Q
"RTN","HMPWB5A",97,0)
 ..S HMPE=$P(HMP2,U,4)
"RTN","HMPWB5A",98,0)
 ..S OUTPUT(CNT)="SK+^"_HMPD_"^^"_HMPN_U_HMPR_"^^"_$P(HMP2,U,3)_"^^^"_HMP1
"RTN","HMPWB5A",99,0)
 ..S CNT=CNT+1
"RTN","HMPWB5A",100,0)
 ..S OUTPUT(CNT)="COM^"_HMP1_U_$S(HMPE]"":HMPE,1:"@")
"RTN","HMPWB5A",101,0)
 .I TYPE="XAM" D  ;Exams
"RTN","HMPWB5A",102,0)
 ..;HMP2=Exam name^Result code^Comment
"RTN","HMPWB5A",103,0)
 ..S HMPN=$$UP^XLFSTR($P(HMP2,U))
"RTN","HMPWB5A",104,0)
 ..S HMPD=$O(^AUTTEXAM("B",HMPN,""))
"RTN","HMPWB5A",105,0)
 ..I HMPD'=+HMPD S ERR="Invalid exam name: "_$P(HMP2,U) Q
"RTN","HMPWB5A",106,0)
 ..S HMPR=$$UP^XLFSTR($P(HMP2,U,2))
"RTN","HMPWB5A",107,0)
 ..I (",A,N,")'[(","_HMPR_",") S ERR="Invalid exam result code: "_$P(HMP2,U,2) Q
"RTN","HMPWB5A",108,0)
 ..S HMPE=$P(HMP2,U,3)
"RTN","HMPWB5A",109,0)
 ..S OUTPUT(CNT)="XAM+^"_HMPD_"^^"_HMPN_U_HMPR_"^^^^^"_HMP1
"RTN","HMPWB5A",110,0)
 ..S CNT=CNT+1
"RTN","HMPWB5A",111,0)
 ..S OUTPUT(CNT)="COM^"_HMP1_U_$S(HMPE]"":HMPE,1:"@")
"RTN","HMPWB5A",112,0)
 Q
"RTN","HMPWBIM1")
0^49^B55295368
"RTN","HMPWBIM1",1,0)
HMPWBIM1 ;;OB/JD/CNP - Write back entry points for IMMUNIZATIONS (related to Notes, and Encounters);Sep 2, 2015@08:31:16
"RTN","HMPWBIM1",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPWBIM1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWBIM1",4,0)
 ;
"RTN","HMPWBIM1",5,0)
 Q
"RTN","HMPWBIM1",6,0)
 ;
"RTN","HMPWBIM1",7,0)
IMMUN(RSLT,IEN,DFN,DATA)   ; Immunization
"RTN","HMPWBIM1",8,0)
 ;
"RTN","HMPWBIM1",9,0)
 ;RPC: HMP WRITEBACK IMMUNIZATION
"RTN","HMPWBIM1",10,0)
 ;Output
"RTN","HMPWBIM1",11,0)
 ; RSLT = JSON format string for Immunization
"RTN","HMPWBIM1",12,0)
 ;Input
"RTN","HMPWBIM1",13,0)
 ; IEN  = record to be updated
"RTN","HMPWBIM1",14,0)
 ; DFN  = patient IEN
"RTN","HMPWBIM1",15,0)
 ; DATA - input format - string
"RTN","HMPWBIM1",16,0)
 ;   Piece 1: DFN - Patient IEN
"RTN","HMPWBIM1",17,0)
 ;   Piece 2: Inpatient flag - 1 = inpatient, 0 = otherwise
"RTN","HMPWBIM1",18,0)
 ;   Piece 3: Hospital location IEN
"RTN","HMPWBIM1",19,0)
 ;   Piece 4: Visit/episode date
"RTN","HMPWBIM1",20,0)
 ;   Piece 5: Service category
"RTN","HMPWBIM1",21,0)
 ;   Piece 6: Author/dictator IEN (i.e. Provider)
"RTN","HMPWBIM1",22,0)
 ;   Piece 7: (IMM)unization/Encounter type - A 2- or 3-character string as follows:
"RTN","HMPWBIM1",23,0)
 ;               CPT for CPT (^AUPNVCPT; #9000010.18)
"RTN","HMPWBIM1",24,0)
 ;               HF      Health Factor (^AUPNVHF; #9000010.23)
"RTN","HMPWBIM1",25,0)
 ;               IMM     Immunization (^AUPNVIMM; #9000010.11)
"RTN","HMPWBIM1",26,0)
 ;               PED     Patient Education (^AUPNVPED; #9000010.16)
"RTN","HMPWBIM1",27,0)
 ;               POV     POV - Purpose of Visit; a.k.a Diagnosis - (^AUPNVPOV; #9000010.07)
"RTN","HMPWBIM1",28,0)
 ;               SK      Skin (^AUPNVSK; #9000010.12)
"RTN","HMPWBIM1",29,0)
 ;               XAM     Exam (^AUPNVXAM; #9000010.13)
"RTN","HMPWBIM1",30,0)
 ;   Piece 8: (IMM)unization/Encounter ID - As follows:
"RTN","HMPWBIM1",31,0)
 ;               CPT     ^ICPT
"RTN","HMPWBIM1",32,0)
 ;               HF      ^AUTTHF
"RTN","HMPWBIM1",33,0)
 ;               IMM     ^AUTTIMM
"RTN","HMPWBIM1",34,0)
 ;               PED     ^AUTTEDT
"RTN","HMPWBIM1",35,0)
 ;               POV     ^ICD9
"RTN","HMPWBIM1",36,0)
 ;               SK      ^AUTTSK
"RTN","HMPWBIM1",37,0)
 ;               XAM     ^AUTTEXAM
"RTN","HMPWBIM1",38,0)
 ;   Piece 9: Immunization /Encounter result CODE
"RTN","HMPWBIM1",39,0)
 ;  Piece 10: Immunization /Encounter comment number
"RTN","HMPWBIM1",40,0)
 ;  Piece 11: Immunization /Encounter comment text
"RTN","HMPWBIM1",41,0)
 ;  Piece 12: Reaction
"RTN","HMPWBIM1",42,0)
 ;  Piece 13: Repeat ContraIndicated
"RTN","HMPWBIM1",43,0)
 ;
"RTN","HMPWBIM1",44,0)
 N ERRMSG,JSONERR
"RTN","HMPWBIM1",45,0)
 I '$G(DFN) D MSG^HMPTOOLS("DFN",1) D ERR(.RSLT) Q  ; DFN is required
"RTN","HMPWBIM1",46,0)
 N ADMNDATE,ENC,ENCNM,ENCNUM,ENCTL,ENCTYP,ENCGLB,ERROR,GLB,HMP,HMPA,HMPFCNT,HMPE
"RTN","HMPWBIM1",47,0)
 N HMPUID,INFO,LOCALID,LOCALIEN,NOTE,NOTEIEN,OK,ORLOC,PCELIST,PRVNM,STMPTM
"RTN","HMPWBIM1",48,0)
 S INFO=$G(DATA)
"RTN","HMPWBIM1",49,0)
 ;
"RTN","HMPWBIM1",50,0)
 ;Check for required fields
"RTN","HMPWBIM1",51,0)
 ;
"RTN","HMPWBIM1",52,0)
 I '$P(INFO,U) D MSG^HMPTOOLS("DFN",1) D ERR(.RSLT) Q  ; DFN is required
"RTN","HMPWBIM1",53,0)
 I $D(^DPT($P(INFO,U)))'>0 D MSG^HMPTOOLS("DFN",2,$P(INFO,U)) D ERR(.RSLT) Q  ; Invalid DFN
"RTN","HMPWBIM1",54,0)
 I '$P(INFO,U,3) D MSG^HMPTOOLS("Location",1) D ERR(.RSLT) Q  ; Location is required
"RTN","HMPWBIM1",55,0)
 I '$P(INFO,U,4) D MSG^HMPTOOLS("Visit",1) D ERR(.RSLT) Q  ; Visit is required
"RTN","HMPWBIM1",56,0)
 I $L($P(INFO,U,5))=0 D MSG^HMPTOOLS("Service category",1) D ERR(.RSLT) Q  ; Service category is required
"RTN","HMPWBIM1",57,0)
 I $L($P(INFO,U,7))=0 D MSG^HMPTOOLS("Immunization Encounter type",1) D ERR(.RSLT) Q  ; Immunization /Encounter type is required
"RTN","HMPWBIM1",58,0)
 ;
"RTN","HMPWBIM1",59,0)
 S DFN=$P(INFO,U),OK="",NOTEIEN=0,ORLOC=$P(INFO,U,3)
"RTN","HMPWBIM1",60,0)
 S ENCTYP=$$UP^XLFSTR($P(INFO,U,7))
"RTN","HMPWBIM1",61,0)
 S ENCNUM=$P(INFO,U,8)  ; Immunization Code (Number)
"RTN","HMPWBIM1",62,0)
 S ENCGLB=$S(ENCTYP="CPT":"^ICPT",ENCTYP="POV":"^ICD9",1:"MORE")
"RTN","HMPWBIM1",63,0)
 I ENCGLB="MORE" S ENCGLB=$S(ENCTYP="PED":"^AUTTEDT",ENCTYP="XAM":"^AUTTEXAM",1:"MORE")
"RTN","HMPWBIM1",64,0)
 I ENCGLB="MORE" S ENCGLB="^AUTT"_ENCTYP
"RTN","HMPWBIM1",65,0)
 I $D(@ENCGLB)'>0 D MSG^HMPTOOLS("Immunization Encounter typ",2,ENCTYP) D ERR(.RSLT) Q  ; Invalid Immunization /encounter type
"RTN","HMPWBIM1",66,0)
 S ENCNM=$P($G(@ENCGLB@($P(INFO,U,8),0)),U)  ; Immunization /Encounter name
"RTN","HMPWBIM1",67,0)
 S PRVNM=$P($G(^VA(200,$P(INFO,U,6),0)),U)   ; Provider name
"RTN","HMPWBIM1",68,0)
 ;
"RTN","HMPWBIM1",69,0)
 ;Prepare the Immunization /encounter array for the RPC
"RTN","HMPWBIM1",70,0)
 ;
"RTN","HMPWBIM1",71,0)
 S PCELIST(1)="HDR^"_$P(INFO,U,2)_"^^"_$P(INFO,U,3)_";"_(+$P(INFO,U,4))_";"_$P(INFO,U,5)
"RTN","HMPWBIM1",72,0)
 S PCELIST(2)="VST^DT^"_(+$P(INFO,U,4))
"RTN","HMPWBIM1",73,0)
 S PCELIST(3)="VST^PT^"_$P(INFO,U)
"RTN","HMPWBIM1",74,0)
 S PCELIST(4)="VST^HL^"_$P(INFO,U,3)
"RTN","HMPWBIM1",75,0)
 S PCELIST(5)="VST^VC^"_$P(INFO,U,5)
"RTN","HMPWBIM1",76,0)
 S PCELIST(6)="PRV^"_$P(INFO,U,6)_"^^^"_PRVNM_"^1"
"RTN","HMPWBIM1",77,0)
 S PCELIST(7)=ENCTYP_"+^"_$P(INFO,U,8)_"^^"_ENCNM_U_$P(INFO,U,9)_U_$P(INFO,U,6)_U_$P(INFO,U,12)_U_$P(INFO,U,13)_"^0^"
"RTN","HMPWBIM1",78,0)
 S PCELIST(7)=PCELIST(7)_$P(INFO,U,10)
"RTN","HMPWBIM1",79,0)
 S PCELIST(8)="COM^"_$P(INFO,U,10)_U_$S($P(INFO,U,11)]"":$P(INFO,U,11),1:"@")
"RTN","HMPWBIM1",80,0)
 ;
"RTN","HMPWBIM1",81,0)
 ;Invoke the already existing RPC (ORWPCE1 DQSAVE)
"RTN","HMPWBIM1",82,0)
 ;
"RTN","HMPWBIM1",83,0)
 ; Wrap for ORWPCE1 DQSAVE
"RTN","HMPWBIM1",84,0)
 ; Description:  This RPC saves immunizations
"RTN","HMPWBIM1",85,0)
 ;
"RTN","HMPWBIM1",86,0)
 ; Input:   Parameters are as noted above for this routine, IMMUN^HMPWBIM1.
"RTN","HMPWBIM1",87,0)
 ;
"RTN","HMPWBIM1",88,0)
 ; Output:  Immunization parameters for the DQSAVE^ORWPCE1 Broker Call
"RTN","HMPWBIM1",89,0)
 ;
"RTN","HMPWBIM1",90,0)
 ;          DFN^IEN^HospitalLocation^VisitDate^Service category^Provider^ImmunizationType^IMM^ImmunizationResultCODE^ImmunizationCommentNumber^ImmunizationCommentText
"RTN","HMPWBIM1",91,0)
 ;          Note: IMM     Immunization (^AUPNVIMM; #9000010.11) and ^AUTTIMM
"RTN","HMPWBIM1",92,0)
 ;
"RTN","HMPWBIM1",93,0)
 ; Check for duplicates and send a JSON error message if a duplicate IMMUNIZATION is found
"RTN","HMPWBIM1",94,0)
 S ADMNDATE=+$P(INFO,U,4)
"RTN","HMPWBIM1",95,0)
 S ERROR=0
"RTN","HMPWBIM1",96,0)
 S LOCALID="" F  S LOCALID=$O(^AUPNVSIT("B",ADMNDATE,LOCALID)) Q:LOCALID=""  D
"RTN","HMPWBIM1",97,0)
 .S LOCALIEN="" F  S LOCALIEN=$O(^AUPNVIMM("AD",LOCALID,LOCALIEN)) Q:LOCALIEN=""  I $D(^AUPNVIMM(LOCALIEN,0)) I $P(^AUPNVIMM(LOCALIEN,0),"^")=ENCNUM I $P(^AUPNVIMM(LOCALIEN,0),"^",2)=DFN S ERROR=1
"RTN","HMPWBIM1",98,0)
 I ERROR D MSG^HMPTOOLS("Entry: Immunization already exist for the specified Date and Time for ",2,$P(INFO,U)) D ERR(.RSLT) Q  ;
"RTN","HMPWBIM1",99,0)
 ;
"RTN","HMPWBIM1",100,0)
 ; Save/Write IMMUNIZATION to VistA
"RTN","HMPWBIM1",101,0)
 D DQSAVE^ORWPCE1
"RTN","HMPWBIM1",102,0)
 ;
"RTN","HMPWBIM1",103,0)
 ; Match DFN with the VISIT
"RTN","HMPWBIM1",104,0)
 S (VISIT,LOCALID)="" F  S LOCALID=$O(^AUPNVSIT("B",ADMNDATE,LOCALID)) Q:LOCALID=""  D
"RTN","HMPWBIM1",105,0)
 .S VISIT=LOCALID S LOCALIEN="" F  S LOCALIEN=$O(^AUPNVIMM("AD",LOCALID,LOCALIEN)) Q:LOCALIEN=""  I $D(^AUPNVIMM(LOCALIEN,0)) I $P(^AUPNVIMM(LOCALIEN,0),"^")=ENCNUM Q:$P(^AUPNVIMM(LOCALIEN,0),"^",2)=DFN
"RTN","HMPWBIM1",106,0)
 I VISIT>0 D
"RTN","HMPWBIM1",107,0)
 .K FILTER
"RTN","HMPWBIM1",108,0)
 .S FILTER("noHead")=1
"RTN","HMPWBIM1",109,0)
 .S FILTER("patientId")=DFN
"RTN","HMPWBIM1",110,0)
 .S FILTER("domain")="visit"
"RTN","HMPWBIM1",111,0)
 .S FILTER("id")=VISIT
"RTN","HMPWBIM1",112,0)
 .D GET^HMPDJ(.HMP,.FILTER)   ; Return JSON visit Data
"RTN","HMPWBIM1",113,0)
 .S NOTE=$O(^TIU(8925,"V",VISIT,""))
"RTN","HMPWBIM1",114,0)
 .I NOTE>0 D
"RTN","HMPWBIM1",115,0)
 ..K FILTER
"RTN","HMPWBIM1",116,0)
 ..S FILTER("noHead")=1
"RTN","HMPWBIM1",117,0)
 ..S FILTER("patientId")=DFN
"RTN","HMPWBIM1",118,0)
 ..S FILTER("domain")="document"
"RTN","HMPWBIM1",119,0)
 ..S FILTER("id")=OK   ; Return JSON document Data
"RTN","HMPWBIM1",120,0)
 ..D GET^HMPDJ(.HMP,.FILTER)
"RTN","HMPWBIM1",121,0)
 .S GLB="^AUPNV"_ENCTYP
"RTN","HMPWBIM1",122,0)
 .S ENC=LOCALIEN  ;S ENC=$O(@GLB@("AD",VISIT,""))  ; replaced the code with LOCALIEN variable
"RTN","HMPWBIM1",123,0)
 .I ENC>0 D   ; Get the full domain name so it matches the tags in HMPDJ0
"RTN","HMPWBIM1",124,0)
 ..S ENCTL=$S(ENCTYP="CPT":"cpt",ENCTYP="HF":"factor",ENCTYP="IMM":"immuniza",1:"MORE")
"RTN","HMPWBIM1",125,0)
 ..I ENCTL="MORE" S ENCTL=$S(ENCTYP="PED":"educatio",ENCTYP="POV":"pov",1:"MORE")
"RTN","HMPWBIM1",126,0)
 ..I ENCTL="MORE" S ENCTL=$S(ENCTYP="SK":"skin",ENCTYP="XAM":"exam",1:"")
"RTN","HMPWBIM1",127,0)
 ..K FILTER
"RTN","HMPWBIM1",128,0)
 ..S FILTER("noHead")=1
"RTN","HMPWBIM1",129,0)
 ..S FILTER("patientId")=DFN
"RTN","HMPWBIM1",130,0)
 ..S FILTER("domain")=ENCTL
"RTN","HMPWBIM1",131,0)
 ..S FILTER("id")=ENC
"RTN","HMPWBIM1",132,0)
 ..D GET^HMPDJ(.HMP,.FILTER)   ; Return JSON Immunization Data
"RTN","HMPWBIM1",133,0)
 ..;; renmove this ;; line
"RTN","HMPWBIM1",134,0)
 ..S HMPFCNT=0
"RTN","HMPWBIM1",135,0)
 ..S HMPUID=$$SETUID^HMPUTILS(ENCTL,DFN,ENC)   ; Build Metastamp and Syncstatus
"RTN","HMPWBIM1",136,0)
 ..S HMPE=$G(^TMP("HMP",$J,1,1))
"RTN","HMPWBIM1",137,0)
 ..S STMPTM=$TR($P($P(HMPE,"stampTime",2),","),""":")
"RTN","HMPWBIM1",138,0)
 ..D ADHOC^HMPUTIL2(ENCTL,HMPFCNT,DFN,HMPUID,STMPTM)   ; Removed METASTAMP and SYNCSTART /SYNCSTOP
"RTN","HMPWBIM1",139,0)
 ..S RSLT=$$EXTRACT(HMP)
"RTN","HMPWBIM1",140,0)
 ..K ^TMP("HMPIMM",$J)
"RTN","HMPWBIM1",141,0)
 ..M ^TMP("HMPIMM",$J)=RSLT
"RTN","HMPWBIM1",142,0)
 ..;M ^TMP("HMPIMM",$J)=^TMP("HMP",$J)
"RTN","HMPWBIM1",143,0)
 ..K ^TMP("HMPIMM",$J,"total")   ;Stored JSON in HMP WRTIEBACK IMMUNIZATION temporary global for the job/user
"RTN","HMPWBIM1",144,0)
 ..K RSLT
"RTN","HMPWBIM1",145,0)
 ..S RSLT=$NA(^TMP("HMPIMM",$J))   ;Stored location of top level of HMP WRITEBACK JSON in Result variable
"RTN","HMPWBIM1",146,0)
 Q
"RTN","HMPWBIM1",147,0)
 ;
"RTN","HMPWBIM1",148,0)
EXTRACT(GLOB) ; Move ^TMP("HMP",$J) into string format
"RTN","HMPWBIM1",149,0)
 N HMPSTOP,HMPFND,NULLCHK
"RTN","HMPWBIM1",150,0)
 S RSLT="",X=0,HMPSTOP=0,HMPFND=0
"RTN","HMPWBIM1",151,0)
 S (I,J)=0
"RTN","HMPWBIM1",152,0)
 F  S I=$O(^TMP("HMPF",$J,I)) Q:I=""!(HMPSTOP)  D
"RTN","HMPWBIM1",153,0)
 . F  S J=$O(^TMP("HMPF",$J,I,J)) Q:J=""  D
"RTN","HMPWBIM1",154,0)
 .. I $G(^TMP("HMPF",$J,I,J))["syncStatus" D
"RTN","HMPWBIM1",155,0)
 ... Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWBIM1",156,0)
 ... S RSLT(X)=RSLT(X)_$P(^TMP("HMPF",$J,I,J),",",1)
"RTN","HMPWBIM1",157,0)
 ... S HMPSTOP=1
"RTN","HMPWBIM1",158,0)
 ... Q
"RTN","HMPWBIM1",159,0)
 .. Q:$D(^TMP("HMPF",$J))=""
"RTN","HMPWBIM1",160,0)
 .. Q:$G(^TMP("HMPF",$J,I,J))=""
"RTN","HMPWBIM1",161,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),",",1)'["immuniza"
"RTN","HMPWBIM1",162,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),",",4)'["localId"
"RTN","HMPWBIM1",163,0)
 .. Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWBIM1",164,0)
 .. S X=X+1
"RTN","HMPWBIM1",165,0)
 .. S RSLT(X)=$G(^TMP("HMPF",$J,I,J))
"RTN","HMPWBIM1",166,0)
 .. F  S J=$O(^TMP("HMPF",$J,I,J)) Q:J=""  D
"RTN","HMPWBIM1",167,0)
 ... Q:$P(^TMP("HMPF",$J,I,J),":",1)["domainTotals"
"RTN","HMPWBIM1",168,0)
 ... S X=X+1
"RTN","HMPWBIM1",169,0)
 ... S RSLT(X)=$G(^TMP("HMPF",$J,I,J))
"RTN","HMPWBIM1",170,0)
 ... S HMPFND=1
"RTN","HMPWBIM1",171,0)
 ... Q
"RTN","HMPWBIM1",172,0)
 .. S I=$O(^TMP("HMPF",$J,I))
"RTN","HMPWBIM1",173,0)
 .. Q
"RTN","HMPWBIM1",174,0)
 . Q
"RTN","HMPWBIM1",175,0)
 Q RSLT
"RTN","HMPWBIM1",176,0)
ERR(RSLT) ; Display Error
"RTN","HMPWBIM1",177,0)
 K ^TMP("HMPIMM",$J)
"RTN","HMPWBIM1",178,0)
 M ^TMP("HMPIMM",$J)=RSLT
"RTN","HMPWBIM1",179,0)
 K ^TMP("HMPIMM",$J,"total")   ;Stored JSON in HMP WRTIEBACK IMMUNIZATION temporary global for the job/user
"RTN","HMPWBIM1",180,0)
 K RSLT
"RTN","HMPWBIM1",181,0)
 S RSLT=$NA(^TMP("HMPIMM",$J))   ;Stored location of top level of HMP WRITEBACK JSON in Result variable
"RTN","HMPWBIM1",182,0)
 Q
"RTN","HMPWBIM1",183,0)
 ;
"RTN","HMPWBM1")
0^50^B2139238
"RTN","HMPWBM1",1,0)
HMPWBM1 ;ASMR/RRB - Medication Order Writeback ;Jul 02, 2015@10:22:02
"RTN","HMPWBM1",2,0)
 ;;2.0;HEALTH MANAGEMENT PLATFORM;**2**;Oct 10, 2014;Build 24
"RTN","HMPWBM1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWBM1",4,0)
 ;
"RTN","HMPWBM1",5,0)
ORCHECK(HMPOUT,DFN,FID,STRT,ORL,OIL,ORIFN,ORREN) ; Wraps for order checking
"RTN","HMPWBM1",6,0)
 ;             
"RTN","HMPWBM1",7,0)
 ; Input Parameters:
"RTN","HMPWBM1",8,0)
 ;      DFN(R):  Patient IEN
"RTN","HMPWBM1",9,0)
 ;      FID: FILLER ID.  Acquired by passing the selected orderDialogIen from the
"RTN","HMPWBM1",10,0)
 ;           ORWDX WRLST RPC output to the ORWDXC FILLID.
"RTN","HMPWBM1",11,0)
 ;      STRT: Desired Date in Mmm DD,YYYY@HH:SS format
"RTN","HMPWBM1",12,0)
 ;      ORL: Ordering Location (locationIen from the Visit)
"RTN","HMPWBM1",13,0)
 ;      OIL:  An ordered list (array) of orderable Items for Radiology, 
"RTN","HMPWBM1",14,0)
 ;            or orderable items + package info for pharmacy (npatient, outpatient,
"RTN","HMPWBM1",15,0)
 ;            and infusion) and lab as appropriate.
"RTN","HMPWBM1",16,0)
 ;      ORIFN:  orderIen  (This is only available for existing orders that are being copied, changed, or renewed.  New orders do not have an orderIen until they are saved.)
"RTN","HMPWBM1",17,0)
 ;      ORREN: Renewed?  1 = Yes, 0 = No.  Note:  The ORIFN is required if ORREN = 1
"RTN","HMPWBM1",18,0)
 ;
"RTN","HMPWBM1",19,0)
 ;Associated ICRs:
"RTN","HMPWBM1",20,0)
 ;
"RTN","HMPWBM1",21,0)
 ; Wrap for ORWDXC ACCEPT
"RTN","HMPWBM1",22,0)
 ;      Description:  This RPC returns a list of Order Checks on Accept Order.
"RTN","HMPWBM1",23,0)
 ;
"RTN","HMPWBM1",24,0)
 ; Input:  See input parameters for ORCHECK entry point above.
"RTN","HMPWBM1",25,0)
 ;
"RTN","HMPWBM1",26,0)
 ; Output:  Order Checks
"RTN","HMPWBM1",27,0)
 ;          orderIen^orderCheckIen^CDL^message
"RTN","HMPWBM1",28,0)
 ;          orderIen = NEW for new orders.
"RTN","HMPWBM1",29,0)
 ;          CDL = Clinic Danger Level.  If CDL = 1, an override comment will be
"RTN","HMPWBM1",30,0)
 ;                required during processing order checks during the signing process.
"RTN","HMPWBM1",31,0)
 ;
"RTN","HMPWBM1",32,0)
 K ^TMP($T(+0),$J)
"RTN","HMPWBM1",33,0)
 S HMPOUT=$NA(^TMP($T(+0),$J))
"RTN","HMPWBM1",34,0)
 N CNT,OUT,XOUT,XTRA,XTRA1,XTRA2
"RTN","HMPWBM1",35,0)
 ;
"RTN","HMPWBM1",36,0)
 D ACCEPT^ORWDXC(.OUT,.DFN,FID,STRT,ORL,.OIL,ORIFN,ORREN)
"RTN","HMPWBM1",37,0)
 I $G(OUT(1))'="" S OUT(0)="ORCHECK"
"RTN","HMPWBM1",38,0)
 D GETXTRA(.OUT)
"RTN","HMPWBM1",39,0)
 D GETMONO
"RTN","HMPWBM1",40,0)
 ;
"RTN","HMPWBM1",41,0)
 Q
"RTN","HMPWBM1",42,0)
 ;
"RTN","HMPWBM1",43,0)
SESSION ; This is a place holder for future development of session order checks
"RTN","HMPWBM1",44,0)
 ;
"RTN","HMPWBM1",45,0)
 ; I $G(OUT(1))'="" S OUT(0)="SESSION"
"RTN","HMPWBM1",46,0)
 ; D GETXTRA(.OUT)
"RTN","HMPWBM1",47,0)
 ; D GETMONO
"RTN","HMPWBM1",48,0)
 ;
"RTN","HMPWBM1",49,0)
 Q
"RTN","HMPWBM1",50,0)
 ;
"RTN","HMPWBM1",51,0)
GETXTRA(OUT) ; Get extra lines for each order check as required and combine for a single output
"RTN","HMPWBM1",52,0)
 ;
"RTN","HMPWBM1",53,0)
 N CNT
"RTN","HMPWBM1",54,0)
 ; Check each order check for extra lines, and retreive them
"RTN","HMPWBM1",55,0)
 ; using the ORCHECK GETXTRA broker call
"RTN","HMPWBM1",56,0)
 ;
"RTN","HMPWBM1",57,0)
 ; Input Parameters: 
"RTN","HMPWBM1",58,0)
 ;   The inputs for this RPC come from the ORWDXC ACCEPT RPC order check output
"RTN","HMPWBM1",59,0)
 ;   Example:  NEW^25^2^||63679,54957,NEW&These checks could not be completed for this patient:
"RTN","HMPWBM1",60,0)
 ;   Note:  An order check that is returned with the double pipe (||) as noted above is the
"RTN","HMPWBM1",61,0)
 ;   indication that this RPC needs to be run.  Inputs for the RPC are parsed by the ?&?. 
"RTN","HMPWBM1",62,0)
 ;       XTRA1: piece 1
"RTN","HMPWBM1",63,0)
 ;       XTRA2: piece 2
"RTN","HMPWBM1",64,0)
 ;
"RTN","HMPWBM1",65,0)
 ; Output Parameters:  Additional lines of order check text
"RTN","HMPWBM1",66,0)
 ;
"RTN","HMPWBM1",67,0)
 S CNT=""
"RTN","HMPWBM1",68,0)
 F  S CNT=$O(OUT(CNT)) Q:CNT=""  D
"RTN","HMPWBM1",69,0)
 . S XTRA=$P(OUT(CNT),"||",2)
"RTN","HMPWBM1",70,0)
 . I XTRA'="" D
"RTN","HMPWBM1",71,0)
 . . S XTRA1=$P(XTRA,"&",1),XTRA2=$P(XTRA,"&",2)
"RTN","HMPWBM1",72,0)
 . . D GETXTRA^ORCHECK(.XOUT,XTRA1,XTRA2)
"RTN","HMPWBM1",73,0)
 . . M OUT(CNT)=XOUT
"RTN","HMPWBM1",74,0)
 M @HMPOUT@("ORCHK")=OUT
"RTN","HMPWBM1",75,0)
 ;
"RTN","HMPWBM1",76,0)
 Q
"RTN","HMPWBM1",77,0)
 ;
"RTN","HMPWBM1",78,0)
GETMONO ; Get and consolidate monograph data
"RTN","HMPWBM1",79,0)
 ;
"RTN","HMPWBM1",80,0)
 ; This is a place holder for a future story after MOCHA is available for remote checking
"RTN","HMPWBM1",81,0)
 ;
"RTN","HMPWBM1",82,0)
 Q
"RTN","HMPWBM2")
0^51^B8891114
"RTN","HMPWBM2",1,0)
HMPWBM2 ;ASMR/RRB - Medication Order Writeback ;Jul 02, 2015@10:19:41
"RTN","HMPWBM2",2,0)
 ;;2.0;HEALTH MANAGEMENT PLATFORM;**2**;Oct 10, 2014;Build 24
"RTN","HMPWBM2",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWBM2",4,0)
 ;
"RTN","HMPWBM2",5,0)
ORSAVE(HMPOUT,DFN,DUZ,LOCIEN,DLG,ORDG,ORIT,ORIFN,ORDIALOG,ORDEA,ORAPPT,ORSRC,OREVTDF) ; Calls for saving order
"RTN","HMPWBM2",6,0)
 ; Input Parameters:
"RTN","HMPWBM2",7,0)
 ;     DFN:  Patient DFN acquired when the patient is selected and placed in context.
"RTN","HMPWBM2",8,0)
 ;     DUZ:  Provider IEN acquired during login
"RTN","HMPWBM2",9,0)
 ;     LOCIEN: Ordering Location (locationIen from the Visit)
"RTN","HMPWBM2",10,0)
 ;     DLG: (internalDialogName) Acquired from the ORWDXM DLGNAME RPC
"RTN","HMPWBM2",11,0)
 ;     ORDG:(displayGroupPointer) From the ORWDX WRLST RPC
"RTN","HMPWBM2",12,0)
 ;     ORIT: (orderDialogIen) Acquired from the ORWDX WRLST RPC
"RTN","HMPWBM2",13,0)
 ;     ORIFN: (orderIen) This is only available for existing orders that are being 
"RTN","HMPWBM2",14,0)
 ;             changed or renewed.  New orders do not have an orderIen until they are saved.)
"RTN","HMPWBM2",15,0)
 ;     ORDIALOG: (orderDialogArray) An ordered array consisting of the following....
"RTN","HMPWBM2",16,0)
 ;         A map of the input screen to the dialog question subscripts returned from the
"RTN","HMPWBM2",17,0)
 ;         ORWDX DLGDEF RPC.
"RTN","HMPWBM2",18,0)
 ;         Order checks from the ORWDXC ACCEPT RPC.  These included as:
"RTN","HMPWBM2",19,0)
 ;         ("ORCHECK") = number of order checks
"RTN","HMPWBM2",20,0)
 ;         ("ORCHECK",Piece 1, Piece 3,increment)=Piece 2 through Piece 4 of the order 
"RTN","HMPWBM2",21,0)
 ;                    checks delimited by "^".
"RTN","HMPWBM2",22,0)
 ;         ("ORTS") = treating specialty.  Will be set to 0 (zero) if not available. 
"RTN","HMPWBM2",23,0)
 ;                    (Only applies to inpatient locations.)
"RTN","HMPWBM2",24,0)
 ;     ORDEA: digital signature
"RTN","HMPWBM2",25,0)
 ;     ORAPPT:  date.time stamp of visit in VA format
"RTN","HMPWBM2",26,0)
 ;     ORSRC:  order source
"RTN","HMPWBM2",27,0)
 ;     OREVTDF: (eventDefault) only used for delayed orders
"RTN","HMPWBM2",28,0)
 ;
"RTN","HMPWBM2",29,0)
 ;Associated ICRs:
"RTN","HMPWBM2",30,0)
 ;  ICR#
"RTN","HMPWBM2",31,0)
 ;      3371:  ORWU HASKEY
"RTN","HMPWBM2",32,0)
 ;
"RTN","HMPWBM2",33,0)
 N HMFLTR,JOUT,ORDIEN,OUT
"RTN","HMPWBM2",34,0)
 ;
"RTN","HMPWBM2",35,0)
 D LOCK^ORWDX(.OUT,DFN)  ; Lock patient record
"RTN","HMPWBM2",36,0)
 I OUT'=1 D  G ENDSAVE
"RTN","HMPWBM2",37,0)
 . S HMPOUT="ERROR^Patient record locked by another user."
"RTN","HMPWBM2",38,0)
 ;
"RTN","HMPWBM2",39,0)
 ; Wrap for ORWDX SAVE
"RTN","HMPWBM2",40,0)
 ;      Description:  This RPC saves an order
"RTN","HMPWBM2",41,0)
 ;
"RTN","HMPWBM2",42,0)
 ; Input:  Parameters are as noted above for this routine, ORSAVE^HMPWBM2.
"RTN","HMPWBM2",43,0)
 ;
"RTN","HMPWBM2",44,0)
 ; Output:  Order parameters for the SAVE^ORWDX Broker Call
"RTN","HMPWBM2",45,0)
 ;
"RTN","HMPWBM2",46,0)
 ;          ~orderIen^Grp^OrdTm^StrtTm^StopTm^Sts^Sig^Nrs^Clk^PrvID^PrvNam^Act^Flagged[^DCType]^ChartRev^DEA#^^DigSig^LOC^[DCORIGNAL]^IsPendingDCorder^IsDelayOrder
"RTN","HMPWBM2",47,0)
 ;          There may be multiple lines of text entry.  All will begin with a lower case "t".
"RTN","HMPWBM2",48,0)
 ;               tline 1
"RTN","HMPWBM2",49,0)
 ;               tline 2 
"RTN","HMPWBM2",50,0)
 ;               tline 3 And so forth
"RTN","HMPWBM2",51,0)
 ;
"RTN","HMPWBM2",52,0)
 D SAVE^ORWDX(.OUT,DFN,.DUZ,LOCIEN,DLG,ORDG,ORIT,ORIFN,.ORDIALOG,ORDEA,ORAPPT,ORSRC,OREVTDF)
"RTN","HMPWBM2",53,0)
 ;
"RTN","HMPWBM2",54,0)
 S ORDIEN=+($P($E(OUT(1),2,999),"^",1))  ; Extract the orderIen from the broker output
"RTN","HMPWBM2",55,0)
 ;
"RTN","HMPWBM2",56,0)
 ; Setup and call utility to return JSON order data
"RTN","HMPWBM2",57,0)
 ;
"RTN","HMPWBM2",58,0)
 S HMFLTR("domain")="order",HMFLTR("noHead")=1,HMFLTR("patientId")=DFN,HMFLTR("id")=ORDIEN
"RTN","HMPWBM2",59,0)
 ;
"RTN","HMPWBM2",60,0)
 D GET^HMPDJ(.JOUT,.HMFLTR)
"RTN","HMPWBM2",61,0)
 ;
"RTN","HMPWBM2",62,0)
 ; Return JSON order data
"RTN","HMPWBM2",63,0)
 ;
"RTN","HMPWBM2",64,0)
 ;
"RTN","HMPWBM2",65,0)
 N CNT,HMPDMN,HMPFCNT,I,II,JNAME,JSTRNG,JVALPR,JVALUE,STMPTM,UID,WRPOUT
"RTN","HMPWBM2",66,0)
 ;
"RTN","HMPWBM2",67,0)
 M WRPOUT=@JOUT
"RTN","HMPWBM2",68,0)
 ;
"RTN","HMPWBM2",69,0)
 ; Setup HMPDMN, HMPFCNT, STMPTM, and UID variables necessary for calling ADHOC^HMPUTIL2
"RTN","HMPWBM2",70,0)
 ;
"RTN","HMPWBM2",71,0)
 S HMPDMN="order",HMPFCNT=WRPOUT("total")
"RTN","HMPWBM2",72,0)
 ;
"RTN","HMPWBM2",73,0)
 ; Acquire stampTime and uid JSON name value pairs
"RTN","HMPWBM2",74,0)
 ;
"RTN","HMPWBM2",75,0)
 S I=""
"RTN","HMPWBM2",76,0)
 F  S I=$O(WRPOUT(I)) Q:I=""!(I'?1.N)  D
"RTN","HMPWBM2",77,0)
 . S II=""
"RTN","HMPWBM2",78,0)
 . F  S II=$O(WRPOUT(I,II)) Q:II=""  D
"RTN","HMPWBM2",79,0)
 . . S JSTRNG=$TR($G(WRPOUT(I,II)),$CHAR(34),"")
"RTN","HMPWBM2",80,0)
 . . F CNT=1:1:$L(JSTRNG,",") D
"RTN","HMPWBM2",81,0)
 . . . S JVALPR=$P(JSTRNG,",",CNT)
"RTN","HMPWBM2",82,0)
 . . . S JNAME=$TR($P(JVALPR,":"),"{",""),JVALUE=$TR($E($P(JVALPR,JNAME,2),2,999),"}","")
"RTN","HMPWBM2",83,0)
 . . . I JNAME="stampTime"!(JNAME="uid") D
"RTN","HMPWBM2",84,0)
 . . . . S JNAME=$S(JNAME="stampTime":"STMPTM",JNAME="uid":"UID",1:"")
"RTN","HMPWBM2",85,0)
 . . . . S @JNAME=JVALUE  ; Create the variable names STMPTM and UID, and set their respective values
"RTN","HMPWBM2",86,0)
 ;
"RTN","HMPWBM2",87,0)
 ; Call ADHOC^HMPUTIL2 to wrap JSON order data with metastamp
"RTN","HMPWBM2",88,0)
 ;
"RTN","HMPWBM2",89,0)
 D ADHOC^HMPUTIL2(HMPDMN,HMPFCNT,DFN,UID,STMPTM)
"RTN","HMPWBM2",90,0)
 ;
"RTN","HMPWBM2",91,0)
 ; Return complete JSON order package
"RTN","HMPWBM2",92,0)
 ;
"RTN","HMPWBM2",93,0)
 M HMPOUT=^TMP("HMPF",$J)
"RTN","HMPWBM2",94,0)
 ;
"RTN","HMPWBM2",95,0)
 D UNLOCK^ORWDX(.OUT,DFN)  ; Unlock patient record
"RTN","HMPWBM2",96,0)
 ; "Unlocking the patient record is silent and will always be 1"
"RTN","HMPWBM2",97,0)
 ;
"RTN","HMPWBM2",98,0)
ENDSAVE ;
"RTN","HMPWBM2",99,0)
 ;
"RTN","HMPWBM2",100,0)
 Q
"RTN","HMPWBM2",101,0)
 ;
"RTN","HMPWBPL")
0^52^B2694501
"RTN","HMPWBPL",1,0)
HMPWBPL ;;EJK/AGX - ENTRY POINT FOR ALL PROBLEM WRITEBACK ACTIVITY; 3/11/2016
"RTN","HMPWBPL",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;DEC 11 2014;Build 24
"RTN","HMPWBPL",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWBPL",4,0)
 ; INPUT PARAMETERS
"RTN","HMPWBPL",5,0)
 ;   DFN - Patient Identifier. 
"RTN","HMPWBPL",6,0)
 ;   PRV - IEN of provider updating the comment/note for this problem
"RTN","HMPWBPL",7,0)
 ;   VAMC - IEN of location from ^AUTTLOC (file 9999999.06)
"RTN","HMPWBPL",8,0)
 ;   GMPFLD(list) - array of related data
"RTN","HMPWBPL",9,0)
 ;      .01     ;DIAGNOSIS - ICD DIAGNOSIS FILE (FILE 
"RTN","HMPWBPL",10,0)
 ;      .03     ;DATE LAST MODIFIED - DEFAULTS TO CURRENT DATE, FILEMAN DATE FORMAT
"RTN","HMPWBPL",11,0)
 ;      .05     ;PROVIDER NARRATIVE - PROVIDER NARRATIVE FILE, FREE TEXT
"RTN","HMPWBPL",12,0)
 ;      .08     ;DATE ENTERED - FILEMAN DATE FORMAT
"RTN","HMPWBPL",13,0)
 ;      .12     ;STATUS - VALUES ARE (A)CTIVE OR (I)NACTIVE
"RTN","HMPWBPL",14,0)
 ;      .13     ;DATE OF ONSET - FILEMAN DATE FORMAT
"RTN","HMPWBPL",15,0)
 ;      1.01    ;PROBLEM - EXPRESSIONS FILE - Search text from file 9999999.27
"RTN","HMPWBPL",16,0)
 ;      1.02    ;CONDITION - VALUES ARE (T)RANSCRIBED, (P)ERMANENT OR (H)IDDEN
"RTN","HMPWBPL",17,0)
 ;      1.03    ;ENTERED BY - DUZ OF THE PERSON ENTERING THE PROBLEM (NEW PERSON FILE)
"RTN","HMPWBPL",18,0)
 ;      1.04    ;RECORDING PROVIDER - IEN FROM NEW PERSON FILE
"RTN","HMPWBPL",19,0)
 ;      1.05    ;RESPONSIBLE PROVIDER - IEN FROM NEW PERSON FILE
"RTN","HMPWBPL",20,0)
 ;      1.06    ;SERVICE - IEN to SERVICE/SECTION FILE (#49)
"RTN","HMPWBPL",21,0)
 ;      1.07    ;DATE RESOLVED - FILEMAN DATE FORMAT
"RTN","HMPWBPL",22,0)
 ;      1.08    ;IEN TO HOSPITAL LOCATION (FILE 44)
"RTN","HMPWBPL",23,0)
 ;      1.09    ;DATE RECORDED - FILEMAN DATE FORMAT
"RTN","HMPWBPL",24,0)
 ;      1.1     ;SERVICE CONNECTED - 1 FOR YES, 0 FOR NO
"RTN","HMPWBPL",25,0)
 ;      1.11    ;AGENT ORANGE EXPOSURE - 1 FOR YES, 0 FOR NO
"RTN","HMPWBPL",26,0)
 ;      1.12    ;IONIZING RADIATION EXPOSURE - 1 FOR YES, 0 FOR NO
"RTN","HMPWBPL",27,0)
 ;      1.13    ;PERSIAN GULF EXPOSURE  - 1 FOR YES, 0 FOR NO
"RTN","HMPWBPL",28,0)
 ;      1.14    ;PRIORITY - (A)CUTE OR (C)HRONIC
"RTN","HMPWBPL",29,0)
 ;      1.15    ;HEAD AND/OR NECK CANCER - 1 FOR YES, 0 FOR NO
"RTN","HMPWBPL",30,0)
 ;      1.16    ;MILITARY SEXUAL TRAUMA - 1 FOR YES, 0 FOR NO
"RTN","HMPWBPL",31,0)
 ;      1.17    ;COMBAT VETERAN - 1 FOR YES, 0 FOR NO
"RTN","HMPWBPL",32,0)
 ;      1.18    ;SHIPBOARD HAZARD & DEFENSE - 1 FOR YES, 0 FOR NO
"RTN","HMPWBPL",33,0)
 ;      (10,"NEW",1) ;FREE TEXT 60 CHARACTER LIMIT - 1 INDICATES THE NOTE NUMBER
"RTN","HMPWBPL",34,0)
 ;      10,0)   ;WHICH NOTE IS BEING ADDED OR CHANGED
"RTN","HMPWBPL",35,0)
 ;
"RTN","HMPWBPL",36,0)
 Q
"RTN","HMPWBPL",37,0)
 ;
"RTN","HMPWBPL",38,0)
PL(RSLT,DFN,PRV,VAMC,GMPFLD) ; MAIN ENTRY POINT FROM RPC HMP WRITEBACK PROBLEM
"RTN","HMPWBPL",39,0)
 N GMPDFN,GMPVAMC
"RTN","HMPWBPL",40,0)
 S GMPDFN=$G(DFN)
"RTN","HMPWBPL",41,0)
 ;if VAMC is not sent, get the default VAMC site id
"RTN","HMPWBPL",42,0)
 S GMPVAMC=$S($G(VAMC)'="":VAMC,1:+$$SITE^VASITE())
"RTN","HMPWBPL",43,0)
 S RETURN=0
"RTN","HMPWBPL",44,0)
 ;
"RTN","HMPWBPL",45,0)
 ;Lock the problem file. This is a carryover from the GMPLSAVE routine.
"RTN","HMPWBPL",46,0)
 ;For new entries, an IEN to the problem file is not yet assigned so the 
"RTN","HMPWBPL",47,0)
 ;entire file is locked to avoid a collission. 
"RTN","HMPWBPL",48,0)
 ;
"RTN","HMPWBPL",49,0)
 L +^AUPNPROB(0):10 I '$T D MSG^HMPTOOLS("Unable to lock problem file",1) Q
"RTN","HMPWBPL",50,0)
 ;
"RTN","HMPWBPL",51,0)
 ;save patient problem
"RTN","HMPWBPL",52,0)
 D NEW^GMPLSAVE
"RTN","HMPWBPL",53,0)
 ;if record field, DA will be populated. 
"RTN","HMPWBPL",54,0)
 I $G(DA)'>0 D MSG^HMPTOOLS("Problem was not successfully filed",1) Q
"RTN","HMPWBPL",55,0)
 L -^AUPNPROB(0)
"RTN","HMPWBPL",56,0)
 ;set filters for building the JSON result
"RTN","HMPWBPL",57,0)
 S FILTER("id")=DA
"RTN","HMPWBPL",58,0)
 S FILTER("noHead")=1
"RTN","HMPWBPL",59,0)
 S FILTER("domain")="problem"
"RTN","HMPWBPL",60,0)
 S FILTER("patientId")=GMPDFN
"RTN","HMPWBPL",61,0)
 ;create the JSON response
"RTN","HMPWBPL",62,0)
 D GET^HMPDJ(.RSLT,.FILTER)
"RTN","HMPWBPL",63,0)
 ;do not need the 'total' node
"RTN","HMPWBPL",64,0)
 K ^TMP("HMP",$J,"total")
"RTN","HMPWBPL",65,0)
 ;return everything else.
"RTN","HMPWBPL",66,0)
 S RSLT=$NA(^TMP("HMP",$J))
"RTN","HMPWBPL",67,0)
 Q
"RTN","HMPWBSO")
0^53^B3162958
"RTN","HMPWBSO",1,0)
HMPWBSO ; CNP/JD,MBS - Sign orders RPCs ;08/27/15 12:05
"RTN","HMPWBSO",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;August 27, 2015;Build 24
"RTN","HMPWBSO",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPWBSO",4,0)
 ;
"RTN","HMPWBSO",5,0)
 Q
"RTN","HMPWBSO",6,0)
 ;
"RTN","HMPWBSO",7,0)
 ; RPC: HMP SIGN ORDERS
"RTN","HMPWBSO",8,0)
SIGN(RSLT,DFN,ORNP,ORL,ES,DATA) ;
"RTN","HMPWBSO",9,0)
 ;
"RTN","HMPWBSO",10,0)
 ;Output
"RTN","HMPWBSO",11,0)
 ; RSLT = 1 on success, 0 otherwise
"RTN","HMPWBSO",12,0)
 ; RSLT(ORIEN) = error message
"RTN","HMPWBSO",13,0)
 ;Input
"RTN","HMPWBSO",14,0)
 ; DFN - patient IEN - ^DPT(
"RTN","HMPWBSO",15,0)
 ; ORNP - provider IEN - ^VA(200
"RTN","HMPWBSO",16,0)
 ; ORL - location IEN - ^SC(
"RTN","HMPWBSO",17,0)
 ; ES - electronic signature
"RTN","HMPWBSO",18,0)
 ; DATA(ORIEN) = order IEN - ^OR(100
"RTN","HMPWBSO",19,0)
 ;
"RTN","HMPWBSO",20,0)
 N ESOK,ORID,VAL,OK,ORS,IDX,ERR
"RTN","HMPWBSO",21,0)
 S U="^",IDX=0,ERR=0,XQY0="OR CPRS GUI CHART"
"RTN","HMPWBSO",22,0)
 S RSLT=0
"RTN","HMPWBSO",23,0)
 I $D(^DPT(+$G(DFN)))'>1 S RSLT(0)="Invalid DFN - "_+$G(DFN) Q
"RTN","HMPWBSO",24,0)
 I $D(^VA(200,+$G(ORNP)))'>1 S RSLT(0)="Invalid ORNP - "_+$G(ORNP) Q
"RTN","HMPWBSO",25,0)
 I $D(^SC(+$G(ORL)))'>1 S RSLT(0)="Invalid ORL - "_+$G(ORL) Q
"RTN","HMPWBSO",26,0)
 I '$D(^XUSEC("PROVIDER",ORNP)) S RSLT(0)="Not a provider" Q
"RTN","HMPWBSO",27,0)
 D VALIDSIG^ORWU(.ESOK,$G(ES)) I $G(ESOK)'>0 S RSLT(0)="Signature not valid" Q
"RTN","HMPWBSO",28,0)
 I $D(DATA)'>1 S RSLT(0)="Invalid DATA array" Q
"RTN","HMPWBSO",29,0)
 S ORID=0 F  S ORID=$O(DATA(ORID)) Q:'ORID  D
"RTN","HMPWBSO",30,0)
 . D VALID^ORWDXA(.VAL,ORID,"ES",ORNP)
"RTN","HMPWBSO",31,0)
 . I $L(VAL)>0 S RSLT(ORID)=ORID_";1"_U_"E"_U_VAL,ERR=1
"RTN","HMPWBSO",32,0)
 . D LOCKORD^ORWDX(.OK,ORID)
"RTN","HMPWBSO",33,0)
 . I 'OK S RSLT(ORID)=ORID_";1"_U_"E"_U_$P(OK,U,2),ERR=1
"RTN","HMPWBSO",34,0)
 . S IDX=IDX+1,ORS(IDX)=ORID_";1^1^1^E"
"RTN","HMPWBSO",35,0)
 I ERR S RSLT=0 Q
"RTN","HMPWBSO",36,0)
 D SEND^ORWDX(.RSLT,DFN,ORNP,ORL,ES,.ORS)
"RTN","HMPWBSO",37,0)
 S ORID=0 F  S ORID=$O(DATA(ORID)) Q:'ORID  D
"RTN","HMPWBSO",38,0)
 . D UNLKORD^ORWDX(.OK,ORID)
"RTN","HMPWBSO",39,0)
 S RSLT=1
"RTN","HMPWBSO",40,0)
 Q
"RTN","HMPXGDPT")
0^54^B2019789
"RTN","HMPXGDPT",1,0)
HMPXGDPT ; ASMR/PB - Patient File Utilities;Nov 03, 2015 18:23:03
"RTN","HMPXGDPT",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;November 30,2015;Build 24
"RTN","HMPXGDPT",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPXGDPT",4,0)
 ;
"RTN","HMPXGDPT",5,0)
 ; External References
"RTN","HMPXGDPT",6,0)
 ; -------------------
"RTN","HMPXGDPT",7,0)
 ; Patient File - IA 10035
"RTN","HMPXGDPT",8,0)
 ; DBIA3327
"RTN","HMPXGDPT",9,0)
 ;
"RTN","HMPXGDPT",10,0)
 Q
"RTN","HMPXGDPT",11,0)
 ;
"RTN","HMPXGDPT",12,0)
TOP(HMPARRAY,HMPDFN,HMPFLDS,HMPFLG) ; returns data based on the DFN and the list of fields supplied.
"RTN","HMPXGDPT",13,0)
 ;This API only returns fields that are at the top level of the record.
"RTN","HMPXGDPT",14,0)
 ;It will not return data from multiples, use the LOWER API to return fields from a multiple in the Patient file.
"RTN","HMPXGDPT",15,0)
 ;Data is returned in the array passed in the ARRAY parameter. Data is returned for both internal and external values.
"RTN","HMPXGDPT",16,0)
 ;
"RTN","HMPXGDPT",17,0)
 ; HMPARRAY - result array, passed by reference
"RTN","HMPXGDPT",18,0)
 ; HMPDFN - IEN of the Patient, required
"RTN","HMPXGDPT",19,0)
 ; HMPFLDS - FileMan field list (optional), if not passed all fields returned 
"RTN","HMPXGDPT",20,0)
 ; HMPFLG - FileMan data flag (optional)
"RTN","HMPXGDPT",21,0)
 ; 
"RTN","HMPXGDPT",22,0)
 N DA,DR,DIQ,DIC,FLAGS
"RTN","HMPXGDPT",23,0)
 Q:$G(HMPDFN)=""  ;DFN must be defined
"RTN","HMPXGDPT",24,0)
 Q:$G(HMPFLDS)=""  ;FLDS must have a least one field defined. Fields are listed by field number and separated by a semi colon
"RTN","HMPXGDPT",25,0)
 S:'$G(HMPFLG) FLAGS="IE"
"RTN","HMPXGDPT",26,0)
 S DIC=2,DR=HMPFLDS,DA=HMPDFN,DIQ=HMPARRAY,DIQ(0)=$G(HMPFLG)
"RTN","HMPXGDPT",27,0)
 D EN^DIQ1
"RTN","HMPXGDPT",28,0)
 Q
"RTN","HMPXGDPT",29,0)
 ;
"RTN","HMPXGDPT",30,0)
INOUT(HMPDFN) ; Boolean function, 1 for inpatient, else zero
"RTN","HMPXGDPT",31,0)
 N LOC S LOC=$G(^DPT(+$G(HMPDFN),.1)) Q $S($L(LOC):1,1:0)  ;ICR 10035, (#.1) WARD LOCATION [E1,30F]
"RTN","HMPXGDPT",32,0)
 ;
"RTN","HMPXGLAB")
0^55^B1064430
"RTN","HMPXGLAB",1,0)
HMPXGLAB ; ASMR/hrubovcak - Lab data retrieval ;Nov 05, 2015 15:27:37
"RTN","HMPXGLAB",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPXGLAB",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPXGLAB",4,0)
 ;
"RTN","HMPXGLAB",5,0)
 Q
"RTN","HMPXGLAB",6,0)
 ;
"RTN","HMPXGLAB",7,0)
LABTSTNM(HMPLTIEN) ;function, return NAME field (#.01) from LABORATORY TEST file (#60)
"RTN","HMPXGLAB",8,0)
 ; IA 10054 - NAME can be read with FileMan
"RTN","HMPXGLAB",9,0)
 ; HMPLTIEN - Lab Test IEN (required)
"RTN","HMPXGLAB",10,0)
 Q:'($G(HMPLTIEN)>0) "ERROR: Lab Test IEN missing"
"RTN","HMPXGLAB",11,0)
 ;
"RTN","HMPXGLAB",12,0)
 N DA,DIC,DIQ,DR,FLAGS,HMPRSLT,HMPTSTNM
"RTN","HMPXGLAB",13,0)
 S DIC=60,DR=".01",DA=HMPLTIEN,DIQ="HMPRSLT",DIQ(0)="E",FLAGS="E"
"RTN","HMPXGLAB",14,0)
 D EN^DIQ1
"RTN","HMPXGLAB",15,0)
 ;
"RTN","HMPXGLAB",16,0)
 Q $G(HMPRSLT(60,HMPLTIEN,.01,"E"))
"RTN","HMPXGLAB",17,0)
 ;
"RTN","HMPXGLAB",18,0)
LRDFN(HMPDFN) ;function, return LRDFN from PATIENT file
"RTN","HMPXGLAB",19,0)
 ;
"RTN","HMPXGLAB",20,0)
 Q:'($G(HMPDFN)>0) ""  ; patient's DFN required
"RTN","HMPXGLAB",21,0)
 ;
"RTN","HMPXGLAB",22,0)
 N HMPDEMOG
"RTN","HMPXGLAB",23,0)
 D TOP^HMPXGDPT("HMPDEMOG",HMPDFN,"63","I")  ; (#63) LABORATORY REFERENCE
"RTN","HMPXGLAB",24,0)
 Q $G(HMPDEMOG(2,HMPDFN,63,"I"))
"RTN","HMPXGLAB",25,0)
 ;
"RTN","HMPXGNP")
0^56^B1299808
"RTN","HMPXGNP",1,0)
HMPXGNP ; ASMR/hrubovcak - NEW PERSON file (#200) data retrieval ;Nov 03, 2015 18:23:03
"RTN","HMPXGNP",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPXGNP",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPXGNP",4,0)
 ;
"RTN","HMPXGNP",5,0)
 Q
"RTN","HMPXGNP",6,0)
 ; IA 10060 - All NEW PERSON fields supported for read via FileMan
"RTN","HMPXGNP",7,0)
 ;
"RTN","HMPXGNP",8,0)
TOP(HMPRSLT,HMPNPIEN,HMPFLDS,HMPFLG) ; return top-level fields, null fields not returned
"RTN","HMPXGNP",9,0)
 ; HMPRSLT - result array, closed reference, required
"RTN","HMPXGNP",10,0)
 ; HMPNPIEN - IEN of NEW PERSON, required
"RTN","HMPXGNP",11,0)
 ; HMPFLDS - field list, required, FileMan convention 
"RTN","HMPXGNP",12,0)
 ; HMPFLG - data flag, optional, FileMan convention
"RTN","HMPXGNP",13,0)
 ;
"RTN","HMPXGNP",14,0)
 Q:'$L($G(HMPRSLT))
"RTN","HMPXGNP",15,0)
 ;
"RTN","HMPXGNP",16,0)
 K @HMPRSLT  ; clear all results
"RTN","HMPXGNP",17,0)
 ; error data is found in -1 subscript
"RTN","HMPXGNP",18,0)
 I '($G(HMPNPIEN)>0) S @HMPRSLT@(-1,$T(+0))="NEW PERSON IEN required" Q
"RTN","HMPXGNP",19,0)
 I $G(HMPFLDS)="" S @HMPRSLT@(-1,$T(+0))="NEW PERSON fields required" Q
"RTN","HMPXGNP",20,0)
 I '$L($G(HMPFLG)) N HMPFLG S HMPFLG="EIN"
"RTN","HMPXGNP",21,0)
 N DA,DIC,DIQ,DR,FLAGS  ; FileMan variables
"RTN","HMPXGNP",22,0)
 S DIC=200,DR=HMPFLDS,DA=HMPNPIEN,DIQ=HMPRSLT,DIQ(0)=HMPFLG,FLAGS=HMPFLG
"RTN","HMPXGNP",23,0)
 D EN^DIQ1
"RTN","HMPXGNP",24,0)
 Q
"RTN","HMPXGNP",25,0)
 ;
"RTN","HMPXGORD")
0^57^B2568884
"RTN","HMPXGORD",1,0)
HMPXGORD ; ASMR/hrubovcak - ORDER file (#100) data retrieval ;Nov 03, 2015 18:23:03
"RTN","HMPXGORD",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPXGORD",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPXGORD",4,0)
 ;
"RTN","HMPXGORD",5,0)
 Q
"RTN","HMPXGORD",6,0)
 ;
"RTN","HMPXGORD",7,0)
TOP(HMPRSLT,HMPORIEN,HMPFLDS,HMPFLG) ; return top-level fields
"RTN","HMPXGORD",8,0)
 ; HMPRSLT - result array, closed reference, required
"RTN","HMPXGORD",9,0)
 ; HMPORIEN - IEN of NEW PERSON, required
"RTN","HMPXGORD",10,0)
 ; HMPFLDS - field list, required, FileMan convention 
"RTN","HMPXGORD",11,0)
 ; HMPFLG - data flag, optional, FileMan convention
"RTN","HMPXGORD",12,0)
 ;
"RTN","HMPXGORD",13,0)
 Q:'$L($G(HMPRSLT))
"RTN","HMPXGORD",14,0)
 ;
"RTN","HMPXGORD",15,0)
 K @HMPRSLT  ; clear all results
"RTN","HMPXGORD",16,0)
 ; error data is found in -1 subscript
"RTN","HMPXGORD",17,0)
 I '($G(HMPORIEN)>0) S @HMPRSLT@(-1,$T(+0))="ORDER IEN required" Q
"RTN","HMPXGORD",18,0)
 I $G(HMPFLDS)="" S @HMPRSLT@(-1,$T(+0))="ORDER fields required" Q
"RTN","HMPXGORD",19,0)
 I '$L($G(HMPFLG)) N HMPFLG S HMPFLG="EIN"  ; default is external and internal, skip nulls
"RTN","HMPXGORD",20,0)
 N DA,DIC,DIQ,DR,FLAGS  ; FileMan variables
"RTN","HMPXGORD",21,0)
 S DIC=100,DR=HMPFLDS,DA=HMPORIEN,DIQ=HMPRSLT,DIQ(0)=HMPFLG,FLAGS=HMPFLG
"RTN","HMPXGORD",22,0)
 D EN^DIQ1
"RTN","HMPXGORD",23,0)
 Q
"RTN","HMPXGORD",24,0)
 ;
"RTN","HMPXGORD",25,0)
DIALOG(HMPORIEN) ; function, return (#2) DIALOG [5V] for ORDER
"RTN","HMPXGORD",26,0)
 Q $P($G(^OR(100,+$G(HMPORIEN),0)),"^",5)
"RTN","HMPXGORD",27,0)
 ;
"RTN","HMPXGORD",28,0)
ORDTOP(HMPORDFL,HMPORDIEN,HMPORDND) ; function, return top-level node from a file in ^ORD (file list below)
"RTN","HMPXGORD",29,0)
 ;
"RTN","HMPXGORD",30,0)
 I '($G(HMPORDFL)>0)!'($G(HMPORDIEN)>0)!'$L($G(HMPORDND)) Q ""  ; all required
"RTN","HMPXGORD",31,0)
 ;
"RTN","HMPXGORD",32,0)
 Q $G(^ORD(HMPORDFL,HMPORDIEN,HMPORDND))  ; returns internal format
"RTN","HMPXGORD",33,0)
 ;
"RTN","HMPXGORD",34,0)
 ;
"RTN","HMPXGORD",35,0)
 ; files in the ^ORD global:
"RTN","HMPXGORD",36,0)
 ;
"RTN","HMPXGORD",37,0)
 ;ORDER STATUS (#100.01)
"RTN","HMPXGORD",38,0)
 ;NATURE OF ORDER (#100.02)
"RTN","HMPXGORD",39,0)
 ;ORDER REASON (#100.03)
"RTN","HMPXGORD",40,0)
 ;ORDER CHECK INSTANCES (#100.05)
"RTN","HMPXGORD",41,0)
 ;OE/RR PRINT FIELDS (#100.22)
"RTN","HMPXGORD",42,0)
 ;OE/RR PRINT FORMATS (#100.23)
"RTN","HMPXGORD",43,0)
 ;OE/RR RELEASE EVENTS (#100.5)
"RTN","HMPXGORD",44,0)
 ;OE/RR AUTO-DC RULES (#100.6)
"RTN","HMPXGORD",45,0)
 ;OE/RR EPCS PARAMETERS (#100.7)
"RTN","HMPXGORD",46,0)
 ;ORDER CHECKS (#100.8)
"RTN","HMPXGORD",47,0)
 ;OE/RR NOTIFICATIONS (#100.9)
"RTN","HMPXGORD",48,0)
 ;DISPLAY GROUP (#100.98)
"RTN","HMPXGORD",49,0)
 ;ORDER PARAMETERS (#100.99)
"RTN","HMPXGORD",50,0)
 ;PROTOCOL (#101)
"RTN","HMPXGORD",51,0)
 ;OR CPRS TABS (#101.13)
"RTN","HMPXGORD",52,0)
 ;OE/RR COM OBJECTS (#101.15)
"RTN","HMPXGORD",53,0)
 ;OE/RR REPORT (#101.24)
"RTN","HMPXGORD",54,0)
 ;ORDER EXECUTE CODES (#101.3)
"RTN","HMPXGORD",55,0)
 ;ORDER DIALOG (#101.41)
"RTN","HMPXGORD",56,0)
 ;ORDER URGENCY (#101.42)
"RTN","HMPXGORD",57,0)
 ;ORDERABLE ITEMS (#101.43)
"RTN","HMPXGORD",58,0)
 ;ORDER QUICK VIEW (#101.44)
"RTN","HMPXGORD",59,0)
 ;CPRS QUERY DEFINITION (#102.21)
"RTN","HMPXGORD",60,0)
 ;CPRS QUERY CONSTRAINT (#102.22)
"RTN","HMPXGORD",61,0)
 ;CPRS QUERY EDIT CONTROL (#102.23)
"RTN","HMPXGORD",62,0)
 ;CPRS QUERY DISPLAY FIELDS (#102.24)
"RTN","HMPXGORD",63,0)
 ;
"RTN","HMPXGSD")
0^58^B2602100
"RTN","HMPXGSD",1,0)
HMPXGSD ; ASMR/hrubovcak - Scheduling data retrieval ;Nov 20, 2015 01:49:50
"RTN","HMPXGSD",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**2**;Sep 01, 2011;Build 24
"RTN","HMPXGSD",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPXGSD",4,0)
 ;
"RTN","HMPXGSD",5,0)
 Q
"RTN","HMPXGSD",6,0)
 ;
"RTN","HMPXGSD",7,0)
 ; DE2818, code below adapted from CLINLOC^ORWU
"RTN","HMPXGSD",8,0)
CLINLOC(RSLT,FROM,DIR) ; return list of clinics from HOSPITAL LOCATION file (#44)
"RTN","HMPXGSD",9,0)
 ; all 3 arguments required
"RTN","HMPXGSD",10,0)
 ; RSLT=returned list (passed by reference), FROM=text to $ORDER from, DIR=$ORDER direction
"RTN","HMPXGSD",11,0)
 ; RSLT(counter) = IEN^location name
"RTN","HMPXGSD",12,0)
 N I,IEN,LOCNM  ; counter, internal entry number, location name
"RTN","HMPXGSD",13,0)
 S I=0,LOCNM=$G(FROM)
"RTN","HMPXGSD",14,0)
 F  S LOCNM=$O(^SC("B",LOCNM),DIR) Q:LOCNM=""  D  ; ICR 10040
"RTN","HMPXGSD",15,0)
 . S IEN="" F  S IEN=$O(^SC("B",LOCNM,IEN),DIR) Q:'IEN  D
"RTN","HMPXGSD",16,0)
 ..  Q:'($P($G(^SC(IEN,0)),U,3)="C")  ; check (#2) TYPE [3S], must be clinic
"RTN","HMPXGSD",17,0)
 ..  Q:'$$ACTLOC(IEN)  ; must be active
"RTN","HMPXGSD",18,0)
 ..  S I=I+1,RSLT(I)=IEN_"^"_LOCNM
"RTN","HMPXGSD",19,0)
 ;
"RTN","HMPXGSD",20,0)
 Q
"RTN","HMPXGSD",21,0)
 ;
"RTN","HMPXGSD",22,0)
 ; DE2818, code below adapted from ACTLOC^ORWU
"RTN","HMPXGSD",23,0)
ACTLOC(LOC) ; Boolean function, TRUE if active hospital location
"RTN","HMPXGSD",24,0)
 ; LOC - IEN in HOSPITAL LOCATION file, ICR 10040
"RTN","HMPXGSD",25,0)
 ; IND - the "I" node, ^SC(D0,I) = (#2505) INACTIVATE DATE [1D] ^ (#2506) REACTIVATE DATE [2D] ^
"RTN","HMPXGSD",26,0)
 ; D0, X - used by WIN^DGPMDDCF
"RTN","HMPXGSD",27,0)
 N D0,IND,X
"RTN","HMPXGSD",28,0)
 Q:+$G(^SC(LOC,"OOS")) 0  ; (#50.01) OCCASION OF SERVICE CLINIC?, screen entry
"RTN","HMPXGSD",29,0)
 S D0=+$G(^SC(LOC,42)) I D0 D WIN^DGPMDDCF Q 'X  ; check out-of-service wards, ICR 1246
"RTN","HMPXGSD",30,0)
 S IND=$G(^SC(LOC,"I")) Q:'IND 1  ; INACTIVATE DATE not found
"RTN","HMPXGSD",31,0)
 I DT>$P(IND,U)&($P(IND,U,2)=""!(DT<$P(IND,U,2))) Q 0  ; check REACTIVATE DATE
"RTN","HMPXGSD",32,0)
 Q 1  ; active
"RTN","HMPXGSD",33,0)
 ;
"SEC","^DIC",800000,800000,0,"AUDIT")
@
"SEC","^DIC",800000,800000,0,"DD")
@
"SEC","^DIC",800000,800000,0,"DEL")
@
"SEC","^DIC",800000,800000,0,"LAYGO")
@
"SEC","^DIC",800000,800000,0,"RD")
@
"SEC","^DIC",800000,800000,0,"WR")
@
"SEC","^DIC",800003,800003,0,"AUDIT")
@
"SEC","^DIC",800003,800003,0,"DD")
@
"SEC","^DIC",800003,800003,0,"DEL")
@
"SEC","^DIC",800003,800003,0,"LAYGO")
@
"SEC","^DIC",800003,800003,0,"RD")

"SEC","^DIC",800003,800003,0,"WR")
@
"VER")
8.0^22.0
"^DD",800000,800000,0)
FIELD^^.04^11
"^DD",800000,800000,0,"DDA")
N
"^DD",800000,800000,0,"DT")
3160720
"^DD",800000,800000,0,"IX","B",800000,.01)

"^DD",800000,800000,0,"NM","HMP SUBSCRIPTION")

"^DD",800000,800000,0,"VRPK")
HMP
"^DD",800000,800000,.01,0)
SERVER^RF^^0;1^K:$L(X)>64!($L(X)<1)!'(X'?1P.E) X
"^DD",800000,800000,.01,1,0)
^.1^^-1
"^DD",800000,800000,.01,1,1,0)
800000^B
"^DD",800000,800000,.01,1,1,1)
S ^HMP(800000,"B",$E(X,1,64),DA)=""
"^DD",800000,800000,.01,1,1,2)
K ^HMP(800000,"B",$E(X,1,64),DA)
"^DD",800000,800000,.01,3)
Answer must be 1-64 characters in length.
"^DD",800000,800000,.01,21,0)
^.001^1^1^3140212^^^^
"^DD",800000,800000,.01,21,1,0)
This is the name of the client system that is subscribing to data updates.
"^DD",800000,800000,.01,"DT")
3141028
"^DD",800000,800000,.02,0)
LASTUPDATE^F^^0;2^K:$L(X)>100!($L(X)<3) X
"^DD",800000,800000,.02,3)
Answer must be 3-100 characters in length. (Do not modify.)
"^DD",800000,800000,.02,21,0)
^^3^3^3110908^
"^DD",800000,800000,.02,21,1,0)
This field holds a flag, indicating if this URL should be notified via the
"^DD",800000,800000,.02,21,2,0)
nightly scheduled option HMP APPOINTMENTS of the list of patients expected
"^DD",800000,800000,.02,21,3,0)
to be seen tomorrow.
"^DD",800000,800000,.02,"DT")
3160719
"^DD",800000,800000,.03,0)
OPERATION DATA^S^0:UNSUBCRIBED;1:SUBSCRIBED;2:INITIALIZED;^0;3^Q
"^DD",800000,800000,.03,3)
Select the type of notification for this URL. (Do Not Modify)
"^DD",800000,800000,.03,21,0)
^^2^2^3160720^
"^DD",800000,800000,.03,21,1,0)
This field holds a flag, indicating if this URL should be notified via http
"^DD",800000,800000,.03,21,2,0)
when a patient is admitted.
"^DD",800000,800000,.03,"DT")
3160720
"^DD",800000,800000,.04,0)
REPEAT POLLS^NJ8,0^^0;4^K:+X'=X!(X>99999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",800000,800000,.04,3)
Type a number between 0 and 99999999, 0 decimal digits.
"^DD",800000,800000,.04,21,0)
^^2^2^3140404^
"^DD",800000,800000,.04,21,1,0)
This tracks the number of times the same "last update" value has been
"^DD",800000,800000,.04,21,2,0)
repeated.  A high repeat may be normal if data are not changing.
"^DD",800000,800000,.04,"DT")
3141028
"^DD",800000,800000,.05,0)
DISK USAGE STATUS^S^0:WITHIN LIMIT;1:EXCEEDED LIMIT;^0;5^Q
"^DD",800000,800000,.05,3)
Enter current status of eHMP disk usage
"^DD",800000,800000,.05,21,0)
^^5^5^3150624^
"^DD",800000,800000,.05,21,1,0)
The DISK USAGE STATUS flag is an indicator set automatically in the eHMP 
"^DD",800000,800000,.05,21,2,0)
subscription process. If the disk space usage in global ^XTMP by eHMP 
"^DD",800000,800000,.05,21,3,0)
subscriptions is above the threshold in the HMP EXTRACT DISK SIZE LIMIT 
"^DD",800000,800000,.05,21,4,0)
is exceeded this flag will be set. Similarly the flag is reset if usage 
"^DD",800000,800000,.05,21,5,0)
later falls below the threshold.
"^DD",800000,800000,.05,23,0)
^^4^4^3150624^
"^DD",800000,800000,.05,23,1,0)
The field is updated from subscription process by the STATUS^HMPMETA
"^DD",800000,800000,.05,23,2,0)
routine.
"^DD",800000,800000,.05,23,3,0)
 
"^DD",800000,800000,.05,23,4,0)
The field is referenced by the fetch process using CHECK^HMPMETA routine.
"^DD",800000,800000,.05,"DT")
3150624
"^DD",800000,800000,.06,0)
DISK USAGE STATUS TIME^D^^0;6^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",800000,800000,.06,3)
Enter the time the DISK USAGE STATUS field was updated.
"^DD",800000,800000,.06,21,0)
^^6^6^3150624^
"^DD",800000,800000,.06,21,1,0)
The DISK USAGE STATUS TIME is a field set automatically in the eHMP 
"^DD",800000,800000,.06,21,2,0)
subscription process. If the disk space usage in global ^XTMP by eHMP 
"^DD",800000,800000,.06,21,3,0)
subscriptions is above the threshold in the HMP EXTRACT DISK SIZE LIMIT is
"^DD",800000,800000,.06,21,4,0)
exceeded the DISK USAGE STATUS field will be set and the time of the 
"^DD",800000,800000,.06,21,5,0)
change recorded in this field . Similarly the flag and time fields will be
"^DD",800000,800000,.06,21,6,0)
reset if usage later falls below the threshold.
"^DD",800000,800000,.06,23,0)
^^4^4^3150624^
"^DD",800000,800000,.06,23,1,0)
The field is updated from subscription process by the STATUS^HMPMETA
"^DD",800000,800000,.06,23,2,0)
routine.
"^DD",800000,800000,.06,23,3,0)
 
"^DD",800000,800000,.06,23,4,0)
The field is referenced by the fetch process using CHECK^HMPMETA routine.
"^DD",800000,800000,.06,"DT")
3150624
"^DD",800000,800000,.07,0)
DEFAULT?^S^1:YES;0:NO;^0;7^Q
"^DD",800000,800000,.07,3)
Enter 1 for the default eHMP primary subscription.
"^DD",800000,800000,.07,21,0)
^^5^5^3160720^
"^DD",800000,800000,.07,21,1,0)
This field identifies the primary eHMP subscription for this server. It 
"^DD",800000,800000,.07,21,2,0)
identifies this server as the default for operations such as selecting a 
"^DD",800000,800000,.07,21,3,0)
subscription to monitor in the option eHMP Dashboard [HMPMON DASHBOARD].
"^DD",800000,800000,.07,21,4,0)
Only one server at a time can be set as the default. If this file contains
"^DD",800000,800000,.07,21,5,0)
only one record, then it will be used automatically as the default.
"^DD",800000,800000,.07,23,0)
^^2^2^3160719^
"^DD",800000,800000,.07,23,1,0)
Used in $$GETSRVR^HMPMOND to identify the default subscription if this 
"^DD",800000,800000,.07,23,2,0)
file contains more than one.
"^DD",800000,800000,.07,"DT")
3160720
"^DD",800000,800000,.1,0)
URL^F^^.1;1^K:$L(X)>250!($L(X)<1) X
"^DD",800000,800000,.1,3)
Answer must be 1-250 characters in length.
"^DD",800000,800000,.1,21,0)
^^1^1^3160719^
"^DD",800000,800000,.1,21,1,0)
This is the fully qualified URL to call when updates are available.
"^DD",800000,800000,.1,"DT")
3160719
"^DD",800000,800000,1,0)
PATIENT^800000.01P^^1;0
"^DD",800000,800000,1,21,0)
^.001^1^1^3160718^^^^
"^DD",800000,800000,1,21,1,0)
This is a patient that will be monitored for new data and updates.
"^DD",800000,800000,2,0)
ROSTER^800000.02P^^2;0
"^DD",800000,800000,2,21,0)
^.001^1^1^3130417^^^^
"^DD",800000,800000,2,21,1,0)
This is a roster that will be monitored for new patients and updates.
"^DD",800000,800000,2,"DT")
3130417
"^DD",800000,800000,91,0)
CONCURRENT UPDATE CALLS^NJ3,0^^91;1^K:+X'=X!(X>999)!(X<0)!(X?.E1"."1N.N) X
"^DD",800000,800000,91,3)
Type a number between 0 and 999, 0 decimal digits.
"^DD",800000,800000,91,21,0)
^^3^3^3150218^
"^DD",800000,800000,91,21,1,0)
This field is used to track the number of simultaneous calls to 
"^DD",800000,800000,91,21,2,0)
getPtUpdates in API^HMPDJFS. This allows checkHealth to report if a 
"^DD",800000,800000,91,21,3,0)
getPtUpdates RPC is in progress.
"^DD",800000,800000,91,"DT")
3150218
"^DD",800000,800000.01,0)
PATIENT SUB-FIELD^^3^4
"^DD",800000,800000.01,0,"DT")
3160720
"^DD",800000,800000.01,0,"NM","PATIENT")

"^DD",800000,800000.01,0,"UP")
800000
"^DD",800000,800000.01,.01,0)
PATIENT NAME^MP2'X^DPT(^0;1^S DINUM=X
"^DD",800000,800000.01,.01,1,0)
^.1^^0
"^DD",800000,800000.01,.01,3)
Enter the name of a patient to be tracked.
"^DD",800000,800000.01,.01,21,0)
^.001^1^1^3140212^^
"^DD",800000,800000.01,.01,21,1,0)
This is the name of the patient being monitored for new data.
"^DD",800000,800000.01,.01,"DT")
3140226
"^DD",800000,800000.01,2,0)
STATUS^S^0:UNINITIALIZED;1:INITIALIZING;2:INITIALIZED;^0;2^Q
"^DD",800000,800000.01,2,3)
Select the status for a patient sync. (Do Not Modify)
"^DD",800000,800000.01,2,21,0)
^^4^4^3160719^
"^DD",800000,800000.01,2,21,1,0)
This field tracks the initialization progress of the patient.  When a 
"^DD",800000,800000.01,2,21,2,0)
patient is initially subscribed, they are added to this multiple.  The 
"^DD",800000,800000.01,2,21,3,0)
status is "1" when the extracts start and "2" when they finish.  At that 
"^DD",800000,800000.01,2,21,4,0)
point, freshness updates are moved into the stream.
"^DD",800000,800000.01,2,"DT")
3160720
"^DD",800000,800000.01,3,0)
STATUS DATE/TIME^D^^0;3^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",800000,800000.01,3,.1)

"^DD",800000,800000.01,3,3)
Enter the date/time the status changed.
"^DD",800000,800000.01,3,21,0)
^^1^1^3160722^
"^DD",800000,800000.01,3,21,1,0)
This is the date/time of the last change in extract status.
"^DD",800000,800000.01,3,"DT")
3160722
"^DD",800000,800000.01,4,0)
ORDERS^800000.14PA^^1;0
"^DD",800000,800000.01,4,21,0)
^^7^7^3160719^
"^DD",800000,800000.01,4,21,1,0)
This multiple contains order data needed by eHMP data storage. 
"^DD",800000,800000.01,4,21,2,0)
The data in the sub-file
"^DD",800000,800000.01,4,21,3,0)
are stored based on the date and time, including seconds,
"^DD",800000,800000.01,4,21,4,0)
for an action with the order. 
"^DD",800000,800000.01,4,21,5,0)
 
"^DD",800000,800000.01,4,21,6,0)
All data in this sub-file are to be manipulated by software only.
"^DD",800000,800000.01,4,21,7,0)
Users should NOT edit any data without consulting with the developers.
"^DD",800000,800000.02,0)
ROSTER SUB-FIELD^^2^2
"^DD",800000,800000.02,0,"NM","ROSTER")

"^DD",800000,800000.02,0,"UP")
800000
"^DD",800000,800000.02,.01,0)
NAME^MP800001.2'X^HMPROSTR(800001.2,^0;1^S DINUM=X
"^DD",800000,800000.02,.01,1,0)
^.1^^0
"^DD",800000,800000.02,.01,3)
Enter the name of a roster to be tracked.
"^DD",800000,800000.02,.01,21,0)
^.001^1^1^3130417^^
"^DD",800000,800000.02,.01,21,1,0)
This is the name of the roster being monitored for new patients.
"^DD",800000,800000.02,.01,"DT")
3130417
"^DD",800000,800000.02,2,0)
ON^S^1:YES;0:NO;^0;2^Q
"^DD",800000,800000.02,2,3)
Enter YES to turn on data tracking for this roster.
"^DD",800000,800000.02,2,21,0)
^.001^3^3^3130417^^
"^DD",800000,800000.02,2,21,1,0)
This field turns on the Data Monitor for this roster and client system.
"^DD",800000,800000.02,2,21,2,0)
If ON=true, a new snapshot of this roster will be sent to the client
"^DD",800000,800000.02,2,21,3,0)
when new data updates are requested.
"^DD",800000,800000.02,2,"DT")
3130417
"^DD",800000,800000.14,0)
ORDERS SUB-FIELD^^1.01^17
"^DD",800000,800000.14,0,"DT")
3160720
"^DD",800000,800000.14,0,"IX","B",800000.14,.01)

"^DD",800000,800000.14,0,"NM","ORDERS")

"^DD",800000,800000.14,0,"UP")
800000.01
"^DD",800000,800000.14,.01,0)
ORDER NUMBER^P100'X^OR(100,^0;1^S DINUM=X
"^DD",800000,800000.14,.01,1,0)
^.1
"^DD",800000,800000.14,.01,1,1,0)
800000.14^B
"^DD",800000,800000.14,.01,1,1,1)
S ^HMP(800000,DA(2),1,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",800000,800000.14,.01,1,1,2)
K ^HMP(800000,DA(2),1,DA(1),1,"B",$E(X,1,30),DA)
"^DD",800000,800000.14,.01,3)
Enter the Order number.
"^DD",800000,800000.14,.01,21,0)
^^5^5^3160719^
"^DD",800000,800000.14,.01,21,1,0)
All the data in this sub-file are entered programmatically.
"^DD",800000,800000.14,.01,21,2,0)
 
"^DD",800000,800000.14,.01,21,3,0)
The data are used to create timestamps with seconds in order to correctly 
"^DD",800000,800000.14,.01,21,4,0)
sequence orders activities in the eHMP system. Two activities on an order 
"^DD",800000,800000.14,.01,21,5,0)
may occur within the same minute.
"^DD",800000,800000.14,.01,"DT")
3160719
"^DD",800000,800000.14,.02,0)
CREATE DATE/TIME^D^^0;2^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",800000,800000.14,.02,3)
Enter the date and time the order was created.
"^DD",800000,800000.14,.02,21,0)
^.001^2^2^3151217^^^
"^DD",800000,800000.14,.02,21,1,0)
The date/time to include seconds that the order was created.
"^DD",800000,800000.14,.02,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.02,"DT")
3151216
"^DD",800000,800000.14,.03,0)
SIGNED BY^P200'^VA(200,^0;3^Q
"^DD",800000,800000.14,.03,3)
Enter the User who signed the order.
"^DD",800000,800000.14,.03,21,0)
^.001^2^2^3151217^^
"^DD",800000,800000.14,.03,21,1,0)
The person signing the order.
"^DD",800000,800000.14,.03,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.03,"DT")
3151216
"^DD",800000,800000.14,.04,0)
SIGNED DATE/TIME^D^^0;4^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",800000,800000.14,.04,3)
Enter the date and time the order was signed.
"^DD",800000,800000.14,.04,21,0)
^^2^2^3160719^
"^DD",800000,800000.14,.04,21,1,0)
The date/time with seconds the order was signed. This field is entered
"^DD",800000,800000.14,.04,21,2,0)
programmatically.
"^DD",800000,800000.14,.04,"DT")
3160719
"^DD",800000,800000.14,.05,0)
VERIFYING NURSE^P200'^VA(200,^0;5^Q
"^DD",800000,800000.14,.05,3)
Enter the nurse who verified the order.
"^DD",800000,800000.14,.05,21,0)
^^2^2^3160719^
"^DD",800000,800000.14,.05,21,1,0)
The nurse verifying the order.
"^DD",800000,800000.14,.05,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.05,"DT")
3160719
"^DD",800000,800000.14,.06,0)
NURSE VERIFY DATE/TIME^D^^0;6^S %DT="ESTX" D ^%DT S X=Y K:X<1 X
"^DD",800000,800000.14,.06,3)
Enter the date and time the nurse verified the order.
"^DD",800000,800000.14,.06,21,0)
^^2^2^3160726^
"^DD",800000,800000.14,.06,21,1,0)
The date/time, including seconds, when the nurse verified the order. This
"^DD",800000,800000.14,.06,21,2,0)
field is entered programmatically.
"^DD",800000,800000.14,.06,"DT")
3160726
"^DD",800000,800000.14,.07,0)
VERIFYING CLERK^P200'^VA(200,^0;7^Q
"^DD",800000,800000.14,.07,3)
Enter the clerk who verified the order.
"^DD",800000,800000.14,.07,21,0)
^.001^2^2^3151217^^^
"^DD",800000,800000.14,.07,21,1,0)
The clerk who verified the order.
"^DD",800000,800000.14,.07,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.07,"DT")
3151216
"^DD",800000,800000.14,.08,0)
CLERK VERIFY DATE/TIME^D^^0;8^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",800000,800000.14,.08,3)
Enter the date and time the clerk verified the order.
"^DD",800000,800000.14,.08,21,0)
^.001^2^2^3151217^^
"^DD",800000,800000.14,.08,21,1,0)
The date/time, including seconds, the clerk verified the order.
"^DD",800000,800000.14,.08,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.08,"DT")
3151217
"^DD",800000,800000.14,.09,0)
REVIEWED BY^P200'^VA(200,^0;9^Q
"^DD",800000,800000.14,.09,3)
Enter the user who reviewed the order.
"^DD",800000,800000.14,.09,21,0)
^.001^2^2^3151217^^^
"^DD",800000,800000.14,.09,21,1,0)
The user who reviewed the order.
"^DD",800000,800000.14,.09,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.09,"DT")
3151216
"^DD",800000,800000.14,.1,0)
REVIEWED DATE/TIME^D^^0;10^S %DT="ESTR" D ^%DT S X=Y K:Y<1 X
"^DD",800000,800000.14,.1,3)
Enter the date and time the order was reviewed.
"^DD",800000,800000.14,.1,21,0)
^^2^2^3160719^
"^DD",800000,800000.14,.1,21,1,0)
The date/time, including seconds, that the order was reviewed. This field
"^DD",800000,800000.14,.1,21,2,0)
is entered programmatically.
"^DD",800000,800000.14,.1,"DT")
3160719
"^DD",800000,800000.14,.11,0)
RELEASED BY^P200'^VA(200,^0;11^Q
"^DD",800000,800000.14,.11,3)
Enter the user who released the order.
"^DD",800000,800000.14,.11,21,0)
^.001^2^2^3151217^^
"^DD",800000,800000.14,.11,21,1,0)
The user who released the order.
"^DD",800000,800000.14,.11,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.11,"DT")
3151216
"^DD",800000,800000.14,.12,0)
RELEASED DATE/TIME^D^^0;12^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",800000,800000.14,.12,3)
Enter the date and time the order was released.
"^DD",800000,800000.14,.12,21,0)
^^2^2^3160719^
"^DD",800000,800000.14,.12,21,1,0)
The date/time, including seconds, when the order was released. This field
"^DD",800000,800000.14,.12,21,2,0)
is entered programmatically.
"^DD",800000,800000.14,.12,"DT")
3160719
"^DD",800000,800000.14,.13,0)
PURGE DATE/TIME^D^^0;13^S %DT="ESTR" D ^%DT S X=Y K:X<1 X
"^DD",800000,800000.14,.13,3)
The date this order can be purged from the file.
"^DD",800000,800000.14,.13,21,0)
^.001^2^2^3151217^^
"^DD",800000,800000.14,.13,21,1,0)
The earliest date/time the order data can be purged.
"^DD",800000,800000.14,.13,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.13,"DT")
3160720
"^DD",800000,800000.14,.14,0)
ORDER ACTION^S^NW:NEW;DC:DISCONTINUED;HD:HOLD;RL:RELEASE HOLD;XX:CHANGE;VA:VALIDATE;IP:TRANSFERRED TO IP;OP:TRANSFERRED TO OP;^0;14^Q
"^DD",800000,800000.14,.14,3)
Enter the action performed on this order.
"^DD",800000,800000.14,.14,21,0)
^.001^2^2^3151217^^^
"^DD",800000,800000.14,.14,21,1,0)
The action taken on the order.
"^DD",800000,800000.14,.14,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.14,.14,"DT")
3151216
"^DD",800000,800000.14,.15,0)
ACTION DATE/TIME^D^^0;15^S %DT="ESTR" D ^%DT S X=Y K:X<1 X
"^DD",800000,800000.14,.15,3)
(No range limit on date)
"^DD",800000,800000.14,.15,21,0)
^^1^1^3160719^
"^DD",800000,800000.14,.15,21,1,0)
The date/time of the order action. This field is entered programmatically.
"^DD",800000,800000.14,.15,"DT")
3160720
"^DD",800000,800000.14,1.01,0)
TRACKING START^DI^^1;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",800000,800000.14,1.01,3)
Enter the date and time that eHMP started tracking this Order.
"^DD",800000,800000.14,1.01,21,0)
^^2^2^3160126^
"^DD",800000,800000.14,1.01,21,1,0)
This field is set to NOW when the Order is first added to this sub-file.
"^DD",800000,800000.14,1.01,21,2,0)
It is uneditable.
"^DD",800000,800000.14,1.01,"DT")
3160126
"^DD",800000,800000.14,2,0)
ORDER FLAG/UNFLAG DATE/TIME^800000.142DA^^2;0
"^DD",800000,800000.14,2,21,0)
^^1^1^3160719^
"^DD",800000,800000.14,2,21,1,0)
This sub-file contains flagging/unflagging actions on orders.
"^DD",800000,800000.14,2,"DT")
3151216
"^DD",800000,800000.142,0)
ORDER FLAG/UNFLAG DATE/TIME SUB-FIELD^^.04^4
"^DD",800000,800000.142,0,"DT")
3151216
"^DD",800000,800000.142,0,"IX","B",800000.142,.01)

"^DD",800000,800000.142,0,"NM","ORDER FLAG/UNFLAG DATE/TIME")

"^DD",800000,800000.142,0,"UP")
800000.14
"^DD",800000,800000.142,.01,0)
ORDER FLAG/UNFLAG DATE/TIME^D^^0;1^S %DT="ESTR" D ^%DT S X=Y K:Y<1 X
"^DD",800000,800000.142,.01,1,0)
^.1
"^DD",800000,800000.142,.01,1,1,0)
800000.142^B
"^DD",800000,800000.142,.01,1,1,1)
S ^HMP(800000,DA(3),1,DA(2),1,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",800000,800000.142,.01,1,1,2)
K ^HMP(800000,DA(3),1,DA(2),1,DA(1),2,"B",$E(X,1,30),DA)
"^DD",800000,800000.142,.01,3)
Enter the date and time the order was flagged or unflagged.
"^DD",800000,800000.142,.01,21,0)
^^3^3^3160719^
"^DD",800000,800000.142,.01,21,1,0)
This is the date/time with seconds that an order was flagged /unflagged.
"^DD",800000,800000.142,.01,21,2,0)
This field is entered programmatically. An order can be flagged or
"^DD",800000,800000.142,.01,21,3,0)
unflagged multiple times.
"^DD",800000,800000.142,.01,"DT")
3160719
"^DD",800000,800000.142,.02,0)
FLAG ACTION^S^F:FLAGGED;U:UNFLAGGED;^0;2^Q
"^DD",800000,800000.142,.02,3)
Select the flagged action for this order.
"^DD",800000,800000.142,.02,21,0)
^^2^2^3160718^
"^DD",800000,800000.142,.02,21,1,0)
The flagging action, FLAGGED or UNFLAGGED.
"^DD",800000,800000.142,.02,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.142,.02,"DT")
3160720
"^DD",800000,800000.142,.03,0)
FLAG/UNFLAG USER^P200'^VA(200,^0;3^Q
"^DD",800000,800000.142,.03,3)
Enter the user who flagged or unflagged the order.
"^DD",800000,800000.142,.03,21,0)
^.001^2^2^3151217^^
"^DD",800000,800000.142,.03,21,1,0)
The user who flagged /unflagged the order.
"^DD",800000,800000.142,.03,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.142,.03,"DT")
3151216
"^DD",800000,800000.142,.04,0)
FLAG/UNFLAG REASON^F^^0;4^K:$L(X)>80!($L(X)<1) X
"^DD",800000,800000.142,.04,.1)
REASON FOR FLAGGING /UNFLAGGING
"^DD",800000,800000.142,.04,3)
Answer must be 1-80 characters.
"^DD",800000,800000.142,.04,21,0)
^.001^2^2^3151217^^^
"^DD",800000,800000.142,.04,21,1,0)
This is why the order was flagged /unflagged.
"^DD",800000,800000.142,.04,21,2,0)
This field is entered programmatically.
"^DD",800000,800000.142,.04,"DT")
3151216
"^DD",800003,800003,0)
FIELD^^1^4
"^DD",800003,800003,0,"DDA")
N
"^DD",800003,800003,0,"DT")
3160613
"^DD",800003,800003,0,"ID",.02)
W "   ",$$FMTE^DILIBF($P(^(0),U,2),5)
"^DD",800003,800003,0,"IX","ATYP",800003,.03)

"^DD",800003,800003,0,"IX","B",800003,.01)

"^DD",800003,800003,0,"IX","C",800003,.02)

"^DD",800003,800003,0,"NM","HMP EVENT")

"^DD",800003,800003,0,"VRPK")
HMP
"^DD",800003,800003,.01,0)
LOG NUMBER^RNJ9,0X^^0;1^K:+X'=X!(X>999999999)!(X<1)!(X?.E1"."1N.N) X S:$G(X) DINUM=X
"^DD",800003,800003,.01,1,0)
^.1
"^DD",800003,800003,.01,1,1,0)
800003^B
"^DD",800003,800003,.01,1,1,1)
S ^HMPLOG(800003,"B",$E(X,1,30),DA)=""
"^DD",800003,800003,.01,1,1,2)
K ^HMPLOG(800003,"B",$E(X,1,30),DA)
"^DD",800003,800003,.01,3)
Type a number between 1 and 999999999, 0 decimal digits.
"^DD",800003,800003,.01,21,0)
^^1^1^3160613^
"^DD",800003,800003,.01,21,1,0)
This is an integer that corresponds to the internal entry number.
"^DD",800003,800003,.01,23,0)
^^1^1^3160613^
"^DD",800003,800003,.01,23,1,0)
An integer with a DINUM relationship.
"^DD",800003,800003,.01,"DT")
3160613
"^DD",800003,800003,.02,0)
EVENT DATE/TIME^RD^^0;2^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",800003,800003,.02,1,0)
^.1
"^DD",800003,800003,.02,1,1,0)
800003^C
"^DD",800003,800003,.02,1,1,1)
S ^HMPLOG(800003,"C",$E(X,1,30),DA)=""
"^DD",800003,800003,.02,1,1,2)
K ^HMPLOG(800003,"C",$E(X,1,30),DA)
"^DD",800003,800003,.02,1,1,3)
Do not delete this cross-reference.  It allows for lookup by date/time.
"^DD",800003,800003,.02,1,1,"%D",0)
^^1^1^3160613^
"^DD",800003,800003,.02,1,1,"%D",1,0)
Allows a user to look up an HMP EVENT entry by date and time.
"^DD",800003,800003,.02,1,1,"DT")
3160613
"^DD",800003,800003,.02,3)
Enter the date and time (with seconds) of the event.  Time is required.
"^DD",800003,800003,.02,21,0)
^^2^2^3160613^
"^DD",800003,800003,.02,21,1,0)
This is a precise date with required time (with seconds).
"^DD",800003,800003,.02,21,2,0)
This field is required for each entry.
"^DD",800003,800003,.02,"DT")
3160613
"^DD",800003,800003,.03,0)
TYPE OF EVENT^S^C:corruption;I:informational;M:missing entry;O:other;^0;3^Q
"^DD",800003,800003,.03,1,0)
^.1
"^DD",800003,800003,.03,1,1,0)
800003^ATYP
"^DD",800003,800003,.03,1,1,1)
S ^HMPLOG(800003,"ATYP",$E(X,1,30),DA)=""
"^DD",800003,800003,.03,1,1,2)
K ^HMPLOG(800003,"ATYP",$E(X,1,30),DA)
"^DD",800003,800003,.03,1,1,3)
Do not delete.  This field is used to sort by event type.
"^DD",800003,800003,.03,1,1,"%D",0)
^^1^1^3160613^
"^DD",800003,800003,.03,1,1,"%D",1,0)
This cross-reference can be used to provide reports of specific event types.
"^DD",800003,800003,.03,1,1,"DT")
3160613
"^DD",800003,800003,.03,3)
Indicate the type of event that was logged.  This value is optional.
"^DD",800003,800003,.03,21,0)
^.001^12^12^3160613^^
"^DD",800003,800003,.03,21,1,0)
A set of codes that will be used to classify the type of event logged.
"^DD",800003,800003,.03,21,2,0)
 
"^DD",800003,800003,.03,21,3,0)
 C - Corrupt entry was found.  For example, the value in a field would not pass
"^DD",800003,800003,.03,21,4,0)
     the Input Transform.
"^DD",800003,800003,.03,21,5,0)
 
"^DD",800003,800003,.03,21,6,0)
 I - Informational. An event of note that would not cause an error.
"^DD",800003,800003,.03,21,7,0)
     For example, an entry was missing a field that was expected, but not required.
"^DD",800003,800003,.03,21,8,0)
 
"^DD",800003,800003,.03,21,9,0)
 M - Missing entry. An internal entry number (IEN) was found without a corresponding
"^DD",800003,800003,.03,21,10,0)
     entry.  Also called a "broken pointer" or "dangling pointer".
"^DD",800003,800003,.03,21,11,0)
 
"^DD",800003,800003,.03,21,12,0)
 O - Other type of event.  Use this code for all other event types.
"^DD",800003,800003,.03,"DT")
3160613
"^DD",800003,800003,1,0)
DESCRIPTIVE TEXT^800003.01^^1;0
"^DD",800003,800003.01,0)
DESCRIPTIVE TEXT SUB-FIELD^^.01^1
"^DD",800003,800003.01,0,"DT")
3160613
"^DD",800003,800003.01,0,"NM","DESCRIPTIVE TEXT")

"^DD",800003,800003.01,0,"UP")
800003
"^DD",800003,800003.01,.01,0)
DESCRIPTIVE TEXT^Wx^^0;1^Q
"^DD",800003,800003.01,.01,3)
Enter text that describes the event that was logged.
"^DD",800003,800003.01,.01,21,0)
^^9^9^3160613^
"^DD",800003,800003.01,.01,21,1,0)
This text should contain any descriptive information about the event.
"^DD",800003,800003.01,.01,21,2,0)
For example, an event that was of type "missing" might have the pointer
"^DD",800003,800003.01,.01,21,3,0)
number, the file name(s) and number(s).
"^DD",800003,800003.01,.01,21,4,0)
 
"^DD",800003,800003.01,.01,21,5,0)
An event that was of type "corruption" might have the corrupt value,
"^DD",800003,800003.01,.01,21,6,0)
the file number and name, and the field number and name.
"^DD",800003,800003.01,.01,21,7,0)
 
"^DD",800003,800003.01,.01,21,8,0)
No personally identifiable information (PII) or personal health
"^DD",800003,800003.01,.01,21,9,0)
identifier (PHI) should be stored in this field.
"^DD",800003,800003.01,.01,"DT")
3160613
"^DIC",800000,800000,0)
HMP SUBSCRIPTION^800000
"^DIC",800000,800000,0,"GL")
^HMP(800000,
"^DIC",800000,800000,"%",0)
^1.005^^0
"^DIC",800000,800000,"%D",0)
^^3^3^3160720^
"^DIC",800000,800000,"%D",1,0)
This file contains the data needed for eHMP data retrieval. The top level 
"^DIC",800000,800000,"%D",2,0)
fields store information about servers know to eHMP. Each patient's 
"^DIC",800000,800000,"%D",3,0)
subscription is stored in #800000.01 sub-file for a server.
"^DIC",800000,"B","HMP SUBSCRIPTION",800000)

"^DIC",800003,800003,0)
HMP EVENT^800003
"^DIC",800003,800003,0,"GL")
^HMPLOG(800003,
"^DIC",800003,800003,"%",0)
^1.005^^0
"^DIC",800003,800003,"%D",0)
^^5^5^3160726^
"^DIC",800003,800003,"%D",1,0)
This file is used to log VistA events relevant to the eHMP environment.
"^DIC",800003,800003,"%D",2,0)
Its primary purpose is to record data that otherwise would not be
"^DIC",800003,800003,"%D",3,0)
logged, such as corrupt or missing data, or broken pointers.
"^DIC",800003,800003,"%D",4,0)
 
"^DIC",800003,800003,"%D",5,0)
It is also used by the eHMP to log maintenance activities.
"^DIC",800003,"B","HMP EVENT",800003)

**END**
**END**
